{
  "current_date": "2024-05-13T22:16:29.589Z",
  "author": "Sanat",
  "tokens": 105886,
  "scripts": [
    {
      "filename": "AbilityCard",
      "content": "using System; using FishnetInvector; using Invector.vCharacterController; using SingletonsExtension; using UnityEngine.UI; using UnityEngine; public class AbilityCard : MonoBehaviour { [SerializeField] private Image _abilityIcon; [SerializeField] private Image abilityBg; [SerializeField] private Sprite activeAbilityBg; [SerializeField] private Sprite passiveAbilityBg; [SerializeField] private TMProDecorator _abilityNameTextDecorator; [SerializeField] private TMProDecorator _abilityDescriptionTextDecorator; [SerializeField] private TMProDecorator _abilityHotkeyDescriptionTextDecorator; private Button _selectionButton; private static readonly float ABILITY_SELECTION_COOLDOWN = 1.0f; public GenericInput key = new GenericInput(\"1\", \"A\", \"RB\"); [SerializeField] private KeyCode _abilitySelectionKey = KeyCode.Alpha1; [SerializeField] private Sprite[] joystickImagesABXY; private string[] _joystickKeys = new string[] {\"A\", \"B\", \"X\", \"Y\"}; [SerializeField] private Image joystickButtonHolder; private byte _abilityId; private void Awake() => _selectionButton = GetComponent<Button>(); private void Update() { if (key.GetButtonUp()) { OnCtrlOneKeyCombo(); } if (Input.GetKeyUp(_abilitySelectionKey)) { OnCtrlOneKeyCombo(); } } private void OnCtrlOneKeyCombo() { Debug.Log($\"[AbilityCard][OnCtrlOneKeyCombo] {key.key} key combo pressed\"); OnAbilitySelected(_abilityId); } public void ClientLoadAbility(byte abilityId, int index) { joystickButtonHolder.sprite = joystickImagesABXY[index]; key = new GenericInput((index + 1).ToString(), _joystickKeys[index], _joystickKeys[index]); //_abilitySelectionKey = (KeyCode)(49 + index);//49 is the keycode for 1 //char lastSymbol = _abilitySelectionKey.ToString().Last(); _abilityHotkeyDescriptionTextDecorator.SetText($\"press: {key.keyboard}\"); _abilityId = abilityId; Ability abilityInstance = AbilityManager.Instance.GetAbility(abilityId); uint abilityStacksForPlayer = CharacterDataController.Instance.CharacterData.GetAbilityStacks(abilityId); int abilityRankForPlayer = abilityInstance.CalculateRankBasedOnStacks(abilityStacksForPlayer); AbilityDefinition abilityDefinition = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityById(abilityId); ChangeBackground(abilityDefinition.IsPassive); Debug.Log($\"[AbilityCard][ClientLoadAbility] Ability with id {abilityDefinition.Name} loaded. Hotkey to learn: {key.key}\"); _abilityIcon.sprite = abilityDefinition.Icon; _abilityNameTextDecorator.SetText(abilityInstance.GetAbilityName(abilityRankForPlayer)); string description = String.Empty; if (abilityDefinition.IsPassive) { description = abilityInstance.GetAbilityDescription(abilityRankForPlayer, abilityStacksForPlayer); } else { description = abilityInstance.GetAbilityDescription(abilityRankForPlayer, FishnetInvectorManager.LocalPlayer.Unit.StatsController); } _abilityDescriptionTextDecorator.SetText(description); _selectionButton.onClick.RemoveAllListeners(); _selectionButton.onClick.AddListener(() => OnAbilitySelected(_abilityId)); } private void ChangeBackground(bool isPassive) { abilityBg.sprite = isPassive ? passiveAbilityBg : activeAbilityBg; } private void OnAbilitySelected(byte abilityId) { RewardAbilityManager.OnAbilityRewardSelected?.Invoke(abilityId); Debug.Log($\"[AbilityCard][OnAbilitySelected] Ability with id {abilityId} selected\"); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AbilityCard",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "AbilityCard",
          "content": "using System; using FishnetInvector; using Invector.vCharacterController; using SingletonsExtension; using UnityEngine.UI; using UnityEngine; public class AbilityCard : MonoBehaviour { [SerializeField] private Image _abilityIcon; [SerializeField] private Image abilityBg; [SerializeField] private Sprite activeAbilityBg; [SerializeField] private Sprite passiveAbilityBg; [SerializeField] private TMProDecorator _abilityNameTextDecorator; [SerializeField] private TMProDecorator _abilityDescriptionTextDecorator; [SerializeField] private TMProDecorator _abilityHotkeyDescriptionTextDecorator; private Button _selectionButton; private static readonly float ABILITY_SELECTION_COOLDOWN = 1.0f; public GenericInput key = new GenericInput(\"1\", \"A\", \"RB\"); [SerializeField] private KeyCode _abilitySelectionKey = KeyCode.Alpha1; [SerializeField] private Sprite[] joystickImagesABXY; private string[] _joystickKeys = new string[] {\"A\", \"B\", \"X\", \"Y\"}; [SerializeField] private Image joystickButtonHolder; private byte _abilityId; private void Awake() => _selectionButton = GetComponent<Button>(); private void Update() { if (key.GetButtonUp()) { OnCtrlOneKeyCombo();  ",
          "content_tokens": 305,
          "embedding": []
        },
        {
          "cs_scriptfile": "AbilityCard",
          "content": "if (Input.GetKeyUp(_abilitySelectionKey)) { OnCtrlOneKeyCombo(); }  private void OnCtrlOneKeyCombo() { Debug.Log($\"[AbilityCard][OnCtrlOneKeyCombo] {key.key} key combo pressed\"); OnAbilitySelected(_abilityId);  ",
          "content_tokens": 67,
          "embedding": []
        },
        {
          "cs_scriptfile": "AbilityCard",
          "content": "public void ClientLoadAbility(byte abilityId, int index) { joystickButtonHolder.sprite = joystickImagesABXY[index]; key = new GenericInput((index + 1).ToString(), _joystickKeys[index], _joystickKeys[index]); //_abilitySelectionKey = (KeyCode)(49 + index);//49 is the keycode for 1 //char lastSymbol = _abilitySelectionKey.ToString().Last(); _abilityHotkeyDescriptionTextDecorator.SetText($\"press: {key.keyboard}\"); _abilityId = abilityId; Ability abilityInstance = AbilityManager.Instance.GetAbility(abilityId); uint abilityStacksForPlayer = CharacterDataController.Instance.CharacterData.GetAbilityStacks(abilityId); int abilityRankForPlayer = abilityInstance.CalculateRankBasedOnStacks(abilityStacksForPlayer); AbilityDefinition abilityDefinition = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityById(abilityId); ChangeBackground(abilityDefinition.IsPassive); Debug.Log($\"[AbilityCard][ClientLoadAbility] Ability with id {abilityDefinition.Name} loaded. Hotkey to learn: {key.key}\"); _abilityIcon.sprite = abilityDefinition.Icon; _abilityNameTextDecorator.SetText(abilityInstance.GetAbilityName(abilityRankForPlayer)); string description = String.Empty; if (abilityDefinition.IsPassive) { description = abilityInstance.GetAbilityDescription(abilityRankForPlayer, abilityStacksForPlayer); } else { description = abilityInstance.GetAbilityDescription(abilityRankForPlayer, FishnetInvectorManager.LocalPlayer.Unit.StatsController); } _abilityDescriptionTextDecorator.SetText(description); _selectionButton.onClick.RemoveAllListeners(); _selectionButton.onClick.AddListener(() => OnAbilitySelected(_abilityId));  ",
          "content_tokens": 406,
          "embedding": []
        },
        {
          "cs_scriptfile": "AbilityCard",
          "content": "private void ChangeBackground(bool isPassive) { abilityBg.sprite = isPassive ? passiveAbilityBg : activeAbilityBg;  private void OnAbilitySelected(byte abilityId) { RewardAbilityManager.OnAbilityRewardSelected?.Invoke(abilityId); Debug.Log($\"[AbilityCard][OnAbilitySelected] Ability with id {abilityId} selected\"); } }",
          "content_tokens": 86,
          "embedding": []
        }
      ],
      "length": 3315
    },
    {
      "filename": "AbilityChoosingMenu",
      "content": "using System; using System.Collections; using System.Collections.Generic; using FishnetInvector; using UnityEngine; public class AbilityChoosingMenu : MonoBehaviour { [SerializeField] private AbilityCard[] _abilityCards; private UICanvasGroupDecorator _canvasGroupDecorator; private bool _isReloadAvailable = false; public static readonly float RELOAD_XP_COST = 100; [SerializeField] private KeyCode _reloadKey = KeyCode.R; private void Awake() { HideAbilitiesMenu(); } public UICanvasGroupDecorator CanvasGroupDecorator { get { return _canvasGroupDecorator ??= GetComponent<UICanvasGroupDecorator>(); } } public void HideAbilitiesMenu() { FoldAllCards(); CanvasGroupDecorator.Hide(); _isReloadAvailable = false; } private void Update() { if (_isReloadAvailable) { bool iDontHaveEnoughXP = FishnetInvectorManager.LocalPlayer.XpController.GetXpStat().GetCurrentAmount() < RELOAD_XP_COST; if (iDontHaveEnoughXP) return; if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)) { if (Input.GetKeyUp(_reloadKey)) { RewardAbilityManager.LocalPlayer.CmdReloadAbilities(); } } } } public void ClientLoadRandomAbilities(List<byte> abilitiesToShow) { StartCoroutine(SafeClientLoadRandomAbilities(abilitiesToShow)); } private IEnumerator SafeClientLoadRandomAbilities(List<byte> abilitiesToShow) { yield return new WaitUntil(() => AbilityManager.Instance.IsInitialized); FoldAllCards(); for (int i = 0; i < abilitiesToShow.Count; i++) { _abilityCards[i].gameObject.SetActive(true); _abilityCards[i].ClientLoadAbility(abilitiesToShow[i], i); } CanvasGroupDecorator.Show(); _isReloadAvailable = true; } private void FoldAllCards() { foreach (var card in _abilityCards) { card.gameObject.SetActive(false); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AbilityChoosingMenu",
          "content": "using System; using System.Collections; using System.Collections.Generic; using FishnetInvector; using UnityEngine; public class AbilityChoosingMenu : MonoBehaviour { [SerializeField] private AbilityCard[] _abilityCards; private UICanvasGroupDecorator _canvasGroupDecorator; private bool _isReloadAvailable = false; public static readonly float RELOAD_XP_COST = 100; [SerializeField] private KeyCode _reloadKey = KeyCode.R; private void Awake() { HideAbilitiesMenu(); } public UICanvasGroupDecorator CanvasGroupDecorator { get { return _canvasGroupDecorator ??= GetComponent<UICanvasGroupDecorator>(); }  public void HideAbilitiesMenu() { FoldAllCards(); CanvasGroupDecorator.Hide(); _isReloadAvailable = false;  ",
          "content_tokens": 199,
          "embedding": []
        },
        {
          "cs_scriptfile": "AbilityChoosingMenu",
          "content": "private void Update() { if (_isReloadAvailable) { bool iDontHaveEnoughXP = FishnetInvectorManager.LocalPlayer.XpController.GetXpStat().GetCurrentAmount() < RELOAD_XP_COST; if (iDontHaveEnoughXP) return; if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)) { if (Input.GetKeyUp(_reloadKey)) { RewardAbilityManager.LocalPlayer.CmdReloadAbilities(); } } }  ",
          "content_tokens": 120,
          "embedding": []
        },
        {
          "cs_scriptfile": "AbilityChoosingMenu",
          "content": "public void ClientLoadRandomAbilities(List<byte> abilitiesToShow) { StartCoroutine(SafeClientLoadRandomAbilities(abilitiesToShow)); } private IEnumerator SafeClientLoadRandomAbilities(List<byte> abilitiesToShow) { yield return new WaitUntil(() => AbilityManager.Instance.IsInitialized); FoldAllCards(); for (int i = 0; i < abilitiesToShow.Count; i++) { _abilityCards[i].gameObject.SetActive(true); _abilityCards[i].ClientLoadAbility(abilitiesToShow[i], i); } CanvasGroupDecorator.Show(); _isReloadAvailable = true;  private void FoldAllCards() { foreach (var card in _abilityCards) { card.gameObject.SetActive(false); } } }",
          "content_tokens": 179,
          "embedding": []
        }
      ],
      "length": 1718
    },
    {
      "filename": "AbilityDefinition",
      "content": "using System; using System.Collections.Generic; using System.Text; using UnityEngine; [CreateAssetMenu(fileName = \"New Ability\", menuName = \"ScriptableObjects/Ability\")] public class AbilityDefinition : ScriptableObject { public byte Id => _id; [Header(\"-----BASE DATA-----\")] [SerializeField] private byte _id; [SerializeField] private string _name; [SerializeField] [TextArea(3, 10)] private string _description; [field:SerializeField, TextArea(2,10)] public string mainDescription { get; private set; } [field:SerializeField, TextArea(2,10)] public string questDescription { get; private set; } [field:SerializeField, TextArea(2,10)] public string persistDescription { get; private set; } [SerializeField] private Sprite _icon; [field:SerializeField] public int CastID { get; private set; } [SerializeField] private RPGAbilityRankData[] _ranksDatas; [SerializeField] private Ability ability; [field:SerializeField] public bool IsPassive { get; private set; } public Ability AbilityInstance => ability; public RPGAbilityRankData[] RanksDatas => _ranksDatas; #region Accessors public string Name => _name; public string Description => _description; public Sprite Icon => _icon; #endregion public enum AbilityType { Normal, PlayerAutoAttack, PlayerActionAbility } public enum TARGET_TYPES { SELF, CONE, AOE, LINEAR, PROJECTILE, SQUARE, GROUND, GROUND_LEAP, TARGET_PROJECTILE, TARGET_INSTANT } public enum ABILITY_TAGS { onHit, onKill, shapeshifting, stealth } public enum AbilityActivationType { Instant, Casted, Channeled, Charged } public enum COST_TYPES { FLAT, PERCENT_OF_MAX, PERCENT_OF_CURRENT } [Serializable] public class RPGAbilityRankData { public bool ShowedInEditor; public int unlockCost; public string TooltipText; public AbilityActivationType activationType; public float manaCost; public float castTime; public bool castInRun; public bool castBarVisible = true; public bool faceCursorWhileCasting = true; public bool faceCursorWhenOnCastStart = true; public bool faceCursorWhenOnCastEnd = true; public bool canBeUsedStunned; public bool animationTriggered; public bool comboStarsAfterCastComplete; public bool cancelStealth; public bool canUseWhileMounted; public TARGET_TYPES targetType; public bool isToggle, isToggleCostOnTrigger; public float toggledTriggerInterval; public int MaxUnitHit = 1; public float minRange; public float maxRange; public float standTimeDuration; public bool canRotateInStandTime; public float castSpeedSlowAmount; public float castSpeedSlowTime; public float castSpeedSlowRate; public float AIAttackTime = 1; public float coneDegree; public int ConeHitCount = 1; public float ConeHitInterval; public float AOERadius; public int AOEHitCount = 1; public float AOEHitInterval; public float linearWidth; public float linearHeight; public float linearLength; public float projectileSpeed; public float projectileDistance; public float projectileAngleSpread; public int projectileCount = 1; public float firstProjectileDelay; public float projectileDelay; public float projectileDuration = 5; public float projectileComeBackTime; public float projectileComeBackSpeed; public bool isProjectileComeBack; public float projectileNearbyUnitDistanceMax; public float projectileNearbyUnitMaxHit; public bool isProjectileNearbyUnit; public bool projectileDestroyedByEnvironment = true; public LayerMask projectileDestroyLayers; public bool projectileAffectedByGravity; public bool projectileShootOnClickPosition; public float projectileDistanceMaxForNPC = 50; public bool mustLookAtTarget = true; public float squareWidth; public float squareLength; public float squareHeight; public float groundRadius; public float groundRange; public float groundHitTime; public int groundHitCount = 1; public float groundHitInterval; public bool CanHitPlayer, CanHitAlly, CanHitNeutral = true, CanHitEnemy = true, CanHitSelf, CanHitPet, CanHitOwner; public bool UsedOnALly; public bool LookAtTargetDuringCombatAction; public bool LookAtTargetOnCombatAction; public GameObject projectileEffect; [HideInInspector] public string projectileSocketName; [HideInInspector] public string projectileTargetSocketName; public bool projectileUseNodeSocket; public bool projectileTargetUseNodeSocket; public bool projectileParentedToCaster; [HideInInspector] public AudioClip projectileSound; //public Sound projectileSoundTemplate; public bool projectileSoundParentedToEffect; public bool useCustomCollision; public Vector3 colliderCenter, colliderSize; public float colliderRadius, colliderHeight; public GameObject groundVisualEffect; public Vector3 effectPositionOffset; public float groundVisualEffectDuration = 5; public bool hitEffectUseSocket; public GameObject hitEffect; public float hitEffectDuration; [HideInInspector] public string hitEffectSocketName; public Vector3 hitEffectPositionOffset; public bool hitAttachedToNode; public float channelTime; public float groundLeapDuration; public float groundLeapHeight; public float groundLeapSpeed; public LayerMask groundLeapBlockLayers; public bool isAttackSpeedCooldown; public bool isAttackSpeedGCD; public float cooldown; public bool isGCD; public bool startCDOnActivate = true; public bool CanUseDuringGCD; public bool isSharingCooldown; [HideInInspector] public string cooldownTag; public List<BuffDefinition> targetEffectsApplied = new List<BuffDefinition>(); public List<float> targetEffectsAppliedDuration; public List<BuffDefinition> casterEffectsApplied = new List<BuffDefinition>(); public List<float> casterEffectsAppliedDuration; public List<AttachmentPoints.Point> FXattachmentPoints = new List<AttachmentPoints.Point>(); } public void SetId(byte id) { _id = id; } public string GetJsonRepresentation() { StringBuilder jsonBuilder = new StringBuilder(); jsonBuilder.Append(\"{\\n\"); if (IsPassive) jsonBuilder.AppendFormat(\" \\\"Name\\\": \\\"{0}\\\"(Passive),\\n\", _name); else jsonBuilder.AppendFormat(\" \\\"Name\\\": \\\"{0}\\\",\\n\", _name); jsonBuilder.AppendFormat(\" \\\"Description\\\": \\\"{0}\\\",\\n\", mainDescription.ToString()); jsonBuilder.AppendFormat(\" \\\"QuestDescription\\\": \\\"{0}\\\",\\n\", questDescription.ToString()); // Add other necessary fields in the same pattern jsonBuilder.Append(\"}\"); return jsonBuilder.ToString(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AbilityDefinition",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "AbilityDefinition",
          "content": "using System; using System.Collections.Generic; using System.Text; using UnityEngine; [CreateAssetMenu(fileName = \"New Ability\", menuName = \"ScriptableObjects/Ability\")] public class AbilityDefinition : ScriptableObject { public byte Id => _id; [Header(\"-----BASE DATA-----\")] [SerializeField] private byte _id; [SerializeField] private string _name; [SerializeField] [TextArea(3, 10)] private string _description; [field:SerializeField, TextArea(2,10)] public string mainDescription { get; private set; } [field:SerializeField, TextArea(2,10)] public string questDescription { get; private set; } [field:SerializeField, TextArea(2,10)] public string persistDescription { get; private set; } [SerializeField] private Sprite _icon; [field:SerializeField] public int CastID { get; private set; } [SerializeField] private RPGAbilityRankData[] _ranksDatas; [SerializeField] private Ability ability; [field:SerializeField] public bool IsPassive { get; private set; } public Ability AbilityInstance => ability; public RPGAbilityRankData[] RanksDatas => _ranksDatas; #region Accessors public string Name => _name; public string Description => _description; public Sprite Icon => _icon; #endregion public enum AbilityType { Normal, PlayerAutoAttack, PlayerActionAbility } public enum TARGET_TYPES { SELF, CONE, AOE, LINEAR, PROJECTILE, SQUARE, GROUND, GROUND_LEAP, TARGET_PROJECTILE, TARGET_INSTANT } public enum ABILITY_TAGS { onHit, onKill, shapeshifting, stealth } public enum AbilityActivationType { Instant, Casted, Channeled, Charged } public enum COST_TYPES { FLAT, PERCENT_OF_MAX, PERCENT_OF_CURRENT } [Serializable] public class RPGAbilityRankData { public bool ShowedInEditor; public int unlockCost; public string TooltipText; public AbilityActivationType activationType; public float manaCost; public float castTime; public bool castInRun; public bool castBarVisible = true; public bool faceCursorWhileCasting = true; public bool faceCursorWhenOnCastStart = true; public bool faceCursorWhenOnCastEnd = true; public bool canBeUsedStunned; public bool animationTriggered; public bool comboStarsAfterCastComplete; public bool cancelStealth; public bool canUseWhileMounted; public TARGET_TYPES targetType; public bool isToggle, isToggleCostOnTrigger; public float toggledTriggerInterval; public int MaxUnitHit = 1; public float minRange; public float maxRange; public float standTimeDuration; public bool canRotateInStandTime; public float castSpeedSlowAmount; public float castSpeedSlowTime; public float castSpeedSlowRate; public float AIAttackTime = 1; public float coneDegree; public int ConeHitCount = 1; public float ConeHitInterval; public float AOERadius; public int AOEHitCount = 1; public float AOEHitInterval; public float linearWidth; public float linearHeight; public float linearLength; public float projectileSpeed; public float projectileDistance; public float projectileAngleSpread; public int projectileCount = 1; public float firstProjectileDelay; public float projectileDelay; public float projectileDuration = 5; public float projectileComeBackTime; public float projectileComeBackSpeed; public bool isProjectileComeBack; public float projectileNearbyUnitDistanceMax; public float projectileNearbyUnitMaxHit; public bool isProjectileNearbyUnit; public bool projectileDestroyedByEnvironment = true; public LayerMask projectileDestroyLayers; public bool projectileAffectedByGravity; public bool projectileShootOnClickPosition; public float projectileDistanceMaxForNPC = 50; public bool mustLookAtTarget = true; public float squareWidth; public float squareLength; public float squareHeight; public float groundRadius; public float groundRange; public float groundHitTime; public int groundHitCount = 1; public float groundHitInterval; public bool CanHitPlayer, CanHitAlly, CanHitNeutral = true, CanHitEnemy = true, CanHitSelf, CanHitPet, CanHitOwner; public bool UsedOnALly; public bool LookAtTargetDuringCombatAction; public bool LookAtTargetOnCombatAction; public GameObject projectileEffect; [HideInInspector] public string projectileSocketName; [HideInInspector] public string projectileTargetSocketName; public bool projectileUseNodeSocket; public bool projectileTargetUseNodeSocket; public bool projectileParentedToCaster; [HideInInspector] public AudioClip projectileSound; //public Sound projectileSoundTemplate; public bool projectileSoundParentedToEffect; public bool useCustomCollision; public Vector3 colliderCenter, colliderSize; public float colliderRadius, colliderHeight; public GameObject groundVisualEffect; public Vector3 effectPositionOffset; public float groundVisualEffectDuration = 5; public bool hitEffectUseSocket; public GameObject hitEffect; public float hitEffectDuration; [HideInInspector] public string hitEffectSocketName; public Vector3 hitEffectPositionOffset; public bool hitAttachedToNode; public float channelTime; public float groundLeapDuration; public float groundLeapHeight; public float groundLeapSpeed; public LayerMask groundLeapBlockLayers; public bool isAttackSpeedCooldown; public bool isAttackSpeedGCD; public float cooldown; public bool isGCD; public bool startCDOnActivate = true; public bool CanUseDuringGCD; public bool isSharingCooldown; [HideInInspector] public string cooldownTag; public List<BuffDefinition> targetEffectsApplied = new List<BuffDefinition>(); public List<float> targetEffectsAppliedDuration; public List<BuffDefinition> casterEffectsApplied = new List<BuffDefinition>(); public List<float> casterEffectsAppliedDuration; public List<AttachmentPoints.Point> FXattachmentPoints = new List<AttachmentPoints.Point>();  ",
          "content_tokens": 1362,
          "embedding": []
        },
        {
          "cs_scriptfile": "AbilityDefinition",
          "content": "public void SetId(byte id) { _id = id;  public string GetJsonRepresentation() { StringBuilder jsonBuilder = new StringBuilder(); jsonBuilder.Append(\"{\\n\"); if (IsPassive) jsonBuilder.AppendFormat(\" \\\"Name\\\": \\\"{0}\\\"(Passive),\\n\", _name); else jsonBuilder.AppendFormat(\" \\\"Name\\\": \\\"{0}\\\",\\n\", _name); jsonBuilder.AppendFormat(\" \\\"Description\\\": \\\"{0}\\\",\\n\", mainDescription.ToString()); jsonBuilder.AppendFormat(\" \\\"QuestDescription\\\": \\\"{0}\\\",\\n\", questDescription.ToString()); // Add other necessary fields in the same pattern jsonBuilder.Append(\"}\"); return jsonBuilder.ToString(); } }",
          "content_tokens": 170,
          "embedding": []
        }
      ],
      "length": 6194
    },
    {
      "filename": "AbilityDefinitionHolder",
      "content": "using System; using System.Collections; using System.Collections.Generic; using System.Text; using DuloGames.UI; using UnityEngine; [CreateAssetMenu(fileName = \"AbilityDefinitionHolderSO\", menuName = \"ScriptableObjects/AbilityHolder\")] public class AbilityDefinitionHolder : ScriptableObject { [SerializeField] private List<AbilityDefinition> _abilityDefinitions; public List<AbilityDefinition> AbilityDefinitions => _abilityDefinitions; public AbilityDefinition GetAbilityById(int id) { return _abilityDefinitions.Find(ability => ability.Id == id); } public AbilityDefinition GetAbilityByName(string name, out bool found) { AbilityDefinition ability = _abilityDefinitions.Find(ability => ability.Name == name); found = ability != null; return ability; } public int GetAbilityId(AbilityDefinition abilityDefinition) { if (!_abilityDefinitions.Contains(abilityDefinition)) { Debug.LogError($\"AbilityDefinitionHolderSO: AbilityDefinition {abilityDefinition} not found in AbilityDefinitions list\"); return -1; } return _abilityDefinitions.Find(x => x == abilityDefinition).Id; } public string SerializeToJson() { StringBuilder jsonBuilder = new StringBuilder(); jsonBuilder.Append(\"[\"); for (int i = 0; i < AbilityDefinitions.Count; i++) { jsonBuilder.Append(AbilityDefinitions[i].GetJsonRepresentation()); if (i < AbilityDefinitions.Count - 1) jsonBuilder.Append(\",\"); } jsonBuilder.Append(\"]\"); return jsonBuilder.ToString(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AbilityDefinitionHolder",
          "content": "using System; using System.Collections; using System.Collections.Generic; using System.Text; using DuloGames.UI; using UnityEngine; [CreateAssetMenu(fileName = \"AbilityDefinitionHolderSO\", menuName = \"ScriptableObjects/AbilityHolder\")] public class AbilityDefinitionHolder : ScriptableObject { [SerializeField] private List<AbilityDefinition> _abilityDefinitions; public List<AbilityDefinition> AbilityDefinitions => _abilityDefinitions; public AbilityDefinition GetAbilityById(int id) { return _abilityDefinitions.Find(ability => ability.Id == id); } public AbilityDefinition GetAbilityByName(string name, out bool found) { AbilityDefinition ability = _abilityDefinitions.Find(ability => ability.Name == name); found = ability != null; return ability;  ",
          "content_tokens": 178,
          "embedding": []
        },
        {
          "cs_scriptfile": "AbilityDefinitionHolder",
          "content": "public int GetAbilityId(AbilityDefinition abilityDefinition) { if (!_abilityDefinitions.Contains(abilityDefinition)) { Debug.LogError($\"AbilityDefinitionHolderSO: AbilityDefinition {abilityDefinition} not found in AbilityDefinitions list\"); return -1; } return _abilityDefinitions.Find(x => x == abilityDefinition).Id;  public string SerializeToJson() { StringBuilder jsonBuilder = new StringBuilder(); jsonBuilder.Append(\"[\"); for (int i = 0; i < AbilityDefinitions.Count; i++) { jsonBuilder.Append(AbilityDefinitions[i].GetJsonRepresentation()); if (i < AbilityDefinitions.Count - 1) jsonBuilder.Append(\",\"); } jsonBuilder.Append(\"]\"); return jsonBuilder.ToString(); } }",
          "content_tokens": 175,
          "embedding": []
        }
      ],
      "length": 1429
    },
    {
      "filename": "AbilityManager",
      "content": "using System.Collections; using System.Collections.Generic; using FishNet; using FishNet.Managing.Timing; using FishNet.Object; using SingletonsExtension; using UnityEngine; public class AbilityManager : RoomManager { public static AbilityManager Instance { get; private set; } public static readonly float GLOBAL_COOLDOWN_TIME = 1.5f; [SerializeField] private Ability[] _abilities; public Buff[] Buffs => _buffs; [SerializeField] private Buff[] _buffs; [field:SerializeField] public bool IsInitialized { get; private set; } private Dictionary<int, Ability> _abilitiesDictionary = new Dictionary<int, Ability>(); public void Init(bool asServer) { // Checking for other instances of AbilityManager. if (Instance != null) { Debug.LogWarning($\"{ClassAndRoomName} There is more than one instance of AbilityManager in the scene.\"); return; } Instance = this; _abilities = GetComponents<Ability>(); _buffs = GetComponents<Buff>(); Debug.Log($\"[AbilityManager] Ability Manager instantiated with \" + _abilities.Length + \" abilities.\"); // Initializing abilities. for (int i = 0; i < _abilities.Length; i++) { int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilities[i].AbilityDefinition); if (abilityId > -1) { _abilitiesDictionary.Add(abilityId, _abilities[i]); _abilities[i].InitAbility(); _abilities[i].OnRankLevelUp += GameplayManager.RewardAbilityManager.SetRankToAbility; Debug.Log($\"{ClassAndRoomName} Initialized ability \" + _abilities[i].AbilityDefinition.name + \" with ID: \" + abilityId); } else { Debug.LogWarning($\"{ClassAndRoomName} Invalid ability ID: {abilityId}. Skipping ability initialization.\"); } } IsInitialized = true; } public BuffDefinition GetBuffDefinition(Buff.BuffType buffType) { for (int i = 0; i < _buffs.Length; i++) { if (_buffs[i].BuffDefinition.buffType == buffType) { return _buffs[i].BuffDefinition; } } return null; } public Ability GetAbility(int id) { for (int i = 0; i < _abilities.Length; i++) { if (_abilities[i].AbilityDefinition.Id == id) { return _abilities[i]; } } return null; } [ServerRpc(RequireOwnership = false)] public void InitAbility(int casterNetId, int abilityId, int rank = 0) { var playerComps = GameplayManager.GetUnitComponentsServerAndClient(casterNetId); if (!playerComps.AbilityController.IsEligibleToCast(abilityId)) { Debug.Log($\"{ClassAndRoomName} Player {casterNetId} is not eligible to cast ability {abilityId}.\"); return; } Ability ability = GetAbility(abilityId); float abilityCastingTime = ability.GetAbilityCastingTime(rank, playerComps.StatsController); bool isInstantCast = abilityCastingTime < float.Epsilon; if (isInstantCast) { playerComps.AbilityController.StartGlobalCooldown(GLOBAL_COOLDOWN_TIME); } Debug.Log($\"{ClassAndRoomName} Initiating ability {abilityId} for player {casterNetId} with rank {rank}.\"); StartCoroutine(InitCooldown(casterNetId, abilityId, rank)); StartCoroutine(_abilitiesDictionary[abilityId].Activate(casterNetId)); } [ServerRpc(RequireOwnership = false)] public void InitDirectionalAbility(Vector3 dir, int casterNetId, int abilityId, int rank = 0) { var playerComps = GameplayManager.GetUnitComponentsServerAndClient(casterNetId); // Check if player is eligible to cast the ability. if (!playerComps.AbilityController.IsEligibleToCast(abilityId)) { Debug.Log($\"{ClassAndRoomName} Player {casterNetId} is not eligible to cast ability {abilityId}.\"); return; } Debug.Log($\"{ClassAndRoomName} Initiating ability {abilityId} for player {casterNetId} with rank {rank}.\"); StartCoroutine(InitCooldown(casterNetId, abilityId, rank)); StartCoroutine(_abilitiesDictionary[abilityId].Activate(casterNetId)); } [Server] private IEnumerator InitCooldown(int casterNetId, int abilityId, int rank) { Ability ability = GetAbility(abilityId); AbilityDefinition abilityDefinition = ability.AbilityDefinition; float cooldown = abilityDefinition.RanksDatas[0].cooldown; var playerComps = GameplayManager.GetUnitComponentsServerAndClient(casterNetId); FNAbilityController.CooldownData cooldownData = new FNAbilityController.CooldownData(); cooldownData.IsOnCooldown = true; cooldownData.cooldownFinishTime = (float)InstanceFinder.TimeManager.TicksToTime(InstanceFinder.TimeManager.Tick) + cooldown; Debug.Log($\"{ClassAndRoomName} Setting ability {abilityId} cooldown for player {casterNetId}; cooldownFinishTime: {cooldownData.cooldownFinishTime}.\"); playerComps.AbilityController.ChangeAbilityCooldown(abilityId, cooldownData); yield return new WaitForSeconds(cooldown); Debug.Log($\"{ClassAndRoomName} Resetting ability {abilityId} cooldown for player {casterNetId}.\"); cooldownData.IsOnCooldown = false; playerComps.AbilityController.ChangeAbilityCooldown(abilityId, cooldownData); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AbilityManager",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "AbilityManager",
          "content": "using System.Collections; using System.Collections.Generic; using FishNet; using FishNet.Managing.Timing; using FishNet.Object; using SingletonsExtension; using UnityEngine; public class AbilityManager : RoomManager { public static AbilityManager Instance { get; private set; } public static readonly float GLOBAL_COOLDOWN_TIME = 1.5f; [SerializeField] private Ability[] _abilities; public Buff[] Buffs => _buffs; [SerializeField] private Buff[] _buffs; [field:SerializeField] public bool IsInitialized { get; private set; } private Dictionary<int, Ability> _abilitiesDictionary = new Dictionary<int, Ability>(); public void Init(bool asServer) { // Checking for other instances of AbilityManager. if (Instance != null) { Debug.LogWarning($\"{ClassAndRoomName} There is more than one instance of AbilityManager in the scene.\"); return; } Instance = this; _abilities = GetComponents<Ability>(); _buffs = GetComponents<Buff>(); Debug.Log($\"[AbilityManager] Ability Manager instantiated with \" + _abilities.Length + \" abilities.\"); // Initializing abilities. for (int i = 0; i < _abilities.Length; i++) { int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilities[i].AbilityDefinition); if (abilityId > -1) { _abilitiesDictionary.Add(abilityId, _abilities[i]); _abilities[i].InitAbility(); _abilities[i].OnRankLevelUp += GameplayManager.RewardAbilityManager.SetRankToAbility; Debug.Log($\"{ClassAndRoomName} Initialized ability \" + _abilities[i].AbilityDefinition.name + \" with ID: \" + abilityId); } else { Debug.LogWarning($\"{ClassAndRoomName} Invalid ability ID: {abilityId}. Skipping ability initialization.\"); } } IsInitialized = true; } public BuffDefinition GetBuffDefinition(Buff.BuffType buffType) { for (int i = 0; i < _buffs.Length; i++) { if (_buffs[i].BuffDefinition.buffType == buffType) { return _buffs[i].BuffDefinition; } } return null; } public Ability GetAbility(int id) { for (int i = 0; i < _abilities.Length; i++) { if (_abilities[i].AbilityDefinition.Id == id) { return _abilities[i]; } } return null; } [ServerRpc(RequireOwnership = false)] public void InitAbility(int casterNetId, int abilityId, int rank = 0) { var playerComps = GameplayManager.GetUnitComponentsServerAndClient(casterNetId); if (!playerComps.AbilityController.IsEligibleToCast(abilityId)) { Debug.Log($\"{ClassAndRoomName} Player {casterNetId} is not eligible to cast ability {abilityId}.\"); return; } Ability ability = GetAbility(abilityId); float abilityCastingTime = ability.GetAbilityCastingTime(rank, playerComps.StatsController); bool isInstantCast = abilityCastingTime < float.Epsilon; if (isInstantCast) { playerComps.AbilityController.StartGlobalCooldown(GLOBAL_COOLDOWN_TIME); } Debug.Log($\"{ClassAndRoomName} Initiating ability {abilityId} for player {casterNetId} with rank {rank}.\"); StartCoroutine(InitCooldown(casterNetId, abilityId, rank)); StartCoroutine(_abilitiesDictionary[abilityId].Activate(casterNetId)); } [ServerRpc(RequireOwnership = false)] public void InitDirectionalAbility(Vector3 dir, int casterNetId, int abilityId, int rank = 0) { var playerComps = GameplayManager.GetUnitComponentsServerAndClient(casterNetId); // Check if player is eligible to cast the ability. if (!playerComps.AbilityController.IsEligibleToCast(abilityId)) { Debug.Log($\"{ClassAndRoomName} Player {casterNetId} is not eligible to cast ability {abilityId}.\"); return; } Debug.Log($\"{ClassAndRoomName} Initiating ability {abilityId} for player {casterNetId} with rank {rank}.\"); StartCoroutine(InitCooldown(casterNetId, abilityId, rank)); StartCoroutine(_abilitiesDictionary[abilityId].Activate(casterNetId)); } [Server] private IEnumerator InitCooldown(int casterNetId, int abilityId, int rank) { Ability ability = GetAbility(abilityId); AbilityDefinition abilityDefinition = ability.AbilityDefinition; float cooldown = abilityDefinition.RanksDatas[0].cooldown; var playerComps = GameplayManager.GetUnitComponentsServerAndClient(casterNetId); FNAbilityController.CooldownData cooldownData = new FNAbilityController.CooldownData(); cooldownData.IsOnCooldown = true; cooldownData.cooldownFinishTime = (float)InstanceFinder.TimeManager.TicksToTime(InstanceFinder.TimeManager.Tick) + cooldown; Debug.Log($\"{ClassAndRoomName} Setting ability {abilityId} cooldown for player {casterNetId}; cooldownFinishTime: {cooldownData.cooldownFinishTime}.\"); playerComps.AbilityController.ChangeAbilityCooldown(abilityId, cooldownData); yield return new WaitForSeconds(cooldown); Debug.Log($\"{ClassAndRoomName} Resetting ability {abilityId} cooldown for player {casterNetId}.\"); cooldownData.IsOnCooldown = false; playerComps.AbilityController.ChangeAbilityCooldown(abilityId, cooldownData); } }",
          "content_tokens": 1263,
          "embedding": []
        }
      ],
      "length": 4696
    },
    {
      "filename": "Ability",
      "content": "using System; using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DuloGames.UI; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using FishnetInvector; using Invector; using UnityEngine; [Serializable] public class Ability: NetworkBehaviour { protected int _rank; [SerializeField] protected AbilityDefinition _abilityDefinition; public Buff Buff => _buff; [SerializeField] protected Buff _buff; [SerializeField] protected bool isPassiveSkill; public static Dictionary<NetworkConnection, uint> StacksCounter { get; private set; } = new (); public static Dictionary<NetworkConnection, uint> RankCounter { get; private set; } = new (); public AbilityDefinition AbilityDefinition => _abilityDefinition; public static Action OnAbilityLearned; public Action<NetworkConnection, byte, uint> OnRankLevelUp; protected string _abilityName => _abilityDefinition.Name; protected GameplayManager _gameplayManager; protected bool _isDebug = true; protected readonly string COLOR_DURATION = \"#00F0FF\"; protected readonly string COLOR_AFFECTING_STAT = \"#00F0FF\"; protected readonly string COLOR_DAMAGE = \"#ff3517\"; protected readonly string COLOR_HEAL = \"#0ec949\"; protected readonly string COLOR_STAT = \"#96e33d\"; protected readonly string COLOR_XP = \"#c3eb34\"; protected readonly string COLOR_COOLDOWN = \"#c8e609\"; protected readonly Color DEBUG_SPHERE_DEFAULT_COLOR = new Color(1f, 0f, 0f, 0.5f); protected readonly Color DEBUG_SPHERE_ACTIVATE_COLOR = new Color(1f, 0f, 1f, 0.5f); protected Color _debugSphereColor; protected bool _showDebugSphere; protected Vector3 _debugSpherePos; protected float _debugSphereRadius = 1f; public virtual void InitAbility() { if (_buff != null) { _buff.Init(GameplayManager.Instance); } else { Debug.LogWarning($\"Buff is null during ability {_abilityName} initialization.\"); } } public virtual float CalculateValueBasedOnStacks(uint stacks) => .01f; public virtual int CalculateRankBasedOnStacks(uint stacks) => 1; public virtual float CalculateDamageBasedOnRank(int rank) => 1; public virtual uint GetStacksForRank() => 1; public uint AddRank(NetworkConnection connection) { if (RankCounter.ContainsKey(connection)) { RankCounter[connection]++; } else { RankCounter.Add(connection, 1); } OnRankLevelUp?.Invoke(connection, _abilityDefinition.Id, RankCounter[connection]); return RankCounter[connection]; } public uint ServerAddStack(FNAbilityController abilityController, uint amount) { if (!abilityController.LearnedAbilityDict.ContainsKey(AbilityDefinition.Id)) { Debug.LogError($\"Ability {AbilityDefinition.Name} is not learned by player {abilityController.gameObject.name}. Cannot add stacks.\"); return 0; } AbilityInfo targetsAbilityStats = abilityController.LearnedAbilityDict[AbilityDefinition.Id]; targetsAbilityStats.Stacks = Math.Max(0, targetsAbilityStats.Stacks + amount); abilityController.AddOrSetAbility(targetsAbilityStats); return targetsAbilityStats.Stacks; } public uint AddStack(NetworkConnection connection) { if (StacksCounter.ContainsKey(connection)) { StacksCounter[connection]++; } else { StacksCounter.Add(connection, 1); } if (EnoughStacksToLevelup(connection)) { StacksCounter[connection] = 0; AddRank(connection); return 1; } else { return 0; } return StacksCounter[connection]; } public UISpellInfo GetUISpellInfo(byte abilityId, uint stacks) { UISpellInfo spellInfo = new UISpellInfo(); spellInfo.ID = _abilityDefinition.Id; uint abilityStacksForPlayer = CharacterDataController.Instance.CharacterData.GetAbilityStacks(abilityId); int abilityRankBasedOnStacks = CalculateRankBasedOnStacks(abilityStacksForPlayer); spellInfo.Name = GetAbilityName(abilityRankBasedOnStacks); spellInfo.Icon = _abilityDefinition.Icon; spellInfo.Description = GetAbilityDescription(abilityRankBasedOnStacks, abilityStacksForPlayer); if (_abilityDefinition.IsPassive) { spellInfo.Flags = UISpellInfo_Flags.Passive; } else { AbilityDefinition.RPGAbilityRankData rankData = _abilityDefinition.RanksDatas[0]; if (rankData != null) { if (rankData.activationType == AbilityDefinition.AbilityActivationType.Instant) spellInfo.Flags = UISpellInfo_Flags.InstantCast; else spellInfo.Flags = UISpellInfo_Flags.PowerCostInPct; spellInfo.Range = rankData.maxRange; spellInfo.Cooldown = rankData.cooldown; if (rankData.castTime > 0) { spellInfo.CastTime = rankData.castTime; } spellInfo.PowerCost = rankData.manaCost; } else { Debug.LogError($\"Ability {spellInfo.Name} does not have rank {abilityId}. Setting default values.\"); } } return spellInfo; } private bool EnoughStacksToLevelup(NetworkConnection connection) { return StacksCounter[connection] >= GetStacksForRank(); } public virtual string GetAbilityName(int rank) => _abilityDefinition.Name; public virtual string GetAbilityDescription(int rank, uint stacks) => _abilityDefinition.Description; public virtual string GetAbilityDescription(int rank, FNStatsController statsController) => _abilityDefinition.persistDescription; public virtual float GetAbilityCastingTime(int rank, FNStatsController statsController) { float castingTime = _abilityDefinition.RanksDatas[rank].castTime; return castingTime; } public virtual IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { yield return null; } [Server] protected virtual void CasterBuffApply(Buff.BuffData casterBuffData, float duration = 1f) { Debug.Log($\"{_abilityName} Applying caster buff.\"); _buff.Activate(casterBuffData, new int[]{}, duration:duration); } protected virtual List<Collider> TargetsSelection(Transform caster) { Debug.LogWarning($\"{_abilityName} TargetsSelection method has not been implemented yet.\"); throw new NotImplementedException(); } [Server] protected void AOEDamageTargets(int casterNetId, float radius, vDamage damage, bool isExcludeSelf = false) { var playerComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); var targets = TargetsInSphereSelection(playerComps, radius); for (int i = 0; i < targets.Count; i++) { if (isExcludeSelf && targets[i] == playerComps.HealthController) { continue; } damage.receiver = targets[i].transform; targets[i].TakeDamage(damage); Debug.Log($\"[{_abilityDefinition.Name}] Damage applied to {targets[i].name}\"); } } [Server] protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, Buff.BuffData caster, float radius) { //Debug.Log($\"{_abilityName} Selecting targets in sphere.\"); List<FishnetInvectorHealthController> targets = EnemyTargetsInRadius(pos, caster, radius); //Debug.Log($\"{_abilityName} {targets.Count} targets found in sphere.\"); return targets; } [Server] protected List<FishnetInvectorHealthController> TargetsExcludingTagsInSphereSelection(string[] tags, Vector3 pos, Buff.BuffData caster, float radius) { List<FishnetInvectorHealthController> targets = TargetsInRadiusExcludingTags(tags, pos, caster, radius); return targets; } public static List<FishnetInvectorHealthController> TargetsInRadiusExcludingTags(string[] tags, Vector3 pos, Buff.BuffData caster, float radius) { List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>(); //check targets foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters) { var targetNob = GameplayManager.Instance.GetUnitNob(possibleTarget); if (targetNob == null) continue; for (int i = 0; i < tags.Length; i++) { if (targetNob.CompareTag(tags[i])) { continue; } } if (!CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius)) continue; var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(possibleTarget); if (targetComps == null) continue; targets.Add(targetComps.HealthController); } return targets; } public static List<FishnetInvectorHealthController> EnemyTargetsInRadius(Vector3 pos, Buff.BuffData caster, float radius) { List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>(); //check targets foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters) { var targetNob = GameplayManager.Instance.GetUnitNob(possibleTarget); if (targetNob == null) continue; if (!CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius)) continue; var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(possibleTarget); if (targetComps == null) continue; Buff.BuffData targetData = new Buff.BuffData(targetComps.HealthController.ObjectId, targetComps.HealthController.gameObject.tag, 0f, caster.abilityId, 0, null, null, 0); if (IsNotValidTargetEnemy(caster, targetData)) continue; targets.Add(targetComps.HealthController); } return targets; } [Server] protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, UnitComponents caster, float radius) { Debug.Log($\"{_abilityName} Selecting targets in sphere.\"); List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>(); //check targets foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters) { var targetNob = GameplayManager.Instance.GetUnitNob(possibleTarget); var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(possibleTarget); if (IsNotValidTargetEnemy(targetComps, caster)) { continue; } if (CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius)) { var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(possibleTarget); targets.Add(unitComps.HealthController); } } Debug.Log($\"{_abilityName} {targets.Count} targets found in sphere.\"); return targets; } [Server] protected List<FishnetInvectorHealthController> TargetsInSphereSelection(UnitComponents caster, float radius) { Debug.Log($\"{_abilityName} Selecting targets in sphere.\"); List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>(); //check targets foreach (var target in GameplayManager.Instance.UnitCharacters) { var targetNob = GameplayManager.Instance.GetUnitNob(target); var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNob.ObjectId); if (IsNotValidTargetEnemy(targetComps, caster)) { continue; } if (CommonMath.Math.IsWithinRange(caster.HealthController.transform.position, targetNob.transform.position, radius)) { var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(target); targets.Add(unitComps.HealthController); } } Debug.Log($\"{_abilityName} {targets.Count} targets found in sphere.\"); return targets; } [ObserversRpc] protected void RpcShowEffectForObservers(int targetNetId, int abilityId, int rank, float timeout) { Debug.Log($\"{_abilityName} Showing effect for observers.\"); GameplayManager.Instance.StartCoroutine(ShowEffectOnTarget(targetNetId, abilityId, rank, timeout)); } protected virtual IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout) { Debug.Log($\"{_abilityName} Showing effect on target.\"); var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); if(targetComps == null) { Debug.LogError($\"{_abilityName} Target components are null. Cannot show effect on target.\"); yield break; } List<GameObject> effects = new List<GameObject>(); foreach (var attachementPoint in _abilityDefinition.RanksDatas[rank].FXattachmentPoints) { Transform pointTransform = targetComps.AttachmentPoints.GetAttachmentPoint(attachementPoint); GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pointTransform.position + Vector3.up, Quaternion.identity, GameplayManager.Instance.transform); effect.transform.SetParent(pointTransform); effects.Add(effect); } yield return new WaitForSeconds(timeout); foreach (var effect in effects) { Destroy(effect, timeout); } } public static bool IsNotValidTargetEnemy(Buff.BuffData casterData, Buff.BuffData targetData) { if (casterData.ObjectId == targetData.ObjectId) { return true; } int casterTeam = GameplayManager.Instance.GetUnitTeamId(casterData.ObjectId); int targetTeam = GameplayManager.Instance.GetUnitTeamId(targetData.ObjectId); if (casterData.Tag == GameplayManager.TAG_PLAYER) { if (casterTeam == targetTeam) { return true; } return false; }else if (targetData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID]) { if (casterData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID]) { return true; } return false; } return false; } protected bool IsNotValidTargetEnemy(UnitComponents target, UnitComponents caster) { //Debug.Log($\"{_abilityName} Checking if target is valid.\"); if (target == null) return true; if (target == caster) { //Debug.Log($\"{_abilityName} Target is the same as caster. Invalid target.\"); return true; } var targetHealthController = target.HealthController; if (targetHealthController == null) { return true; } if (targetHealthController.CompareTag(GameplayManager.TAG_PLAYER)) { //Debug.Log($\"{_abilityName} Target is a player. Valid target.\"); return false; }else if (targetHealthController.CompareTag(\"Enemy\")) { //Debug.Log($\"{_abilityName} Target is an enemy. Valid target.\"); if (caster.HealthController.CompareTag(\"Enemy\")) { return true; } return false; } //Debug.Log($\"{_abilityName} Target does not have a Player or Enemy tag. Invalid target.\"); return false; } protected void DrawDebugSphere(Vector3 pos, float radius) { _debugSpherePos = pos; _debugSphereRadius = radius; _showDebugSphere = true; _debugSphereColor = DEBUG_SPHERE_ACTIVATE_COLOR; StartCoroutine(ResetDebugSphereColorAfterDelay(0.3f)); } protected IEnumerator ResetDebugSphereColorAfterDelay(float delay) { yield return new WaitForSeconds(delay); _debugSphereColor = DEBUG_SPHERE_DEFAULT_COLOR; _showDebugSphere = false; } public virtual float CalcAmount(FNStatsController statsController) { return 1f; } public virtual float CalcDuration(FNStatsController statsController) { return 1f; } #if UNITY_EDITOR protected void OnDrawGizmos() { if (_showDebugSphere) { Gizmos.color = _debugSphereColor; Gizmos.DrawSphere(_debugSpherePos, _debugSphereRadius); } } #endif }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Ability",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "Ability",
          "content": "using System; using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DuloGames.UI; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using FishnetInvector; using Invector; using UnityEngine; [Serializable] public class Ability: NetworkBehaviour { protected int _rank; [SerializeField] protected AbilityDefinition _abilityDefinition; public Buff Buff => _buff; [SerializeField] protected Buff _buff; [SerializeField] protected bool isPassiveSkill; public static Dictionary<NetworkConnection, uint> StacksCounter { get; private set; } = new (); public static Dictionary<NetworkConnection, uint> RankCounter { get; private set; } = new (); public AbilityDefinition AbilityDefinition => _abilityDefinition; public static Action OnAbilityLearned; public Action<NetworkConnection, byte, uint> OnRankLevelUp; protected string _abilityName => _abilityDefinition.Name; protected GameplayManager _gameplayManager; protected bool _isDebug = true; protected readonly string COLOR_DURATION = \"#00F0FF\"; protected readonly string COLOR_AFFECTING_STAT = \"#00F0FF\"; protected readonly string COLOR_DAMAGE = \"#ff3517\"; protected readonly string COLOR_HEAL = \"#0ec949\"; protected readonly string COLOR_STAT = \"#96e33d\"; protected readonly string COLOR_XP = \"#c3eb34\"; protected readonly string COLOR_COOLDOWN = \"#c8e609\"; protected readonly Color DEBUG_SPHERE_DEFAULT_COLOR = new Color(1f, 0f, 0f, 0.5f); protected readonly Color DEBUG_SPHERE_ACTIVATE_COLOR = new Color(1f, 0f, 1f, 0.5f); protected Color _debugSphereColor; protected bool _showDebugSphere; protected Vector3 _debugSpherePos; protected float _debugSphereRadius = 1f; public virtual void InitAbility() { if (_buff != null) { _buff.Init(GameplayManager.Instance); } else { Debug.LogWarning($\"Buff is null during ability {_abilityName} initialization.\"); } } public virtual float CalculateValueBasedOnStacks(uint stacks) => .01f; public virtual int CalculateRankBasedOnStacks(uint stacks) => 1; public virtual float CalculateDamageBasedOnRank(int rank) => 1; public virtual uint GetStacksForRank() => 1; public uint AddRank(NetworkConnection connection) { if (RankCounter.ContainsKey(connection)) { RankCounter[connection]++; } else { RankCounter.Add(connection, 1); } OnRankLevelUp?.Invoke(connection, _abilityDefinition.Id, RankCounter[connection]); return RankCounter[connection]; } public uint ServerAddStack(FNAbilityController abilityController, uint amount) { if (!abilityController.LearnedAbilityDict.ContainsKey(AbilityDefinition.Id)) { Debug.LogError($\"Ability {AbilityDefinition.Name} is not learned by player {abilityController.gameObject.name}. Cannot add stacks.\"); return 0; } AbilityInfo targetsAbilityStats = abilityController.LearnedAbilityDict[AbilityDefinition.Id]; targetsAbilityStats.Stacks = Math.Max(0, targetsAbilityStats.Stacks + amount); abilityController.AddOrSetAbility(targetsAbilityStats); return targetsAbilityStats.Stacks; } public uint AddStack(NetworkConnection connection) { if (StacksCounter.ContainsKey(connection)) { StacksCounter[connection]++; } else { StacksCounter.Add(connection, 1);  ",
          "content_tokens": 823,
          "embedding": []
        },
        {
          "cs_scriptfile": "Ability",
          "content": "if (EnoughStacksToLevelup(connection)) { StacksCounter[connection] = 0; AddRank(connection); return 1; } else { return 0; } return StacksCounter[connection]; } public UISpellInfo GetUISpellInfo(byte abilityId, uint stacks) { UISpellInfo spellInfo = new UISpellInfo(); spellInfo.ID = _abilityDefinition.Id; uint abilityStacksForPlayer = CharacterDataController.Instance.CharacterData.GetAbilityStacks(abilityId); int abilityRankBasedOnStacks = CalculateRankBasedOnStacks(abilityStacksForPlayer); spellInfo.Name = GetAbilityName(abilityRankBasedOnStacks); spellInfo.Icon = _abilityDefinition.Icon; spellInfo.Description = GetAbilityDescription(abilityRankBasedOnStacks, abilityStacksForPlayer); if (_abilityDefinition.IsPassive) { spellInfo.Flags = UISpellInfo_Flags.Passive; } else { AbilityDefinition.RPGAbilityRankData rankData = _abilityDefinition.RanksDatas[0]; if (rankData != null) { if (rankData.activationType == AbilityDefinition.AbilityActivationType.Instant) spellInfo.Flags = UISpellInfo_Flags.InstantCast; else spellInfo.Flags = UISpellInfo_Flags.PowerCostInPct; spellInfo.Range = rankData.maxRange; spellInfo.Cooldown = rankData.cooldown; if (rankData.castTime > 0) { spellInfo.CastTime = rankData.castTime; } spellInfo.PowerCost = rankData.manaCost; } else { Debug.LogError($\"Ability {spellInfo.Name} does not have rank {abilityId}. Setting default values.\"); } } return spellInfo;  ",
          "content_tokens": 387,
          "embedding": []
        },
        {
          "cs_scriptfile": "Ability",
          "content": "private bool EnoughStacksToLevelup(NetworkConnection connection) { return StacksCounter[connection] >= GetStacksForRank(); } public virtual string GetAbilityName(int rank) => _abilityDefinition.Name; public virtual string GetAbilityDescription(int rank, uint stacks) => _abilityDefinition.Description; public virtual string GetAbilityDescription(int rank, FNStatsController statsController) => _abilityDefinition.persistDescription; public virtual float GetAbilityCastingTime(int rank, FNStatsController statsController) { float castingTime = _abilityDefinition.RanksDatas[rank].castTime; return castingTime; } public virtual IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { yield return null; } [Server] protected virtual void CasterBuffApply(Buff.BuffData casterBuffData, float duration = 1f) { Debug.Log($\"{_abilityName} Applying caster buff.\"); _buff.Activate(casterBuffData, new int[]{}, duration:duration); } protected virtual List<Collider> TargetsSelection(Transform caster) { Debug.LogWarning($\"{_abilityName} TargetsSelection method has not been implemented yet.\"); throw new NotImplementedException(); } [Server] protected void AOEDamageTargets(int casterNetId, float radius, vDamage damage, bool isExcludeSelf = false) { var playerComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); var targets = TargetsInSphereSelection(playerComps, radius); for (int i = 0; i < targets.Count; i++) { if (isExcludeSelf && targets[i] == playerComps.HealthController) { continue; } damage.receiver = targets[i].transform; targets[i].TakeDamage(damage); Debug.Log($\"[{_abilityDefinition.Name}] Damage applied to {targets[i].name}\"); } } [Server] protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, Buff.BuffData caster, float radius) { //Debug.Log($\"{_abilityName} Selecting targets in sphere.\"); List<FishnetInvectorHealthController> targets = EnemyTargetsInRadius(pos, caster, radius); //Debug.Log($\"{_abilityName} {targets.Count} targets found in sphere.\"); return targets; } [Server] protected List<FishnetInvectorHealthController> TargetsExcludingTagsInSphereSelection(string[] tags, Vector3 pos, Buff.BuffData caster, float radius) { List<FishnetInvectorHealthController> targets = TargetsInRadiusExcludingTags(tags, pos, caster, radius); return targets; } public static List<FishnetInvectorHealthController> TargetsInRadiusExcludingTags(string[] tags, Vector3 pos, Buff.BuffData caster, float radius) { List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>(); //check targets foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters) { var targetNob = GameplayManager.Instance.GetUnitNob(possibleTarget); if (targetNob == null) continue; for (int i = 0; i < tags.Length; i++) { if (targetNob.CompareTag(tags[i])) { continue; }  ",
          "content_tokens": 758,
          "embedding": []
        },
        {
          "cs_scriptfile": "Ability",
          "content": "if (!CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius)) continue; var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(possibleTarget); if (targetComps == null) continue; targets.Add(targetComps.HealthController); } return targets; } public static List<FishnetInvectorHealthController> EnemyTargetsInRadius(Vector3 pos, Buff.BuffData caster, float radius) { List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>(); //check targets foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters) { var targetNob = GameplayManager.Instance.GetUnitNob(possibleTarget); if (targetNob == null) continue; if (!CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius)) continue; var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(possibleTarget); if (targetComps == null) continue; Buff.BuffData targetData = new Buff.BuffData(targetComps.HealthController.ObjectId, targetComps.HealthController.gameObject.tag, 0f, caster.abilityId, 0, null, null, 0); if (IsNotValidTargetEnemy(caster, targetData)) continue; targets.Add(targetComps.HealthController); } return targets; } [Server] protected List<FishnetInvectorHealthController> EnemyTargetsInSphereSelection(Vector3 pos, UnitComponents caster, float radius) { Debug.Log($\"{_abilityName} Selecting targets in sphere.\"); List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>(); //check targets foreach (var possibleTarget in GameplayManager.Instance.UnitCharacters) { var targetNob = GameplayManager.Instance.GetUnitNob(possibleTarget); var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(possibleTarget); if (IsNotValidTargetEnemy(targetComps, caster)) { continue;  ",
          "content_tokens": 470,
          "embedding": []
        },
        {
          "cs_scriptfile": "Ability",
          "content": "if (CommonMath.Math.IsWithinRange(pos, targetNob.transform.position, radius)) { var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(possibleTarget); targets.Add(unitComps.HealthController); } } Debug.Log($\"{_abilityName} {targets.Count} targets found in sphere.\"); return targets; } [Server] protected List<FishnetInvectorHealthController> TargetsInSphereSelection(UnitComponents caster, float radius) { Debug.Log($\"{_abilityName} Selecting targets in sphere.\"); List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>(); //check targets foreach (var target in GameplayManager.Instance.UnitCharacters) { var targetNob = GameplayManager.Instance.GetUnitNob(target); var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNob.ObjectId); if (IsNotValidTargetEnemy(targetComps, caster)) { continue;  ",
          "content_tokens": 234,
          "embedding": []
        },
        {
          "cs_scriptfile": "Ability",
          "content": "if (CommonMath.Math.IsWithinRange(caster.HealthController.transform.position, targetNob.transform.position, radius)) { var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(target); targets.Add(unitComps.HealthController); } } Debug.Log($\"{_abilityName} {targets.Count} targets found in sphere.\"); return targets; } [ObserversRpc] protected void RpcShowEffectForObservers(int targetNetId, int abilityId, int rank, float timeout) { Debug.Log($\"{_abilityName} Showing effect for observers.\"); GameplayManager.Instance.StartCoroutine(ShowEffectOnTarget(targetNetId, abilityId, rank, timeout)); } protected virtual IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout) { Debug.Log($\"{_abilityName} Showing effect on target.\"); var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); if(targetComps == null) { Debug.LogError($\"{_abilityName} Target components are null. Cannot show effect on target.\"); yield break; } List<GameObject> effects = new List<GameObject>(); foreach (var attachementPoint in _abilityDefinition.RanksDatas[rank].FXattachmentPoints) { Transform pointTransform = targetComps.AttachmentPoints.GetAttachmentPoint(attachementPoint); GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pointTransform.position + Vector3.up, Quaternion.identity, GameplayManager.Instance.transform); effect.transform.SetParent(pointTransform); effects.Add(effect); } yield return new WaitForSeconds(timeout); foreach (var effect in effects) { Destroy(effect, timeout); } } public static bool IsNotValidTargetEnemy(Buff.BuffData casterData, Buff.BuffData targetData) { if (casterData.ObjectId == targetData.ObjectId) { return true; } int casterTeam = GameplayManager.Instance.GetUnitTeamId(casterData.ObjectId); int targetTeam = GameplayManager.Instance.GetUnitTeamId(targetData.ObjectId); if (casterData.Tag == GameplayManager.TAG_PLAYER) { if (casterTeam == targetTeam) { return true; } return false; }else if (targetData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID]) { if (casterData.Tag == GameplayManager.SERVER_AI_CONTROLLED_TAGS[GameplayManager.MONSTER_TAG_ID]) { return true; } return false; } return false;  ",
          "content_tokens": 629,
          "embedding": []
        },
        {
          "cs_scriptfile": "Ability",
          "content": "protected bool IsNotValidTargetEnemy(UnitComponents target, UnitComponents caster) { //Debug.Log($\"{_abilityName} Checking if target is valid.\"); if (target == null) return true; if (target == caster) { //Debug.Log($\"{_abilityName} Target is the same as caster. Invalid target.\"); return true; } var targetHealthController = target.HealthController; if (targetHealthController == null) { return true;  ",
          "content_tokens": 104,
          "embedding": []
        },
        {
          "cs_scriptfile": "Ability",
          "content": "if (targetHealthController.CompareTag(GameplayManager.TAG_PLAYER)) { //Debug.Log($\"{_abilityName} Target is a player. Valid target.\"); return false; }else if (targetHealthController.CompareTag(\"Enemy\")) { //Debug.Log($\"{_abilityName} Target is an enemy. Valid target.\"); if (caster.HealthController.CompareTag(\"Enemy\")) { return true; } return false; } //Debug.Log($\"{_abilityName} Target does not have a Player or Enemy tag. Invalid target.\"); return false;  ",
          "content_tokens": 128,
          "embedding": []
        },
        {
          "cs_scriptfile": "Ability",
          "content": "protected void DrawDebugSphere(Vector3 pos, float radius) { _debugSpherePos = pos; _debugSphereRadius = radius; _showDebugSphere = true; _debugSphereColor = DEBUG_SPHERE_ACTIVATE_COLOR; StartCoroutine(ResetDebugSphereColorAfterDelay(0.3f)); } protected IEnumerator ResetDebugSphereColorAfterDelay(float delay) { yield return new WaitForSeconds(delay); _debugSphereColor = DEBUG_SPHERE_DEFAULT_COLOR; _showDebugSphere = false; } public virtual float CalcAmount(FNStatsController statsController) { return 1f; } public virtual float CalcDuration(FNStatsController statsController) { return 1f; } #if UNITY_EDITOR protected void OnDrawGizmos() { if (_showDebugSphere) { Gizmos.color = _debugSphereColor; Gizmos.DrawSphere(_debugSpherePos, _debugSphereRadius); } } #endif }",
          "content_tokens": 217,
          "embedding": []
        }
      ],
      "length": 14025
    },
    {
      "filename": "AbilityBlessedLand",
      "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using FishnetInvector; using Invector; using UnityEngine; using SingletonsExtension; #if UNITY_EDITOR using UnityEditor; using UnityEngine; #endif public class AbilityBlessedLand : Ability { public static readonly float RADIUS = 4f; private static readonly float HEAL_FIELD_DURATION = 10f; private readonly float SMOKE_END_SIZE = 20f; private readonly float TIME_TO_REACH_END_SIZE = 1f; private readonly float TICK_COOLDOWN = 1f; private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.Wisdom; private readonly float BASE_HEAL_PER_TICK = 1f; private readonly float BASE_DURATION = 5f; private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Poison; private readonly string[] EXCLUDED_TAGS = new string[] { \"Enemy\" }; [SerializeField] private NetworkObject networkedParticleSystem; public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); private string _className; public override float CalcDuration(FNStatsController statsController) { return HEAL_FIELD_DURATION; } public override float CalcAmount(FNStatsController statsController) { return BASE_HEAL_PER_TICK + statsController.GetStatByType(AFFECTING_STAT).CurrentAmount * .1f; } /// <summary> /// Invokes by server to activate the ability. /// </summary> /// <param name=\"casterNetId\"></param> /// <param name=\"targetNetId\"></param> /// <param name=\"rank\"></param> /// <returns></returns> public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var casterComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition); var healthController = casterComps.HealthController; Vector3 effectPos = healthController.transform.position + new Vector3(.0f,.1f,.0f); NetworkObject nps = Instantiate(networkedParticleSystem, effectPos, Quaternion.identity); Spawn(nps); Debug.Log($\"{ClassName} Activated for unit #{casterNetId} with abilityId #{abilityId} and rank {rank}\"); float currentDuration = 0f; float tickTime = TICK_COOLDOWN; float radius = RADIUS; Buff.BuffData casterData = new Buff.BuffData(casterNetId, healthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null, CalcAmount(casterComps.StatsController)); while (currentDuration < CalcDuration(casterComps.StatsController)) { currentDuration += tickTime; DoHeal(casterData, effectPos, radius); yield return new WaitForSeconds(tickTime); } Despawn(nps); } [Server] private void DoHeal(Buff.BuffData casterData, Vector3 pos, float radius) { DrawDebugSphere(pos, radius); UpdateHealAmountIfCasterNobExists(casterData); var targets = TargetsExcludingTagsInSphereSelection(EXCLUDED_TAGS, pos, casterData, radius); FishnetInvectorHealthController.HealData healData = new FishnetInvectorHealthController.HealData(); healData.abilityId = AbilityDefinition.Id; healData.amount = casterData.Value; healData.senderNetId = casterData.ObjectId; foreach (var targetHealthController in targets) { targetHealthController.Heal(healData); StartCoroutine(ShowEffectOnTarget(targetHealthController.NetworkObject.ObjectId, AbilityDefinition.Id, 0, .5f)); } } private void UpdateHealAmountIfCasterNobExists(Buff.BuffData casterData) { var caster = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterData.ObjectId); if (caster != null) { casterData.Value = CalcAmount(caster.StatsController); } } protected override IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout) { Debug.Log($\"{_abilityName} Showing effect on target.\"); var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); if(targetComps == null) { Debug.LogError($\"{_abilityName} Target components are null. Cannot show effect on target.\"); yield break; } List<GameObject> effects = new List<GameObject>(); foreach (var attachementPoint in _abilityDefinition.RanksDatas[rank].FXattachmentPoints) { Transform pointTransform = targetComps.AttachmentPoints.GetAttachmentPoint(attachementPoint); GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pointTransform.position, Quaternion.identity); effect.transform.SetParent(pointTransform); effects.Add(effect); } yield return new WaitForSeconds(timeout); foreach (var effect in effects) { Destroy(effect, timeout); } } public override string GetAbilityDescription(int rank, FNStatsController statsController) { float amount = CalcAmount(statsController); float duration = CalcDuration(statsController); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@@@\", $\"<color={COLOR_DURATION}>{duration.ToString(\"F1\")}</color>\"); mainEdited = mainEdited.Replace(\"@@@@\", $\"<color=#00F0FF>{TICK_COOLDOWN.ToString(\"F1\")}</color>\"); mainEdited = mainEdited.Replace(\"@@@\", $\"<color=green>{(amount).ToString(\"F2\")}</color>\"); mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>\"; return $\"{mainEdited}\"; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AbilityBlessedLand",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "AbilityBlessedLand",
          "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using FishnetInvector; using Invector; using UnityEngine; using SingletonsExtension; #if UNITY_EDITOR using UnityEditor; using UnityEngine; #endif public class AbilityBlessedLand : Ability { public static readonly float RADIUS = 4f; private static readonly float HEAL_FIELD_DURATION = 10f; private readonly float SMOKE_END_SIZE = 20f; private readonly float TIME_TO_REACH_END_SIZE = 1f; private readonly float TICK_COOLDOWN = 1f; private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.Wisdom; private readonly float BASE_HEAL_PER_TICK = 1f; private readonly float BASE_DURATION = 5f; private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Poison; private readonly string[] EXCLUDED_TAGS = new string[] { \"Enemy\" }; [SerializeField] private NetworkObject networkedParticleSystem; public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); private string _className; public override float CalcDuration(FNStatsController statsController) { return HEAL_FIELD_DURATION; } public override float CalcAmount(FNStatsController statsController) { return BASE_HEAL_PER_TICK + statsController.GetStatByType(AFFECTING_STAT).CurrentAmount * .1f; } /// <summary> /// Invokes by server to activate the ability. /// </summary> /// <param name=\"casterNetId\"></param> /// <param name=\"targetNetId\"></param> /// <param name=\"rank\"></param> /// <returns></returns> public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var casterComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition); var healthController = casterComps.HealthController; Vector3 effectPos = healthController.transform.position + new Vector3(.0f,.1f,.0f); NetworkObject nps = Instantiate(networkedParticleSystem, effectPos, Quaternion.identity); Spawn(nps); Debug.Log($\"{ClassName} Activated for unit #{casterNetId} with abilityId #{abilityId} and rank {rank}\"); float currentDuration = 0f; float tickTime = TICK_COOLDOWN; float radius = RADIUS; Buff.BuffData casterData = new Buff.BuffData(casterNetId, healthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null, CalcAmount(casterComps.StatsController)); while (currentDuration < CalcDuration(casterComps.StatsController)) { currentDuration += tickTime; DoHeal(casterData, effectPos, radius); yield return new WaitForSeconds(tickTime);  ",
          "content_tokens": 738,
          "embedding": []
        },
        {
          "cs_scriptfile": "AbilityBlessedLand",
          "content": "Despawn(nps); } [Server] private void DoHeal(Buff.BuffData casterData, Vector3 pos, float radius) { DrawDebugSphere(pos, radius); UpdateHealAmountIfCasterNobExists(casterData); var targets = TargetsExcludingTagsInSphereSelection(EXCLUDED_TAGS, pos, casterData, radius); FishnetInvectorHealthController.HealData healData = new FishnetInvectorHealthController.HealData(); healData.abilityId = AbilityDefinition.Id; healData.amount = casterData.Value; healData.senderNetId = casterData.ObjectId; foreach (var targetHealthController in targets) { targetHealthController.Heal(healData); StartCoroutine(ShowEffectOnTarget(targetHealthController.NetworkObject.ObjectId, AbilityDefinition.Id, 0, .5f)); }  ",
          "content_tokens": 196,
          "embedding": []
        },
        {
          "cs_scriptfile": "AbilityBlessedLand",
          "content": "private void UpdateHealAmountIfCasterNobExists(Buff.BuffData casterData) { var caster = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterData.ObjectId); if (caster != null) { casterData.Value = CalcAmount(caster.StatsController); } } protected override IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout) { Debug.Log($\"{_abilityName} Showing effect on target.\"); var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); if(targetComps == null) { Debug.LogError($\"{_abilityName} Target components are null. Cannot show effect on target.\"); yield break; } List<GameObject> effects = new List<GameObject>(); foreach (var attachementPoint in _abilityDefinition.RanksDatas[rank].FXattachmentPoints) { Transform pointTransform = targetComps.AttachmentPoints.GetAttachmentPoint(attachementPoint); GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pointTransform.position, Quaternion.identity); effect.transform.SetParent(pointTransform); effects.Add(effect); } yield return new WaitForSeconds(timeout); foreach (var effect in effects) { Destroy(effect, timeout); } } public override string GetAbilityDescription(int rank, FNStatsController statsController) { float amount = CalcAmount(statsController); float duration = CalcDuration(statsController); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@@@\", $\"<color={COLOR_DURATION}>{duration.ToString(\"F1\")}</color>\"); mainEdited = mainEdited.Replace(\"@@@@\", $\"<color=#00F0FF>{TICK_COOLDOWN.ToString(\"F1\")}</color>\"); mainEdited = mainEdited.Replace(\"@@@\", $\"<color=green>{(amount).ToString(\"F2\")}</color>\"); mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>\"; return $\"{mainEdited}\"; } }",
          "content_tokens": 525,
          "embedding": []
        }
      ],
      "length": 5193
    },
    {
      "filename": "Backtrack",
      "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using FishnetInvector; using UnityEngine; public class Backtrack : Ability { private static float BACK_IN_TIME = 5f; private Dictionary<int, BacktrackableStats> _backtrackableStats = new Dictionary<int, BacktrackableStats>(); private List<int> _backtrackableUnits = new List<int>(); public override void InitAbility() { base.InitAbility(); GameplayManager.Instance.RewardAbilityManager.OnPlayerLearnedAbility_ServerOnly += RewardAbilityManager_OnPlayerLearnedAbility_ServerOnly; StartCoroutine(SaveAllPlayersStatsCoroutine()); } [Server] private void RewardAbilityManager_OnPlayerLearnedAbility_ServerOnly(int casterNetId, int abilityId) { if (abilityId == AbilityDefinition.Id) { SaveStats(casterNetId); } } [Server] private void SaveStats(int casterNetId) { var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); float currentHealth = unitComps.HealthController.CurrentHealth; float currentMana = 100f; float currentStamina = 100f; if (!_backtrackableStats.ContainsKey(casterNetId)) { _backtrackableStats.Add(casterNetId, new BacktrackableStats(currentMana, currentHealth, currentStamina)); } else { _backtrackableStats[casterNetId] = new BacktrackableStats(currentMana, currentHealth, currentStamina); } } [Server] private BacktrackableStats GetStats(int casterNetId) { if (_backtrackableStats.ContainsKey(casterNetId)) { return _backtrackableStats[casterNetId]; } else { DebugWrite.LogError($\"[Backtrack] No stats found for {casterNetId}\", gameObject, true); } return null; } [Server] private IEnumerator SaveAllPlayersStatsCoroutine() { while (true) { foreach (var casterNetId in _backtrackableUnits) { SaveStats(casterNetId); } yield return new WaitForSeconds(1f); } } [Server] public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); var stats = GetStats(casterNetId); if (stats == null) { yield break; } var healData = new FishnetInvectorHealthController.HealData(); healData.abilityId = AbilityDefinition.Id; healData.amount = stats.health; unitComps.HealthController.SetHealth(FishnetInvectorHealthController.HealthType.Current, healData); RpcShowEffectForObservers(casterNetId, AbilityDefinition.Id, _rank, 2.0f); yield return null; } public override string GetAbilityDescription(int rank, FNStatsController statsController) { string mainEdited = _abilityDefinition.mainDescription; return $\"{mainEdited}\"; } public class BacktrackableStats { public float mana; public float health; public float stamina; public BacktrackableStats(float mana, float health, float stamina) { this.mana = mana; this.health = health; this.stamina = stamina; } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Backtrack",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "Backtrack",
          "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using FishnetInvector; using UnityEngine; public class Backtrack : Ability { private static float BACK_IN_TIME = 5f; private Dictionary<int, BacktrackableStats> _backtrackableStats = new Dictionary<int, BacktrackableStats>(); private List<int> _backtrackableUnits = new List<int>(); public override void InitAbility() { base.InitAbility(); GameplayManager.Instance.RewardAbilityManager.OnPlayerLearnedAbility_ServerOnly += RewardAbilityManager_OnPlayerLearnedAbility_ServerOnly; StartCoroutine(SaveAllPlayersStatsCoroutine()); } [Server] private void RewardAbilityManager_OnPlayerLearnedAbility_ServerOnly(int casterNetId, int abilityId) { if (abilityId == AbilityDefinition.Id) { SaveStats(casterNetId); } } [Server] private void SaveStats(int casterNetId) { var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); float currentHealth = unitComps.HealthController.CurrentHealth; float currentMana = 100f; float currentStamina = 100f; if (!_backtrackableStats.ContainsKey(casterNetId)) { _backtrackableStats.Add(casterNetId, new BacktrackableStats(currentMana, currentHealth, currentStamina)); } else { _backtrackableStats[casterNetId] = new BacktrackableStats(currentMana, currentHealth, currentStamina); } } [Server] private BacktrackableStats GetStats(int casterNetId) { if (_backtrackableStats.ContainsKey(casterNetId)) { return _backtrackableStats[casterNetId]; } else { DebugWrite.LogError($\"[Backtrack] No stats found for {casterNetId}\", gameObject, true); } return null; } [Server] private IEnumerator SaveAllPlayersStatsCoroutine() { while (true) { foreach (var casterNetId in _backtrackableUnits) { SaveStats(casterNetId); } yield return new WaitForSeconds(1f); } } [Server] public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); var stats = GetStats(casterNetId); if (stats == null) { yield break; } var healData = new FishnetInvectorHealthController.HealData(); healData.abilityId = AbilityDefinition.Id; healData.amount = stats.health; unitComps.HealthController.SetHealth(FishnetInvectorHealthController.HealthType.Current, healData); RpcShowEffectForObservers(casterNetId, AbilityDefinition.Id, _rank, 2.0f); yield return null; } public override string GetAbilityDescription(int rank, FNStatsController statsController) { string mainEdited = _abilityDefinition.mainDescription; return $\"{mainEdited}\"; } public class BacktrackableStats { public float mana; public float health; public float stamina; public BacktrackableStats(float mana, float health, float stamina) { this.mana = mana; this.health = health; this.stamina = stamina; } } }",
          "content_tokens": 776,
          "embedding": []
        }
      ],
      "length": 2910
    },
    {
      "filename": "Blink",
      "content": "using System.Collections; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using FishnetInvector; using UnityEngine; public class Blink : Ability { private static float BLINK_DISTANCE = 8.0f; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { Debug.Log(\"Blink ability activated.\"); var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); if(unitComps == null) { Debug.LogError(\"Failed to retrieve Unit Components.\"); yield break; } NetworkConnection conn = unitComps.HealthController.Owner; TargetBlinkForward(conn, casterNetId); yield return null; } [TargetRpc] private void TargetBlinkForward(NetworkConnection conn, int casterNetId) { StringBuilder sb = new StringBuilder(); sb.Append(\"[Blink][TargetBlinkForward]\"); RaycastHit hit; var playerComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); FishnetInvectorManager playerFim = playerComps.InvectorManager; Transform hero = playerFim.transform; //get desired position with same y + forward + distance var lookRotation = Quaternion.LookRotation(hero.forward); sb.Append($\" before pos: {transform.position}, hero.forward: {hero.forward}; lookRotation: {lookRotation}\"); Vector3 rotationNormalized = new Vector3(.0f, hero.forward.y, .0f); sb.Append($\" rotationNormalized: {rotationNormalized}; \"); Vector3 destination = hero.position + hero.forward * BLINK_DISTANCE; sb.Append($\" destination: {destination}; \"); var defaultLayerMask = LayerMask.GetMask(\"Default\"); if (Physics.Linecast(hero.position + Vector3.up, destination + Vector3.up, out hit, defaultLayerMask)) { destination = hero.position + hero.forward * (hit.distance-.5f); } // if (Physics.Raycast(destination, -Vector3.up, out hit, BLINK_DISTANCE)) // { // destination = hit.point; // destination.y += .5f; // } destination.y += .2f; if (hit.transform != null) { sb.Append($\" hit: {hit.transform}, hit pos: {hit.transform.position}; \"); } sb.Append($\"result destination: {destination}, after pos: {transform.position}\"); DebugWrite.Log($\"{sb}\", gameObject, _isDebug); Vector3 oldPos = hero.position; playerFim.OwnerTeleport(destination); BlinkForwardServerRpc(oldPos, destination); Vector3 middlePoint = (oldPos + destination) / 2; InternalBlinkEffect(middlePoint, lookRotation); } [ServerRpc(RequireOwnership = false)] private void BlinkForwardServerRpc(Vector3 oldPos, Vector3 destination) { Debug.Log(\"Blink forward on server.\"); var directionRotation = Quaternion.LookRotation(destination - oldPos); Vector3 middlePoint = (oldPos + destination) / 2; Debug.Log($\"[Blink][BlinkForwardServerRpc] start: {oldPos}, Middle: {middlePoint}, destination: {destination}\"); SpawnEffectOnObservers(middlePoint, directionRotation); } [ObserversRpc(ExcludeOwner = true)] private void SpawnEffectOnObservers(Vector3 middlePoint, Quaternion directionRotation) { InternalBlinkEffect(middlePoint, directionRotation); } private void InternalBlinkEffect(Vector3 middlePoint, Quaternion directionRotation) { Debug.Log(\"Spawning blink effect.\"); var fx = _abilityDefinition.RanksDatas[0].hitEffect; if (fx != null) { GameObject fxInstance = Instantiate(fx, middlePoint, directionRotation); Destroy(fxInstance, 1.5f); } else { Debug.LogError(\"Failed to retrieve hit effect.\"); } } public override string GetAbilityDescription(int rank, FNStatsController statsController) { string mainEdited = _abilityDefinition.mainDescription; return $\"{mainEdited}\"; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Blink",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "Blink",
          "content": "using System.Collections; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using FishnetInvector; using UnityEngine; public class Blink : Ability { private static float BLINK_DISTANCE = 8.0f; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { Debug.Log(\"Blink ability activated.\"); var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); if(unitComps == null) { Debug.LogError(\"Failed to retrieve Unit Components.\"); yield break; } NetworkConnection conn = unitComps.HealthController.Owner; TargetBlinkForward(conn, casterNetId); yield return null; } [TargetRpc] private void TargetBlinkForward(NetworkConnection conn, int casterNetId) { StringBuilder sb = new StringBuilder(); sb.Append(\"[Blink][TargetBlinkForward]\"); RaycastHit hit; var playerComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); FishnetInvectorManager playerFim = playerComps.InvectorManager; Transform hero = playerFim.transform; //get desired position with same y + forward + distance var lookRotation = Quaternion.LookRotation(hero.forward); sb.Append($\" before pos: {transform.position}, hero.forward: {hero.forward}; lookRotation: {lookRotation}\"); Vector3 rotationNormalized = new Vector3(.0f, hero.forward.y, .0f); sb.Append($\" rotationNormalized: {rotationNormalized}; \"); Vector3 destination = hero.position + hero.forward * BLINK_DISTANCE; sb.Append($\" destination: {destination}; \"); var defaultLayerMask = LayerMask.GetMask(\"Default\"); if (Physics.Linecast(hero.position + Vector3.up, destination + Vector3.up, out hit, defaultLayerMask)) { destination = hero.position + hero.forward * (hit.distance-.5f); } // if (Physics.Raycast(destination, -Vector3.up, out hit, BLINK_DISTANCE)) // { // destination = hit.point; // destination.y += .5f; // } destination.y += .2f; if (hit.transform != null) { sb.Append($\" hit: {hit.transform}, hit pos: {hit.transform.position}; \"); } sb.Append($\"result destination: {destination}, after pos: {transform.position}\"); DebugWrite.Log($\"{sb}\", gameObject, _isDebug); Vector3 oldPos = hero.position; playerFim.OwnerTeleport(destination); BlinkForwardServerRpc(oldPos, destination); Vector3 middlePoint = (oldPos + destination) / 2; InternalBlinkEffect(middlePoint, lookRotation); } [ServerRpc(RequireOwnership = false)] private void BlinkForwardServerRpc(Vector3 oldPos, Vector3 destination) { Debug.Log(\"Blink forward on server.\"); var directionRotation = Quaternion.LookRotation(destination - oldPos); Vector3 middlePoint = (oldPos + destination) / 2; Debug.Log($\"[Blink][BlinkForwardServerRpc] start: {oldPos}, Middle: {middlePoint}, destination: {destination}\"); SpawnEffectOnObservers(middlePoint, directionRotation); } [ObserversRpc(ExcludeOwner = true)] private void SpawnEffectOnObservers(Vector3 middlePoint, Quaternion directionRotation) { InternalBlinkEffect(middlePoint, directionRotation);  ",
          "content_tokens": 871,
          "embedding": []
        },
        {
          "cs_scriptfile": "Blink",
          "content": "private void InternalBlinkEffect(Vector3 middlePoint, Quaternion directionRotation) { Debug.Log(\"Spawning blink effect.\"); var fx = _abilityDefinition.RanksDatas[0].hitEffect; if (fx != null) { GameObject fxInstance = Instantiate(fx, middlePoint, directionRotation); Destroy(fxInstance, 1.5f); } else { Debug.LogError(\"Failed to retrieve hit effect.\"); } } public override string GetAbilityDescription(int rank, FNStatsController statsController) { string mainEdited = _abilityDefinition.mainDescription; return $\"{mainEdited}\"; } }",
          "content_tokens": 139,
          "embedding": []
        }
      ],
      "length": 3589
    },
    {
      "filename": "BreathOfFire",
      "content": "using System.Collections; using System.Collections.Generic; using System.Linq; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using FishnetInvector; using Invector; using UnityEngine; public class BreathOfFire : Ability { private static float DURATION = 5f; private static float TICK_COOLDOWN = 1f; private static float TICK_BASE_DAMAGE = 10f; private static float CONE_ANGLE = 30f; private static float CONE_RANGE = 10f; private static float TARGETS_CHECKER_COOLDOWN = .5f; private FishnetInvectorHealthController[] _targetHealthControllers; [Server] public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); StartCoroutine(DOT(casterNetId, unitComps)); StartCoroutine(BuffApplier(casterNetId, unitComps, rank)); yield return null; } [Server] private IEnumerator BuffApplier(int casterNetId, UnitComponents unitComps, int rank = 0) { float channelTime = _abilityDefinition.RanksDatas[rank].channelTime; float channelEndTime = Time.time + channelTime; WaitForSeconds cooldown = new WaitForSeconds(TARGETS_CHECKER_COOLDOWN); while (Time.time < channelEndTime) { //select targets in front of the player in a cone List<FishnetInvectorHealthController> targets = EnemyTargetsInSphereSelection(unitComps.HealthController.transform.position, unitComps, CONE_RANGE); Buff.BuffData casterData = new Buff.BuffData(casterNetId, unitComps.HealthController.gameObject.tag, 0f, AbilityDefinition.Id,1, null, null, 0); _buff.Activate(casterData, targets.Select(t => t.ObjectId).ToArray()); yield return cooldown; } } [Server] private IEnumerator DOT(int casterNetId, UnitComponents unitComps) { float dotEndTime = Time.time + DURATION; while (Time.time < dotEndTime) { yield return new WaitForSeconds(TICK_COOLDOWN); if (_targetHealthControllers == null) yield break; foreach (FishnetInvectorHealthController healthController in _targetHealthControllers) { if (_buff.IsBuffedByCaster(casterNetId, healthController.NetworkObject.ObjectId)) { float dmg = CalculateDOTEffect(unitComps.StatsController); vDamage damage = new vDamage(dmg, casterNetId, unitComps.HealthController.transform, \"Fire\"); healthController.TakeDamage(damage); } } } } [Server] private float CalculateDOTEffect(FNStatsController playerStats) { float damage = 10.0f + (float)playerStats.GetAllCurrentValue(Stat.STAT_TYPE.INTELLECT); return damage; } [Server] protected virtual List<NetworkObject> TargetsSelection(Transform caster) { List<int> possibleTargets = new List<int>(); possibleTargets.AddRange(GameplayManager.Instance.UnitCharacters); List<NetworkObject> targetsInCone = new List<NetworkObject>(); foreach (var targetId in possibleTargets) { var targetNob = GameplayManager.Instance.GetUnitNob(targetId); if (targetNob == null) continue; var targetUnitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetId); //if (IsNotValidTargetEnemy(targetUnitComps, caster)) continue; Vector3 directionToTarget = targetNob.transform.position - caster.position; float angleToTarget = Vector3.Angle(caster.forward, directionToTarget); // If the target is within the cone and within the specified detection distance if (angleToTarget < CONE_ANGLE * 0.5f && directionToTarget.magnitude <= CONE_RANGE) { // Add target to the list targetsInCone.Add(targetNob); } } return targetsInCone; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BreathOfFire",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "BreathOfFire",
          "content": "using System.Collections; using System.Collections.Generic; using System.Linq; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using FishnetInvector; using Invector; using UnityEngine; public class BreathOfFire : Ability { private static float DURATION = 5f; private static float TICK_COOLDOWN = 1f; private static float TICK_BASE_DAMAGE = 10f; private static float CONE_ANGLE = 30f; private static float CONE_RANGE = 10f; private static float TARGETS_CHECKER_COOLDOWN = .5f; private FishnetInvectorHealthController[] _targetHealthControllers; [Server] public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); StartCoroutine(DOT(casterNetId, unitComps)); StartCoroutine(BuffApplier(casterNetId, unitComps, rank)); yield return null; } [Server] private IEnumerator BuffApplier(int casterNetId, UnitComponents unitComps, int rank = 0) { float channelTime = _abilityDefinition.RanksDatas[rank].channelTime; float channelEndTime = Time.time + channelTime; WaitForSeconds cooldown = new WaitForSeconds(TARGETS_CHECKER_COOLDOWN); while (Time.time < channelEndTime) { //select targets in front of the player in a cone List<FishnetInvectorHealthController> targets = EnemyTargetsInSphereSelection(unitComps.HealthController.transform.position, unitComps, CONE_RANGE); Buff.BuffData casterData = new Buff.BuffData(casterNetId, unitComps.HealthController.gameObject.tag, 0f, AbilityDefinition.Id,1, null, null, 0); _buff.Activate(casterData, targets.Select(t => t.ObjectId).ToArray()); yield return cooldown; } } [Server] private IEnumerator DOT(int casterNetId, UnitComponents unitComps) { float dotEndTime = Time.time + DURATION; while (Time.time < dotEndTime) { yield return new WaitForSeconds(TICK_COOLDOWN); if (_targetHealthControllers == null) yield break; foreach (FishnetInvectorHealthController healthController in _targetHealthControllers) { if (_buff.IsBuffedByCaster(casterNetId, healthController.NetworkObject.ObjectId)) { float dmg = CalculateDOTEffect(unitComps.StatsController); vDamage damage = new vDamage(dmg, casterNetId, unitComps.HealthController.transform, \"Fire\"); healthController.TakeDamage(damage); } } } } [Server] private float CalculateDOTEffect(FNStatsController playerStats) { float damage = 10.0f + (float)playerStats.GetAllCurrentValue(Stat.STAT_TYPE.INTELLECT); return damage; } [Server] protected virtual List<NetworkObject> TargetsSelection(Transform caster) { List<int> possibleTargets = new List<int>(); possibleTargets.AddRange(GameplayManager.Instance.UnitCharacters); List<NetworkObject> targetsInCone = new List<NetworkObject>(); foreach (var targetId in possibleTargets) { var targetNob = GameplayManager.Instance.GetUnitNob(targetId); if (targetNob == null) continue; var targetUnitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetId); //if (IsNotValidTargetEnemy(targetUnitComps, caster)) continue; Vector3 directionToTarget = targetNob.transform.position - caster.position; float angleToTarget = Vector3.Angle(caster.forward, directionToTarget); // If the target is within the cone and within the specified detection distance if (angleToTarget < CONE_ANGLE * 0.5f && directionToTarget.magnitude <= CONE_RANGE) { // Add target to the list targetsInCone.Add(targetNob); } } return targetsInCone; } }",
          "content_tokens": 966,
          "embedding": []
        }
      ],
      "length": 3457
    },
    {
      "filename": "CrystalNova",
      "content": "using System.Collections; using System.Linq; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using Invector; using UnityEngine; using SingletonsExtension; using UnityEngine.VFX; #if UNITY_EDITOR using UnityEditor; using UnityEngine; #endif public class CrystalNova : Ability { public static readonly float NOVA_RADIUS = 3.6f; private static readonly float CRYSTAL_FIELD_DURATION = 10f; private readonly float SMOKE_END_SIZE = 20f; private readonly float TIME_TO_REACH_END_SIZE = 1f; private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.Wisdom; private readonly float BASE_DAMAGE_PER_TICK = 3f; private readonly float TICK_TIME = 3f; private readonly float BASE_DURATION = 5f; private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Magic; [SerializeField] private NetworkObject networkedParticleSystem; public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); private string _className; private float GetCrystalFeildDuration() { return CRYSTAL_FIELD_DURATION; } private float CalculateTickDamage(float wisdom) { return BASE_DAMAGE_PER_TICK + wisdom * .1f; } public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var casterComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition); var healthController = casterComps.HealthController; NetworkObject nps = Instantiate(networkedParticleSystem, healthController.transform.position, Quaternion.identity); Spawn(nps); RpcShowEffectForObservers(casterNetId, abilityId, _rank, GetCrystalFeildDuration()); Debug.Log($\"{ClassName} Activated for unit #{casterNetId} with abilityId #{abilityId} and rank {rank}\"); float currentDuration = 0f; float tickTime = TICK_TIME; Buff.BuffData casterData = new Buff.BuffData(casterNetId, healthController.gameObject.tag, 0, AbilityDefinition.Id, rank, null, null, CalculateTickDamage(casterComps.StatsController.GetAllCurrentValue(AFFECTING_STAT))); vDamage damage = Buff.GetTickDamage(casterComps, casterData, DAMAGE_TYPE); Vector3 crystalCloudPos = healthController.transform.position; while (currentDuration < GetCrystalFeildDuration()) { currentDuration += tickTime; InstaBuffApplier(casterData, crystalCloudPos, damage, NOVA_RADIUS); yield return new WaitForSeconds(tickTime); } Despawn(nps); } [Server] private void InstaBuffApplier(Buff.BuffData casterData, Vector3 pos, vDamage damage, float radius) { DrawDebugSphere(pos, radius); var caster = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterData.ObjectId); if (caster != null) { damage = UpdateDamage(ref casterData, caster); } var targets = EnemyTargetsInSphereSelection(pos, casterData, radius); //remove duplicates var targetCleared = targets.Distinct().Select(t => t.NetworkObject.ObjectId).ToArray(); if (targetCleared.Length == 0) { return; } else { _buff.Activate(casterData, targetCleared, BASE_DURATION, damage); } } private vDamage UpdateDamage(ref Buff.BuffData casterData, GameplayManager.UnitComponents caster) { vDamage damage; casterData = new Buff.BuffData(casterData.ObjectId, caster.HealthController.gameObject.tag, 0, AbilityDefinition.Id, casterData.Rank, null, null, CalculateTickDamage(caster.StatsController.GetAllCurrentValue(AFFECTING_STAT))); damage = Buff.GetTickDamage(caster, casterData, DAMAGE_TYPE); return damage; } protected override IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout) { Debug.Log($\"{_abilityName} Showing effect on target.\"); var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); if (targetComps == null) { Debug.LogError($\"[{ClassName}]{_abilityName} Target components are null. Cannot show effect on target.\"); yield break; } Vector3 pos = targetComps.HealthController.transform.position; GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pos, Quaternion.identity); VisualEffect vfxGraph = effect.GetComponent<VisualEffect>(); float cloudCurrentSize = vfxGraph.GetFloat(\"SmokeSize\"); float timeElapsed = 0f; while (timeElapsed < TIME_TO_REACH_END_SIZE) { cloudCurrentSize = Mathf.Lerp(cloudCurrentSize, SMOKE_END_SIZE, timeElapsed / TIME_TO_REACH_END_SIZE); vfxGraph.SetFloat(\"SmokeSize\", cloudCurrentSize); timeElapsed += Time.deltaTime; yield return null; } Destroy(effect, timeout); } public override string GetAbilityDescription(int rank, FNStatsController statsController) { float damage = CalculateTickDamage(statsController.GetAllCurrentValue(AFFECTING_STAT)); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color={COLOR_DAMAGE}>{damage.ToString(\"F2\")}</color>\"); mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>\"; return $\"{mainEdited}\"; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CrystalNova",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "CrystalNova",
          "content": "using System.Collections; using System.Linq; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using Invector; using UnityEngine; using SingletonsExtension; using UnityEngine.VFX; #if UNITY_EDITOR using UnityEditor; using UnityEngine; #endif public class CrystalNova : Ability { public static readonly float NOVA_RADIUS = 3.6f; private static readonly float CRYSTAL_FIELD_DURATION = 10f; private readonly float SMOKE_END_SIZE = 20f; private readonly float TIME_TO_REACH_END_SIZE = 1f; private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.Wisdom; private readonly float BASE_DAMAGE_PER_TICK = 3f; private readonly float TICK_TIME = 3f; private readonly float BASE_DURATION = 5f; private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Magic; [SerializeField] private NetworkObject networkedParticleSystem; public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); private string _className; private float GetCrystalFeildDuration() { return CRYSTAL_FIELD_DURATION;  ",
          "content_tokens": 309,
          "embedding": []
        },
        {
          "cs_scriptfile": "CrystalNova",
          "content": "private float CalculateTickDamage(float wisdom) { return BASE_DAMAGE_PER_TICK + wisdom * .1f; } public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var casterComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition); var healthController = casterComps.HealthController; NetworkObject nps = Instantiate(networkedParticleSystem, healthController.transform.position, Quaternion.identity); Spawn(nps); RpcShowEffectForObservers(casterNetId, abilityId, _rank, GetCrystalFeildDuration()); Debug.Log($\"{ClassName} Activated for unit #{casterNetId} with abilityId #{abilityId} and rank {rank}\"); float currentDuration = 0f; float tickTime = TICK_TIME; Buff.BuffData casterData = new Buff.BuffData(casterNetId, healthController.gameObject.tag, 0, AbilityDefinition.Id, rank, null, null, CalculateTickDamage(casterComps.StatsController.GetAllCurrentValue(AFFECTING_STAT))); vDamage damage = Buff.GetTickDamage(casterComps, casterData, DAMAGE_TYPE); Vector3 crystalCloudPos = healthController.transform.position; while (currentDuration < GetCrystalFeildDuration()) { currentDuration += tickTime; InstaBuffApplier(casterData, crystalCloudPos, damage, NOVA_RADIUS); yield return new WaitForSeconds(tickTime);  ",
          "content_tokens": 374,
          "embedding": []
        },
        {
          "cs_scriptfile": "CrystalNova",
          "content": "Despawn(nps); } [Server] private void InstaBuffApplier(Buff.BuffData casterData, Vector3 pos, vDamage damage, float radius) { DrawDebugSphere(pos, radius); var caster = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterData.ObjectId); if (caster != null) { damage = UpdateDamage(ref casterData, caster); } var targets = EnemyTargetsInSphereSelection(pos, casterData, radius); //remove duplicates var targetCleared = targets.Distinct().Select(t => t.NetworkObject.ObjectId).ToArray(); if (targetCleared.Length == 0) { return; } else { _buff.Activate(casterData, targetCleared, BASE_DURATION, damage); } } private vDamage UpdateDamage(ref Buff.BuffData casterData, GameplayManager.UnitComponents caster) { vDamage damage; casterData = new Buff.BuffData(casterData.ObjectId, caster.HealthController.gameObject.tag, 0, AbilityDefinition.Id, casterData.Rank, null, null, CalculateTickDamage(caster.StatsController.GetAllCurrentValue(AFFECTING_STAT))); damage = Buff.GetTickDamage(caster, casterData, DAMAGE_TYPE); return damage; } protected override IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout) { Debug.Log($\"{_abilityName} Showing effect on target.\"); var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); if (targetComps == null) { Debug.LogError($\"[{ClassName}]{_abilityName} Target components are null. Cannot show effect on target.\"); yield break; } Vector3 pos = targetComps.HealthController.transform.position; GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pos, Quaternion.identity); VisualEffect vfxGraph = effect.GetComponent<VisualEffect>(); float cloudCurrentSize = vfxGraph.GetFloat(\"SmokeSize\"); float timeElapsed = 0f; while (timeElapsed < TIME_TO_REACH_END_SIZE) { cloudCurrentSize = Mathf.Lerp(cloudCurrentSize, SMOKE_END_SIZE, timeElapsed / TIME_TO_REACH_END_SIZE); vfxGraph.SetFloat(\"SmokeSize\", cloudCurrentSize); timeElapsed += Time.deltaTime; yield return null;  ",
          "content_tokens": 569,
          "embedding": []
        },
        {
          "cs_scriptfile": "CrystalNova",
          "content": "Destroy(effect, timeout); } public override string GetAbilityDescription(int rank, FNStatsController statsController) { float damage = CalculateTickDamage(statsController.GetAllCurrentValue(AFFECTING_STAT)); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color={COLOR_DAMAGE}>{damage.ToString(\"F2\")}</color>\"); mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>\"; return $\"{mainEdited}\"; } }",
          "content_tokens": 154,
          "embedding": []
        }
      ],
      "length": 4928
    },
    {
      "filename": "DivineShield",
      "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Object; using UnityEngine; public class DivineShield : Ability { private static float DEFAULT_DURATION = 6f; private static Stat.STAT_TYPE STAT_TYPE = Stat.STAT_TYPE.Wisdom; private static float STAT_MOD = .1f; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var casterComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); float duration = DEFAULT_DURATION; if (casterComps == null) { Debug.LogError($\"[DivineShield] casterComps is null\"); } else { duration = CalcDuration(casterComps.StatsController); } float finishTime = GameplayManager.GetCurrentServerTime() + duration; Buff.BuffData casterData = new Buff.BuffData(casterNetId, casterComps.HealthController.gameObject.tag, finishTime, AbilityDefinition.Id, 0, null, null, 0); CasterBuffApply(casterData, duration); yield return null; } [Server] protected override void CasterBuffApply(Buff.BuffData casterBuffData, float duration = 1f) { Debug.Log($\"{_abilityName} Applying caster buff.\"); _buff.Activate(casterBuffData, new int[]{}, duration); } public virtual float CalcDuration(FNStatsController statsController) { return DEFAULT_DURATION + statsController.GetStatByType(STAT_TYPE).CurrentAmount * STAT_MOD; } public virtual string GetAbilityDescription(int rank, uint stacks) => _abilityDefinition.Description; public override string GetAbilityDescription(int rank, FNStatsController statsController) { float duration = CalcDuration(statsController); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color={COLOR_DURATION}>{duration.ToString(\"F2\")}</color>\"); mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{STAT_TYPE.ToString()}</color>\"; //string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); //questEdited = questEdited.Replace(\"@@@@@\", $\"{(DAMAGE_REDUCTION_PER_RANK * 100).ToString(\"F0\")}%\"); return $\"{mainEdited}\"; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DivineShield",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "DivineShield",
          "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Object; using UnityEngine; public class DivineShield : Ability { private static float DEFAULT_DURATION = 6f; private static Stat.STAT_TYPE STAT_TYPE = Stat.STAT_TYPE.Wisdom; private static float STAT_MOD = .1f; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var casterComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); float duration = DEFAULT_DURATION; if (casterComps == null) { Debug.LogError($\"[DivineShield] casterComps is null\"); } else { duration = CalcDuration(casterComps.StatsController); } float finishTime = GameplayManager.GetCurrentServerTime() + duration; Buff.BuffData casterData = new Buff.BuffData(casterNetId, casterComps.HealthController.gameObject.tag, finishTime, AbilityDefinition.Id, 0, null, null, 0); CasterBuffApply(casterData, duration); yield return null; } [Server] protected override void CasterBuffApply(Buff.BuffData casterBuffData, float duration = 1f) { Debug.Log($\"{_abilityName} Applying caster buff.\"); _buff.Activate(casterBuffData, new int[]{}, duration); } public virtual float CalcDuration(FNStatsController statsController) { return DEFAULT_DURATION + statsController.GetStatByType(STAT_TYPE).CurrentAmount * STAT_MOD; } public virtual string GetAbilityDescription(int rank, uint stacks) => _abilityDefinition.Description; public override string GetAbilityDescription(int rank, FNStatsController statsController) { float duration = CalcDuration(statsController); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color={COLOR_DURATION}>{duration.ToString(\"F2\")}</color>\"); mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{STAT_TYPE.ToString()}</color>\"; //string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); //questEdited = questEdited.Replace(\"@@@@@\", $\"{(DAMAGE_REDUCTION_PER_RANK * 100).ToString(\"F0\")}%\"); return $\"{mainEdited}\"; } }",
          "content_tokens": 658,
          "embedding": []
        }
      ],
      "length": 2269
    },
    {
      "filename": "EnergyShield",
      "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; public class EnergyShield : Ability { private static float DAMAGE_INSTANCES = 2f; private static Stat.STAT_TYPE STAT_TYPE = Stat.STAT_TYPE.ABILITY_ENERGY_SHIELD_ABSORBTIONS; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); unitComps.StatsController.AddChanges(STAT_TYPE, CombatEntityStat.From.Timed, DAMAGE_INSTANCES); Buff.BuffData casterData = new Buff.BuffData(casterNetId, unitComps.HealthController.gameObject.tag, 60f, AbilityDefinition.Id, 1, null, null, 0); CasterBuffApply(casterData); yield return null; } public static bool IsDamageAbsorbed(FNStatsController statsController) { bool isAbsorbed = statsController.GetAllCurrentValue(STAT_TYPE) > float.Epsilon; if (isAbsorbed) { statsController.AddChanges(STAT_TYPE, CombatEntityStat.From.Timed, -1f); DebugWrite.Log($\"[EnergyShield][IsDamageAbsorbed] ABILITY_ENERGY_SHIELD_ABSORBTIONS {statsController.GetAllCurrentValue(STAT_TYPE)} stacks left.\"); } else { //TODO Remove Buff } return isAbsorbed; } private float CalcDamage(FNStatsController statsController) { return DAMAGE_INSTANCES; } public override string GetAbilityDescription(int rank, FNStatsController statsController) { float damage = CalcDamage(statsController); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color={COLOR_DAMAGE}>{damage.ToString(\"F2\")}</color>\"); // mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{STAT_TYPE.ToString()}</color>\"; //string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); return $\"{mainEdited}\"; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "EnergyShield",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "EnergyShield",
          "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; public class EnergyShield : Ability { private static float DAMAGE_INSTANCES = 2f; private static Stat.STAT_TYPE STAT_TYPE = Stat.STAT_TYPE.ABILITY_ENERGY_SHIELD_ABSORBTIONS; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); unitComps.StatsController.AddChanges(STAT_TYPE, CombatEntityStat.From.Timed, DAMAGE_INSTANCES); Buff.BuffData casterData = new Buff.BuffData(casterNetId, unitComps.HealthController.gameObject.tag, 60f, AbilityDefinition.Id, 1, null, null, 0); CasterBuffApply(casterData); yield return null; } public static bool IsDamageAbsorbed(FNStatsController statsController) { bool isAbsorbed = statsController.GetAllCurrentValue(STAT_TYPE) > float.Epsilon; if (isAbsorbed) { statsController.AddChanges(STAT_TYPE, CombatEntityStat.From.Timed, -1f); DebugWrite.Log($\"[EnergyShield][IsDamageAbsorbed] ABILITY_ENERGY_SHIELD_ABSORBTIONS {statsController.GetAllCurrentValue(STAT_TYPE)} stacks left.\"); } else { //TODO Remove Buff } return isAbsorbed;  ",
          "content_tokens": 374,
          "embedding": []
        },
        {
          "cs_scriptfile": "EnergyShield",
          "content": "private float CalcDamage(FNStatsController statsController) { return DAMAGE_INSTANCES; } public override string GetAbilityDescription(int rank, FNStatsController statsController) { float damage = CalcDamage(statsController); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color={COLOR_DAMAGE}>{damage.ToString(\"F2\")}</color>\"); // mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{STAT_TYPE.ToString()}</color>\"; //string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); return $\"{mainEdited}\"; } }",
          "content_tokens": 239,
          "embedding": []
        }
      ],
      "length": 2019
    },
    {
      "filename": "FleshExplosion",
      "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishnetInvector; using Invector; public class FleshExplosion : Ability { private static float HEALTH_TO_DAMAGE_MOD = .75f; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { UnitComponents playerComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); float health = playerComps.HealthController.CurrentHealth; float damageValue = CalcDamage(playerComps.HealthController); vDamage damage = new vDamage(damageValue, casterNetId, playerComps.HealthController.transform, \"Blood\"); damage.type = vDamage.DamageType.Blood; AOEDamageTargets(casterNetId, 5.0f, damage, true); RpcShowEffectForObservers(casterNetId, AbilityDefinition.Id, _rank, 3.0f); int howMuchDamagePlayerTakes = health - damage.damageValue < 0 ? (int)health : damage.damageValue; damage.damageValue = howMuchDamagePlayerTakes; playerComps.HealthController.TakeDamage(damage); yield return null; } private float CalcDamage(FishnetInvectorHealthController statsController) { return statsController.CurrentHealth * HEALTH_TO_DAMAGE_MOD; } public override string GetAbilityDescription(int rank, FNStatsController statsController) { var damage = HEALTH_TO_DAMAGE_MOD * 100; string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color={COLOR_DAMAGE}>{damage.ToString(\"F2\")}%</color>\"); return $\"{mainEdited}\"; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "FleshExplosion",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "FleshExplosion",
          "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishnetInvector; using Invector; public class FleshExplosion : Ability { private static float HEALTH_TO_DAMAGE_MOD = .75f; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { UnitComponents playerComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); float health = playerComps.HealthController.CurrentHealth; float damageValue = CalcDamage(playerComps.HealthController); vDamage damage = new vDamage(damageValue, casterNetId, playerComps.HealthController.transform, \"Blood\"); damage.type = vDamage.DamageType.Blood; AOEDamageTargets(casterNetId, 5.0f, damage, true); RpcShowEffectForObservers(casterNetId, AbilityDefinition.Id, _rank, 3.0f); int howMuchDamagePlayerTakes = health - damage.damageValue < 0 ? (int)health : damage.damageValue; damage.damageValue = howMuchDamagePlayerTakes; playerComps.HealthController.TakeDamage(damage); yield return null;  ",
          "content_tokens": 296,
          "embedding": []
        },
        {
          "cs_scriptfile": "FleshExplosion",
          "content": "private float CalcDamage(FishnetInvectorHealthController statsController) { return statsController.CurrentHealth * HEALTH_TO_DAMAGE_MOD; } public override string GetAbilityDescription(int rank, FNStatsController statsController) { var damage = HEALTH_TO_DAMAGE_MOD * 100; string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color={COLOR_DAMAGE}>{damage.ToString(\"F2\")}%</color>\"); return $\"{mainEdited}\"; } }",
          "content_tokens": 122,
          "embedding": []
        }
      ],
      "length": 1476
    },
    {
      "filename": "FrostNova",
      "content": "using System.Collections; using System.Collections.Generic; using System.Linq; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; using FishNet.Object; using FishnetInvector; using Invector; using SingletonsExtension; public class FrostNova : Ability { private static readonly float NOVA_RADIUS = 100f; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var playerComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition); RpcShowEffectForObservers(casterNetId, abilityId, _rank, 1f); Debug.Log($\"[FrostNova] Activated for player {casterNetId} with abilityId {abilityId} and rank {rank}\"); yield return new WaitForSeconds(.5f); InstaBuffApplier(casterNetId, playerComps, rank, out List<FishnetInvectorHealthController> _targetHealthControllers); if (_targetHealthControllers.Count == 0) { Debug.Log($\"[FrostNova] No targets found.\"); yield break; } float dmg = CalculateDamage(playerComps.StatsController); Debug.Log($\"[FrostNova] Damage calculated: {dmg}\"); vDamage damage = new vDamage(dmg, casterNetId, playerComps.HealthController.transform, \"Ice\"); for (int i = 0; i < _targetHealthControllers.Count; i++) { damage.receiver = _targetHealthControllers[i].transform; _targetHealthControllers[i].TakeDamage(damage); Debug.Log($\"[FrostNova] Damage applied to {_targetHealthControllers[i].name}\"); } } [Server] private void InstaBuffApplier(int casterNetId, UnitComponents unitComps, int rank, out List<FishnetInvectorHealthController> targets) { targets = TargetsInSphereSelection(unitComps, NOVA_RADIUS); Buff.BuffData casterData = new Buff.BuffData(casterNetId, unitComps.HealthController.gameObject.tag, 0, AbilityDefinition.Id,1, null, null, 0); _buff.Activate(casterData, targets.Select(t => t.NetworkObject.ObjectId).ToArray()); Debug.Log($\"[FrostNova] Buff activated for targets.\"); } [Server] private float CalculateDamage(FNStatsController playerStats) { float damage = 5.0f + (float)playerStats.GetAllCurrentValue(Stat.STAT_TYPE.INTELLECT); Debug.Log($\"[FrostNova] Damage calculated: {damage}\"); return damage; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "FrostNova",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "FrostNova",
          "content": "using System.Collections; using System.Collections.Generic; using System.Linq; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; using FishNet.Object; using FishnetInvector; using Invector; using SingletonsExtension; public class FrostNova : Ability { private static readonly float NOVA_RADIUS = 100f; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var playerComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition); RpcShowEffectForObservers(casterNetId, abilityId, _rank, 1f); Debug.Log($\"[FrostNova] Activated for player {casterNetId} with abilityId {abilityId} and rank {rank}\"); yield return new WaitForSeconds(.5f); InstaBuffApplier(casterNetId, playerComps, rank, out List<FishnetInvectorHealthController> _targetHealthControllers); if (_targetHealthControllers.Count == 0) { Debug.Log($\"[FrostNova] No targets found.\"); yield break; } float dmg = CalculateDamage(playerComps.StatsController); Debug.Log($\"[FrostNova] Damage calculated: {dmg}\"); vDamage damage = new vDamage(dmg, casterNetId, playerComps.HealthController.transform, \"Ice\"); for (int i = 0; i < _targetHealthControllers.Count; i++) { damage.receiver = _targetHealthControllers[i].transform; _targetHealthControllers[i].TakeDamage(damage); Debug.Log($\"[FrostNova] Damage applied to {_targetHealthControllers[i].name}\"); } } [Server] private void InstaBuffApplier(int casterNetId, UnitComponents unitComps, int rank, out List<FishnetInvectorHealthController> targets) { targets = TargetsInSphereSelection(unitComps, NOVA_RADIUS); Buff.BuffData casterData = new Buff.BuffData(casterNetId, unitComps.HealthController.gameObject.tag, 0, AbilityDefinition.Id,1, null, null, 0); _buff.Activate(casterData, targets.Select(t => t.NetworkObject.ObjectId).ToArray()); Debug.Log($\"[FrostNova] Buff activated for targets.\"); } [Server] private float CalculateDamage(FNStatsController playerStats) { float damage = 5.0f + (float)playerStats.GetAllCurrentValue(Stat.STAT_TYPE.INTELLECT); Debug.Log($\"[FrostNova] Damage calculated: {damage}\"); return damage; } }",
          "content_tokens": 649,
          "embedding": []
        }
      ],
      "length": 2242
    },
    {
      "filename": "IceBarrier",
      "content": "using System.Collections; using System.Collections.Generic; using System.Linq; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; using FishNet.Object; using FishnetInvector; using Invector; using SingletonsExtension; public class IceBarrier : Ability { private readonly int ICE_BARRIER_LENGHT = 5; private readonly float ICE_BARRIER_SPAWN_DISTANCE = 3f; private readonly float ICE_BARRIER_DURATION = 5f; [SerializeField] private NetworkObject networkedParticleSystem; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var casterComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition); var healthController = casterComps.HealthController; var nps = SpawnShards(healthController, ICE_BARRIER_LENGHT); float currentDuration = 0f; float tickTime = 1f; while (currentDuration < GetCrystalFeildDuration()) { currentDuration += tickTime; yield return new WaitForSeconds(tickTime); } DespawnShards(nps); } private List<NetworkObject> SpawnShards(FishnetInvectorHealthController healthController, int count) { var netObjs = new List<NetworkObject>(); for(int i = 0; i < count; i++) { var wallTransform = healthController.transform.localPosition + healthController.transform.forward * ICE_BARRIER_SPAWN_DISTANCE; var rotate = healthController.transform.localRotation; Vector3 newPos = new Vector3(wallTransform.x + i - ((float)ICE_BARRIER_LENGHT / 2), wallTransform.y, wallTransform.z); ShardsSetUp(networkedParticleSystem); NetworkObject nps = Instantiate(networkedParticleSystem, newPos, rotate); Spawn(nps); netObjs.Add(nps); } return netObjs; } private void DespawnShards(List<NetworkObject> nps) { nps.ForEach(n => Despawn(n)); } private void ShardsSetUp(NetworkObject netObj) { //All particle var particles = new List<ParticleSystem>(); particles = netObj.GetComponentsInChildren<ParticleSystem>().ToList(); particles.ForEach(p => { var main = p.main; main.duration = ICE_BARRIER_DURATION + 1; }); // ////Shards var psLifetime = new ParticleSystem.MinMaxCurve() { mode = ParticleSystemCurveMode.TwoConstants, constantMin = Random.Range(ICE_BARRIER_DURATION, ICE_BARRIER_DURATION - 0.2f), constantMax = Random.Range(ICE_BARRIER_DURATION, ICE_BARRIER_DURATION + 0.2f), }; var shardB = netObj.transform.Find(\"FX_Shard\").GetComponent<ParticleSystem>().main; var shardS = netObj.GetComponent<ParticleSystem>().main; shardB.startLifetime = psLifetime; shardS.startLifetime = psLifetime; //// } private float GetCrystalFeildDuration() { return ICE_BARRIER_DURATION; } public override string GetAbilityDescription(int rank, FNStatsController statsController) { string mainEdited = _abilityDefinition.mainDescription; return $\"{mainEdited}\"; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IceBarrier",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "IceBarrier",
          "content": "using System.Collections; using System.Collections.Generic; using System.Linq; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; using FishNet.Object; using FishnetInvector; using Invector; using SingletonsExtension; public class IceBarrier : Ability { private readonly int ICE_BARRIER_LENGHT = 5; private readonly float ICE_BARRIER_SPAWN_DISTANCE = 3f; private readonly float ICE_BARRIER_DURATION = 5f; [SerializeField] private NetworkObject networkedParticleSystem; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var casterComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition); var healthController = casterComps.HealthController; var nps = SpawnShards(healthController, ICE_BARRIER_LENGHT); float currentDuration = 0f; float tickTime = 1f; while (currentDuration < GetCrystalFeildDuration()) { currentDuration += tickTime; yield return new WaitForSeconds(tickTime);  ",
          "content_tokens": 293,
          "embedding": []
        },
        {
          "cs_scriptfile": "IceBarrier",
          "content": "DespawnShards(nps); } private List<NetworkObject> SpawnShards(FishnetInvectorHealthController healthController, int count) { var netObjs = new List<NetworkObject>(); for(int i = 0; i < count; i++) { var wallTransform = healthController.transform.localPosition + healthController.transform.forward * ICE_BARRIER_SPAWN_DISTANCE; var rotate = healthController.transform.localRotation; Vector3 newPos = new Vector3(wallTransform.x + i - ((float)ICE_BARRIER_LENGHT / 2), wallTransform.y, wallTransform.z); ShardsSetUp(networkedParticleSystem); NetworkObject nps = Instantiate(networkedParticleSystem, newPos, rotate); Spawn(nps); netObjs.Add(nps); } return netObjs;  ",
          "content_tokens": 198,
          "embedding": []
        },
        {
          "cs_scriptfile": "IceBarrier",
          "content": "private void DespawnShards(List<NetworkObject> nps) { nps.ForEach(n => Despawn(n));  ",
          "content_tokens": 33,
          "embedding": []
        },
        {
          "cs_scriptfile": "IceBarrier",
          "content": "private void ShardsSetUp(NetworkObject netObj) { //All particle var particles = new List<ParticleSystem>(); particles = netObj.GetComponentsInChildren<ParticleSystem>().ToList(); particles.ForEach(p => { var main = p.main; main.duration = ICE_BARRIER_DURATION + 1; }); // ////Shards var psLifetime = new ParticleSystem.MinMaxCurve() { mode = ParticleSystemCurveMode.TwoConstants, constantMin = Random.Range(ICE_BARRIER_DURATION, ICE_BARRIER_DURATION - 0.2f), constantMax = Random.Range(ICE_BARRIER_DURATION, ICE_BARRIER_DURATION + 0.2f), }; var shardB = netObj.transform.Find(\"FX_Shard\").GetComponent<ParticleSystem>().main; var shardS = netObj.GetComponent<ParticleSystem>().main; shardB.startLifetime = psLifetime; shardS.startLifetime = psLifetime; ////  ",
          "content_tokens": 259,
          "embedding": []
        },
        {
          "cs_scriptfile": "IceBarrier",
          "content": "private float GetCrystalFeildDuration() { return ICE_BARRIER_DURATION; } public override string GetAbilityDescription(int rank, FNStatsController statsController) { string mainEdited = _abilityDefinition.mainDescription; return $\"{mainEdited}\"; } }",
          "content_tokens": 60,
          "embedding": []
        }
      ],
      "length": 2819
    },
    {
      "filename": "BookExpAbility",
      "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishnetInvector; using UnityEngine; public class BookExpAbility : Ability { private static float XP_AMOUNT = 100f; private static float STATS = 2; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { Debug.Log(\"BookExpAbility ability activated.\"); var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); if(unitComps == null) { Debug.LogError(\"Failed to retrieve Unit Components.\"); yield break; } GainXpAndStats(unitComps); yield return null; } private void GainXpAndStats(UnitComponents unitComps) { unitComps.XpController.AddXp(XP_AMOUNT); var stats = unitComps.StatsController.GetStats(); foreach (var stat in stats) { unitComps.StatsController.AddChanges(stat.StatType, CombatEntityStat.From.Bonus, STATS); } } public float CalcXP(FNStatsController statsController) { return XP_AMOUNT; } public float CalcStats(FNStatsController statsController) { return STATS; } public override string GetAbilityDescription(int rank, FNStatsController statsController) { float xp = CalcXP(statsController); float stats = CalcStats(statsController); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@@\", $\"<color={COLOR_STAT}>{stats.ToString(\"F2\")}%</color>\"); mainEdited = mainEdited.Replace(\"@@@\", $\"<color={COLOR_XP}>{xp.ToString(\"F1\")}</color>\"); // mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{STAT_TYPE.ToString()}</color>\"; return $\"{mainEdited}\"; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BookExpAbility",
          "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishnetInvector; using UnityEngine; public class BookExpAbility : Ability { private static float XP_AMOUNT = 100f; private static float STATS = 2; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { Debug.Log(\"BookExpAbility ability activated.\"); var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); if(unitComps == null) { Debug.LogError(\"Failed to retrieve Unit Components.\"); yield break;  GainXpAndStats(unitComps); yield return null;  ",
          "content_tokens": 189,
          "embedding": []
        },
        {
          "cs_scriptfile": "BookExpAbility",
          "content": "private void GainXpAndStats(UnitComponents unitComps) { unitComps.XpController.AddXp(XP_AMOUNT); var stats = unitComps.StatsController.GetStats(); foreach (var stat in stats) { unitComps.StatsController.AddChanges(stat.StatType, CombatEntityStat.From.Bonus, STATS); }  public float CalcXP(FNStatsController statsController) { return XP_AMOUNT;  ",
          "content_tokens": 103,
          "embedding": []
        },
        {
          "cs_scriptfile": "BookExpAbility",
          "content": "public float CalcStats(FNStatsController statsController) { return STATS; } public override string GetAbilityDescription(int rank, FNStatsController statsController) { float xp = CalcXP(statsController); float stats = CalcStats(statsController); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@@\", $\"<color={COLOR_STAT}>{stats.ToString(\"F2\")}%</color>\"); mainEdited = mainEdited.Replace(\"@@@\", $\"<color={COLOR_XP}>{xp.ToString(\"F1\")}</color>\"); // mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{STAT_TYPE.ToString()}</color>\"; return $\"{mainEdited}\"; } }",
          "content_tokens": 192,
          "embedding": []
        }
      ],
      "length": 1688
    },
    {
      "filename": "HealingPotionAbility",
      "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishnetInvector; using UnityEngine; public class HealingPotionAbility : Ability { private static float MAX_HP_AMOUNT = .3f; private readonly float TOTAL_TIME = 5f; private readonly float TIME_BETWEEN_HEALS = 1f; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { Debug.Log(\"HealingPotionAbility ability activated.\"); var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); if(unitComps == null) { Debug.LogError(\"Failed to retrieve Unit Components.\"); yield break; } StartCoroutine(HealOverTime(unitComps.HealthController)); yield return null; } private IEnumerator HealOverTime(FishnetInvectorHealthController casterHealthController) { var howMuchToHeal = MAX_HP_AMOUNT * casterHealthController.MaxHealth; var howManyTimesToHeal = TOTAL_TIME / TIME_BETWEEN_HEALS; var timePassed = 0f; var healData = new FishnetInvectorHealthController.HealData(); healData.abilityId = AbilityDefinition.Id; while (timePassed < TOTAL_TIME) { healData.amount = howMuchToHeal / howManyTimesToHeal; casterHealthController.Heal(healData); timePassed += TIME_BETWEEN_HEALS; yield return new WaitForSeconds(TIME_BETWEEN_HEALS); } } public static float CalcHeal(FNStatsController statsController) { return MAX_HP_AMOUNT * 100; } public override string GetAbilityDescription(int rank, FNStatsController statsController) { float heal = CalcHeal(statsController); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color={COLOR_HEAL}>{heal.ToString(\"F2\")}%</color>\"); // mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{STAT_TYPE.ToString()}</color>\"; return $\"{mainEdited}\"; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "HealingPotionAbility",
          "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishnetInvector; using UnityEngine; public class HealingPotionAbility : Ability { private static float MAX_HP_AMOUNT = .3f; private readonly float TOTAL_TIME = 5f; private readonly float TIME_BETWEEN_HEALS = 1f; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { Debug.Log(\"HealingPotionAbility ability activated.\"); var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); if(unitComps == null) { Debug.LogError(\"Failed to retrieve Unit Components.\"); yield break;  ",
          "content_tokens": 201,
          "embedding": []
        },
        {
          "cs_scriptfile": "HealingPotionAbility",
          "content": "StartCoroutine(HealOverTime(unitComps.HealthController)); yield return null; } private IEnumerator HealOverTime(FishnetInvectorHealthController casterHealthController) { var howMuchToHeal = MAX_HP_AMOUNT * casterHealthController.MaxHealth; var howManyTimesToHeal = TOTAL_TIME / TIME_BETWEEN_HEALS; var timePassed = 0f; var healData = new FishnetInvectorHealthController.HealData(); healData.abilityId = AbilityDefinition.Id; while (timePassed < TOTAL_TIME) { healData.amount = howMuchToHeal / howManyTimesToHeal; casterHealthController.Heal(healData); timePassed += TIME_BETWEEN_HEALS; yield return new WaitForSeconds(TIME_BETWEEN_HEALS); } } public static float CalcHeal(FNStatsController statsController) { return MAX_HP_AMOUNT * 100; } public override string GetAbilityDescription(int rank, FNStatsController statsController) { float heal = CalcHeal(statsController); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color={COLOR_HEAL}>{heal.ToString(\"F2\")}%</color>\"); // mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{STAT_TYPE.ToString()}</color>\"; return $\"{mainEdited}\"; } }",
          "content_tokens": 352,
          "embedding": []
        }
      ],
      "length": 1897
    },
    {
      "filename": "MountainSplitterStrike",
      "content": "using System.Collections; /// <summary> /// Every first attack is a critical hit, dealing 150% + 10% per rank of the attack's damage. /// Player needs to perform 10 crits to unlock the next rank. /// </summary> public class MountainSplitterStrike : Ability { public static readonly byte SWING_COUNT_THAT_TRIGGER = 0; public static readonly byte ABILITY_ID = 6; public static readonly float CRIT_DAMAGE_MOD = 1.5f; public static readonly float CRIT_DAMAGE_MOD_PER_RANK = .1f; public static readonly uint STACKS_COUNT_TO_RANK_UP = 100; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { yield return null; } public override uint GetStacksForRank() => STACKS_COUNT_TO_RANK_UP; public override float CalculateDamageBasedOnRank(int rank) => CalculateDamage(rank); public override int CalculateRankBasedOnStacks(uint stacks) => (int) (stacks / STACKS_COUNT_TO_RANK_UP); public static float CalculateDamage(int rank) => CRIT_DAMAGE_MOD + CRIT_DAMAGE_MOD_PER_RANK * rank; public override string GetAbilityName(int rank) => $\"{_abilityDefinition.Name} - {rank}\"; public override string GetAbilityDescription(int rank, uint stacks) { float damageMod = CRIT_DAMAGE_MOD + CRIT_DAMAGE_MOD_PER_RANK * rank; string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color=red>{damageMod * 100}%</color>\"); uint currentStacks = stacks % STACKS_COUNT_TO_RANK_UP; string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); string persistEdited = $\"<color=#40ff00>{_abilityDefinition.persistDescription}</color>\"; return $\"{mainEdited}\\n{questEdited}\\n{persistEdited}\"; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MountainSplitterStrike",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "MountainSplitterStrike",
          "content": "using System.Collections; /// <summary> /// Every first attack is a critical hit, dealing 150% + 10% per rank of the attack's damage. /// Player needs to perform 10 crits to unlock the next rank. /// </summary> public class MountainSplitterStrike : Ability { public static readonly byte SWING_COUNT_THAT_TRIGGER = 0; public static readonly byte ABILITY_ID = 6; public static readonly float CRIT_DAMAGE_MOD = 1.5f; public static readonly float CRIT_DAMAGE_MOD_PER_RANK = .1f; public static readonly uint STACKS_COUNT_TO_RANK_UP = 100; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { yield return null; } public override uint GetStacksForRank() => STACKS_COUNT_TO_RANK_UP; public override float CalculateDamageBasedOnRank(int rank) => CalculateDamage(rank); public override int CalculateRankBasedOnStacks(uint stacks) => (int) (stacks / STACKS_COUNT_TO_RANK_UP); public static float CalculateDamage(int rank) => CRIT_DAMAGE_MOD + CRIT_DAMAGE_MOD_PER_RANK * rank; public override string GetAbilityName(int rank) => $\"{_abilityDefinition.Name} - {rank}\"; public override string GetAbilityDescription(int rank, uint stacks) { float damageMod = CRIT_DAMAGE_MOD + CRIT_DAMAGE_MOD_PER_RANK * rank; string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color=red>{damageMod * 100}%</color>\"); uint currentStacks = stacks % STACKS_COUNT_TO_RANK_UP; string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); string persistEdited = $\"<color=#40ff00>{_abilityDefinition.persistDescription}</color>\"; return $\"{mainEdited}\\n{questEdited}\\n{persistEdited}\"; } }",
          "content_tokens": 559,
          "embedding": []
        }
      ],
      "length": 1784
    },
    {
      "filename": "PassiveResilienceGlobules",
      "content": "using System.Collections; public class PassiveResilienceGlobules : Ability { public static readonly byte ABILITY_ID = 11; public static readonly float BASE = 20f; public static readonly float PER_RANK = 5f; public static readonly uint STACKS_COUNT_TO_RANK_UP = 100; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { yield return null; } public override uint GetStacksForRank() => STACKS_COUNT_TO_RANK_UP; public override float CalculateValueBasedOnStacks(uint stacks) => BASE + CalculateRankBasedOnStacks(stacks) * PER_RANK; public override int CalculateRankBasedOnStacks(uint stacks) => (int) (stacks / STACKS_COUNT_TO_RANK_UP); public override float CalculateDamageBasedOnRank(int rank) => BASE + PER_RANK * rank; public static float CalculateDamage(int rank) => BASE + PER_RANK * rank; public override string GetAbilityName(int rank) => $\"{_abilityDefinition.Name} - {rank}\"; public override string GetAbilityDescription(int rank, uint stacks) { float damageMod = BASE + PER_RANK * rank; string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color=red>{(damageMod).ToString(\"F0\")}%</color>\"); uint currentStacks = stacks % STACKS_COUNT_TO_RANK_UP; string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); questEdited = questEdited.Replace(\"@@@@\", $\"{(PER_RANK * 100).ToString(\"F0\")}%\"); string persistEdited = $\"<color=#40ff00>{_abilityDefinition.persistDescription}</color>\"; return $\"{mainEdited}\\n{questEdited}\\n{persistEdited}\"; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PassiveResilienceGlobules",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "PassiveResilienceGlobules",
          "content": "using System.Collections; public class PassiveResilienceGlobules : Ability { public static readonly byte ABILITY_ID = 11; public static readonly float BASE = 20f; public static readonly float PER_RANK = 5f; public static readonly uint STACKS_COUNT_TO_RANK_UP = 100; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { yield return null; } public override uint GetStacksForRank() => STACKS_COUNT_TO_RANK_UP; public override float CalculateValueBasedOnStacks(uint stacks) => BASE + CalculateRankBasedOnStacks(stacks) * PER_RANK; public override int CalculateRankBasedOnStacks(uint stacks) => (int) (stacks / STACKS_COUNT_TO_RANK_UP); public override float CalculateDamageBasedOnRank(int rank) => BASE + PER_RANK * rank; public static float CalculateDamage(int rank) => BASE + PER_RANK * rank; public override string GetAbilityName(int rank) => $\"{_abilityDefinition.Name} - {rank}\"; public override string GetAbilityDescription(int rank, uint stacks) { float damageMod = BASE + PER_RANK * rank; string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color=red>{(damageMod).ToString(\"F0\")}%</color>\"); uint currentStacks = stacks % STACKS_COUNT_TO_RANK_UP; string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); questEdited = questEdited.Replace(\"@@@@\", $\"{(PER_RANK * 100).ToString(\"F0\")}%\"); string persistEdited = $\"<color=#40ff00>{_abilityDefinition.persistDescription}</color>\"; return $\"{mainEdited}\\n{questEdited}\\n{persistEdited}\"; } }",
          "content_tokens": 521,
          "embedding": []
        }
      ],
      "length": 1677
    },
    {
      "filename": "PassiveRockSkin",
      "content": "using System.Collections; public class PassiveRockSkin : Ability { public static readonly byte ABILITY_ID = 7; public static readonly float DAMAGE_REDUCTION_BASE = .1f; public static readonly float DAMAGE_REDUCTION_PER_RANK = .01f; public static readonly uint STACKS_COUNT_TO_RANK_UP = 2000; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { yield return null; } public override uint GetStacksForRank() => STACKS_COUNT_TO_RANK_UP; public override float CalculateDamageBasedOnRank(int rank) => CalculateDamage(rank); public override int CalculateRankBasedOnStacks(uint stacks) => (int) (stacks / STACKS_COUNT_TO_RANK_UP); public static float CalculateDamage(int rank) => DAMAGE_REDUCTION_BASE + DAMAGE_REDUCTION_PER_RANK * rank; public override string GetAbilityName(int rank) => $\"{_abilityDefinition.Name} - {rank}\"; public override string GetAbilityDescription(int rank, uint stacks) { float damageMod = DAMAGE_REDUCTION_BASE + DAMAGE_REDUCTION_PER_RANK * rank; string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color=red>{(damageMod * 100).ToString(\"F0\")}%</color>\"); uint currentStacks = stacks % STACKS_COUNT_TO_RANK_UP; string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); questEdited = questEdited.Replace(\"@@@@@\", $\"{(DAMAGE_REDUCTION_PER_RANK * 100).ToString(\"F0\")}%\"); string persistEdited = $\"<color=#40ff00>{_abilityDefinition.persistDescription}</color>\"; return $\"{mainEdited}\\n{questEdited}\\n{persistEdited}\"; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PassiveRockSkin",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "PassiveRockSkin",
          "content": "using System.Collections; public class PassiveRockSkin : Ability { public static readonly byte ABILITY_ID = 7; public static readonly float DAMAGE_REDUCTION_BASE = .1f; public static readonly float DAMAGE_REDUCTION_PER_RANK = .01f; public static readonly uint STACKS_COUNT_TO_RANK_UP = 2000; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { yield return null; } public override uint GetStacksForRank() => STACKS_COUNT_TO_RANK_UP; public override float CalculateDamageBasedOnRank(int rank) => CalculateDamage(rank); public override int CalculateRankBasedOnStacks(uint stacks) => (int) (stacks / STACKS_COUNT_TO_RANK_UP); public static float CalculateDamage(int rank) => DAMAGE_REDUCTION_BASE + DAMAGE_REDUCTION_PER_RANK * rank; public override string GetAbilityName(int rank) => $\"{_abilityDefinition.Name} - {rank}\"; public override string GetAbilityDescription(int rank, uint stacks) { float damageMod = DAMAGE_REDUCTION_BASE + DAMAGE_REDUCTION_PER_RANK * rank; string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color=red>{(damageMod * 100).ToString(\"F0\")}%</color>\"); uint currentStacks = stacks % STACKS_COUNT_TO_RANK_UP; string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); questEdited = questEdited.Replace(\"@@@@@\", $\"{(DAMAGE_REDUCTION_PER_RANK * 100).ToString(\"F0\")}%\"); string persistEdited = $\"<color=#40ff00>{_abilityDefinition.persistDescription}</color>\"; return $\"{mainEdited}\\n{questEdited}\\n{persistEdited}\"; } }",
          "content_tokens": 537,
          "embedding": []
        }
      ],
      "length": 1673
    },
    {
      "filename": "PassiveThornShell",
      "content": "using System.Collections; public class PassiveThornShell : Ability { public static readonly byte ABILITY_ID = 10; public static readonly float DAMAGE_RETURNING_BASE = .2f; public static readonly float DAMAGE_RETURNING_PER_RANK = .01f; public static readonly uint STACKS_COUNT_TO_RANK_UP = 10000; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { yield return null; } public override uint GetStacksForRank() => STACKS_COUNT_TO_RANK_UP; public override int CalculateRankBasedOnStacks(uint stacks) => (int) (stacks / STACKS_COUNT_TO_RANK_UP); public override float CalculateDamageBasedOnRank(int rank) => DAMAGE_RETURNING_BASE + DAMAGE_RETURNING_PER_RANK * rank; public static float CalculateDamage(int rank) => DAMAGE_RETURNING_BASE + DAMAGE_RETURNING_PER_RANK * rank; public override string GetAbilityName(int rank) => $\"{_abilityDefinition.Name} - {rank}\"; public override string GetAbilityDescription(int rank, uint stacks) { float damageMod = DAMAGE_RETURNING_BASE + DAMAGE_RETURNING_PER_RANK * rank; string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color=red>{(damageMod * 100).ToString(\"F0\")}%</color>\"); uint currentStacks = stacks % STACKS_COUNT_TO_RANK_UP; string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); questEdited = questEdited.Replace(\"@@@@@\", $\"{(DAMAGE_RETURNING_PER_RANK * 100).ToString(\"F0\")}%\"); string persistEdited = $\"<color=#40ff00>{_abilityDefinition.persistDescription}</color>\"; return $\"{mainEdited}\\n{questEdited}\\n{persistEdited}\"; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PassiveThornShell",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "PassiveThornShell",
          "content": "using System.Collections; public class PassiveThornShell : Ability { public static readonly byte ABILITY_ID = 10; public static readonly float DAMAGE_RETURNING_BASE = .2f; public static readonly float DAMAGE_RETURNING_PER_RANK = .01f; public static readonly uint STACKS_COUNT_TO_RANK_UP = 10000; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { yield return null; } public override uint GetStacksForRank() => STACKS_COUNT_TO_RANK_UP; public override int CalculateRankBasedOnStacks(uint stacks) => (int) (stacks / STACKS_COUNT_TO_RANK_UP); public override float CalculateDamageBasedOnRank(int rank) => DAMAGE_RETURNING_BASE + DAMAGE_RETURNING_PER_RANK * rank; public static float CalculateDamage(int rank) => DAMAGE_RETURNING_BASE + DAMAGE_RETURNING_PER_RANK * rank; public override string GetAbilityName(int rank) => $\"{_abilityDefinition.Name} - {rank}\"; public override string GetAbilityDescription(int rank, uint stacks) { float damageMod = DAMAGE_RETURNING_BASE + DAMAGE_RETURNING_PER_RANK * rank; string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color=red>{(damageMod * 100).ToString(\"F0\")}%</color>\"); uint currentStacks = stacks % STACKS_COUNT_TO_RANK_UP; string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); questEdited = questEdited.Replace(\"@@@@@\", $\"{(DAMAGE_RETURNING_PER_RANK * 100).ToString(\"F0\")}%\"); string persistEdited = $\"<color=#40ff00>{_abilityDefinition.persistDescription}</color>\"; return $\"{mainEdited}\\n{questEdited}\\n{persistEdited}\"; } }",
          "content_tokens": 556,
          "embedding": []
        }
      ],
      "length": 1712
    },
    {
      "filename": "PassiveVampiricTouch",
      "content": "using System.Collections; public class PassiveVampiricTouch : Ability { public static readonly byte ABILITY_ID = 8; public static readonly float DAMAGE_STEALING_BASE = .1f; public static readonly float DAMAGE_STEALING_PER_RANK = .01f; public static readonly uint STACKS_COUNT_TO_RANK_UP = 5000; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { yield return null; } public override uint GetStacksForRank() => STACKS_COUNT_TO_RANK_UP; public override int CalculateRankBasedOnStacks(uint stacks) => (int) (stacks / STACKS_COUNT_TO_RANK_UP); public override float CalculateDamageBasedOnRank(int rank) => CalculateDamage(rank); public static float CalculateDamage(int rank) => DAMAGE_STEALING_BASE + DAMAGE_STEALING_PER_RANK * rank; public override string GetAbilityName(int rank) => $\"{_abilityDefinition.Name} - {rank}\"; public override string GetAbilityDescription(int rank, uint stacks) { float damageMod = DAMAGE_STEALING_BASE + DAMAGE_STEALING_PER_RANK * rank; string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color=red>{(damageMod * 100).ToString(\"F0\")}%</color>\"); uint currentStacks = stacks % STACKS_COUNT_TO_RANK_UP; string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); questEdited = questEdited.Replace(\"@@@@@\", $\"{(DAMAGE_STEALING_PER_RANK * 100).ToString(\"F0\")}%\"); string persistEdited = $\"<color=#40ff00>{_abilityDefinition.persistDescription}</color>\"; return $\"{mainEdited}\\n{questEdited}\\n{persistEdited}\"; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PassiveVampiricTouch",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "PassiveVampiricTouch",
          "content": "using System.Collections; public class PassiveVampiricTouch : Ability { public static readonly byte ABILITY_ID = 8; public static readonly float DAMAGE_STEALING_BASE = .1f; public static readonly float DAMAGE_STEALING_PER_RANK = .01f; public static readonly uint STACKS_COUNT_TO_RANK_UP = 5000; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { yield return null; } public override uint GetStacksForRank() => STACKS_COUNT_TO_RANK_UP; public override int CalculateRankBasedOnStacks(uint stacks) => (int) (stacks / STACKS_COUNT_TO_RANK_UP); public override float CalculateDamageBasedOnRank(int rank) => CalculateDamage(rank); public static float CalculateDamage(int rank) => DAMAGE_STEALING_BASE + DAMAGE_STEALING_PER_RANK * rank; public override string GetAbilityName(int rank) => $\"{_abilityDefinition.Name} - {rank}\"; public override string GetAbilityDescription(int rank, uint stacks) { float damageMod = DAMAGE_STEALING_BASE + DAMAGE_STEALING_PER_RANK * rank; string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color=red>{(damageMod * 100).ToString(\"F0\")}%</color>\"); uint currentStacks = stacks % STACKS_COUNT_TO_RANK_UP; string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); questEdited = questEdited.Replace(\"@@@@@\", $\"{(DAMAGE_STEALING_PER_RANK * 100).ToString(\"F0\")}%\"); string persistEdited = $\"<color=#40ff00>{_abilityDefinition.persistDescription}</color>\"; return $\"{mainEdited}\\n{questEdited}\\n{persistEdited}\"; } }",
          "content_tokens": 540,
          "embedding": []
        }
      ],
      "length": 1671
    },
    {
      "filename": "PassiveWeakSpot",
      "content": "using System.Collections; public class PassiveWeakSpot : Ability { public static readonly byte ABILITY_ID = 9; public static readonly float CRIT_DAMAGE_MOD_BASE = .2f; public static readonly float CRIT_DAMAGE_MOD_PER_RANK = .01f; public static readonly uint STACKS_COUNT_TO_RANK_UP = 200; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { yield return null; } public override uint GetStacksForRank() => STACKS_COUNT_TO_RANK_UP; public override int CalculateRankBasedOnStacks(uint stacks) => (int) (stacks / STACKS_COUNT_TO_RANK_UP); public static float CalculateDamage(int rank) => CRIT_DAMAGE_MOD_BASE + CRIT_DAMAGE_MOD_PER_RANK * rank; public override float CalculateDamageBasedOnRank(int rank) => CRIT_DAMAGE_MOD_BASE + CRIT_DAMAGE_MOD_PER_RANK * rank; public override string GetAbilityName(int rank) => $\"{_abilityDefinition.Name} - {rank}\"; public override string GetAbilityDescription(int rank, uint stacks) { float damageMod = CRIT_DAMAGE_MOD_BASE + CRIT_DAMAGE_MOD_PER_RANK * rank; string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color=red>{(damageMod * 100).ToString(\"F0\")}%</color>\"); uint currentStacks = stacks % STACKS_COUNT_TO_RANK_UP; string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); questEdited = questEdited.Replace(\"@@@@@\", $\"{(CRIT_DAMAGE_MOD_PER_RANK * 100).ToString(\"F0\")}%\"); string persistEdited = $\"<color=#40ff00>{_abilityDefinition.persistDescription}</color>\"; return $\"{mainEdited}\\n{questEdited}\\n{persistEdited}\"; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PassiveWeakSpot",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "PassiveWeakSpot",
          "content": "using System.Collections; public class PassiveWeakSpot : Ability { public static readonly byte ABILITY_ID = 9; public static readonly float CRIT_DAMAGE_MOD_BASE = .2f; public static readonly float CRIT_DAMAGE_MOD_PER_RANK = .01f; public static readonly uint STACKS_COUNT_TO_RANK_UP = 200; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { yield return null; } public override uint GetStacksForRank() => STACKS_COUNT_TO_RANK_UP; public override int CalculateRankBasedOnStacks(uint stacks) => (int) (stacks / STACKS_COUNT_TO_RANK_UP); public static float CalculateDamage(int rank) => CRIT_DAMAGE_MOD_BASE + CRIT_DAMAGE_MOD_PER_RANK * rank; public override float CalculateDamageBasedOnRank(int rank) => CRIT_DAMAGE_MOD_BASE + CRIT_DAMAGE_MOD_PER_RANK * rank; public override string GetAbilityName(int rank) => $\"{_abilityDefinition.Name} - {rank}\"; public override string GetAbilityDescription(int rank, uint stacks) { float damageMod = CRIT_DAMAGE_MOD_BASE + CRIT_DAMAGE_MOD_PER_RANK * rank; string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color=red>{(damageMod * 100).ToString(\"F0\")}%</color>\"); uint currentStacks = stacks % STACKS_COUNT_TO_RANK_UP; string questEdited = _abilityDefinition.questDescription.Replace(\"@@@@\", $\"<color={StringToHexColor.GetColorClamped(currentStacks, STACKS_COUNT_TO_RANK_UP)}>{currentStacks}</color><color=#00ff00>/{STACKS_COUNT_TO_RANK_UP}</color>\"); questEdited = questEdited.Replace(\"@@@@@\", $\"{(CRIT_DAMAGE_MOD_PER_RANK * 100).ToString(\"F0\")}%\"); string persistEdited = $\"<color=#40ff00>{_abilityDefinition.persistDescription}</color>\"; return $\"{mainEdited}\\n{questEdited}\\n{persistEdited}\"; } }",
          "content_tokens": 572,
          "embedding": []
        }
      ],
      "length": 1698
    },
    {
      "filename": "PoisonNova",
      "content": "using System.Collections; using System.Linq; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using Invector; using UnityEngine; using SingletonsExtension; using UnityEngine.VFX; #if UNITY_EDITOR using UnityEditor; using UnityEngine; #endif public class PoisonNova : Ability { public static readonly float NOVA_RADIUS = 3.6f; private static readonly float POISON_FIELD_DURATION = 10f; private readonly float SMOKE_END_SIZE = 20f; private readonly float TIME_TO_REACH_END_SIZE = 1f; private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.Wisdom; private readonly float BASE_DAMAGE_PER_TICK = 1f; private readonly float BASE_DURATION = 5f; private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Poison; [SerializeField] private NetworkObject networkedParticleSystem; public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); private string _className; private float GetPoisonFeildDuration() { return POISON_FIELD_DURATION; } private float CalculateTickDamage(float wisdom) { return BASE_DAMAGE_PER_TICK + wisdom * .1f; } public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var casterComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition); var healthController = casterComps.HealthController; NetworkObject nps = Instantiate(networkedParticleSystem, healthController.transform.position, Quaternion.identity); Spawn(nps); RpcShowEffectForObservers(casterNetId, abilityId, _rank, GetPoisonFeildDuration()); Debug.Log($\"{ClassName} Activated for unit #{casterNetId} with abilityId #{abilityId} and rank {rank}\"); float currentDuration = 0f; float tickTime = 1f; float radius = 1f; Buff.BuffData casterData = new Buff.BuffData(casterNetId, healthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null, CalculateTickDamage(casterComps.StatsController.GetAllCurrentValue(AFFECTING_STAT))); vDamage damage = Buff.GetTickDamage(casterComps, casterData, DAMAGE_TYPE); Vector3 poisonCloudPos = healthController.transform.position; while (currentDuration < GetPoisonFeildDuration()) { currentDuration += tickTime; InstaBuffApplier(casterData, poisonCloudPos, damage, NOVA_RADIUS); yield return new WaitForSeconds(tickTime); } Despawn(nps); } [Server] private void InstaBuffApplier(Buff.BuffData casterData, Vector3 pos, vDamage damage, float radius) { DrawDebugSphere(pos, radius); var caster = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterData.ObjectId); if (caster != null) { damage = UpdateDamage(ref casterData, caster); } var targets = EnemyTargetsInSphereSelection(pos, casterData, radius); //remove duplicates var targetCleared = targets.Distinct().Select(t => t.NetworkObject.ObjectId).ToArray(); if (targetCleared.Length == 0) { //Debug.Log($\"{ClassName} No targets in sphere.\"); return; } else { _buff.Activate(casterData, targetCleared, BASE_DURATION, damage); //Debug.Log($\"[{ClassName}] Buff activated for {targetCleared.Length} targets.\"); } } private vDamage UpdateDamage(ref Buff.BuffData casterData, UnitComponents caster) { vDamage damage; casterData = new Buff.BuffData(casterData.ObjectId, caster.HealthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null, CalculateTickDamage(caster.StatsController.GetAllCurrentValue(AFFECTING_STAT))); damage = Buff.GetTickDamage(caster, casterData, DAMAGE_TYPE); return damage; } protected override IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout) { Debug.Log($\"{_abilityName} Showing effect on target.\"); var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); if (targetComps == null) { Debug.LogError($\"[{ClassName}]{_abilityName} Target components are null. Cannot show effect on target.\"); yield break; } Vector3 pos = targetComps.HealthController.transform.position; GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pos, Quaternion.identity); VisualEffect vfxGraph = effect.GetComponent<VisualEffect>(); float cloudCurrentSize = vfxGraph.GetFloat(\"SmokeSize\"); float timeElapsed = 0f; while (timeElapsed < TIME_TO_REACH_END_SIZE) { cloudCurrentSize = Mathf.Lerp(cloudCurrentSize, SMOKE_END_SIZE, timeElapsed / TIME_TO_REACH_END_SIZE); vfxGraph.SetFloat(\"SmokeSize\", cloudCurrentSize); timeElapsed += Time.deltaTime; yield return null; } Destroy(effect, timeout); } public override string GetAbilityDescription(int rank, FNStatsController statsController) { float damage = CalculateTickDamage(statsController.GetAllCurrentValue(AFFECTING_STAT)); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color={COLOR_DAMAGE}>{damage.ToString(\"F2\")}</color>\"); mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>\"; return $\"{mainEdited}\"; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PoisonNova",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "PoisonNova",
          "content": "using System.Collections; using System.Linq; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using Invector; using UnityEngine; using SingletonsExtension; using UnityEngine.VFX; #if UNITY_EDITOR using UnityEditor; using UnityEngine; #endif public class PoisonNova : Ability { public static readonly float NOVA_RADIUS = 3.6f; private static readonly float POISON_FIELD_DURATION = 10f; private readonly float SMOKE_END_SIZE = 20f; private readonly float TIME_TO_REACH_END_SIZE = 1f; private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.Wisdom; private readonly float BASE_DAMAGE_PER_TICK = 1f; private readonly float BASE_DURATION = 5f; private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Poison; [SerializeField] private NetworkObject networkedParticleSystem; public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); private string _className; private float GetPoisonFeildDuration() { return POISON_FIELD_DURATION;  ",
          "content_tokens": 307,
          "embedding": []
        },
        {
          "cs_scriptfile": "PoisonNova",
          "content": "private float CalculateTickDamage(float wisdom) { return BASE_DAMAGE_PER_TICK + wisdom * .1f; } public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var casterComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); int abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(_abilityDefinition); var healthController = casterComps.HealthController; NetworkObject nps = Instantiate(networkedParticleSystem, healthController.transform.position, Quaternion.identity); Spawn(nps); RpcShowEffectForObservers(casterNetId, abilityId, _rank, GetPoisonFeildDuration()); Debug.Log($\"{ClassName} Activated for unit #{casterNetId} with abilityId #{abilityId} and rank {rank}\"); float currentDuration = 0f; float tickTime = 1f; float radius = 1f; Buff.BuffData casterData = new Buff.BuffData(casterNetId, healthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null, CalculateTickDamage(casterComps.StatsController.GetAllCurrentValue(AFFECTING_STAT))); vDamage damage = Buff.GetTickDamage(casterComps, casterData, DAMAGE_TYPE); Vector3 poisonCloudPos = healthController.transform.position; while (currentDuration < GetPoisonFeildDuration()) { currentDuration += tickTime; InstaBuffApplier(casterData, poisonCloudPos, damage, NOVA_RADIUS); yield return new WaitForSeconds(tickTime);  ",
          "content_tokens": 380,
          "embedding": []
        },
        {
          "cs_scriptfile": "PoisonNova",
          "content": "Despawn(nps); } [Server] private void InstaBuffApplier(Buff.BuffData casterData, Vector3 pos, vDamage damage, float radius) { DrawDebugSphere(pos, radius); var caster = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterData.ObjectId); if (caster != null) { damage = UpdateDamage(ref casterData, caster); } var targets = EnemyTargetsInSphereSelection(pos, casterData, radius); //remove duplicates var targetCleared = targets.Distinct().Select(t => t.NetworkObject.ObjectId).ToArray(); if (targetCleared.Length == 0) { //Debug.Log($\"{ClassName} No targets in sphere.\"); return; } else { _buff.Activate(casterData, targetCleared, BASE_DURATION, damage); //Debug.Log($\"[{ClassName}] Buff activated for {targetCleared.Length} targets.\"); } } private vDamage UpdateDamage(ref Buff.BuffData casterData, UnitComponents caster) { vDamage damage; casterData = new Buff.BuffData(casterData.ObjectId, caster.HealthController.gameObject.tag, 0, AbilityDefinition.Id, 1, null, null, CalculateTickDamage(caster.StatsController.GetAllCurrentValue(AFFECTING_STAT))); damage = Buff.GetTickDamage(caster, casterData, DAMAGE_TYPE); return damage; } protected override IEnumerator ShowEffectOnTarget(int targetNetId, int abilityId, int rank, float timeout) { Debug.Log($\"{_abilityName} Showing effect on target.\"); var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); if (targetComps == null) { Debug.LogError($\"[{ClassName}]{_abilityName} Target components are null. Cannot show effect on target.\"); yield break; } Vector3 pos = targetComps.HealthController.transform.position; GameObject effect = Instantiate(_abilityDefinition.RanksDatas[rank].hitEffect, pos, Quaternion.identity); VisualEffect vfxGraph = effect.GetComponent<VisualEffect>(); float cloudCurrentSize = vfxGraph.GetFloat(\"SmokeSize\"); float timeElapsed = 0f; while (timeElapsed < TIME_TO_REACH_END_SIZE) { cloudCurrentSize = Mathf.Lerp(cloudCurrentSize, SMOKE_END_SIZE, timeElapsed / TIME_TO_REACH_END_SIZE); vfxGraph.SetFloat(\"SmokeSize\", cloudCurrentSize); timeElapsed += Time.deltaTime; yield return null;  ",
          "content_tokens": 602,
          "embedding": []
        },
        {
          "cs_scriptfile": "PoisonNova",
          "content": "Destroy(effect, timeout); } public override string GetAbilityDescription(int rank, FNStatsController statsController) { float damage = CalculateTickDamage(statsController.GetAllCurrentValue(AFFECTING_STAT)); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@\", $\"<color={COLOR_DAMAGE}>{damage.ToString(\"F2\")}</color>\"); mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{AFFECTING_STAT.ToString()}</color>\"; return $\"{mainEdited}\"; } }",
          "content_tokens": 154,
          "embedding": []
        }
      ],
      "length": 5028
    },
    {
      "filename": "Regeneration",
      "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; public class Regeneration : Ability { private static float DEFAULT_DURATION = 12f; private static float TICK_COOLDOWN = 3f; private static Stat.STAT_TYPE STAT_TYPE = Stat.STAT_TYPE.Wisdom; private static float BASE_HEALING = 5f; private static float STAT_MOD = .1f; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var casterComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); float tickHealing = CalcAmount(casterComps.StatsController); float finishTime = GameplayManager.GetCurrentServerTime() + CalcDuration(casterComps.StatsController); Buff.BuffData casterData = new Buff.BuffData(casterNetId, casterComps.HealthController.gameObject.tag, finishTime, AbilityDefinition.Id,1, null, null, tickHealing); _buff.Activate(casterData, new []{casterData.ObjectId}, DEFAULT_DURATION); yield return null; } public override float CalcDuration(FNStatsController statsController) { return DEFAULT_DURATION; } public static float CalcTickCooldown(FNStatsController statsController) { return TICK_COOLDOWN; } public override float CalcAmount(FNStatsController statsController) { return BASE_HEALING + statsController.GetStatByType(STAT_TYPE).CurrentAmount * STAT_MOD; } public override string GetAbilityDescription(int rank, FNStatsController statsController) { float amount = CalcAmount(statsController); float duration = CalcDuration(statsController); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@@@\", $\"<color={COLOR_DURATION}>{duration.ToString(\"F1\")}</color>\"); mainEdited = mainEdited.Replace(\"@@@@\", $\"<color={COLOR_COOLDOWN}>{TICK_COOLDOWN.ToString(\"F1\")}</color>\"); mainEdited = mainEdited.Replace(\"@@@\", $\"<color={COLOR_HEAL}>{(amount).ToString(\"F2\")}</color>\"); mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{STAT_TYPE.ToString()}</color>\"; return $\"{mainEdited}\"; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Regeneration",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "Regeneration",
          "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; public class Regeneration : Ability { private static float DEFAULT_DURATION = 12f; private static float TICK_COOLDOWN = 3f; private static Stat.STAT_TYPE STAT_TYPE = Stat.STAT_TYPE.Wisdom; private static float BASE_HEALING = 5f; private static float STAT_MOD = .1f; public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { var casterComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); float tickHealing = CalcAmount(casterComps.StatsController); float finishTime = GameplayManager.GetCurrentServerTime() + CalcDuration(casterComps.StatsController); Buff.BuffData casterData = new Buff.BuffData(casterNetId, casterComps.HealthController.gameObject.tag, finishTime, AbilityDefinition.Id,1, null, null, tickHealing); _buff.Activate(casterData, new []{casterData.ObjectId}, DEFAULT_DURATION); yield return null; } public override float CalcDuration(FNStatsController statsController) { return DEFAULT_DURATION; } public static float CalcTickCooldown(FNStatsController statsController) { return TICK_COOLDOWN; } public override float CalcAmount(FNStatsController statsController) { return BASE_HEALING + statsController.GetStatByType(STAT_TYPE).CurrentAmount * STAT_MOD; } public override string GetAbilityDescription(int rank, FNStatsController statsController) { float amount = CalcAmount(statsController); float duration = CalcDuration(statsController); string mainEdited = _abilityDefinition.mainDescription.Replace(\"@@@@@\", $\"<color={COLOR_DURATION}>{duration.ToString(\"F1\")}</color>\"); mainEdited = mainEdited.Replace(\"@@@@\", $\"<color={COLOR_COOLDOWN}>{TICK_COOLDOWN.ToString(\"F1\")}</color>\"); mainEdited = mainEdited.Replace(\"@@@\", $\"<color={COLOR_HEAL}>{(amount).ToString(\"F2\")}</color>\"); mainEdited += I2.Loc.LocalizationManager.GetTermTranslation(\"Affecting stat\") + $\": <color={COLOR_AFFECTING_STAT}>{STAT_TYPE.ToString()}</color>\"; return $\"{mainEdited}\"; } }",
          "content_tokens": 593,
          "embedding": []
        }
      ],
      "length": 2061
    },
    {
      "filename": "TeleportationCircle",
      "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Object; using UnityEngine; public class TeleportationCircle : Ability { private Dictionary<int, bool> _teleportationCircleActive = new Dictionary<int, bool>(); private Dictionary<int, bool> _abilityBlockForPlayer = new Dictionary<int, bool>(); private Dictionary<int, GameObject> _spawnedTeleportationCircles = new Dictionary<int, GameObject>(); [Server] public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); if (IsAbilityBlocked(casterNetId)) { Debug.Log($\"Ability {AbilityDefinition.Name} is blocked for player {casterNetId}\"); yield break; } if (IsTeleportationCircleActive(casterNetId)) { GameObject teleportationCircle = LoadTeleportationCircle(casterNetId); if (teleportationCircle == null) { yield break; } RpcShowEffectForObservers(casterNetId, AbilityDefinition.Id, _rank, 2.0f); yield return new WaitForSeconds(2f); unitComps.InvectorManager.ServerTeleportPlayer(teleportationCircle.transform.position); SetTeleportationCircleActive(casterNetId, false); InstanceFinder.ServerManager.Despawn(teleportationCircle); } else { SetTeleportationCircleActive(casterNetId, true); Vector3 pos = unitComps.HealthController.transform.position; GameObject teleportationCircle = Instantiate(_abilityDefinition.RanksDatas[rank].groundVisualEffect, pos + Vector3.up * .1f, Quaternion.identity, GameplayManager.Instance.transform); Spawn(teleportationCircle); SaveTeleportationCircle(casterNetId, teleportationCircle); StartCoroutine(BlockAbilityForSeconds(casterNetId, 2f)); } yield return null; } [Server] private IEnumerator BlockAbilityForSeconds(int casterNetId, float duration) { SetAbilityBlock(casterNetId, true); yield return new WaitForSeconds(duration); SetAbilityBlock(casterNetId, false); } [Server] private bool IsTeleportationCircleActive(int casterNetId) { if (_teleportationCircleActive.ContainsKey(casterNetId)) { return _teleportationCircleActive[casterNetId]; } else { return false; } } [Server] private void SetTeleportationCircleActive(int casterNetId, bool active) { if (_teleportationCircleActive.ContainsKey(casterNetId)) { _teleportationCircleActive[casterNetId] = active; } else { _teleportationCircleActive.Add(casterNetId, active); } } [Server] private bool IsAbilityBlocked(int casterNetId) { if (_abilityBlockForPlayer.ContainsKey(casterNetId)) { return _abilityBlockForPlayer[casterNetId]; } else { return false; } } [Server] private void SetAbilityBlock(int casterNetId, bool active) { if (_abilityBlockForPlayer.ContainsKey(casterNetId)) { _abilityBlockForPlayer[casterNetId] = active; } else { _abilityBlockForPlayer.Add(casterNetId, active); } } [Server] private void SaveTeleportationCircle(int casterNetId, GameObject teleportationCircle) { if (!_spawnedTeleportationCircles.ContainsKey(casterNetId)) { _spawnedTeleportationCircles.Add(casterNetId, teleportationCircle); }else{ _spawnedTeleportationCircles[casterNetId] = teleportationCircle; } } [Server] private GameObject LoadTeleportationCircle(int casterNetId) { if (_spawnedTeleportationCircles.ContainsKey(casterNetId)) { return _spawnedTeleportationCircles[casterNetId]; } else { DebugWrite.LogError($\"[TeleportationCircle] No teleportation circle found for player {casterNetId}\"); return null; } } public override string GetAbilityDescription(int rank, FNStatsController statsController) { string mainEdited = _abilityDefinition.mainDescription; return $\"{mainEdited}\"; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "TeleportationCircle",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeleportationCircle",
          "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Object; using UnityEngine; public class TeleportationCircle : Ability { private Dictionary<int, bool> _teleportationCircleActive = new Dictionary<int, bool>(); private Dictionary<int, bool> _abilityBlockForPlayer = new Dictionary<int, bool>(); private Dictionary<int, GameObject> _spawnedTeleportationCircles = new Dictionary<int, GameObject>(); [Server] public override IEnumerator Activate(int casterNetId, int targetNetId = -1, int rank = 0) { UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); if (IsAbilityBlocked(casterNetId)) { Debug.Log($\"Ability {AbilityDefinition.Name} is blocked for player {casterNetId}\"); yield break;  ",
          "content_tokens": 236,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeleportationCircle",
          "content": "if (IsTeleportationCircleActive(casterNetId)) { GameObject teleportationCircle = LoadTeleportationCircle(casterNetId); if (teleportationCircle == null) { yield break;  ",
          "content_tokens": 45,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeleportationCircle",
          "content": "RpcShowEffectForObservers(casterNetId, AbilityDefinition.Id, _rank, 2.0f); yield return new WaitForSeconds(2f); unitComps.InvectorManager.ServerTeleportPlayer(teleportationCircle.transform.position); SetTeleportationCircleActive(casterNetId, false); InstanceFinder.ServerManager.Despawn(teleportationCircle); } else { SetTeleportationCircleActive(casterNetId, true); Vector3 pos = unitComps.HealthController.transform.position; GameObject teleportationCircle = Instantiate(_abilityDefinition.RanksDatas[rank].groundVisualEffect, pos + Vector3.up * .1f, Quaternion.identity, GameplayManager.Instance.transform); Spawn(teleportationCircle); SaveTeleportationCircle(casterNetId, teleportationCircle); StartCoroutine(BlockAbilityForSeconds(casterNetId, 2f)); } yield return null; } [Server] private IEnumerator BlockAbilityForSeconds(int casterNetId, float duration) { SetAbilityBlock(casterNetId, true); yield return new WaitForSeconds(duration); SetAbilityBlock(casterNetId, false); } [Server] private bool IsTeleportationCircleActive(int casterNetId) { if (_teleportationCircleActive.ContainsKey(casterNetId)) { return _teleportationCircleActive[casterNetId]; } else { return false; } } [Server] private void SetTeleportationCircleActive(int casterNetId, bool active) { if (_teleportationCircleActive.ContainsKey(casterNetId)) { _teleportationCircleActive[casterNetId] = active; } else { _teleportationCircleActive.Add(casterNetId, active); } } [Server] private bool IsAbilityBlocked(int casterNetId) { if (_abilityBlockForPlayer.ContainsKey(casterNetId)) { return _abilityBlockForPlayer[casterNetId]; } else { return false; } } [Server] private void SetAbilityBlock(int casterNetId, bool active) { if (_abilityBlockForPlayer.ContainsKey(casterNetId)) { _abilityBlockForPlayer[casterNetId] = active; } else { _abilityBlockForPlayer.Add(casterNetId, active); } } [Server] private void SaveTeleportationCircle(int casterNetId, GameObject teleportationCircle) { if (!_spawnedTeleportationCircles.ContainsKey(casterNetId)) { _spawnedTeleportationCircles.Add(casterNetId, teleportationCircle); }else{ _spawnedTeleportationCircles[casterNetId] = teleportationCircle; } } [Server] private GameObject LoadTeleportationCircle(int casterNetId) { if (_spawnedTeleportationCircles.ContainsKey(casterNetId)) { return _spawnedTeleportationCircles[casterNetId]; } else { DebugWrite.LogError($\"[TeleportationCircle] No teleportation circle found for player {casterNetId}\"); return null; } } public override string GetAbilityDescription(int rank, FNStatsController statsController) { string mainEdited = _abilityDefinition.mainDescription; return $\"{mainEdited}\"; } }",
          "content_tokens": 717,
          "embedding": []
        }
      ],
      "length": 3706
    },
    {
      "filename": "AbilityChoosingMenuEditor",
      "content": "using UnityEngine; using UnityEditor; using System.Collections; [CustomEditor(typeof(AbilityChoosingMenu))] public class AbilityChoosingMenuEditor : Editor { public override void OnInspectorGUI() { base.OnInspectorGUI(); AbilityChoosingMenu abilityChoosingMenu = (AbilityChoosingMenu)target; if (GUILayout.Button(\"Load Random Abilities\")) { //abilityChoosingMenu.LoadRandomAbilities(); throw new System.NotImplementedException(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AbilityChoosingMenuEditor",
          "content": "using UnityEngine; using UnityEditor; using System.Collections; [CustomEditor(typeof(AbilityChoosingMenu))] public class AbilityChoosingMenuEditor : Editor { public override void OnInspectorGUI() { base.OnInspectorGUI(); AbilityChoosingMenu abilityChoosingMenu = (AbilityChoosingMenu)target; if (GUILayout.Button(\"Load Random Abilities\")) { //abilityChoosingMenu.LoadRandomAbilities(); throw new System.NotImplementedException(); } } }",
          "content_tokens": 110,
          "embedding": []
        }
      ],
      "length": 435
    },
    {
      "filename": "AbilityDefinitionHolderEditor",
      "content": " #if UNITY_EDITOR using UnityEditor; using UnityEngine; namespace _ZombieRoyale.Scripts.Abilities.Editor { [CustomEditor(typeof(AbilityDefinitionHolder))] public class AbilityDefinitionHolderEditor : UnityEditor.Editor { private string _jsonRepresentation; public override void OnInspectorGUI() { base.OnInspectorGUI(); // Get the scriptable object instance AbilityDefinitionHolder definitionsHolder = (AbilityDefinitionHolder)target; if (definitionsHolder.AbilityDefinitions != null) { // Set the Id for each enemyDefinition based on their position. for(byte i = 0; i < definitionsHolder.AbilityDefinitions.Count; i++) { definitionsHolder.AbilityDefinitions[i].SetId(i); } // Mark the scriptable object as dirty so changes persist EditorUtility.SetDirty(definitionsHolder); for (byte i = 0; i < definitionsHolder.AbilityDefinitions.Count; i++) { EditorUtility.SetDirty(definitionsHolder.AbilityDefinitions[i]); } } if (GUILayout.Button(\"Serialize to JSON\")) { _jsonRepresentation = definitionsHolder.SerializeToJson(); } _jsonRepresentation = EditorGUILayout.TextArea(_jsonRepresentation, GUILayout.MinHeight(5 * EditorGUIUtility.singleLineHeight)); } } } #endif",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AbilityDefinitionHolderEditor",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "AbilityDefinitionHolderEditor",
          "content": " #if UNITY_EDITOR using UnityEditor; using UnityEngine; namespace _ZombieRoyale.Scripts.Abilities.Editor { [CustomEditor(typeof(AbilityDefinitionHolder))] public class AbilityDefinitionHolderEditor : UnityEditor.Editor { private string _jsonRepresentation; public override void OnInspectorGUI() { base.OnInspectorGUI(); // Get the scriptable object instance AbilityDefinitionHolder definitionsHolder = (AbilityDefinitionHolder)target; if (definitionsHolder.AbilityDefinitions != null) { // Set the Id for each enemyDefinition based on their position. for(byte i = 0; i < definitionsHolder.AbilityDefinitions.Count; i++) { definitionsHolder.AbilityDefinitions[i].SetId(i); } // Mark the scriptable object as dirty so changes persist EditorUtility.SetDirty(definitionsHolder); for (byte i = 0; i < definitionsHolder.AbilityDefinitions.Count; i++) { EditorUtility.SetDirty(definitionsHolder.AbilityDefinitions[i]); }  ",
          "content_tokens": 237,
          "embedding": []
        },
        {
          "cs_scriptfile": "AbilityDefinitionHolderEditor",
          "content": "if (GUILayout.Button(\"Serialize to JSON\")) { _jsonRepresentation = definitionsHolder.SerializeToJson(); } _jsonRepresentation = EditorGUILayout.TextArea(_jsonRepresentation, GUILayout.MinHeight(5 * EditorGUIUtility.singleLineHeight)); } } } #endif}",
          "content_tokens": 74,
          "embedding": []
        }
      ],
      "length": 1163
    },
    {
      "filename": "UIAbilitiesSkillPanel",
      "content": "using System.Collections.Generic; using DuloGames.UI; using UnityEngine; public class UIAbilitiesSkillPanel : MonoBehaviour { [SerializeField] private FNAbilityController _abilityController; [SerializeField] private UISkillButton _skillButtonPrefab; private List<UISkillButton> _skillButtons = new List<UISkillButton>(); [SerializeField] private Transform _gridPanel; [field:SerializeField] public UISpellSlot[] SpellSlots { get; private set; } [field:SerializeField] public UISpellSlot[] PassiveSpellSlots { get; private set; } public void AddAbility(Ability ability, uint stacks) { UISpellInfo spellInfo = ability.GetUISpellInfo(ability.AbilityDefinition.Id, stacks); if (ability.AbilityDefinition.IsPassive) { AddPassiveAbility(spellInfo); } else { AddActiveAbility(spellInfo); } } private void AddPassiveAbility(UISpellInfo spellInfo) { int slot = GetFirstAvailablePassiveSpellSlot(); PassiveSpellSlots[slot].gameObject.SetActive(true); PassiveSpellSlots[slot].Assign(spellInfo); } private void AddActiveAbility(UISpellInfo spellInfo) { int slot = GetFirstAvailableEmptySpellSlot(); SpellSlots[slot].Assign(spellInfo); } private int GetFirstAvailablePassiveSpellSlot() { for (int i = 0; i < PassiveSpellSlots.Length; i++) { if (PassiveSpellSlots[i].IsAssigned()) { continue; } return i; } Debug.LogError(\"No available passive spell slots\"); return -1; } private int GetFirstAvailableEmptySpellSlot() { for (int i = 0; i < SpellSlots.Length; i++) { if (SpellSlots[i].IsAssigned()) { continue; } return i; } Debug.LogError(\"No available spell slots\"); return -1; } public void UpdateAbility(AbilityInfo abilityInfo) { //TODO: Update ability info. } public void StartCooldown(int abilityId, float time) { UISpellSlot slot = GetSpellSlotByAbilityId(abilityId); slot.cooldownComponent.StartCooldown(abilityId, time); } public void ResetAbilityCooldown(int abilityId) { UISpellSlot slot = GetSpellSlotByAbilityId(abilityId); slot.cooldownComponent.InterruptCooldown(); } public int GetAbilityIdBySlot(int i) { return SpellSlots[i].spellInfo.ID; } private UISpellSlot GetSpellSlotByAbilityId(int abilityId) { for (int i = 0; i < SpellSlots.Length; i++) { if (SpellSlots[i].spellInfo == null) continue; if (SpellSlots[i].spellInfo.ID == abilityId) { return SpellSlots[i]; } } Debug.LogError($\"No spell slot found for ability id {abilityId}\"); return null; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "UIAbilitiesSkillPanel",
          "content": "using System.Collections.Generic; using DuloGames.UI; using UnityEngine; public class UIAbilitiesSkillPanel : MonoBehaviour { [SerializeField] private FNAbilityController _abilityController; [SerializeField] private UISkillButton _skillButtonPrefab; private List<UISkillButton> _skillButtons = new List<UISkillButton>(); [SerializeField] private Transform _gridPanel; [field:SerializeField] public UISpellSlot[] SpellSlots { get; private set; } [field:SerializeField] public UISpellSlot[] PassiveSpellSlots { get; private set;  ",
          "content_tokens": 144,
          "embedding": []
        },
        {
          "cs_scriptfile": "UIAbilitiesSkillPanel",
          "content": "public void AddAbility(Ability ability, uint stacks) { UISpellInfo spellInfo = ability.GetUISpellInfo(ability.AbilityDefinition.Id, stacks); if (ability.AbilityDefinition.IsPassive) { AddPassiveAbility(spellInfo); } else { AddActiveAbility(spellInfo); }  private void AddPassiveAbility(UISpellInfo spellInfo) { int slot = GetFirstAvailablePassiveSpellSlot(); PassiveSpellSlots[slot].gameObject.SetActive(true); PassiveSpellSlots[slot].Assign(spellInfo);  private void AddActiveAbility(UISpellInfo spellInfo) { int slot = GetFirstAvailableEmptySpellSlot(); SpellSlots[slot].Assign(spellInfo);  ",
          "content_tokens": 161,
          "embedding": []
        },
        {
          "cs_scriptfile": "UIAbilitiesSkillPanel",
          "content": "private int GetFirstAvailablePassiveSpellSlot() { for (int i = 0; i < PassiveSpellSlots.Length; i++) { if (PassiveSpellSlots[i].IsAssigned()) { continue; } return i; } Debug.LogError(\"No available passive spell slots\"); return -1;  private int GetFirstAvailableEmptySpellSlot() { for (int i = 0; i < SpellSlots.Length; i++) { if (SpellSlots[i].IsAssigned()) { continue; } return i; } Debug.LogError(\"No available spell slots\"); return -1;  public void UpdateAbility(AbilityInfo abilityInfo) { //TODO: Update ability info.  public void StartCooldown(int abilityId, float time) { UISpellSlot slot = GetSpellSlotByAbilityId(abilityId); slot.cooldownComponent.StartCooldown(abilityId, time);  ",
          "content_tokens": 197,
          "embedding": []
        },
        {
          "cs_scriptfile": "UIAbilitiesSkillPanel",
          "content": "public void ResetAbilityCooldown(int abilityId) { UISpellSlot slot = GetSpellSlotByAbilityId(abilityId); slot.cooldownComponent.InterruptCooldown();  public int GetAbilityIdBySlot(int i) { return SpellSlots[i].spellInfo.ID; } private UISpellSlot GetSpellSlotByAbilityId(int abilityId) { for (int i = 0; i < SpellSlots.Length; i++) { if (SpellSlots[i].spellInfo == null) continue; if (SpellSlots[i].spellInfo.ID == abilityId) { return SpellSlots[i]; } } Debug.LogError($\"No spell slot found for ability id {abilityId}\"); return null; } }",
          "content_tokens": 162,
          "embedding": []
        }
      ],
      "length": 2356
    },
    {
      "filename": "UISkillButton",
      "content": "using System.Collections; using System.Collections.Generic; using SingletonsExtension; using UnityEngine; using UnityEngine.UI; public class UISkillButton : MonoBehaviour { [SerializeField] private Image _abilityIcon; [SerializeField] private Image _cooldownOverlay; [SerializeField] private TMProDecorator _abilityCooldownText; [SerializeField] private TMProDecorator _abilityKey; public int AbilityId => abilityId; private int abilityId; public void Init(AbilityDefinition ability, string key, int rank = 0) { abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(ability); _abilityIcon.sprite = ability.Icon; _abilityIcon.color = Color.white; _abilityKey.SetText(key); } public void StartCooldown(float time) { StartCoroutine(StartCooldownCoroutine(time)); } IEnumerator StartCooldownCoroutine(float time) { _cooldownOverlay.fillAmount = 1.0f; float fillAmount = 1.0f; int cooldown = (int)time; int lastTime = 999; while (fillAmount > 0.0f) { fillAmount -= Time.deltaTime / time; cooldown = (int)(fillAmount * time); if (lastTime != cooldown) { _abilityCooldownText.SetText(cooldown.ToString()); lastTime = cooldown; } _cooldownOverlay.fillAmount = fillAmount; yield return null; } _abilityCooldownText.SetText(\"\"); _cooldownOverlay.fillAmount = 0.0f; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "UISkillButton",
          "content": "using System.Collections; using System.Collections.Generic; using SingletonsExtension; using UnityEngine; using UnityEngine.UI; public class UISkillButton : MonoBehaviour { [SerializeField] private Image _abilityIcon; [SerializeField] private Image _cooldownOverlay; [SerializeField] private TMProDecorator _abilityCooldownText; [SerializeField] private TMProDecorator _abilityKey; public int AbilityId => abilityId; private int abilityId; public void Init(AbilityDefinition ability, string key, int rank = 0) { abilityId = MasterManager.Instance.AbilityDefinitionHolder.GetAbilityId(ability); _abilityIcon.sprite = ability.Icon; _abilityIcon.color = Color.white; _abilityKey.SetText(key);  ",
          "content_tokens": 178,
          "embedding": []
        },
        {
          "cs_scriptfile": "UISkillButton",
          "content": "public void StartCooldown(float time) { StartCoroutine(StartCooldownCoroutine(time)); } IEnumerator StartCooldownCoroutine(float time) { _cooldownOverlay.fillAmount = 1.0f; float fillAmount = 1.0f; int cooldown = (int)time; int lastTime = 999; while (fillAmount > 0.0f) { fillAmount -= Time.deltaTime / time; cooldown = (int)(fillAmount * time); if (lastTime != cooldown) { _abilityCooldownText.SetText(cooldown.ToString()); lastTime = cooldown; } _cooldownOverlay.fillAmount = fillAmount; yield return null; } _abilityCooldownText.SetText(\"\"); _cooldownOverlay.fillAmount = 0.0f; } }",
          "content_tokens": 173,
          "embedding": []
        }
      ],
      "length": 1276
    },
    {
      "filename": "AddLODGroupAndCleanup",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; public class AddLODGroupAndCleanup : MonoBehaviour { public bool WorkIsDone = false; public void DoForAllChildren() { foreach (Transform child in transform) { Renderer renderer = child.gameObject.GetComponent<Renderer>(); if (renderer == null) continue; if (child.gameObject.GetComponent<LODGroup>() != null) continue; Init(child.gameObject); } } public void Init(GameObject targetGo) { if (targetGo.GetComponent<Renderer>() == null) return; // Add LOD Group component LODGroup lodGroup = targetGo.AddComponent<LODGroup>(); //lodgroup Reset Object Size lodGroup.RecalculateBounds(); // Remove 2nd and 3rd layers LOD[] lods = new LOD[1]; // Only one LOD layer is enough lods[0].renderers = GetRenderersRecursive(targetGo); lods[0].screenRelativeTransitionHeight = 0.5f; // Adjust as needed lodGroup.SetLODs(lods); // Set correct culling distance float maxDistance = CalculateMaxDistance(lods[0].renderers); lodGroup.size = maxDistance / Camera.main.transform.lossyScale.magnitude; // Update prefab if this object is a prefab instance UpdatePrefab(targetGo); WorkIsDone = true; // Remove this script component DestroyImmediate(this); } // Recursively get all Mesh Renderers from the GameObject and its children Renderer[] GetRenderersRecursive(GameObject obj) { return obj.GetComponentsInChildren<Renderer>(); } // Calculate the maximum distance among all Mesh Renderers float CalculateMaxDistance(Renderer[] renderers) { float maxDistance = 0f; foreach (Renderer renderer in renderers) { Bounds bounds = renderer.bounds; float distance = Vector3.Distance(bounds.center, Camera.main.transform.position) + bounds.extents.magnitude; if (distance > maxDistance) { maxDistance = distance; } } return maxDistance; } void UpdatePrefab(GameObject targetGameObject) { #if UNITY_EDITOR // Get the prefab root GameObject prefabRoot = PrefabUtility.GetCorrespondingObjectFromSource(targetGameObject); // Check if this object is a prefab instance and its root exists if (prefabRoot != null && PrefabUtility.IsPartOfAnyPrefab(prefabRoot)) { // Apply changes to the prefab PrefabUtility.ApplyPrefabInstance(targetGameObject, InteractionMode.UserAction); } #endif } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AddLODGroupAndCleanup",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; public class AddLODGroupAndCleanup : MonoBehaviour { public bool WorkIsDone = false; public void DoForAllChildren() { foreach (Transform child in transform) { Renderer renderer = child.gameObject.GetComponent<Renderer>(); if (renderer == null) continue; if (child.gameObject.GetComponent<LODGroup>() != null) continue; Init(child.gameObject); }  ",
          "content_tokens": 116,
          "embedding": []
        },
        {
          "cs_scriptfile": "AddLODGroupAndCleanup",
          "content": "public void Init(GameObject targetGo) { if (targetGo.GetComponent<Renderer>() == null) return; // Add LOD Group component LODGroup lodGroup = targetGo.AddComponent<LODGroup>(); //lodgroup Reset Object Size lodGroup.RecalculateBounds(); // Remove 2nd and 3rd layers LOD[] lods = new LOD[1]; // Only one LOD layer is enough lods[0].renderers = GetRenderersRecursive(targetGo); lods[0].screenRelativeTransitionHeight = 0.5f; // Adjust as needed lodGroup.SetLODs(lods); // Set correct culling distance float maxDistance = CalculateMaxDistance(lods[0].renderers); lodGroup.size = maxDistance / Camera.main.transform.lossyScale.magnitude; // Update prefab if this object is a prefab instance UpdatePrefab(targetGo); WorkIsDone = true; // Remove this script component DestroyImmediate(this); } // Recursively get all Mesh Renderers from the GameObject and its children Renderer[] GetRenderersRecursive(GameObject obj) { return obj.GetComponentsInChildren<Renderer>(); } // Calculate the maximum distance among all Mesh Renderers float CalculateMaxDistance(Renderer[] renderers) { float maxDistance = 0f; foreach (Renderer renderer in renderers) { Bounds bounds = renderer.bounds; float distance = Vector3.Distance(bounds.center, Camera.main.transform.position) + bounds.extents.magnitude; if (distance > maxDistance) { maxDistance = distance; } } return maxDistance;  ",
          "content_tokens": 379,
          "embedding": []
        },
        {
          "cs_scriptfile": "AddLODGroupAndCleanup",
          "content": "void UpdatePrefab(GameObject targetGameObject) { #if UNITY_EDITOR // Get the prefab root GameObject prefabRoot = PrefabUtility.GetCorrespondingObjectFromSource(targetGameObject); // Check if this object is a prefab instance and its root exists if (prefabRoot != null && PrefabUtility.IsPartOfAnyPrefab(prefabRoot)) { // Apply changes to the prefab PrefabUtility.ApplyPrefabInstance(targetGameObject, InteractionMode.UserAction); } #endif } }",
          "content_tokens": 120,
          "embedding": []
        }
      ],
      "length": 2248
    },
    {
      "filename": "AIRootMotionCharacterController",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class AIRootMotionCharacterController : MonoBehaviour { } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AIRootMotionCharacterController",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class AIRootMotionCharacterController : MonoBehaviour { }",
          "content_tokens": 31,
          "embedding": []
        }
      ],
      "length": 144
    },
    {
      "filename": "AIUnit",
      "content": "using System; using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DG.Tweening; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using FishnetInvector; using Invector; using Pathfinding; using UnityEditor; using UnityEngine; using UnityEngine.Events; using Zomb.Creatures.Helpers; using Random = UnityEngine.Random; [RequireComponent(typeof(BehavioursSwitcher))] public class AIUnit : Unit { public struct BattleInfo { private List<float> time; private List<float> damageDealt; public BattleInfo(byte size = 0) { this.time = new List<float>(); this.damageDealt = new List<float>(); } public void Add( float time, float damageDealt ) { this.time.Add( time ); this.damageDealt.Add( damageDealt ); } public float GetAllCurrentPlayerDealtDamage() { float totalDamage = 0; foreach( float damage in damageDealt ) { totalDamage += damage; } return totalDamage; } } public enum AIState { Idle, Wander, Chase, Attack, Dead, TakingOff, Landing, Flying, Landed } #region Publics public ushort SpawnPointId { set { _spawnPointId = value; } get { return _spawnPointId; } } public AnimatorDecorator AnimatorDecorator => _animatorDecorator; public float Damage { get { var baseStr = _definition.Strength; float bonusStr = (float)_statsController.GetAllCurrentValue(Stat.STAT_TYPE.STRENGTH); float result = baseStr + bonusStr; return result; } } public List<SkinnedMeshRenderer> AIMeshes => _aiMeshes; public bool IsDebug => _isDebug; public float Accuracy => 80f; public bool IsInCombat => _isInCombat; public bool IsAttackOnCooldown => _isAttackOnCooldown; public bool IsDead => HealthController.IsDead; public ZombieEars ZombieEars => _zombieEars; public EnemyDefinition EnemyDefinition => _definition; public float ViewDistance => _definition.ViewDistance; public UnityAction<AIUnit> OnHideCreature; private string RoomNameHoldingMe => _roomNameHoldingMe; public bool IsAware => _isAware; public Vector3 LastTargetPosition => _lastTargetPosition; public float TimeInCombat => _timeInCombat; private Vector3 _lastTargetPosition = Vector3.zero; public AstarAI AstarAINavigation => _astarAI; #endregion #region Animation IDs public int AnimIDIsInCombat => _animIDIsInCombat; public int AnimIDIsMoving => _animIDIsMoving; private static int _animIDSpeed; private static int _animIDAttack; private static int _animIDGrounded; private static int _animIDJump; private static int _animIDFire; private static int _animIDReload; private static int _animIDFreeFall; private static int _animIDHorizontal; private static int _animIDVertical; private static int _animIDAim; private static int _animIDHorAngle; private static int _animIDVerAngle; private static int _animIDIsMoving; private static int _animIDIsDead; private static int _animIDIsAttacking; private static float _canMoveAt; private static float _canActAt; private static float _canWanderAt; private static bool _isWanderState; private static int _animIDIsInCombat; private static int _animIDDoAttack; private static int _animIDStunned; private static int _animIDHit; private static int _animIDHitId; private static int _animIDTakeOff; private static int _animIDIsFlying; private static int _animIDIsFalling; private static int _animIDDoFrozenBreath; private static int _animIDDoLanding; private static int _animGotHit; #endregion #region Privates private static float TIME_TO_EXIT_AWARENESS = 10f; [SerializeField] private AnimatorDecorator _animatorDecorator; [SerializeField] private ZombieEars _zombieEars; [SerializeField] private BehaviorDesigner.Runtime.BehaviorTree _behaviorTree; [SerializeField] private EnemyMoanAudio _moanAudio; [SerializeField] private AstarAI _astarAI; [SerializeField] private List<SkinnedMeshRenderer> _aiMeshes; [SerializeField] private FNvMeleeManager _meleeManager; [SerializeField] private EnemyDefinition _definition; [SerializeField] private bool _isDamageByMeleeManager; [SerializeField] private HeadEffectorMovement headEffectorMovement; [SerializeField] private bool isPlayAnimationsHit; [SerializeField] private bool isPlayIndicator; [field:SerializeField] public List<RendererColor> rendererColor { get; protected set; } [field:SerializeField] public Texture textureToBlink { get; protected set; } private AIPath _aiPath; private ushort _creatureType; private ushort _spawnPointId; private Vector3 _spawnPosition; private bool _goingToSpawn; private int HitAudioChance; private Dictionary<int, BattleInfo> _battleInfo = new Dictionary<int, BattleInfo>(); private float _lifeTime; private static Dictionary<Transform, FishnetInvectorManager> _fishnetManagers = new Dictionary<Transform, FishnetInvectorManager>(); private bool _isInCombat; private Coroutine _combatTimer; private float _timeInCombat = 0; private string _roomNameHoldingMe; private FNvRagdoll _ragdoll; [SyncVar] private Vector3 _birdthPosition; [SyncVar] private Vector3 _currentServerPosition; public bool IsAbleToGetHit => _isAbleToGetHit; [SyncVar] private bool _isAbleToGetHit = true; private bool _isKnockBack = true; private float _currentSpeedRaw; [SerializeField] private float[] _attackAnimationTimes; private CharacterController _characterController; private bool _isAware; private Coroutine _awarenessCoroutine; private static WaitForSeconds _awarenessTimeWait = new WaitForSeconds(TIME_TO_EXIT_AWARENESS); private bool _isStunned; private bool _isFlying; public enum HitDirection { Front, Right, Left, Back} public bool IsHaveTarget { get { if (_targetObjectId > -1) return true; return false; } } [SerializeField, SyncVar(OnChange = nameof(OnTargetChanged))] private int _targetObjectId; public SyncHashSet<int> PlayersWithinSight => _playersWithinSight; [SyncObject] private readonly SyncHashSet<int> _playersWithinSight = new SyncHashSet<int>(); private const string STRING_HEAD_TRANSFORM_NAME = \"Head\"; public Transform Head => _head; [SerializeField] private Transform _head; [SerializeField] private bool _isDebug; private bool _isAttackOnCooldown; private bool[] _isHealthPercentLeft = new bool[10]; public bool IsPaused => _isPaused; private bool _isPaused; public bool IsPlayingAttackAnimation => _isPlayingAttackAnimation; private bool _isPlayingAttackAnimation; private Coroutine _attackAnimationTimer; [SerializeField] private float _swingStretchTime; [field: SerializeField] public AIState CurrentState { get; private set; } = AIState.Landed; public Action OnStateFlying; public Action OnStateLanded; private float _takeOffTime; private float _landingTime; private float _groundedY; public UnitComponents ThisUnitComponents { get { if (_unitComponents == null) { _unitComponents = GameplayManager.Instance.GetUnitComponentsServerAndClient(NetworkObject.ObjectId); } return _unitComponents; } } private UnitComponents _unitComponents; #endregion protected override void Awake() { base.Awake(); StoreComponents(); _ragdoll = GetComponentInChildren(typeof(FNvRagdoll)) as FNvRagdoll; AssignAnimationIDs(); _playersWithinSight.OnChange += _playersWithinSight_OnChange; SetupAnimationTimes(); } protected override void OnValidate() { base.OnValidate(); headEffectorMovement ??= GetComponentInChildren<HeadEffectorMovement>(); StoreComponents(); } public void StoreComponents() { if (_animatorDecorator == null) _animatorDecorator = GetComponent<AnimatorDecorator>(); if (_zombieEars == null) _zombieEars = GetComponent<ZombieEars>(); if (_behaviorTree == null) _behaviorTree = GetComponent<BehaviorDesigner.Runtime.BehaviorTree>(); if (_moanAudio == null) _moanAudio = GetComponent<EnemyMoanAudio>(); if (_statsController == null) _statsController = GetComponent<FNStatsController>(); if (_astarAI == null) _astarAI = GetComponent<AstarAI>(); if (_meleeManager == null) _meleeManager = GetComponentInChildren<FNvMeleeManager>(); if (_characterController == null) _characterController = GetComponent<CharacterController>(); if (_aiPath == null) _aiPath = GetComponent<AIPath>(); if (_aiPath == null) _aiPath = GetComponent<AIPath>(); if (_aiMeshes.Count == 0) _aiMeshes = GetComponentsInChildren<SkinnedMeshRenderer>().vToList(); } public override void OnStartNetwork() { base.OnStartNetwork(); if (base.IsHost) { _meleeManager.SetAsHost(); } if (base.IsHost || base.IsServerOnly) {//Server _birdthPosition = transform.position; _astarAI.ServerInit(this, _animatorDecorator); _statsController.InitForAI(this); GameplayManager.Instance.SaveNpcToRoom(NetworkObject); } else {//Client if (_head == null) { foreach (Transform child in transform) { if (child.name == STRING_HEAD_TRANSFORM_NAME) { _head = child; break; } } } if (!_head) { DebugWrite.LogError($\"[ZombieUnit] No head found for {gameObject.name}\"); } _moanAudio.Init(); DebugWrite.Log($\"[AIUnit] OnStartNetwork: {gameObject.name} _moanAudio.Init\", gameObject, _isDebug); } SetName(); } public override void OnStartServer() { base.OnStartServer(); SubscribeToEvents(true); CombatLeave(); _meleeManager.SetAsServerOwned(); _meleeManager.Initialize(GameplayManager.Instance); _meleeManager.SetAsOwner(); _meleeManager.SetAIDamage(Damage); SetupHealth(); } public override void OnStartClient() { base.OnStartClient(); _meleeManager.Initialize(GameplayManager.LocalPlayer); StoreRendererColors(); } public override void OnStopNetwork() { base.OnStopNetwork(); if (base.IsHost || base.IsServerOnly) {//Server SubscribeToEvents(false); } } private void Update() { if (base.IsServer) { _currentServerPosition = transform.position; //InstantLookAtTarget(); SmoothLookAtTarget(); } } private void SetupHealth() { var healData = new FishnetInvectorHealthController.HealData(); healData.amount = EnemyDefinition.MaxHealth; HealthController.SetHealth(FishnetInvectorHealthController.HealthType.Max, healData); HealthController.SetHealth(FishnetInvectorHealthController.HealthType.Current, healData); } private void AssignAnimationIDs() { _animIDSpeed = Animator.StringToHash(\"Speed\"); _animIDGrounded = Animator.StringToHash(\"Grounded\"); _animIDJump = Animator.StringToHash(\"Jump\"); _animIDFire = Animator.StringToHash(\"Fire\"); _animIDReload = Animator.StringToHash(\"Reload\"); _animIDFreeFall = Animator.StringToHash(\"FreeFall\"); _animIDHorizontal = Animator.StringToHash(\"Horizontal\"); _animIDVertical = Animator.StringToHash(\"Vertical\"); _animIDAim = Animator.StringToHash(\"Aim\"); _animIDHorAngle = Animator.StringToHash(\"HorAimAngle\"); _animIDVerAngle = Animator.StringToHash(\"VerAimAngle\"); _animIDIsMoving = Animator.StringToHash(\"IsMoving\"); _animIDIsAttacking = Animator.StringToHash(\"IsAttacking\"); _animIDIsDead = Animator.StringToHash(\"IsDead\"); _animIDIsInCombat = Animator.StringToHash(\"IsInCombat\"); _animIDDoAttack = Animator.StringToHash(\"DoAttack\"); _animIDAttack = Animator.StringToHash(\"AttackId\"); _animIDStunned = Animator.StringToHash(\"IsStunned\"); _animIDHit = Animator.StringToHash(\"DoHit\"); _animGotHit = Animator.StringToHash(\"GotHit\"); _animIDHitId = Animator.StringToHash(\"HitId\"); _animIDTakeOff = Animator.StringToHash(\"IsTakingOff\"); _animIDIsFlying = Animator.StringToHash(\"IsFlying\"); _animIDDoFrozenBreath = Animator.StringToHash(\"DoFrozenBreath\"); _animIDDoLanding = Animator.StringToHash(\"IsLanding\"); _animIDIsFalling = Animator.StringToHash(\"IsFalling\"); } private void SetName() => gameObject.name = $\"{_definition.Name} #{ObjectId}\"; [Server] private void SubscribeToEvents(bool subscribe) { if (subscribe) { HealthController.OnDead += OnDead_healthController; HealthController.OnTakeDamage += OnDamageTaken_BehaviourNotifier; _zombieEars.OnHeardSomething += OnHeardSound_Handler; _astarAI.OnStopMove.AddListener(() => _animatorDecorator.SetBool(_animIDIsMoving, false)); _astarAI.OnStartMove.AddListener(StartMoving); var stat = _statsController.GetStatByType(Stat.STAT_TYPE.MOVEMENT_SPEED); stat.OnStatChanged += OnSpeedChanged; InstanceFinder.TimeManager.OnTick += OnTick; } else { HealthController.OnDead -= OnDead_healthController; HealthController.OnTakeDamage -= OnDamageTaken_BehaviourNotifier; _zombieEars.OnHeardSomething -= OnHeardSound_Handler; _astarAI.OnStopMove.RemoveAllListeners(); _astarAI.OnStartMove.RemoveAllListeners(); var stat = _statsController.GetStatByType(Stat.STAT_TYPE.MOVEMENT_SPEED); stat.OnStatChanged -= OnSpeedChanged; InstanceFinder.TimeManager.OnTick -= OnTick; } } private void StartMoving() { if (IsPlayingAttackAnimation) return; _animatorDecorator.SetBool(_animIDIsMoving, true); } private void OnHeardSound_Handler(Vector3 pos) { //Vector3 navMeshPos = NavMeshesUtil.GetSpawnablePointAt(pos.x, pos.z); //_behaviorTree.SendEvent<object>(\"OnUnitHeardSound\", navMeshPos); CombatEnter(); } [Server] private void OnDead_healthController(vDamage damage) { //DebugWrite.Log($\"{gameObject.name} died\"); _animatorDecorator.SetBool(_animIDIsMoving, false); _behaviorTree.SendEvent(\"OnUnitDied\"); CombatLeave(); SwitchBehaviour(false); ClearBattleInfo(); BossDeath(); SpawnHealSphere(); GameplayManager.Instance.DropLootBag(this); if (EnemyDefinition.DeadBodyPrefab != null) { SpawnDeadBody(); Despawn(); //GameplayManager.Instance.CreaturesFactory.DeallocateCreature(this); } else { _animatorDecorator.SetBool(_animIDIsDead, true); } } [Server] private DeadBody SpawnDeadBody() { DebugWrite.Log($\"[AIUnit] SpawnDeadBody {gameObject.name}\"); DeadBody body = Instantiate(EnemyDefinition.DeadBodyPrefab, transform.position, transform.rotation); body.Init(GameplayManager.Instance, AnimatorDecorator); Spawn(body.gameObject); return body; } [Server] private void SpawnHealSphere() { if (EnemyDefinition.EnemyType != EnemyDefinition.Type.Boss) { float random = Random.Range(0f, 1f); if (random < 0.5f) GameplayManager.Instance.SpawnHealSphere(transform.position); } } [Server] private void BossDeath() { if (EnemyDefinition.EnemyType == EnemyDefinition.Type.Boss) { GameplayManager.Instance.SpawnEscapePortal(transform.position); } } [Server] public void Revive() { SwitchBehaviour(true); if (base.IsClient) { _moanAudio.Init(); _ragdoll.TurnOffRagdoll(); HealthController.TurnOnColliders(); } } [Server] private void SwitchBehaviour(bool isOn) { if (isOn) { HealthController.ResetHealth(); _animatorDecorator.SetBool(_animIDIsDead, false); _lifeTime = 0f; }else { _astarAI.Stop(); } _astarAI.enabled = isOn; //_fieldOfViewController.enabled = isOn; SubscribeToEvents(isOn); } [Server] private void OnSpeedChanged(float newSpeedModValue) { float newSpeed = _currentSpeedRaw * newSpeedModValue; _astarAI.SetSpeed(newSpeed); } private void _playersWithinSight_OnChange(SyncHashSetOperation op, int item, bool asServer) { switch (op) { case SyncHashSetOperation.Add: break; case SyncHashSetOperation.Remove: break; case SyncHashSetOperation.Clear: break; case SyncHashSetOperation.Update: break; case SyncHashSetOperation.Complete: break; } } [Server] public void UpdateSpeed(float maxSpeed) { _currentSpeedRaw = maxSpeed; float movementSpeedStat = (float)_statsController.GetAllCurrentValue(Stat.STAT_TYPE.MOVEMENT_SPEED); float newSpeed = movementSpeedStat * maxSpeed; _astarAI.SetSpeed(newSpeed); } [Server] public void CombatEnter() { _isInCombat = true; _isAware = true; if (_combatTimer == null) { _combatTimer = StartCoroutine(CombatTimer()); } //DebugWrite.Log($\"[AIUnit][CorRestartAwareness]: {gameObject} _isAware {_isAware}\"); UpdateSpeed(_definition.RunSpeed); _animatorDecorator.SetBool(_animIDIsInCombat, true); //_animatorDecorator.SetFloat(_animIDSpeed, 1f); } [Server] public void CombatLeave() { _isInCombat = false; if (_combatTimer != null) StopCoroutine(_combatTimer); _timeInCombat = 0f; UpdateSpeed(_definition.MoveSpeed); _animatorDecorator.SetBool(_animIDIsInCombat, false); _animatorDecorator.SetFloat(_animIDSpeed, 0f); RestartAwareness(); } private IEnumerator CombatTimer() { var time = new WaitForSeconds(1f); while (_isInCombat) { yield return time; _timeInCombat += 1f; } } [Server] private void RestartAwareness() { if (_awarenessCoroutine != null) StopCoroutine(_awarenessCoroutine); _awarenessCoroutine = StartCoroutine(CorRestartAwareness()); } [Server] private IEnumerator CorRestartAwareness() { yield return _awarenessTimeWait; _isAware = false; DebugWrite.Log($\"[ZombieUnit][CorRestartAwareness]: _isAware {_isAware}\", gameObject, _isDebug); } // Battle info management private void AddDamageReceivedInfo(int objectId, float amount) { if (_battleInfo.TryAdd(objectId, new BattleInfo())) { _battleInfo[objectId].Add(_lifeTime, amount); } else { _battleInfo[objectId].Add(_lifeTime, amount); } } private void ClearBattleInfo() { _battleInfo.Clear(); } private void OnDamageTaken_BehaviourNotifier(vDamage damage) { CombatEnter(); if (_currentSpeedRaw > float.Epsilon) { int targetId = damage.senderNetworkObjectID; DebugWrite.Log($\"[ZombieUnit][OnDamageTaken_Handler]: object #{targetId}\", gameObject, _isDebug); _behaviorTree.SendEvent<object>(\"OnUnitTakeDamage\", targetId); } if (HealthController.CurrentHealth >= 0) { float healthLeft = HealthController.CurrentHealth / HealthController.MaxHealth * 10; int healthPercent = Mathf.FloorToInt(healthLeft); for (int i = _isHealthPercentLeft.Length - 1; i >= 0; i--) { if (i == healthPercent - 1) break; if (!_isHealthPercentLeft[i]) { _isHealthPercentLeft[i] = true; //90 - 100% => OnUnitHealthFallTo100Percent //0 - 10% => OnUnitHealthFallTo10Percent _behaviorTree.SendEvent<object>($\"OnUnitHealthDropsBelowPercent\", 10 * (healthPercent + 1)); } } if (IsAbleToGetHit) { HitDirection hitDir = GetHitPosition(damage.hitPosition); float getHitAnimationTime = GetHitAnimationLen(hitDir, damage.hitHeight) * 1f; float timeout = Random.Range(getHitAnimationTime, getHitAnimationTime * 2f); StartCoroutine(GetHitUpdater(timeout)); PutAttackOnCooldown(getHitAnimationTime); if (IsServer && !IsHost) _animatorDecorator.SetBool(_animIDIsAttacking, false); var damager = GameplayManager.Instance.GetUnitComponentsServerAndClient(damage.senderNetworkObjectID); NetworkConnection senderConn = null; if (damager != null) { senderConn = damager.HealthController.NetworkObject.Owner; } foreach (var conn in NetworkObject.Observers) { if (conn == senderConn) continue; TargetSimulateHitAnimation(conn, damage.hitPosition, damage.hitHeight); } _isKnockBack = Mathf.Approximately(damage.hitHeight, 2f); if (_isKnockBack) { float knockbackDistance = 1f; Vector3 hitDirNormalized = CalculateHitDirection(damage.hitPosition); KnockBack(hitDirNormalized, knockbackDistance); } } } } public void KnockBack(Vector3 dirNorm, float distance) { StartCoroutine(KnockBackCor(dirNorm, distance)); } private IEnumerator KnockBackCor(Vector3 dirNorm, float distance) { _astarAI.Stop(); for (float t = 0; t < distance; t += Time.deltaTime) { _astarAI.AI.Move(dirNorm * Time.deltaTime / (t + 0.1f)); yield return null; } _astarAI.Resume(); } private IEnumerator GetHitUpdater(float timeout) { _isAbleToGetHit = false; _astarAI.Stop(); _isPaused = true; yield return new WaitForSeconds(timeout); _isPaused = false; _astarAI.Resume(); float randomTime = Random.Range(4f, 6f); yield return new WaitForSeconds(randomTime); _isAbleToGetHit = true; } private Vector3 _hitPosition; public Vector3 CalculateHitDirection(Vector3 hitPosition) { _hitPosition = hitPosition; Vector3 headPos = ThisUnitComponents.AttachmentPoints.GetAttachmentPoint(AttachmentPoints.Point.Head).position; return -(hitPosition - headPos).normalized; } private void DrawHitPositionArrow() { Vector3 headPos = ThisUnitComponents.AttachmentPoints.GetAttachmentPoint(AttachmentPoints.Point.Head).position; Vector3 hitPosition = _hitPosition; Vector3 direction = CalculateHitDirection(hitPosition); Gizmos.color = Color.red; // Set color of the arrow // Draw arrow float arrowSize = 1.0f; // Adjust arrow size as needed Gizmos.DrawRay(headPos, direction * arrowSize); Gizmos.DrawRay(headPos + direction * arrowSize, Quaternion.Euler(0, 160, 0) * direction * 0.5f); Gizmos.DrawRay(headPos + direction * arrowSize, Quaternion.Euler(0, -160, 0) * direction * 0.5f); } /// <summary> /// Plays only for local player and if damage dealer is local player /// </summary> /// <param name=\"damage\"></param> [Client] public void GetHitBehaviour(vDamage damage) { Flash(Color.white, 0.1f, 0f, true, null); if (IsAbleToGetHit) { InternalSimulateHitAnimation(damage.hitPosition, damage.hitHeight); } } [TargetRpc] private void TargetSimulateHitAnimation(NetworkConnection conn, Vector3 hitPos, float force) { InternalSimulateHitAnimation(hitPos, force); } [Client] public void InternalSimulateHitAnimation(Vector3 hitPos, float force) { if (isPlayAnimationsHit) { HitDirection hitDir = GetHitPosition(hitPos); GetHit(hitDir, force); } else { Vector3 hitDirNormalized = CalculateHitDirection(hitPos); headEffectorMovement.DoHitEffect(hitDirNormalized, force); } } private HitDirection GetHitPosition(Vector3 damageHitPosition) { // Calculate the relative position of the damage source Vector3 relativePosition = transform.InverseTransformPoint(damageHitPosition); // Determine the direction of the hit based on the relative position if (relativePosition.x > 0) { return HitDirection.Right; } else if (relativePosition.x < 0) { return HitDirection.Left; } else if (relativePosition.y > 0) { return HitDirection.Front; } else { return HitDirection.Back; } } private void GetHit(HitDirection direction, float hitHeight) { _animatorDecorator.SetFloat(_animIDHitId, (float)direction); _animatorDecorator.SetFloat(\"HitHeight\", hitHeight); _animatorDecorator.SetTriggerNonSync(_animIDHit); } private float GetHitAnimationLen(HitDirection direction, float hitHeight) { AnimationClip animation = null; foreach (var hitClips in EnemyDefinition.hitAnimations) { if (hitClips.hitDir != direction) continue; if (!Mathf.Approximately(hitClips.hitHeight, hitHeight)) { continue; } animation = hitClips.clip; break; } if (animation == null && EnemyDefinition.hitAnimations.Length > 0) { animation = EnemyDefinition.hitAnimations[0].clip; } float timeout = 1f; if (animation != null) { timeout = animation.length; Debug.Log( $\"[AIUnit][GetHit]: {gameObject.name} dir: {direction}; height: {hitHeight}; hit animation: {animation.name}\"); } return timeout; } [Server] public void PauseTimed(float time) { StartCoroutine(CorPauseCreatureTimed(time)); } private IEnumerator CorPauseCreatureTimed(float time) { _isPaused = true; yield return new WaitForSeconds(time); _isPaused = false; } private Coroutine _attackCDRoutine; private void PutAttackOnCooldown(float mod = 0f) { if (_attackCDRoutine != null) StopCoroutine(_attackCDRoutine); _attackCDRoutine = StartCoroutine(StartAttackCooldown(mod)); } [Server] public void Attack() { CombatEnter(); InstantLookAtTarget(); if (_isAttackOnCooldown) return; if (_attackAnimationTimes.Length == 0) { DebugWrite.LogError($\"[{gameObject.name}] No attack animations times found\", gameObject, _isDebug); return; } PutAttackOnCooldown(); int randomAttack = Random.Range(0, _attackAnimationTimes.Length); StartAttackFinisherTimer(_attackAnimationTimes[randomAttack]); // #if UNITY_EDITOR // _animatorDecorator.SetInteger(_animIDAttack, randomAttack); // _animatorDecorator.SetBoolTimed(_animIDIsAttacking, true, _attackAnimationTimes[randomAttack]); // #endif ObserverPlayAttackAnimation(randomAttack); PlayAttackSound(); //ObserverPlayAttackAnimation(); DebugWrite.Log($\"[{gameObject.name}] Attack\", gameObject, _isDebug); Transform targetPlayer = _behaviorTree.GetVariable(\"Target\").GetValue() as Transform; if (!_isDamageByMeleeManager) StartCoroutine(DoDamageToPlayer(targetPlayer)); } [Server] private void SmoothLookAtTarget() { if (!IsHaveTarget) { _aiPath.enableRotation = true; return; } _aiPath.enableRotation = false; Vector3 targetPos = GameplayManager.Instance.PlayerPositions[_targetObjectId]; // Calculate direction towards the target Vector3 direction = (targetPos - transform.position).normalized; // Calculate the rotation needed to look at the target Quaternion targetRotation = Quaternion.LookRotation(direction); transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, Time.deltaTime * 5f); } [Server] private void InstantLookAtTarget() { if (_targetObjectId > 0) { Vector3 targetPos = GameplayManager.Instance.PlayerPositions[_targetObjectId]; transform.LookAt(targetPos); } } private IEnumerator StartAttackCooldown(float mod = 0f) { _isAttackOnCooldown = true; Debug.Log($\"[AIUnit][StartAttackCooldown]: Start attack cooldown. _isAttackOnCooldown: {_isAttackOnCooldown}. Waiting for {EnemyDefinition.AttackCooldown + mod} seconds\", gameObject); yield return new WaitForSeconds(EnemyDefinition.AttackCooldown + mod); _isAttackOnCooldown = false; Debug.Log($\"[AIUnit][StartAttackCooldown]: End attack cooldown. _isAttackOnCooldown: {_isAttackOnCooldown}\", gameObject); } private void StartAttackFinisherTimer(float time) { if (_attackAnimationTimer == null) _attackAnimationTimer = StartCoroutine(CorStartAttackFinisherTimer(time)); } internal IEnumerator CorStartAttackFinisherTimer(float time) { _isPlayingAttackAnimation = true; DebugWrite.Log($\"[AIUnit][CorStartAttackFinisherTimer]: Start attack finisher timer. _isPlayingAttackAnimation: {_isPlayingAttackAnimation}\", gameObject, _isDebug); yield return new WaitForSeconds(time); _isPlayingAttackAnimation = false; DebugWrite.Log($\"[AIUnit][CorStartAttackFinisherTimer]: Finish attack finisher timer. _isPlayingAttackAnimation: {_isPlayingAttackAnimation}\", gameObject, _isDebug); _attackAnimationTimer = null; } [ObserversRpc] private void ObserverPlayAttackAnimation(int attackId) { _animatorDecorator.SetInteger(_animIDAttack, attackId); _animatorDecorator.SetBoolTimed(_animIDIsAttacking, true, _attackAnimationTimes[attackId]); if (isPlayIndicator) StatusIndicatorManager.InitCone(transform, _definition.AttackDistance + .1f, _swingStretchTime); // int attackId = Random.Range(0, 3); // if (attackId == 2) { // _animatorDecorator.SetFloat(_animIDAttack, .333333f); // } else if (attackId == 3) { // _animatorDecorator.SetFloat(_animIDAttack, .6666667f); // } else { // _animatorDecorator.SetFloat(_animIDAttack, attackId); // } // _animatorDecorator.SetTrigger(_animIDDoAttack); } /// <summary> /// https://excalidraw.com/#room=abaeb99a6c827f1171bf,CU_iVmew9QkKv7biuYwlCA /// </summary> [Server] private IEnumerator DoDamageToPlayer(Transform player) { var playerFIM = GetFim(player); bool isPlayerDead = playerFIM.FishnetInvectorHealthController.IsDead; if (isPlayerDead) { yield break; } yield return new WaitForSeconds(.5f); vDamage damage = new vDamage(); damage.damageValue = (int)Damage; damage.hitPosition = player.transform.position; damage.Sender = transform; damage.IsShowDamage = false; playerFIM.FishnetInvectorHealthController.TakeDamage(damage); DebugWrite.Log($\"[ZombieUnit][DoDamageToPlayer] {gameObject.name}->{player.name}(dead: {playerFIM.FishnetInvectorHealthController.IsDead}) playerFIM: {(bool)playerFIM}\", gameObject); } public static FishnetInvectorManager GetFim(Transform target) { if (!_fishnetManagers.ContainsKey(target)) { var targetsFim = target.GetComponent<FishnetInvectorManager>(); if (targetsFim == null) { targetsFim = target.GetComponentInParent<FishnetInvectorManager>(); DebugWrite.LogError($\"[ZombieUnit][GetFim] has no fim remove 'Player' tag from {target.name} \"); } _fishnetManagers.Add(target, targetsFim); DebugWrite.Log($\"[ZombieUnit][GetFim] add {target.name} to _fishnetManagers\"); } return _fishnetManagers[target]; } public List<FishnetInvectorManager> GetAllPlayers() { List<NetworkObject> allPlayers = GameplayManager.Instance.GetAllPlayersHeroes(); var possibleTargets = new List<FishnetInvectorManager>(); foreach (var unit in allPlayers) { var playerFim = GetFim(unit.transform); possibleTargets.Add(playerFim); } return possibleTargets; } /// <summary> /// Draws the line of sight representation /// </summary> public void OnDrawGizmos() { #if UNITY_EDITOR //DrawHitPositionArrow(); //Draws Cone of AI vision DebugDrawVisionCone(); DebugDrawAttackDistanceCircle(); #endif } private void DebugDrawAttackDistanceCircle() { #if UNITY_EDITOR var oldColor = Handles.color; var color = new Color(1.0f, 0.0f, 0.0f, .1f); color.a = 0.1f; Handles.color = color; var normalizedDirection = transform.up; var radius = EnemyDefinition.AttackDistance; Handles.DrawSolidDisc(transform.position, normalizedDirection, radius); Handles.color = oldColor; #endif } private void DebugDrawVisionCone() { #if UNITY_EDITOR if (EnemyDefinition == null) return; var oldColor = Handles.color; var color = new Color(1.0f, 1.0f, 0.0f, .1f); color.a = 0.1f; Handles.color = color; var halfFOV = EnemyDefinition.FieldOfView * 0.5f; var centerDirection = transform.forward; var beginDirection = Quaternion.AngleAxis(-halfFOV, Vector3.up) * centerDirection; var normalizedDirection = transform.up; var radius = EnemyDefinition.ViewDistance; Handles.DrawSolidArc(transform.position, normalizedDirection, beginDirection, EnemyDefinition.FieldOfView, radius); Handles.color = oldColor; #endif } public int SearchForEnemyInRadius(out bool isFound) { return GetNearestEnemy(out isFound); } [Server] public int GetNearestEnemy(out bool isFound, float maxDistance = 200f) { maxDistance = 10f * 10f; int targetObjectId = -1; isFound = false; foreach (var kv in GameplayManager.Instance.PlayerPositions) { var position = kv.Value; var squaredDistance = Vector3.SqrMagnitude(position - transform.position); if (squaredDistance < maxDistance) { var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(kv.Key); if (unitComps.HealthController.IsDead) continue; maxDistance = squaredDistance; isFound = true; targetObjectId = kv.Key; } } if (isFound) { return targetObjectId; } //DebugWrite.LogError($\"[ZombieUnit][GetNearestEnemy] no target found\"); return -1; } public int GetTargetId() { return _targetObjectId; } public void ClearTarget() { _targetObjectId = -1; } public bool IsTargetWithinAttackDistance() { if (_targetObjectId < 0) { return false; } if (CommonMath.Math.IsWithinRange(GetTargetTransform().position, transform.position, EnemyDefinition.AttackDistance)) { return true; } return false; } public void UpdateTarget(int newTargetId) { var playerComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(newTargetId); if (playerComps.HealthController.IsAI) return; _targetObjectId = newTargetId; } private void OnTargetChanged(int prev, int next, bool asServer) { if (asServer) return; var targetUnitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(next); if (targetUnitComps == null) return; var targetHead = targetUnitComps.AttachmentPoints.GetAttachmentPoint(AttachmentPoints.Point.Head); if (targetHead == null) return; UpdateHeadLookingTarget(targetHead); } [Client] private void UpdateHeadLookingTarget(Transform target) { if (!_isDoHeadFollow) return; headAimIK.solver.target = target; } private void OnTick() { if (IsDead) return; if (IsHaveTarget) return; Buff.BuffData unit = new Buff.BuffData(ObjectId, gameObject.tag); List<FishnetInvectorHealthController> targetsInRadius = Ability.EnemyTargetsInRadius(transform.position, unit, EnemyDefinition.ViewDistance); foreach (var tempTarget in targetsInRadius) { if (IsTagetWithinViewCone(tempTarget.transform)) { CmdAddTargetToWithinSight(tempTarget.NetworkObject.ObjectId); } else { CmdRemoveTargetFromWithinSight(tempTarget.NetworkObject.ObjectId); } } } private bool IsTagetWithinViewCone(Transform target) { var fov = EnemyDefinition.FieldOfView; Vector3 directionToTarget = (target.position - transform.position).normalized; float angleToTarget = Vector3.Angle(transform.forward, directionToTarget); // Check if the angle to the target is within the field of view if (angleToTarget <= fov / 2f) { // Now, we need to check if there's any obstacle between the enemy and the target RaycastHit hit; if (Physics.Raycast(transform.position, directionToTarget, out hit)) { // Assuming you have defined tags for obstacles if (hit.collider.CompareTag(\"Untagged\")) { // There's an obstacle between the enemy and the target return false; } } // No obstacles and target is within the field of view return true; } // Target is outside the field of view return false; } [ServerRpc(RequireOwnership = false)] public void CmdAddTargetToWithinSight(int targetId) { DebugWrite.Log($\"[AIUnit][CmdAddTargetToWithinSight] {gameObject.name} add {targetId} to _playersWithinSight\", gameObject, _isDebug); if (PlayersWithinSight.Contains(targetId)) return; _playersWithinSight.Add(targetId); } [ServerRpc(RequireOwnership = false)] public void CmdRemoveTargetFromWithinSight(int targetId) { DebugWrite.Log($\"[ZombieUnit][CmdRemoveTargetFromWithinSight] {gameObject.name} remove {targetId} from _playersWithinSight\", gameObject, _isDebug); _lastTargetPosition = GameplayManager.Instance.PlayerPositions[targetId]; _playersWithinSight.Remove(targetId); ClearTarget(); } public Transform GetTargetTransform() { return GameplayManager.Instance.GetTargetTransformServerAndClient(_targetObjectId); } public void SetHeadTransform(Transform head) { _head = head; } [Server] public void OrderToFly() { if (CurrentState == AIState.Flying) return; if (CurrentState == AIState.Landed) { SetState(AIState.TakingOff); } } [Server] public void SetState(AIState nextState) { if (nextState == AIState.Flying) { AnimatorDecorator.SetBool(_animIDIsFlying, true); OnStateFlying?.Invoke(); }else if (nextState == AIState.TakingOff) { _groundedY = transform.position.y; _aiPath.enabled = false; TargetsPlayTakeOffAnimation(); StartCoroutine(DelayedMoveY(.26f, _groundedY + 6f)); }else if (nextState == AIState.Landing) { if (CurrentState == AIState.Flying) { TargetsPlayLandingAnimation(); _aiPath.enabled = true; //DoTween set x and z rotation to 0 transform.DORotate(new Vector3(0f, transform.rotation.eulerAngles.y, 0f), _landingTime*.5f); transform.DOMoveY(_groundedY + 0.1f, _landingTime*.8f).SetEase(Ease.InCubic).OnComplete(() => FinishLanding()); } } else if (nextState == AIState.Landed) { OnStateLanded?.Invoke(); } CurrentState = nextState; } private IEnumerator DelayedMoveY(float delay, float y) { yield return new WaitForSeconds(delay); transform.DOMoveY(y, _takeOffTime *.8f).SetEase(Ease.OutCubic).OnComplete(() => SetState(AIState.Flying)); } private void FinishLanding() { SetState(AIState.Landed); AnimatorDecorator.SetBool(_animIDIsFlying, false); } [ObserversRpc] private void TargetsPlayTakeOffAnimation() => StartCoroutine(CorPlayTakeOffAnimation()); [Client] private IEnumerator CorPlayTakeOffAnimation() { AnimatorDecorator.SetBool(_animIDIsFlying, true); _animatorDecorator.SetBool(_animIDTakeOff, true); yield return new WaitForSeconds(_takeOffTime*.8f); _animatorDecorator.SetBool(_animIDTakeOff, false); } [ObserversRpc] private void TargetsPlayLandingAnimation() => StartCoroutine(CorPlayLandingAnimation()); [Client] private IEnumerator CorPlayLandingAnimation() { AnimatorDecorator.SetBool(_animIDIsFlying, true); _animatorDecorator.SetBool(_animIDDoLanding, true); yield return new WaitForSeconds(_landingTime*.8f); AnimatorDecorator.SetBool(_animIDIsFlying, false); _animatorDecorator.SetBool(_animIDDoLanding, false); } private void SetupAnimationTimes() { if (EnemyDefinition.AnimationTakeOff != null) { _takeOffTime = EnemyDefinition.AnimationTakeOff.length; _landingTime = EnemyDefinition.AnimationLanding.length; } } public void StoreRendererColors() { Renderer[] renderers = GetComponentsInChildren<Renderer>(); for (int i = 0; i < renderers.Length; i++) { RendererColor rendererColor = new RendererColor(new List<Material>(), new List<Color>()); foreach (Material mat in renderers[i].materials) { rendererColor.OriginalTexture.Add(mat.mainTexture); rendererColor.Material.Add(mat); rendererColor.Colors.Add(mat.color); } if (rendererColor.Material.Count > 0) { this.rendererColor.Add(rendererColor); } Debug.Log($\"[Unit] StoreRendererColors {rendererColor.Material.Count}\"); } } public void Flash(Color toColor, float duration, float delay, bool ignoreTimeScale, Action onComplete) { Debug.Log($\"[Unit] Flash {rendererColor.Count}\"); StartCoroutine(CorFlash(toColor, duration, delay, ignoreTimeScale, onComplete)); } public IEnumerator CorFlash(Color toColor, float duration, float delay, bool ignoreTimeScale, Action onComplete) { yield return new WaitForSeconds(delay); SwapTexture(toColor); float time = 0f; while (time < duration) { time += ignoreTimeScale ? Time.unscaledDeltaTime : Time.deltaTime; yield return null; } RevertTextureBack(); onComplete?.Invoke(); } private void SwapTexture(Color toColor) { foreach (RendererColor rColor in rendererColor) { for (int i = 0; i < rColor.Material.Count; i++) { rColor.Material[i].mainTexture = textureToBlink; rColor.Material[i].color = toColor; //Debug.Log($\"[Unit] CorFlash {rColor.Material[i].mainTexture}\"); } } } private void RevertTextureBack() { foreach (RendererColor rColor in rendererColor) { for (int i = 0; i < rColor.Material.Count; i++) { rColor.Material[i].mainTexture = rColor.OriginalTexture[i]; rColor.Material[i].color = rColor.Colors[i]; } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AIUnit",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "using System; using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DG.Tweening; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using FishnetInvector; using Invector; using Pathfinding; using UnityEditor; using UnityEngine; using UnityEngine.Events; using Zomb.Creatures.Helpers; using Random = UnityEngine.Random; [RequireComponent(typeof(BehavioursSwitcher))] public class AIUnit : Unit { public struct BattleInfo { private List<float> time; private List<float> damageDealt; public BattleInfo(byte size = 0) { this.time = new List<float>(); this.damageDealt = new List<float>();  ",
          "content_tokens": 209,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "public void Add( float time, float damageDealt ) { this.time.Add( time ); this.damageDealt.Add( damageDealt );  ",
          "content_tokens": 35,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "public float GetAllCurrentPlayerDealtDamage() { float totalDamage = 0; foreach( float damage in damageDealt ) { totalDamage += damage; } return totalDamage; } } public enum AIState { Idle, Wander, Chase, Attack, Dead, TakingOff, Landing, Flying, Landed } #region Publics public ushort SpawnPointId { set { _spawnPointId = value; } get { return _spawnPointId; } } public AnimatorDecorator AnimatorDecorator => _animatorDecorator; public float Damage { get { var baseStr = _definition.Strength; float bonusStr = (float)_statsController.GetAllCurrentValue(Stat.STAT_TYPE.STRENGTH); float result = baseStr + bonusStr; return result; } } public List<SkinnedMeshRenderer> AIMeshes => _aiMeshes; public bool IsDebug => _isDebug; public float Accuracy => 80f; public bool IsInCombat => _isInCombat; public bool IsAttackOnCooldown => _isAttackOnCooldown; public bool IsDead => HealthController.IsDead; public ZombieEars ZombieEars => _zombieEars; public EnemyDefinition EnemyDefinition => _definition; public float ViewDistance => _definition.ViewDistance; public UnityAction<AIUnit> OnHideCreature; private string RoomNameHoldingMe => _roomNameHoldingMe; public bool IsAware => _isAware; public Vector3 LastTargetPosition => _lastTargetPosition; public float TimeInCombat => _timeInCombat; private Vector3 _lastTargetPosition = Vector3.zero; public AstarAI AstarAINavigation => _astarAI; #endregion #region Animation IDs public int AnimIDIsInCombat => _animIDIsInCombat; public int AnimIDIsMoving => _animIDIsMoving; private static int _animIDSpeed; private static int _animIDAttack; private static int _animIDGrounded; private static int _animIDJump; private static int _animIDFire; private static int _animIDReload; private static int _animIDFreeFall; private static int _animIDHorizontal; private static int _animIDVertical; private static int _animIDAim; private static int _animIDHorAngle; private static int _animIDVerAngle; private static int _animIDIsMoving; private static int _animIDIsDead; private static int _animIDIsAttacking; private static float _canMoveAt; private static float _canActAt; private static float _canWanderAt; private static bool _isWanderState; private static int _animIDIsInCombat; private static int _animIDDoAttack; private static int _animIDStunned; private static int _animIDHit; private static int _animIDHitId; private static int _animIDTakeOff; private static int _animIDIsFlying; private static int _animIDIsFalling; private static int _animIDDoFrozenBreath; private static int _animIDDoLanding; private static int _animGotHit; #endregion #region Privates private static float TIME_TO_EXIT_AWARENESS = 10f; [SerializeField] private AnimatorDecorator _animatorDecorator; [SerializeField] private ZombieEars _zombieEars; [SerializeField] private BehaviorDesigner.Runtime.BehaviorTree _behaviorTree; [SerializeField] private EnemyMoanAudio _moanAudio; [SerializeField] private AstarAI _astarAI; [SerializeField] private List<SkinnedMeshRenderer> _aiMeshes; [SerializeField] private FNvMeleeManager _meleeManager; [SerializeField] private EnemyDefinition _definition; [SerializeField] private bool _isDamageByMeleeManager; [SerializeField] private HeadEffectorMovement headEffectorMovement; [SerializeField] private bool isPlayAnimationsHit; [SerializeField] private bool isPlayIndicator; [field:SerializeField] public List<RendererColor> rendererColor { get; protected set; } [field:SerializeField] public Texture textureToBlink { get; protected set; } private AIPath _aiPath; private ushort _creatureType; private ushort _spawnPointId; private Vector3 _spawnPosition; private bool _goingToSpawn; private int HitAudioChance; private Dictionary<int, BattleInfo> _battleInfo = new Dictionary<int, BattleInfo>(); private float _lifeTime; private static Dictionary<Transform, FishnetInvectorManager> _fishnetManagers = new Dictionary<Transform, FishnetInvectorManager>(); private bool _isInCombat; private Coroutine _combatTimer; private float _timeInCombat = 0; private string _roomNameHoldingMe; private FNvRagdoll _ragdoll; [SyncVar] private Vector3 _birdthPosition; [SyncVar] private Vector3 _currentServerPosition; public bool IsAbleToGetHit => _isAbleToGetHit; [SyncVar] private bool _isAbleToGetHit = true; private bool _isKnockBack = true; private float _currentSpeedRaw; [SerializeField] private float[] _attackAnimationTimes; private CharacterController _characterController; private bool _isAware; private Coroutine _awarenessCoroutine; private static WaitForSeconds _awarenessTimeWait = new WaitForSeconds(TIME_TO_EXIT_AWARENESS); private bool _isStunned; private bool _isFlying; public enum HitDirection { Front, Right, Left, Back} public bool IsHaveTarget { get { if (_targetObjectId > -1) return true; return false; } } [SerializeField, SyncVar(OnChange = nameof(OnTargetChanged))] private int _targetObjectId; public SyncHashSet<int> PlayersWithinSight => _playersWithinSight; [SyncObject] private readonly SyncHashSet<int> _playersWithinSight = new SyncHashSet<int>(); private const string STRING_HEAD_TRANSFORM_NAME = \"Head\"; public Transform Head => _head; [SerializeField] private Transform _head; [SerializeField] private bool _isDebug; private bool _isAttackOnCooldown; private bool[] _isHealthPercentLeft = new bool[10]; public bool IsPaused => _isPaused; private bool _isPaused; public bool IsPlayingAttackAnimation => _isPlayingAttackAnimation; private bool _isPlayingAttackAnimation; private Coroutine _attackAnimationTimer; [SerializeField] private float _swingStretchTime; [field: SerializeField] public AIState CurrentState { get; private set; } = AIState.Landed; public Action OnStateFlying; public Action OnStateLanded; private float _takeOffTime; private float _landingTime; private float _groundedY; public UnitComponents ThisUnitComponents { get { if (_unitComponents == null) { _unitComponents = GameplayManager.Instance.GetUnitComponentsServerAndClient(NetworkObject.ObjectId); } return _unitComponents; } } private UnitComponents _unitComponents; #endregion protected override void Awake() { base.Awake(); StoreComponents(); _ragdoll = GetComponentInChildren(typeof(FNvRagdoll)) as FNvRagdoll; AssignAnimationIDs(); _playersWithinSight.OnChange += _playersWithinSight_OnChange; SetupAnimationTimes(); } protected override void OnValidate() { base.OnValidate(); headEffectorMovement ??= GetComponentInChildren<HeadEffectorMovement>(); StoreComponents();  ",
          "content_tokens": 1699,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "public void StoreComponents() { if (_animatorDecorator == null) _animatorDecorator = GetComponent<AnimatorDecorator>(); if (_zombieEars == null) _zombieEars = GetComponent<ZombieEars>(); if (_behaviorTree == null) _behaviorTree = GetComponent<BehaviorDesigner.Runtime.BehaviorTree>(); if (_moanAudio == null) _moanAudio = GetComponent<EnemyMoanAudio>(); if (_statsController == null) _statsController = GetComponent<FNStatsController>(); if (_astarAI == null) _astarAI = GetComponent<AstarAI>(); if (_meleeManager == null) _meleeManager = GetComponentInChildren<FNvMeleeManager>(); if (_characterController == null) _characterController = GetComponent<CharacterController>(); if (_aiPath == null) _aiPath = GetComponent<AIPath>(); if (_aiPath == null) _aiPath = GetComponent<AIPath>(); if (_aiMeshes.Count == 0) _aiMeshes = GetComponentsInChildren<SkinnedMeshRenderer>().vToList(); } public override void OnStartNetwork() { base.OnStartNetwork(); if (base.IsHost) { _meleeManager.SetAsHost();  ",
          "content_tokens": 297,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "if (base.IsHost || base.IsServerOnly) {//Server _birdthPosition = transform.position; _astarAI.ServerInit(this, _animatorDecorator); _statsController.InitForAI(this); GameplayManager.Instance.SaveNpcToRoom(NetworkObject); } else {//Client if (_head == null) { foreach (Transform child in transform) { if (child.name == STRING_HEAD_TRANSFORM_NAME) { _head = child; break; } }  if (!_head) { DebugWrite.LogError($\"[ZombieUnit] No head found for {gameObject.name}\"); } _moanAudio.Init(); DebugWrite.Log($\"[AIUnit] OnStartNetwork: {gameObject.name} _moanAudio.Init\", gameObject, _isDebug);  ",
          "content_tokens": 187,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "SetName(); } public override void OnStartServer() { base.OnStartServer(); SubscribeToEvents(true); CombatLeave(); _meleeManager.SetAsServerOwned(); _meleeManager.Initialize(GameplayManager.Instance); _meleeManager.SetAsOwner(); _meleeManager.SetAIDamage(Damage); SetupHealth(); } public override void OnStartClient() { base.OnStartClient(); _meleeManager.Initialize(GameplayManager.LocalPlayer); StoreRendererColors(); } public override void OnStopNetwork() { base.OnStopNetwork(); if (base.IsHost || base.IsServerOnly) {//Server SubscribeToEvents(false); }  private void Update() { if (base.IsServer) { _currentServerPosition = transform.position; //InstantLookAtTarget(); SmoothLookAtTarget(); }  ",
          "content_tokens": 187,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void SetupHealth() { var healData = new FishnetInvectorHealthController.HealData(); healData.amount = EnemyDefinition.MaxHealth; HealthController.SetHealth(FishnetInvectorHealthController.HealthType.Max, healData); HealthController.SetHealth(FishnetInvectorHealthController.HealthType.Current, healData);  ",
          "content_tokens": 77,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void AssignAnimationIDs() { _animIDSpeed = Animator.StringToHash(\"Speed\"); _animIDGrounded = Animator.StringToHash(\"Grounded\"); _animIDJump = Animator.StringToHash(\"Jump\"); _animIDFire = Animator.StringToHash(\"Fire\"); _animIDReload = Animator.StringToHash(\"Reload\"); _animIDFreeFall = Animator.StringToHash(\"FreeFall\"); _animIDHorizontal = Animator.StringToHash(\"Horizontal\"); _animIDVertical = Animator.StringToHash(\"Vertical\"); _animIDAim = Animator.StringToHash(\"Aim\"); _animIDHorAngle = Animator.StringToHash(\"HorAimAngle\"); _animIDVerAngle = Animator.StringToHash(\"VerAimAngle\"); _animIDIsMoving = Animator.StringToHash(\"IsMoving\"); _animIDIsAttacking = Animator.StringToHash(\"IsAttacking\"); _animIDIsDead = Animator.StringToHash(\"IsDead\"); _animIDIsInCombat = Animator.StringToHash(\"IsInCombat\"); _animIDDoAttack = Animator.StringToHash(\"DoAttack\"); _animIDAttack = Animator.StringToHash(\"AttackId\"); _animIDStunned = Animator.StringToHash(\"IsStunned\"); _animIDHit = Animator.StringToHash(\"DoHit\"); _animGotHit = Animator.StringToHash(\"GotHit\"); _animIDHitId = Animator.StringToHash(\"HitId\"); _animIDTakeOff = Animator.StringToHash(\"IsTakingOff\"); _animIDIsFlying = Animator.StringToHash(\"IsFlying\"); _animIDDoFrozenBreath = Animator.StringToHash(\"DoFrozenBreath\"); _animIDDoLanding = Animator.StringToHash(\"IsLanding\"); _animIDIsFalling = Animator.StringToHash(\"IsFalling\");  ",
          "content_tokens": 439,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void SetName() => gameObject.name = $\"{_definition.Name} #{ObjectId}\"; [Server] private void SubscribeToEvents(bool subscribe) { if (subscribe) { HealthController.OnDead += OnDead_healthController; HealthController.OnTakeDamage += OnDamageTaken_BehaviourNotifier; _zombieEars.OnHeardSomething += OnHeardSound_Handler; _astarAI.OnStopMove.AddListener(() => _animatorDecorator.SetBool(_animIDIsMoving, false)); _astarAI.OnStartMove.AddListener(StartMoving); var stat = _statsController.GetStatByType(Stat.STAT_TYPE.MOVEMENT_SPEED); stat.OnStatChanged += OnSpeedChanged; InstanceFinder.TimeManager.OnTick += OnTick; } else { HealthController.OnDead -= OnDead_healthController; HealthController.OnTakeDamage -= OnDamageTaken_BehaviourNotifier; _zombieEars.OnHeardSomething -= OnHeardSound_Handler; _astarAI.OnStopMove.RemoveAllListeners(); _astarAI.OnStartMove.RemoveAllListeners(); var stat = _statsController.GetStatByType(Stat.STAT_TYPE.MOVEMENT_SPEED); stat.OnStatChanged -= OnSpeedChanged; InstanceFinder.TimeManager.OnTick -= OnTick; }  ",
          "content_tokens": 321,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void StartMoving() { if (IsPlayingAttackAnimation) return; _animatorDecorator.SetBool(_animIDIsMoving, true);  ",
          "content_tokens": 35,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void OnHeardSound_Handler(Vector3 pos) { //Vector3 navMeshPos = NavMeshesUtil.GetSpawnablePointAt(pos.x, pos.z); //_behaviorTree.SendEvent<object>(\"OnUnitHeardSound\", navMeshPos); CombatEnter(); } [Server] private void OnDead_healthController(vDamage damage) { //DebugWrite.Log($\"{gameObject.name} died\"); _animatorDecorator.SetBool(_animIDIsMoving, false); _behaviorTree.SendEvent(\"OnUnitDied\"); CombatLeave(); SwitchBehaviour(false); ClearBattleInfo(); BossDeath(); SpawnHealSphere(); GameplayManager.Instance.DropLootBag(this); if (EnemyDefinition.DeadBodyPrefab != null) { SpawnDeadBody(); Despawn(); //GameplayManager.Instance.CreaturesFactory.DeallocateCreature(this); } else { _animatorDecorator.SetBool(_animIDIsDead, true); } } [Server] private DeadBody SpawnDeadBody() { DebugWrite.Log($\"[AIUnit] SpawnDeadBody {gameObject.name}\"); DeadBody body = Instantiate(EnemyDefinition.DeadBodyPrefab, transform.position, transform.rotation); body.Init(GameplayManager.Instance, AnimatorDecorator); Spawn(body.gameObject); return body; } [Server] private void SpawnHealSphere() { if (EnemyDefinition.EnemyType != EnemyDefinition.Type.Boss) { float random = Random.Range(0f, 1f); if (random < 0.5f) GameplayManager.Instance.SpawnHealSphere(transform.position); } } [Server] private void BossDeath() { if (EnemyDefinition.EnemyType == EnemyDefinition.Type.Boss) { GameplayManager.Instance.SpawnEscapePortal(transform.position); } } [Server] public void Revive() { SwitchBehaviour(true); if (base.IsClient) { _moanAudio.Init(); _ragdoll.TurnOffRagdoll(); HealthController.TurnOnColliders(); } } [Server] private void SwitchBehaviour(bool isOn) { if (isOn) { HealthController.ResetHealth(); _animatorDecorator.SetBool(_animIDIsDead, false); _lifeTime = 0f; }else { _astarAI.Stop(); } _astarAI.enabled = isOn; //_fieldOfViewController.enabled = isOn; SubscribeToEvents(isOn); } [Server] private void OnSpeedChanged(float newSpeedModValue) { float newSpeed = _currentSpeedRaw * newSpeedModValue; _astarAI.SetSpeed(newSpeed);  ",
          "content_tokens": 608,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void _playersWithinSight_OnChange(SyncHashSetOperation op, int item, bool asServer) { switch (op) { case SyncHashSetOperation.Add: break; case SyncHashSetOperation.Remove: break; case SyncHashSetOperation.Clear: break; case SyncHashSetOperation.Update: break; case SyncHashSetOperation.Complete: break; } } [Server] public void UpdateSpeed(float maxSpeed) { _currentSpeedRaw = maxSpeed; float movementSpeedStat = (float)_statsController.GetAllCurrentValue(Stat.STAT_TYPE.MOVEMENT_SPEED); float newSpeed = movementSpeedStat * maxSpeed; _astarAI.SetSpeed(newSpeed); } [Server] public void CombatEnter() { _isInCombat = true; _isAware = true; if (_combatTimer == null) { _combatTimer = StartCoroutine(CombatTimer()); } //DebugWrite.Log($\"[AIUnit][CorRestartAwareness]: {gameObject} _isAware {_isAware}\"); UpdateSpeed(_definition.RunSpeed); _animatorDecorator.SetBool(_animIDIsInCombat, true); //_animatorDecorator.SetFloat(_animIDSpeed, 1f); } [Server] public void CombatLeave() { _isInCombat = false; if (_combatTimer != null) StopCoroutine(_combatTimer); _timeInCombat = 0f; UpdateSpeed(_definition.MoveSpeed); _animatorDecorator.SetBool(_animIDIsInCombat, false); _animatorDecorator.SetFloat(_animIDSpeed, 0f); RestartAwareness(); } private IEnumerator CombatTimer() { var time = new WaitForSeconds(1f); while (_isInCombat) { yield return time; _timeInCombat += 1f; } } [Server] private void RestartAwareness() { if (_awarenessCoroutine != null) StopCoroutine(_awarenessCoroutine); _awarenessCoroutine = StartCoroutine(CorRestartAwareness()); } [Server] private IEnumerator CorRestartAwareness() { yield return _awarenessTimeWait; _isAware = false; DebugWrite.Log($\"[ZombieUnit][CorRestartAwareness]: _isAware {_isAware}\", gameObject, _isDebug); } // Battle info management private void AddDamageReceivedInfo(int objectId, float amount) { if (_battleInfo.TryAdd(objectId, new BattleInfo())) { _battleInfo[objectId].Add(_lifeTime, amount); } else { _battleInfo[objectId].Add(_lifeTime, amount); }  ",
          "content_tokens": 590,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void ClearBattleInfo() { _battleInfo.Clear();  private void OnDamageTaken_BehaviourNotifier(vDamage damage) { CombatEnter(); if (_currentSpeedRaw > float.Epsilon) { int targetId = damage.senderNetworkObjectID; DebugWrite.Log($\"[ZombieUnit][OnDamageTaken_Handler]: object #{targetId}\", gameObject, _isDebug); _behaviorTree.SendEvent<object>(\"OnUnitTakeDamage\", targetId);  ",
          "content_tokens": 110,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "if (HealthController.CurrentHealth >= 0) { float healthLeft = HealthController.CurrentHealth / HealthController.MaxHealth * 10; int healthPercent = Mathf.FloorToInt(healthLeft); for (int i = _isHealthPercentLeft.Length - 1; i >= 0; i--) { if (i == healthPercent - 1) break; if (!_isHealthPercentLeft[i]) { _isHealthPercentLeft[i] = true; //90 - 100% => OnUnitHealthFallTo100Percent //0 - 10% => OnUnitHealthFallTo10Percent _behaviorTree.SendEvent<object>($\"OnUnitHealthDropsBelowPercent\", 10 * (healthPercent + 1)); }  ",
          "content_tokens": 156,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "if (IsAbleToGetHit) { HitDirection hitDir = GetHitPosition(damage.hitPosition); float getHitAnimationTime = GetHitAnimationLen(hitDir, damage.hitHeight) * 1f; float timeout = Random.Range(getHitAnimationTime, getHitAnimationTime * 2f); StartCoroutine(GetHitUpdater(timeout)); PutAttackOnCooldown(getHitAnimationTime); if (IsServer && !IsHost) _animatorDecorator.SetBool(_animIDIsAttacking, false); var damager = GameplayManager.Instance.GetUnitComponentsServerAndClient(damage.senderNetworkObjectID); NetworkConnection senderConn = null; if (damager != null) { senderConn = damager.HealthController.NetworkObject.Owner;  ",
          "content_tokens": 175,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "foreach (var conn in NetworkObject.Observers) { if (conn == senderConn) continue; TargetSimulateHitAnimation(conn, damage.hitPosition, damage.hitHeight); } _isKnockBack = Mathf.Approximately(damage.hitHeight, 2f); if (_isKnockBack) { float knockbackDistance = 1f; Vector3 hitDirNormalized = CalculateHitDirection(damage.hitPosition); KnockBack(hitDirNormalized, knockbackDistance); } } }  ",
          "content_tokens": 113,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "public void KnockBack(Vector3 dirNorm, float distance) { StartCoroutine(KnockBackCor(dirNorm, distance)); } private IEnumerator KnockBackCor(Vector3 dirNorm, float distance) { _astarAI.Stop(); for (float t = 0; t < distance; t += Time.deltaTime) { _astarAI.AI.Move(dirNorm * Time.deltaTime / (t + 0.1f)); yield return null; } _astarAI.Resume(); } private IEnumerator GetHitUpdater(float timeout) { _isAbleToGetHit = false; _astarAI.Stop(); _isPaused = true; yield return new WaitForSeconds(timeout); _isPaused = false; _astarAI.Resume(); float randomTime = Random.Range(4f, 6f); yield return new WaitForSeconds(randomTime); _isAbleToGetHit = true; } private Vector3 _hitPosition; public Vector3 CalculateHitDirection(Vector3 hitPosition) { _hitPosition = hitPosition; Vector3 headPos = ThisUnitComponents.AttachmentPoints.GetAttachmentPoint(AttachmentPoints.Point.Head).position; return -(hitPosition - headPos).normalized;  ",
          "content_tokens": 286,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void DrawHitPositionArrow() { Vector3 headPos = ThisUnitComponents.AttachmentPoints.GetAttachmentPoint(AttachmentPoints.Point.Head).position; Vector3 hitPosition = _hitPosition; Vector3 direction = CalculateHitDirection(hitPosition); Gizmos.color = Color.red; // Set color of the arrow // Draw arrow float arrowSize = 1.0f; // Adjust arrow size as needed Gizmos.DrawRay(headPos, direction * arrowSize); Gizmos.DrawRay(headPos + direction * arrowSize, Quaternion.Euler(0, 160, 0) * direction * 0.5f); Gizmos.DrawRay(headPos + direction * arrowSize, Quaternion.Euler(0, -160, 0) * direction * 0.5f); } /// <summary> /// Plays only for local player and if damage dealer is local player /// </summary> /// <param name=\"damage\"></param> [Client] public void GetHitBehaviour(vDamage damage) { Flash(Color.white, 0.1f, 0f, true, null); if (IsAbleToGetHit) { InternalSimulateHitAnimation(damage.hitPosition, damage.hitHeight); } } [TargetRpc] private void TargetSimulateHitAnimation(NetworkConnection conn, Vector3 hitPos, float force) { InternalSimulateHitAnimation(hitPos, force); } [Client] public void InternalSimulateHitAnimation(Vector3 hitPos, float force) { if (isPlayAnimationsHit) { HitDirection hitDir = GetHitPosition(hitPos); GetHit(hitDir, force); } else { Vector3 hitDirNormalized = CalculateHitDirection(hitPos); headEffectorMovement.DoHitEffect(hitDirNormalized, force); } } private HitDirection GetHitPosition(Vector3 damageHitPosition) { // Calculate the relative position of the damage source Vector3 relativePosition = transform.InverseTransformPoint(damageHitPosition); // Determine the direction of the hit based on the relative position if (relativePosition.x > 0) { return HitDirection.Right; } else if (relativePosition.x < 0) { return HitDirection.Left; } else if (relativePosition.y > 0) { return HitDirection.Front; } else { return HitDirection.Back; }  ",
          "content_tokens": 522,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void GetHit(HitDirection direction, float hitHeight) { _animatorDecorator.SetFloat(_animIDHitId, (float)direction); _animatorDecorator.SetFloat(\"HitHeight\", hitHeight); _animatorDecorator.SetTriggerNonSync(_animIDHit);  private float GetHitAnimationLen(HitDirection direction, float hitHeight) { AnimationClip animation = null; foreach (var hitClips in EnemyDefinition.hitAnimations) { if (hitClips.hitDir != direction) continue; if (!Mathf.Approximately(hitClips.hitHeight, hitHeight)) { continue; } animation = hitClips.clip; break;  ",
          "content_tokens": 155,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "if (animation == null && EnemyDefinition.hitAnimations.Length > 0) { animation = EnemyDefinition.hitAnimations[0].clip; } float timeout = 1f; if (animation != null) { timeout = animation.length; Debug.Log( $\"[AIUnit][GetHit]: {gameObject.name} dir: {direction}; height: {hitHeight}; hit animation: {animation.name}\"); } return timeout; } [Server] public void PauseTimed(float time) { StartCoroutine(CorPauseCreatureTimed(time)); } private IEnumerator CorPauseCreatureTimed(float time) { _isPaused = true; yield return new WaitForSeconds(time); _isPaused = false; } private Coroutine _attackCDRoutine; private void PutAttackOnCooldown(float mod = 0f) { if (_attackCDRoutine != null) StopCoroutine(_attackCDRoutine); _attackCDRoutine = StartCoroutine(StartAttackCooldown(mod)); } [Server] public void Attack() { CombatEnter(); InstantLookAtTarget(); if (_isAttackOnCooldown) return; if (_attackAnimationTimes.Length == 0) { DebugWrite.LogError($\"[{gameObject.name}] No attack animations times found\", gameObject, _isDebug); return;  ",
          "content_tokens": 291,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "PutAttackOnCooldown(); int randomAttack = Random.Range(0, _attackAnimationTimes.Length); StartAttackFinisherTimer(_attackAnimationTimes[randomAttack]); // #if UNITY_EDITOR // _animatorDecorator.SetInteger(_animIDAttack, randomAttack); // _animatorDecorator.SetBoolTimed(_animIDIsAttacking, true, _attackAnimationTimes[randomAttack]); // #endif ObserverPlayAttackAnimation(randomAttack); PlayAttackSound(); //ObserverPlayAttackAnimation(); DebugWrite.Log($\"[{gameObject.name}] Attack\", gameObject, _isDebug); Transform targetPlayer = _behaviorTree.GetVariable(\"Target\").GetValue() as Transform; if (!_isDamageByMeleeManager) StartCoroutine(DoDamageToPlayer(targetPlayer)); } [Server] private void SmoothLookAtTarget() { if (!IsHaveTarget) { _aiPath.enableRotation = true; return; } _aiPath.enableRotation = false; Vector3 targetPos = GameplayManager.Instance.PlayerPositions[_targetObjectId]; // Calculate direction towards the target Vector3 direction = (targetPos - transform.position).normalized; // Calculate the rotation needed to look at the target Quaternion targetRotation = Quaternion.LookRotation(direction); transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, Time.deltaTime * 5f); } [Server] private void InstantLookAtTarget() { if (_targetObjectId > 0) { Vector3 targetPos = GameplayManager.Instance.PlayerPositions[_targetObjectId]; transform.LookAt(targetPos); } } private IEnumerator StartAttackCooldown(float mod = 0f) { _isAttackOnCooldown = true; Debug.Log($\"[AIUnit][StartAttackCooldown]: Start attack cooldown. _isAttackOnCooldown: {_isAttackOnCooldown}. Waiting for {EnemyDefinition.AttackCooldown + mod} seconds\", gameObject); yield return new WaitForSeconds(EnemyDefinition.AttackCooldown + mod); _isAttackOnCooldown = false; Debug.Log($\"[AIUnit][StartAttackCooldown]: End attack cooldown. _isAttackOnCooldown: {_isAttackOnCooldown}\", gameObject);  ",
          "content_tokens": 498,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void StartAttackFinisherTimer(float time) { if (_attackAnimationTimer == null) _attackAnimationTimer = StartCoroutine(CorStartAttackFinisherTimer(time)); } internal IEnumerator CorStartAttackFinisherTimer(float time) { _isPlayingAttackAnimation = true; DebugWrite.Log($\"[AIUnit][CorStartAttackFinisherTimer]: Start attack finisher timer. _isPlayingAttackAnimation: {_isPlayingAttackAnimation}\", gameObject, _isDebug); yield return new WaitForSeconds(time); _isPlayingAttackAnimation = false; DebugWrite.Log($\"[AIUnit][CorStartAttackFinisherTimer]: Finish attack finisher timer. _isPlayingAttackAnimation: {_isPlayingAttackAnimation}\", gameObject, _isDebug); _attackAnimationTimer = null; } [ObserversRpc] private void ObserverPlayAttackAnimation(int attackId) { _animatorDecorator.SetInteger(_animIDAttack, attackId); _animatorDecorator.SetBoolTimed(_animIDIsAttacking, true, _attackAnimationTimes[attackId]); if (isPlayIndicator) StatusIndicatorManager.InitCone(transform, _definition.AttackDistance + .1f, _swingStretchTime); // int attackId = Random.Range(0, 3); // if (attackId == 2) { // _animatorDecorator.SetFloat(_animIDAttack, .333333f); // } else if (attackId == 3) { // _animatorDecorator.SetFloat(_animIDAttack, .6666667f); // } else { // _animatorDecorator.SetFloat(_animIDAttack, attackId); // } // _animatorDecorator.SetTrigger(_animIDDoAttack); } /// <summary> /// https://excalidraw.com/#room=abaeb99a6c827f1171bf,CU_iVmew9QkKv7biuYwlCA /// </summary> [Server] private IEnumerator DoDamageToPlayer(Transform player) { var playerFIM = GetFim(player); bool isPlayerDead = playerFIM.FishnetInvectorHealthController.IsDead; if (isPlayerDead) { yield break; } yield return new WaitForSeconds(.5f); vDamage damage = new vDamage(); damage.damageValue = (int)Damage; damage.hitPosition = player.transform.position; damage.Sender = transform; damage.IsShowDamage = false; playerFIM.FishnetInvectorHealthController.TakeDamage(damage); DebugWrite.Log($\"[ZombieUnit][DoDamageToPlayer] {gameObject.name}->{player.name}(dead: {playerFIM.FishnetInvectorHealthController.IsDead}) playerFIM: {(bool)playerFIM}\", gameObject); } public static FishnetInvectorManager GetFim(Transform target) { if (!_fishnetManagers.ContainsKey(target)) { var targetsFim = target.GetComponent<FishnetInvectorManager>(); if (targetsFim == null) { targetsFim = target.GetComponentInParent<FishnetInvectorManager>(); DebugWrite.LogError($\"[ZombieUnit][GetFim] has no fim remove 'Player' tag from {target.name} \"); } _fishnetManagers.Add(target, targetsFim); DebugWrite.Log($\"[ZombieUnit][GetFim] add {target.name} to _fishnetManagers\"); } return _fishnetManagers[target]; } public List<FishnetInvectorManager> GetAllPlayers() { List<NetworkObject> allPlayers = GameplayManager.Instance.GetAllPlayersHeroes(); var possibleTargets = new List<FishnetInvectorManager>(); foreach (var unit in allPlayers) { var playerFim = GetFim(unit.transform); possibleTargets.Add(playerFim); } return possibleTargets; } /// <summary> /// Draws the line of sight representation /// </summary> public void OnDrawGizmos() { #if UNITY_EDITOR //DrawHitPositionArrow(); //Draws Cone of AI vision DebugDrawVisionCone(); DebugDrawAttackDistanceCircle(); #endif  ",
          "content_tokens": 946,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void DebugDrawAttackDistanceCircle() { #if UNITY_EDITOR var oldColor = Handles.color; var color = new Color(1.0f, 0.0f, 0.0f, .1f); color.a = 0.1f; Handles.color = color; var normalizedDirection = transform.up; var radius = EnemyDefinition.AttackDistance; Handles.DrawSolidDisc(transform.position, normalizedDirection, radius); Handles.color = oldColor; #endif  ",
          "content_tokens": 114,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void DebugDrawVisionCone() { #if UNITY_EDITOR if (EnemyDefinition == null) return; var oldColor = Handles.color; var color = new Color(1.0f, 1.0f, 0.0f, .1f); color.a = 0.1f; Handles.color = color; var halfFOV = EnemyDefinition.FieldOfView * 0.5f; var centerDirection = transform.forward; var beginDirection = Quaternion.AngleAxis(-halfFOV, Vector3.up) * centerDirection; var normalizedDirection = transform.up; var radius = EnemyDefinition.ViewDistance; Handles.DrawSolidArc(transform.position, normalizedDirection, beginDirection, EnemyDefinition.FieldOfView, radius); Handles.color = oldColor; #endif  ",
          "content_tokens": 188,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "public int SearchForEnemyInRadius(out bool isFound) { return GetNearestEnemy(out isFound); } [Server] public int GetNearestEnemy(out bool isFound, float maxDistance = 200f) { maxDistance = 10f * 10f; int targetObjectId = -1; isFound = false; foreach (var kv in GameplayManager.Instance.PlayerPositions) { var position = kv.Value; var squaredDistance = Vector3.SqrMagnitude(position - transform.position); if (squaredDistance < maxDistance) { var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(kv.Key); if (unitComps.HealthController.IsDead) continue; maxDistance = squaredDistance; isFound = true; targetObjectId = kv.Key; }  ",
          "content_tokens": 190,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "if (isFound) { return targetObjectId; } //DebugWrite.LogError($\"[ZombieUnit][GetNearestEnemy] no target found\"); return -1;  public int GetTargetId() { return _targetObjectId;  public void ClearTarget() { _targetObjectId = -1;  public bool IsTargetWithinAttackDistance() { if (_targetObjectId < 0) { return false;  if (CommonMath.Math.IsWithinRange(GetTargetTransform().position, transform.position, EnemyDefinition.AttackDistance)) { return true; } return false;  public void UpdateTarget(int newTargetId) { var playerComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(newTargetId); if (playerComps.HealthController.IsAI) return; _targetObjectId = newTargetId;  ",
          "content_tokens": 185,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void OnTargetChanged(int prev, int next, bool asServer) { if (asServer) return; var targetUnitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(next); if (targetUnitComps == null) return; var targetHead = targetUnitComps.AttachmentPoints.GetAttachmentPoint(AttachmentPoints.Point.Head); if (targetHead == null) return; UpdateHeadLookingTarget(targetHead); } [Client] private void UpdateHeadLookingTarget(Transform target) { if (!_isDoHeadFollow) return; headAimIK.solver.target = target;  ",
          "content_tokens": 138,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void OnTick() { if (IsDead) return; if (IsHaveTarget) return; Buff.BuffData unit = new Buff.BuffData(ObjectId, gameObject.tag); List<FishnetInvectorHealthController> targetsInRadius = Ability.EnemyTargetsInRadius(transform.position, unit, EnemyDefinition.ViewDistance); foreach (var tempTarget in targetsInRadius) { if (IsTagetWithinViewCone(tempTarget.transform)) { CmdAddTargetToWithinSight(tempTarget.NetworkObject.ObjectId); } else { CmdRemoveTargetFromWithinSight(tempTarget.NetworkObject.ObjectId); } }  ",
          "content_tokens": 151,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private bool IsTagetWithinViewCone(Transform target) { var fov = EnemyDefinition.FieldOfView; Vector3 directionToTarget = (target.position - transform.position).normalized; float angleToTarget = Vector3.Angle(transform.forward, directionToTarget); // Check if the angle to the target is within the field of view if (angleToTarget <= fov / 2f) { // Now, we need to check if there's any obstacle between the enemy and the target RaycastHit hit; if (Physics.Raycast(transform.position, directionToTarget, out hit)) { // Assuming you have defined tags for obstacles if (hit.collider.CompareTag(\"Untagged\")) { // There's an obstacle between the enemy and the target return false; } } // No obstacles and target is within the field of view return true; } // Target is outside the field of view return false; } [ServerRpc(RequireOwnership = false)] public void CmdAddTargetToWithinSight(int targetId) { DebugWrite.Log($\"[AIUnit][CmdAddTargetToWithinSight] {gameObject.name} add {targetId} to _playersWithinSight\", gameObject, _isDebug); if (PlayersWithinSight.Contains(targetId)) return; _playersWithinSight.Add(targetId); } [ServerRpc(RequireOwnership = false)] public void CmdRemoveTargetFromWithinSight(int targetId) { DebugWrite.Log($\"[ZombieUnit][CmdRemoveTargetFromWithinSight] {gameObject.name} remove {targetId} from _playersWithinSight\", gameObject, _isDebug); _lastTargetPosition = GameplayManager.Instance.PlayerPositions[targetId]; _playersWithinSight.Remove(targetId); ClearTarget(); } public Transform GetTargetTransform() { return GameplayManager.Instance.GetTargetTransformServerAndClient(_targetObjectId);  ",
          "content_tokens": 425,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "public void SetHeadTransform(Transform head) { _head = head; } [Server] public void OrderToFly() { if (CurrentState == AIState.Flying) return; if (CurrentState == AIState.Landed) { SetState(AIState.TakingOff); } } [Server] public void SetState(AIState nextState) { if (nextState == AIState.Flying) { AnimatorDecorator.SetBool(_animIDIsFlying, true); OnStateFlying?.Invoke(); }else if (nextState == AIState.TakingOff) { _groundedY = transform.position.y; _aiPath.enabled = false; TargetsPlayTakeOffAnimation(); StartCoroutine(DelayedMoveY(.26f, _groundedY + 6f)); }else if (nextState == AIState.Landing) { if (CurrentState == AIState.Flying) { TargetsPlayLandingAnimation(); _aiPath.enabled = true; //DoTween set x and z rotation to 0 transform.DORotate(new Vector3(0f, transform.rotation.eulerAngles.y, 0f), _landingTime*.5f); transform.DOMoveY(_groundedY + 0.1f, _landingTime*.8f).SetEase(Ease.InCubic).OnComplete(() => FinishLanding()); } } else if (nextState == AIState.Landed) { OnStateLanded?.Invoke(); } CurrentState = nextState; } private IEnumerator DelayedMoveY(float delay, float y) { yield return new WaitForSeconds(delay); transform.DOMoveY(y, _takeOffTime *.8f).SetEase(Ease.OutCubic).OnComplete(() => SetState(AIState.Flying));  ",
          "content_tokens": 404,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void FinishLanding() { SetState(AIState.Landed); AnimatorDecorator.SetBool(_animIDIsFlying, false); } [ObserversRpc] private void TargetsPlayTakeOffAnimation() => StartCoroutine(CorPlayTakeOffAnimation()); [Client] private IEnumerator CorPlayTakeOffAnimation() { AnimatorDecorator.SetBool(_animIDIsFlying, true); _animatorDecorator.SetBool(_animIDTakeOff, true); yield return new WaitForSeconds(_takeOffTime*.8f); _animatorDecorator.SetBool(_animIDTakeOff, false); } [ObserversRpc] private void TargetsPlayLandingAnimation() => StartCoroutine(CorPlayLandingAnimation()); [Client] private IEnumerator CorPlayLandingAnimation() { AnimatorDecorator.SetBool(_animIDIsFlying, true); _animatorDecorator.SetBool(_animIDDoLanding, true); yield return new WaitForSeconds(_landingTime*.8f); AnimatorDecorator.SetBool(_animIDIsFlying, false); _animatorDecorator.SetBool(_animIDDoLanding, false);  ",
          "content_tokens": 276,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "private void SetupAnimationTimes() { if (EnemyDefinition.AnimationTakeOff != null) { _takeOffTime = EnemyDefinition.AnimationTakeOff.length; _landingTime = EnemyDefinition.AnimationLanding.length; }  public void StoreRendererColors() { Renderer[] renderers = GetComponentsInChildren<Renderer>(); for (int i = 0; i < renderers.Length; i++) { RendererColor rendererColor = new RendererColor(new List<Material>(), new List<Color>()); foreach (Material mat in renderers[i].materials) { rendererColor.OriginalTexture.Add(mat.mainTexture); rendererColor.Material.Add(mat); rendererColor.Colors.Add(mat.color);  ",
          "content_tokens": 172,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "if (rendererColor.Material.Count > 0) { this.rendererColor.Add(rendererColor); } Debug.Log($\"[Unit] StoreRendererColors {rendererColor.Material.Count}\"); }  public void Flash(Color toColor, float duration, float delay, bool ignoreTimeScale, Action onComplete) { Debug.Log($\"[Unit] Flash {rendererColor.Count}\"); StartCoroutine(CorFlash(toColor, duration, delay, ignoreTimeScale, onComplete)); } public IEnumerator CorFlash(Color toColor, float duration, float delay, bool ignoreTimeScale, Action onComplete) { yield return new WaitForSeconds(delay); SwapTexture(toColor); float time = 0f; while (time < duration) { time += ignoreTimeScale ? Time.unscaledDeltaTime : Time.deltaTime; yield return null;  ",
          "content_tokens": 196,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnit",
          "content": "RevertTextureBack(); onComplete?.Invoke();  private void SwapTexture(Color toColor) { foreach (RendererColor rColor in rendererColor) { for (int i = 0; i < rColor.Material.Count; i++) { rColor.Material[i].mainTexture = textureToBlink; rColor.Material[i].color = toColor; //Debug.Log($\"[Unit] CorFlash {rColor.Material[i].mainTexture}\"); } }  private void RevertTextureBack() { foreach (RendererColor rColor in rendererColor) { for (int i = 0; i < rColor.Material.Count; i++) { rColor.Material[i].mainTexture = rColor.OriginalTexture[i]; rColor.Material[i].color = rColor.Colors[i]; } } } }",
          "content_tokens": 191,
          "embedding": []
        }
      ],
      "length": 36919
    },
    {
      "filename": "AstarAI",
      "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using Pathfinding; using UnityEngine; using UnityEngine.Events; using Zomb.Creatures.Helpers; public class AstarAI : MonoBehaviour { private Seeker _seeker; private CharacterController controller; private Vector3 _currentDestination = Vector3.zero; private bool _reachedEndOfPath; private Path _path; private int _currentWaypoint = 0; private float repathRate = 0.5f; private float lastRepath = float.NegativeInfinity; public IAstarAI AI => ai; private IAstarAI ai; private AIUnit _aiUnit; [SerializeField] private bool isXRotationFreezed = true; [SerializeField] private bool isYRotationFreezed; [SerializeField] private bool isZRotationFreezed = true; private static int PATROL_RADIUS = 5; private static float PATH_TIMEOUT = 5f; private AnimatorDecorator _animatorDecorator; private float _nextWaypointDistance = 3; public UnityEvent OnStartMove; public UnityEvent OnStopMove; private bool _isDebug = false; private Coroutine _pathTimeoutCoroutine; private bool _isPathTimeout = false; void OnEnable () { ai = GetComponent<IAstarAI>(); ai.onSearchPath += OnSearchPath; // Update the destination right before searching for a path as well. // This is enough in theory, but this script will also update the destination every // frame as the destination is used for debugging and may be used for other things by other // scripts as well. So it makes sense that it is up to date every frame. if (ai != null) { ai.onSearchPath += LateUpdate; } } private void OnSearchPath() { OnStartMove?.Invoke(); } void OnDisable () { if (ai != null) ai.onSearchPath -= LateUpdate; } public void ServerInit(AIUnit aiUnit, AnimatorDecorator animatorDecorator) { // Get a reference to the Seeker component we added earlier _aiUnit = aiUnit; _seeker = GetComponent<Seeker>(); controller = GetComponent<CharacterController>(); _animatorDecorator = animatorDecorator; } public void SetSpeed(float newSpeed) { ai.maxSpeed = newSpeed; } public bool HasArrived() { if (ai != null) return ai.reachedDestination; return false; } public void Stop() { DebugWrite.Log($\"[AstarAI] Stop\", gameObject, _isDebug); _path = null; ai.isStopped = true; OnStopMove?.Invoke(); } public void Resume() { DebugWrite.Log($\"[AstarAI] Resume\", gameObject, _isDebug); ai.isStopped = false; } public Vector3 GetNearRandomPoint() { var startNode = GameplayManager.Instance.AstarPath.GetNearest(transform.position, NNConstraint.Default).node; if (startNode != null) { var nodes = PathUtilities.BFS(startNode, PATROL_RADIUS); var singleRandomPoint = PathUtilities.GetPointsOnNodes(nodes, 1)[0]; return singleRandomPoint; } return transform.position; } public Vector3 GetNearPoint(Vector3 toPos) { NNInfo info = GameplayManager.Instance.AstarPath.GetNearest(transform.position, NNConstraint.Default); return info.position; } public void SetDestination(Vector3 destination) { // Start to calculate a new path to the targetPosition object, return the result to the OnPathComplete method. // Path requests are asynchronous, so when the OnPathComplete method is called depends on how long it // takes to calculate the path. Usually it is called the next frame. if (destination == _currentDestination) return; ai.isStopped = false; //Debug.Log(\"Setting destination to \" + destination); _currentDestination = destination; ai.destination = _currentDestination; // var path = _seeker.StartPath(transform.position, destination); // if (path.error) { // Debug.Log(\"Oh noes, the target was not reachable: \" + path.errorLog); // return; // } } public void SetAttackDestination(Vector3 destination, float attackDistance) { var attackDestination = destination + (transform.position - destination).normalized * (attackDistance); if (attackDestination == _currentDestination) return; ai.isStopped = false; _currentDestination = attackDestination; ai.destination = _currentDestination; if (_pathTimeoutCoroutine == null) _pathTimeoutCoroutine = StartCoroutine(PathTimeout()); } private IEnumerator PathTimeout() { _isPathTimeout = false; yield return new WaitForSeconds(PATH_TIMEOUT); _isPathTimeout = true; _pathTimeoutCoroutine = null; Stop(); } private void OnPathComplete (Path p) { Debug.Log(\"Yay, we got a path back. Did it have an error? \" + p.error); // Path pooling. To avoid unnecessary allocations paths are reference counted. // Calling Claim will increase the reference count by 1 and Release will reduce // it by one, when it reaches zero the path will be pooled and then it may be used // by other scripts. The ABPath.Construct and Seeker.StartPath methods will // take a path from the pool if possible. See also the documentation page about path pooling. p.Claim(this); if (!p.error) { if (_path != null) _path.Release(this); _path = p; // Reset the waypoint counter so that we start to move towards the first point in the path _currentWaypoint = 0; } else { p.Release(this); } } private void LateUpdate () { FixRotation(); if (ai.reachedDestination) { OnStopMove?.Invoke(); } // if (_path == null) { // // We have no path to follow yet, so don't do anything // return; // } // // if (_currentDestination != Vector3.zero && ai != null) ai.destination = _currentDestination; // if (Time.time > lastRepath + repathRate && _seeker.IsDone()) { // lastRepath = Time.time; // // // Start a new path to the targetPosition, call the the OnPathComplete function // // when the path has been calculated (which may take a few frames depending on the complexity) // _seeker.StartPath(transform.position, _currentDestination, OnPathComplete); // } // // // Check in a loop if we are close enough to the current waypoint to switch to the next one. // // We do this in a loop because many waypoints might be close to each other and we may reach // // several of them in the same frame. // _reachedEndOfPath = false; // // The distance to the next waypoint in the path // float distanceToWaypoint; // while (true) { // // If you want maximum performance you can check the squared distance instead to get rid of a // // square root calculation. But that is outside the scope of this tutorial. // distanceToWaypoint = Vector3.Distance(transform.position, _path.vectorPath[_currentWaypoint]); // if (distanceToWaypoint < _nextWaypointDistance) { // // Check if there is another waypoint or if we have reached the end of the path // if (_currentWaypoint + 1 < _path.vectorPath.Count) { // _currentWaypoint++; // } else { // // Set a status variable to indicate that the agent has reached the end of the path. // // You can use this to trigger some special code if your game requires that. // _reachedEndOfPath = true; // OnStopMove?.Invoke(); // break; // } // } else { // break; // } // } // // // Slow down smoothly upon approaching the end of the path // // This value will smoothly go from 1 to 0 as the agent approaches the last waypoint in the path. // var speedFactor = _reachedEndOfPath ? Mathf.Sqrt(distanceToWaypoint/_nextWaypointDistance) : 1f; // // // Direction to the next waypoint // // Normalize it so that it has a length of 1 world unit // Vector3 dir = (_path.vectorPath[_currentWaypoint] - transform.position).normalized; // // Multiply the direction by our desired speed to get a velocity // Vector3 velocity = dir * (_speed * speedFactor); // // // Move the agent using the CharacterController component // // Note that SimpleMove takes a velocity in meters/second, so we should not multiply by Time.deltaTime // controller.SimpleMove(velocity); // // // If you are writing a 2D game you may want to remove the CharacterController and instead modify the position directly // // transform.position += velocity * Time.deltaTime; } private void FixRotation() { if (!isXRotationFreezed && !isYRotationFreezed && !isZRotationFreezed) return; Vector3 currentEulerAngles = transform.eulerAngles; float xAngle = isXRotationFreezed ? 0f : currentEulerAngles.x; float yAngle = isYRotationFreezed ? 0f : currentEulerAngles.y; float zAngle = isZRotationFreezed ? 0f : currentEulerAngles.z; transform.eulerAngles = new Vector3(xAngle, yAngle, zAngle); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AstarAI",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "AstarAI",
          "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using Pathfinding; using UnityEngine; using UnityEngine.Events; using Zomb.Creatures.Helpers; public class AstarAI : MonoBehaviour { private Seeker _seeker; private CharacterController controller; private Vector3 _currentDestination = Vector3.zero; private bool _reachedEndOfPath; private Path _path; private int _currentWaypoint = 0; private float repathRate = 0.5f; private float lastRepath = float.NegativeInfinity; public IAstarAI AI => ai; private IAstarAI ai; private AIUnit _aiUnit; [SerializeField] private bool isXRotationFreezed = true; [SerializeField] private bool isYRotationFreezed; [SerializeField] private bool isZRotationFreezed = true; private static int PATROL_RADIUS = 5; private static float PATH_TIMEOUT = 5f; private AnimatorDecorator _animatorDecorator; private float _nextWaypointDistance = 3; public UnityEvent OnStartMove; public UnityEvent OnStopMove; private bool _isDebug = false; private Coroutine _pathTimeoutCoroutine; private bool _isPathTimeout = false; void OnEnable () { ai = GetComponent<IAstarAI>(); ai.onSearchPath += OnSearchPath; // Update the destination right before searching for a path as well. // This is enough in theory, but this script will also update the destination every // frame as the destination is used for debugging and may be used for other things by other // scripts as well. So it makes sense that it is up to date every frame. if (ai != null) { ai.onSearchPath += LateUpdate; }  ",
          "content_tokens": 416,
          "embedding": []
        },
        {
          "cs_scriptfile": "AstarAI",
          "content": "private void OnSearchPath() { OnStartMove?.Invoke();  void OnDisable () { if (ai != null) ai.onSearchPath -= LateUpdate;  public void ServerInit(AIUnit aiUnit, AnimatorDecorator animatorDecorator) { // Get a reference to the Seeker component we added earlier _aiUnit = aiUnit; _seeker = GetComponent<Seeker>(); controller = GetComponent<CharacterController>(); _animatorDecorator = animatorDecorator;  public void SetSpeed(float newSpeed) { ai.maxSpeed = newSpeed;  public bool HasArrived() { if (ai != null) return ai.reachedDestination; return false;  ",
          "content_tokens": 162,
          "embedding": []
        },
        {
          "cs_scriptfile": "AstarAI",
          "content": "public void Stop() { DebugWrite.Log($\"[AstarAI] Stop\", gameObject, _isDebug); _path = null; ai.isStopped = true; OnStopMove?.Invoke();  ",
          "content_tokens": 48,
          "embedding": []
        },
        {
          "cs_scriptfile": "AstarAI",
          "content": "public void Resume() { DebugWrite.Log($\"[AstarAI] Resume\", gameObject, _isDebug); ai.isStopped = false; } public Vector3 GetNearRandomPoint() { var startNode = GameplayManager.Instance.AstarPath.GetNearest(transform.position, NNConstraint.Default).node; if (startNode != null) { var nodes = PathUtilities.BFS(startNode, PATROL_RADIUS); var singleRandomPoint = PathUtilities.GetPointsOnNodes(nodes, 1)[0]; return singleRandomPoint; } return transform.position; } public Vector3 GetNearPoint(Vector3 toPos) { NNInfo info = GameplayManager.Instance.AstarPath.GetNearest(transform.position, NNConstraint.Default); return info.position;  ",
          "content_tokens": 192,
          "embedding": []
        },
        {
          "cs_scriptfile": "AstarAI",
          "content": "public void SetDestination(Vector3 destination) { // Start to calculate a new path to the targetPosition object, return the result to the OnPathComplete method. // Path requests are asynchronous, so when the OnPathComplete method is called depends on how long it // takes to calculate the path. Usually it is called the next frame. if (destination == _currentDestination) return; ai.isStopped = false; //Debug.Log(\"Setting destination to \" + destination); _currentDestination = destination; ai.destination = _currentDestination; // var path = _seeker.StartPath(transform.position, destination); // if (path.error) { // Debug.Log(\"Oh noes, the target was not reachable: \" + path.errorLog); // return; // }  ",
          "content_tokens": 175,
          "embedding": []
        },
        {
          "cs_scriptfile": "AstarAI",
          "content": "public void SetAttackDestination(Vector3 destination, float attackDistance) { var attackDestination = destination + (transform.position - destination).normalized * (attackDistance); if (attackDestination == _currentDestination) return; ai.isStopped = false; _currentDestination = attackDestination; ai.destination = _currentDestination; if (_pathTimeoutCoroutine == null) _pathTimeoutCoroutine = StartCoroutine(PathTimeout()); } private IEnumerator PathTimeout() { _isPathTimeout = false; yield return new WaitForSeconds(PATH_TIMEOUT); _isPathTimeout = true; _pathTimeoutCoroutine = null; Stop();  ",
          "content_tokens": 150,
          "embedding": []
        },
        {
          "cs_scriptfile": "AstarAI",
          "content": "private void OnPathComplete (Path p) { Debug.Log(\"Yay, we got a path back. Did it have an error? \" + p.error); // Path pooling. To avoid unnecessary allocations paths are reference counted. // Calling Claim will increase the reference count by 1 and Release will reduce // it by one, when it reaches zero the path will be pooled and then it may be used // by other scripts. The ABPath.Construct and Seeker.StartPath methods will // take a path from the pool if possible. See also the documentation page about path pooling. p.Claim(this); if (!p.error) { if (_path != null) _path.Release(this); _path = p; // Reset the waypoint counter so that we start to move towards the first point in the path _currentWaypoint = 0; } else { p.Release(this); }  ",
          "content_tokens": 190,
          "embedding": []
        },
        {
          "cs_scriptfile": "AstarAI",
          "content": "private void LateUpdate () { FixRotation(); if (ai.reachedDestination) { OnStopMove?.Invoke(); } // if (_path == null) { // // We have no path to follow yet, so don't do anything // return; // } // // if (_currentDestination != Vector3.zero && ai != null) ai.destination = _currentDestination; // if (Time.time > lastRepath + repathRate && _seeker.IsDone()) { // lastRepath = Time.time; // // // Start a new path to the targetPosition, call the the OnPathComplete function // // when the path has been calculated (which may take a few frames depending on the complexity) // _seeker.StartPath(transform.position, _currentDestination, OnPathComplete); // } // // // Check in a loop if we are close enough to the current waypoint to switch to the next one. // // We do this in a loop because many waypoints might be close to each other and we may reach // // several of them in the same frame. // _reachedEndOfPath = false; // // The distance to the next waypoint in the path // float distanceToWaypoint; // while (true) { // // If you want maximum performance you can check the squared distance instead to get rid of a // // square root calculation. But that is outside the scope of this tutorial. // distanceToWaypoint = Vector3.Distance(transform.position, _path.vectorPath[_currentWaypoint]); // if (distanceToWaypoint < _nextWaypointDistance) { // // Check if there is another waypoint or if we have reached the end of the path // if (_currentWaypoint + 1 < _path.vectorPath.Count) { // _currentWaypoint++; // } else { // // Set a status variable to indicate that the agent has reached the end of the path. // // You can use this to trigger some special code if your game requires that. // _reachedEndOfPath = true; // OnStopMove?.Invoke(); // break; // } // } else { // break; // } // } // // // Slow down smoothly upon approaching the end of the path // // This value will smoothly go from 1 to 0 as the agent approaches the last waypoint in the path. // var speedFactor = _reachedEndOfPath ? Mathf.Sqrt(distanceToWaypoint/_nextWaypointDistance) : 1f; // // // Direction to the next waypoint // // Normalize it so that it has a length of 1 world unit // Vector3 dir = (_path.vectorPath[_currentWaypoint] - transform.position).normalized; // // Multiply the direction by our desired speed to get a velocity // Vector3 velocity = dir * (_speed * speedFactor); // // // Move the agent using the CharacterController component // // Note that SimpleMove takes a velocity in meters/second, so we should not multiply by Time.deltaTime // controller.SimpleMove(velocity); // // // If you are writing a 2D game you may want to remove the CharacterController and instead modify the position directly // // transform.position += velocity * Time.deltaTime;  ",
          "content_tokens": 694,
          "embedding": []
        },
        {
          "cs_scriptfile": "AstarAI",
          "content": "private void FixRotation() { if (!isXRotationFreezed && !isYRotationFreezed && !isZRotationFreezed) return; Vector3 currentEulerAngles = transform.eulerAngles; float xAngle = isXRotationFreezed ? 0f : currentEulerAngles.x; float yAngle = isYRotationFreezed ? 0f : currentEulerAngles.y; float zAngle = isZRotationFreezed ? 0f : currentEulerAngles.z; transform.eulerAngles = new Vector3(xAngle, yAngle, zAngle); } }",
          "content_tokens": 141,
          "embedding": []
        }
      ],
      "length": 8135
    },
    {
      "filename": "AIAction",
      "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class AIAction : Action { protected AIUnit _aiUnit; public override void OnAwake() { TryGetComponent(out _aiUnit); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AIAction",
          "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class AIAction : Action { protected AIUnit _aiUnit; public override void OnAwake() { TryGetComponent(out _aiUnit); } } }",
          "content_tokens": 55,
          "embedding": []
        }
      ],
      "length": 201
    },
    {
      "filename": "AICastPoisonNova",
      "content": "using _ZombieRoyale.Scripts.AI.Boss_Perks; namespace My.BehaviorTree.Actions{ public class AICastPoisonNova : AIAction { private AIPoisonNovaController _poisonNovaController; public override void OnAwake() { base.OnAwake(); _poisonNovaController = GetComponent<AIPoisonNovaController>(); } public override void OnStart() { base.OnStart(); _poisonNovaController.SpawnNova(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AICastPoisonNova",
          "content": "using _ZombieRoyale.Scripts.AI.Boss_Perks; namespace My.BehaviorTree.Actions{ public class AICastPoisonNova : AIAction { private AIPoisonNovaController _poisonNovaController; public override void OnAwake() { base.OnAwake(); _poisonNovaController = GetComponent<AIPoisonNovaController>(); } public override void OnStart() { base.OnStart(); _poisonNovaController.SpawnNova(); } } }",
          "content_tokens": 116,
          "embedding": []
        }
      ],
      "length": 379
    },
    {
      "filename": "Attack",
      "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class Attack : AIAction { public override void OnStart() { _aiUnit.Attack(); } public override TaskStatus OnUpdate() { if (!_aiUnit.IsPlayingAttackAnimation) return TaskStatus.Running; return TaskStatus.Success; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Attack",
          "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class Attack : AIAction { public override void OnStart() { _aiUnit.Attack(); } public override TaskStatus OnUpdate() { if (!_aiUnit.IsPlayingAttackAnimation) return TaskStatus.Running; return TaskStatus.Success; } } }",
          "content_tokens": 76,
          "embedding": []
        }
      ],
      "length": 298
    },
    {
      "filename": "BossPolarDragonDoBreath",
      "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.AI.Boss_Perks; using BehaviorDesigner.Runtime.Tasks; using UnityEngine; namespace My.BehaviorTree.Actions { public class BossPolarDragonDoBreath : AIAction { private PolarDragonFlying _polarDragonFlying; private bool _isBreathingFinished; public override void OnAwake() { base.OnAwake(); _polarDragonFlying = GetComponent<PolarDragonFlying>(); _polarDragonFlying.OnBreathingFinished += BreathingFinished; } private void BreathingFinished() { _isBreathingFinished = true; } public override void OnStart() { base.OnStart(); if (_polarDragonFlying.IsBreathOnCooldown) { return; } _polarDragonFlying.DoBreathing(); } public override TaskStatus OnUpdate() { if (_polarDragonFlying.IsBreathing) { return TaskStatus.Running; } if (_isBreathingFinished) { _isBreathingFinished = false; return TaskStatus.Success; } return TaskStatus.Failure; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BossPolarDragonDoBreath",
          "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.AI.Boss_Perks; using BehaviorDesigner.Runtime.Tasks; using UnityEngine; namespace My.BehaviorTree.Actions { public class BossPolarDragonDoBreath : AIAction { private PolarDragonFlying _polarDragonFlying; private bool _isBreathingFinished; public override void OnAwake() { base.OnAwake(); _polarDragonFlying = GetComponent<PolarDragonFlying>(); _polarDragonFlying.OnBreathingFinished += BreathingFinished;  ",
          "content_tokens": 138,
          "embedding": []
        },
        {
          "cs_scriptfile": "BossPolarDragonDoBreath",
          "content": "private void BreathingFinished() { _isBreathingFinished = true; } public override void OnStart() { base.OnStart(); if (_polarDragonFlying.IsBreathOnCooldown) { return; } _polarDragonFlying.DoBreathing(); } public override TaskStatus OnUpdate() { if (_polarDragonFlying.IsBreathing) { return TaskStatus.Running;  if (_isBreathingFinished) { _isBreathingFinished = false; return TaskStatus.Success; } return TaskStatus.Failure; } } }",
          "content_tokens": 124,
          "embedding": []
        }
      ],
      "length": 927
    },
    {
      "filename": "BossRockGolemShootStones",
      "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.AI.Boss_Perks; using BehaviorDesigner.Runtime.Tasks; using UnityEngine; namespace My.BehaviorTree.Actions { public class BossRockGolemShootStones : AIAction { private MovingStones _movingStones; public override void OnAwake() { base.OnAwake(); _movingStones = GetComponent<MovingStones>(); } public override void OnStart() { _movingStones.StopAndShootStones(); } public override TaskStatus OnUpdate() { if (_movingStones.IsStonesSpawned) { if (_movingStones.IsShooting) { return TaskStatus.Running; } else { return TaskStatus.Success; } } return TaskStatus.Failure; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BossRockGolemShootStones",
          "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.AI.Boss_Perks; using BehaviorDesigner.Runtime.Tasks; using UnityEngine; namespace My.BehaviorTree.Actions { public class BossRockGolemShootStones : AIAction { private MovingStones _movingStones; public override void OnAwake() { base.OnAwake(); _movingStones = GetComponent<MovingStones>(); } public override void OnStart() { _movingStones.StopAndShootStones(); } public override TaskStatus OnUpdate() { if (_movingStones.IsStonesSpawned) { if (_movingStones.IsShooting) { return TaskStatus.Running; } else { return TaskStatus.Success; } } return TaskStatus.Failure; } } }",
          "content_tokens": 186,
          "embedding": []
        }
      ],
      "length": 659
    },
    {
      "filename": "BossRockGolemSpawnStones",
      "content": "using _ZombieRoyale.Scripts.AI.Boss_Perks; using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions{ public class BossRockGolemSpawnStones : AIAction { private MovingStones _movingStones; public override void OnAwake() { base.OnAwake(); _movingStones = GetComponent<MovingStones>(); } public override TaskStatus OnUpdate() { if (!_movingStones.IsStonesSpawned) { _movingStones.SpawnStones(); return TaskStatus.Success; } return TaskStatus.Failure; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BossRockGolemSpawnStones",
          "content": "using _ZombieRoyale.Scripts.AI.Boss_Perks; using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions{ public class BossRockGolemSpawnStones : AIAction { private MovingStones _movingStones; public override void OnAwake() { base.OnAwake(); _movingStones = GetComponent<MovingStones>(); } public override TaskStatus OnUpdate() { if (!_movingStones.IsStonesSpawned) { _movingStones.SpawnStones(); return TaskStatus.Success; } return TaskStatus.Failure; } } }",
          "content_tokens": 136,
          "embedding": []
        }
      ],
      "length": 468
    },
    {
      "filename": "ClearTarget",
      "content": "namespace My.BehaviorTree.Actions { public class ClearTarget : AIAction { public override void OnStart() { _aiUnit.ClearTarget(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ClearTarget",
          "content": "namespace My.BehaviorTree.Actions { public class ClearTarget : AIAction { public override void OnStart() { _aiUnit.ClearTarget(); } } }",
          "content_tokens": 37,
          "embedding": []
        }
      ],
      "length": 135
    },
    {
      "filename": "GenerateWaypointsInRadius",
      "content": "using _ZombieRoyale.Scripts.Core; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using Pathfinding; using UnityEngine; namespace My.BehaviorTree.Actions { public class GenerateWaypointsInRadius : Action { public SharedVector3 PatrolPoint; public float radius = 5f; public SharedVector3 _spawnPoint; private AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); PatrolPoint.Value = GetRandomPointNearStartingPoint(); } public override TaskStatus OnUpdate() { PatrolPoint.Value = GetRandomPointNearStartingPoint(); return TaskStatus.Success; } private Vector3 GetRandomPointNearStartingPoint() { var startNode = GameplayManager.Instance.AstarPath.GetNearest(transform.position, NNConstraint.Default).node; if (startNode != null) { var nodes = PathUtilities.BFS(startNode, (int)radius); var singleRandomPoint = PathUtilities.GetPointsOnNodes(nodes, 1)[0]; return singleRandomPoint; } //var multipleRandomPoints = PathUtilities.GetPointsOnNodes(nodes, 100); // Vector3 result = Vector3.zero; // while (result == Vector3.zero) { // float x = _spawnPoint.Value.x + Random.Range(-radius, radius); // float y = _spawnPoint.Value.y + Random.Range(-radius, radius); // float z = _spawnPoint.Value.z + Random.Range(-radius, radius); // var point = new Vector3(x, y, z); // NNInfo nearest = _zombieUnit.GameplayManager.AstarPath.GetNearest(point); // result = nearest.position; // } //Debug.Log($\"Generated point: {result}\"); return transform.position; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "GenerateWaypointsInRadius",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "GenerateWaypointsInRadius",
          "content": "using _ZombieRoyale.Scripts.Core; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using Pathfinding; using UnityEngine; namespace My.BehaviorTree.Actions { public class GenerateWaypointsInRadius : Action { public SharedVector3 PatrolPoint; public float radius = 5f; public SharedVector3 _spawnPoint; private AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); PatrolPoint.Value = GetRandomPointNearStartingPoint(); } public override TaskStatus OnUpdate() { PatrolPoint.Value = GetRandomPointNearStartingPoint(); return TaskStatus.Success; } private Vector3 GetRandomPointNearStartingPoint() { var startNode = GameplayManager.Instance.AstarPath.GetNearest(transform.position, NNConstraint.Default).node; if (startNode != null) { var nodes = PathUtilities.BFS(startNode, (int)radius); var singleRandomPoint = PathUtilities.GetPointsOnNodes(nodes, 1)[0]; return singleRandomPoint; } //var multipleRandomPoints = PathUtilities.GetPointsOnNodes(nodes, 100); // Vector3 result = Vector3.zero; // while (result == Vector3.zero) { // float x = _spawnPoint.Value.x + Random.Range(-radius, radius); // float y = _spawnPoint.Value.y + Random.Range(-radius, radius); // float z = _spawnPoint.Value.z + Random.Range(-radius, radius); // var point = new Vector3(x, y, z); // NNInfo nearest = _zombieUnit.GameplayManager.AstarPath.GetNearest(point); // result = nearest.position; // } //Debug.Log($\"Generated point: {result}\"); return transform.position; } } }",
          "content_tokens": 433,
          "embedding": []
        }
      ],
      "length": 1554
    },
    {
      "filename": "MoveTowards",
      "content": "using _ZombieRoyale.Scripts.Core; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using My.BehaviorTree.Actions; using UnityEngine; public class MoveTowards : AIAction { public float FieldOfViewAngle = 157f; public SharedTransform Target; public SharedVector3 interestPos; [SerializeField] private bool IsMoveToPos; [SerializeField] private SharedBool didHearSound; public override void OnStart() { _aiUnit.AstarAINavigation.SetAttackDestination(GetCoords(), _aiUnit.EnemyDefinition.AttackDistance); //DebugWrite.Log($\"[MoveTowards] {GetCoords()} OnStart()\"); _aiUnit.CombatEnter(); } public override TaskStatus OnUpdate() { // if (didHearSound.Value == false) // { // return TaskStatus.Failure; // } if (_aiUnit.AstarAINavigation.HasArrived()) return TaskStatus.Success; _aiUnit.AstarAINavigation.SetDestination(GetCoords()); return TaskStatus.Running; } private bool IsTargetRequiredAndItsNull() { return !IsMoveToPos && Target.Value == null; } // Return targetPosition if target is null private Vector3 GetCoords() { var myPos = _aiUnit.transform.position; Vector3 direction, targetPos = Vector3.zero; if (didHearSound.Value) { //return 0.5f before interestPos to avoid getting stuck in corners direction = (interestPos.Value - myPos).normalized; targetPos = interestPos.Value - direction * 0.5f; Debug.Log($\"[MoveTowards] {gameObject.name} interestPos: {interestPos.Value}\"); } if (IsMoveToPos) { Debug.Log($\"[MoveTowards] {gameObject.name} interestPos: {interestPos.Value}\"); //return 0.5f before interestPos to avoid getting stuck in corners direction = (interestPos.Value - myPos).normalized; targetPos = interestPos.Value - direction * 0.5f; }else { _aiUnit.CombatEnter(); var targetId = _aiUnit.GetTargetId(); var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetId); if (unitComps == null) { Debug.LogError($\"[MoveTowards] {gameObject.name} Target is null\"); direction = Vector3.zero; } else { targetPos = unitComps.HealthController.transform.position; direction = (targetPos - myPos).normalized; targetPos = targetPos - direction * 0.5f; } } //Debug.Log($\"[MoveTowards] {gameObject.name} TargetPos: {Target.Value.position}\"); return targetPos; } private bool IsWithinSight(Transform target, out Vector3 startRayPos, out Vector3 direction) { startRayPos = transform.position + transform.forward * 0.6f + new Vector3(0, 1.3f, 0); direction = target.position - startRayPos; float angle = Vector3.Angle(direction, transform.forward); Debug.Log($\"[WithinSight] angle: {angle}\"); if (angle < FieldOfViewAngle * 0.5f) return true; return false; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MoveTowards",
          "content": "using _ZombieRoyale.Scripts.Core; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using My.BehaviorTree.Actions; using UnityEngine; public class MoveTowards : AIAction { public float FieldOfViewAngle = 157f; public SharedTransform Target; public SharedVector3 interestPos; [SerializeField] private bool IsMoveToPos; [SerializeField] private SharedBool didHearSound; public override void OnStart() { _aiUnit.AstarAINavigation.SetAttackDestination(GetCoords(), _aiUnit.EnemyDefinition.AttackDistance); //DebugWrite.Log($\"[MoveTowards] {GetCoords() ",
          "content_tokens": 182,
          "embedding": []
        },
        {
          "cs_scriptfile": "MoveTowards",
          "content": "OnStart()\"); _aiUnit.CombatEnter(); } public override TaskStatus OnUpdate() { // if (didHearSound.Value == false) // { // return TaskStatus.Failure; //  if (_aiUnit.AstarAINavigation.HasArrived()) return TaskStatus.Success; _aiUnit.AstarAINavigation.SetDestination(GetCoords()); return TaskStatus.Running;  ",
          "content_tokens": 90,
          "embedding": []
        },
        {
          "cs_scriptfile": "MoveTowards",
          "content": "private bool IsTargetRequiredAndItsNull() { return !IsMoveToPos && Target.Value == null; } // Return targetPosition if target is null private Vector3 GetCoords() { var myPos = _aiUnit.transform.position; Vector3 direction, targetPos = Vector3.zero; if (didHearSound.Value) { //return 0.5f before interestPos to avoid getting stuck in corners direction = (interestPos.Value - myPos).normalized; targetPos = interestPos.Value - direction * 0.5f; Debug.Log($\"[MoveTowards] {gameObject.name} interestPos: {interestPos.Value}\");  ",
          "content_tokens": 146,
          "embedding": []
        },
        {
          "cs_scriptfile": "MoveTowards",
          "content": "if (IsMoveToPos) { Debug.Log($\"[MoveTowards] {gameObject.name} interestPos: {interestPos.Value}\"); //return 0.5f before interestPos to avoid getting stuck in corners direction = (interestPos.Value - myPos).normalized; targetPos = interestPos.Value - direction * 0.5f; }else { _aiUnit.CombatEnter(); var targetId = _aiUnit.GetTargetId(); var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetId); if (unitComps == null) { Debug.LogError($\"[MoveTowards] {gameObject.name} Target is null\"); direction = Vector3.zero; } else { targetPos = unitComps.HealthController.transform.position; direction = (targetPos - myPos).normalized; targetPos = targetPos - direction * 0.5f; } } //Debug.Log($\"[MoveTowards] {gameObject.name} TargetPos: {Target.Value.position}\"); return targetPos;  ",
          "content_tokens": 237,
          "embedding": []
        },
        {
          "cs_scriptfile": "MoveTowards",
          "content": "private bool IsWithinSight(Transform target, out Vector3 startRayPos, out Vector3 direction) { startRayPos = transform.position + transform.forward * 0.6f + new Vector3(0, 1.3f, 0); direction = target.position - startRayPos; float angle = Vector3.Angle(direction, transform.forward); Debug.Log($\"[WithinSight] angle: {angle}\"); if (angle < FieldOfViewAngle * 0.5f) return true; return false; } }",
          "content_tokens": 116,
          "embedding": []
        }
      ],
      "length": 2685
    },
    {
      "filename": "MoveTowardsInterestPos",
      "content": "using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using UnityEngine; namespace Zomb.BehaviorTree.Actions{ public class MoveTowardsInterestPos : Action { public SharedVector3 interestPos; private AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } public override void OnStart() { _aiUnit.AstarAINavigation.SetDestination(interestPos.Value); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MoveTowardsInterestPos",
          "content": "using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using UnityEngine; namespace Zomb.BehaviorTree.Actions{ public class MoveTowardsInterestPos : Action { public SharedVector3 interestPos; private AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } public override void OnStart() { _aiUnit.AstarAINavigation.SetDestination(interestPos.Value); } } }",
          "content_tokens": 106,
          "embedding": []
        }
      ],
      "length": 400
    },
    {
      "filename": "MoveTowardsLastTargetPosition",
      "content": "using BehaviorDesigner.Runtime.Tasks; public class MoveTowardsLastTargetPosition : Action { private AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } public override void OnStart() { if (_aiUnit.GetTargetId() == 0) return; _aiUnit.AstarAINavigation.SetAttackDestination(_aiUnit.LastTargetPosition, _aiUnit.EnemyDefinition.AttackDistance); } public override TaskStatus OnUpdate() { if (_aiUnit.GetTargetId() == 0) return TaskStatus.Failure; if (_aiUnit.AstarAINavigation.HasArrived()) return TaskStatus.Success; if (_aiUnit.AstarAINavigation.AI.isStopped) { //Debug.Log($\"[MoveTowardsLastTargetPosition] Path timeout. Stop.\"); return TaskStatus.Failure; } return TaskStatus.Running; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MoveTowardsLastTargetPosition",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "MoveTowardsLastTargetPosition",
          "content": "using BehaviorDesigner.Runtime.Tasks; public class MoveTowardsLastTargetPosition : Action { private AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } public override void OnStart() { if (_aiUnit.GetTargetId() == 0) return; _aiUnit.AstarAINavigation.SetAttackDestination(_aiUnit.LastTargetPosition, _aiUnit.EnemyDefinition.AttackDistance); } public override TaskStatus OnUpdate() { if (_aiUnit.GetTargetId() == 0) return TaskStatus.Failure; if (_aiUnit.AstarAINavigation.HasArrived()) return TaskStatus.Success; if (_aiUnit.AstarAINavigation.AI.isStopped) { //Debug.Log($\"[MoveTowardsLastTargetPosition] Path timeout. Stop.\"); return TaskStatus.Failure; } return TaskStatus.Running; } }",
          "content_tokens": 204,
          "embedding": []
        }
      ],
      "length": 721
    },
    {
      "filename": "Patrol",
      "content": "using UnityEngine; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using System.Collections; using DungeonScrollerCore; namespace My.BehaviorTree.Actions { public class Patrol : Action { private AIUnit _aiUnit; public SharedVector3 PatrolPoint; private Coroutine _pathTimeoutCoroutine; private bool _isPathTimeout = false; private static float PATH_TIMEOUT = 5f; private bool _isDebug = false; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } private void GotoNextPoint() { // Set the agent to go to the currently selected destination. var newPoint = _aiUnit.AstarAINavigation.GetNearRandomPoint(); PatrolPoint.Value = newPoint; _aiUnit.AstarAINavigation.SetDestination(PatrolPoint.Value); _aiUnit.CombatLeave(); _pathTimeoutCoroutine = StartCoroutine(PathTimeout()); } public override void OnStart() { GotoNextPoint(); } public override TaskStatus OnUpdate() { if (PatrolPoint.Value == Vector3.zero) { return TaskStatus.Failure; } if (_aiUnit.AstarAINavigation.HasArrived()) { GotoNextPoint(); return TaskStatus.Success; } if (_isPathTimeout) { _aiUnit.AstarAINavigation.Stop(); return TaskStatus.Failure; } return TaskStatus.Running; } private IEnumerator PathTimeout() { _isPathTimeout = false; DebugWrite.Log($\"[Patrol] {gameObject.name} PathTimeout: {_isPathTimeout}\", gameObject, _isDebug); yield return new WaitForSeconds(PATH_TIMEOUT); _isPathTimeout = true; DebugWrite.Log($\"[Patrol] {gameObject.name} PathTimeout: {_isPathTimeout}\", gameObject, _isDebug); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Patrol",
          "content": "using UnityEngine; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using System.Collections; using DungeonScrollerCore; namespace My.BehaviorTree.Actions { public class Patrol : Action { private AIUnit _aiUnit; public SharedVector3 PatrolPoint; private Coroutine _pathTimeoutCoroutine; private bool _isPathTimeout = false; private static float PATH_TIMEOUT = 5f; private bool _isDebug = false; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>();  ",
          "content_tokens": 121,
          "embedding": []
        },
        {
          "cs_scriptfile": "Patrol",
          "content": "private void GotoNextPoint() { // Set the agent to go to the currently selected destination. var newPoint = _aiUnit.AstarAINavigation.GetNearRandomPoint(); PatrolPoint.Value = newPoint; _aiUnit.AstarAINavigation.SetDestination(PatrolPoint.Value); _aiUnit.CombatLeave(); _pathTimeoutCoroutine = StartCoroutine(PathTimeout()); } public override void OnStart() { GotoNextPoint(); } public override TaskStatus OnUpdate() { if (PatrolPoint.Value == Vector3.zero) { return TaskStatus.Failure;  if (_aiUnit.AstarAINavigation.HasArrived()) { GotoNextPoint(); return TaskStatus.Success;  ",
          "content_tokens": 159,
          "embedding": []
        },
        {
          "cs_scriptfile": "Patrol",
          "content": "if (_isPathTimeout) { _aiUnit.AstarAINavigation.Stop(); return TaskStatus.Failure; } return TaskStatus.Running; } private IEnumerator PathTimeout() { _isPathTimeout = false; DebugWrite.Log($\"[Patrol] {gameObject.name} PathTimeout: {_isPathTimeout}\", gameObject, _isDebug); yield return new WaitForSeconds(PATH_TIMEOUT); _isPathTimeout = true; DebugWrite.Log($\"[Patrol] {gameObject.name} PathTimeout: {_isPathTimeout}\", gameObject, _isDebug); } } }",
          "content_tokens": 136,
          "embedding": []
        }
      ],
      "length": 1514
    },
    {
      "filename": "RaiseDamageTakenEvent",
      "content": "using UnityEngine; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { [TaskDescription(\"Sends an event to the behavior tree, returns success after sending the event.\")] [BehaviorDesigner.Runtime.Tasks.HelpURL(\"https://www.opsive.com/support/documentation/behavior-designer/events/\")] [TaskIcon(\"{SkinColor}SendEventIcon.png\")] public class RaiseDamageTakenEvent : Action { [BehaviorDesigner.Runtime.Tasks.Tooltip(\"The GameObject of the behavior tree that should have the event sent to it. If null use the current behavior\")] public SharedGameObject targetGameObject; [BehaviorDesigner.Runtime.Tasks.Tooltip(\"The event to send\")] public SharedString eventName; [BehaviorDesigner.Runtime.Tasks.Tooltip(\"The group of the behavior tree that the event should be sent to\")] public SharedInt group; private BehaviorDesigner.Runtime.BehaviorTree behaviorTree; public override void OnStart() { var behaviorTrees = GetDefaultGameObject(targetGameObject.Value).GetComponents<BehaviorDesigner.Runtime.BehaviorTree>(); if (behaviorTrees.Length == 1) { behaviorTree = behaviorTrees[0]; } else if (behaviorTrees.Length > 1) { for (int i = 0; i < behaviorTrees.Length; ++i) { if (behaviorTrees[i].Group == group.Value) { behaviorTree = behaviorTrees[i]; break; } } // If the group can't be found then use the first behavior tree if (behaviorTree == null) { behaviorTree = behaviorTrees[0]; } } } public override TaskStatus OnUpdate() { //todo: add damage amount return TaskStatus.Failure; } public override void OnReset() { // Reset the properties back to their original values targetGameObject = null; eventName = \"\"; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RaiseDamageTakenEvent",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "RaiseDamageTakenEvent",
          "content": "using UnityEngine; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { [TaskDescription(\"Sends an event to the behavior tree, returns success after sending the event.\")] [BehaviorDesigner.Runtime.Tasks.HelpURL(\"https://www.opsive.com/support/documentation/behavior-designer/events/\")] [TaskIcon(\"{SkinColor}SendEventIcon.png\")] public class RaiseDamageTakenEvent : Action { [BehaviorDesigner.Runtime.Tasks.Tooltip(\"The GameObject of the behavior tree that should have the event sent to it. If null use the current behavior\")] public SharedGameObject targetGameObject; [BehaviorDesigner.Runtime.Tasks.Tooltip(\"The event to send\")] public SharedString eventName; [BehaviorDesigner.Runtime.Tasks.Tooltip(\"The group of the behavior tree that the event should be sent to\")] public SharedInt group; private BehaviorDesigner.Runtime.BehaviorTree behaviorTree; public override void OnStart() { var behaviorTrees = GetDefaultGameObject(targetGameObject.Value).GetComponents<BehaviorDesigner.Runtime.BehaviorTree>(); if (behaviorTrees.Length == 1) { behaviorTree = behaviorTrees[0]; } else if (behaviorTrees.Length > 1) { for (int i = 0; i < behaviorTrees.Length; ++i) { if (behaviorTrees[i].Group == group.Value) { behaviorTree = behaviorTrees[i]; break; } } // If the group can't be found then use the first behavior tree if (behaviorTree == null) { behaviorTree = behaviorTrees[0]; } } } public override TaskStatus OnUpdate() { //todo: add damage amount return TaskStatus.Failure; } public override void OnReset() { // Reset the properties back to their original values targetGameObject = null; eventName = \"\"; } } }",
          "content_tokens": 439,
          "embedding": []
        }
      ],
      "length": 1663
    },
    {
      "filename": "SearchTargetInRadius",
      "content": "using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using DungeonScrollerCore; using UnityEngine; namespace Zomb.BehaviorTree.Actions { public class SearchTargetInRadius : Conditional { public SharedTransform Target; private AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } public override TaskStatus OnUpdate() { int enemyIdInRadius = _aiUnit.SearchForEnemyInRadius(out bool isFound); DebugWrite.Log($\"[SearchTargetInRadius] enemyIdInRadius: {enemyIdInRadius}, isFound: {isFound}\", gameObject, isShowLog: _aiUnit.IsDebug); if (isFound) { _aiUnit.UpdateTarget(enemyIdInRadius); return TaskStatus.Success; } return TaskStatus.Failure; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SearchTargetInRadius",
          "content": "using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using DungeonScrollerCore; using UnityEngine; namespace Zomb.BehaviorTree.Actions { public class SearchTargetInRadius : Conditional { public SharedTransform Target; private AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } public override TaskStatus OnUpdate() { int enemyIdInRadius = _aiUnit.SearchForEnemyInRadius(out bool isFound); DebugWrite.Log($\"[SearchTargetInRadius] enemyIdInRadius: {enemyIdInRadius}, isFound: {isFound}\", gameObject, isShowLog: _aiUnit.IsDebug); if (isFound) { _aiUnit.UpdateTarget(enemyIdInRadius); return TaskStatus.Success; } return TaskStatus.Failure; } } }",
          "content_tokens": 195,
          "embedding": []
        }
      ],
      "length": 693
    },
    {
      "filename": "SetSpawnPoint",
      "content": "using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class SetSpawnPoint : Action { public SharedVector3 _spawnPoint; public SharedBool _isSpawnPointSet; public override void OnAwake() { if (!_isSpawnPointSet.Value) { _spawnPoint.Value = transform.position; _isSpawnPointSet.Value = true; } } public override TaskStatus OnUpdate() { if (_isSpawnPointSet.Value) { return TaskStatus.Success; } return TaskStatus.Failure; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SetSpawnPoint",
          "content": "using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class SetSpawnPoint : Action { public SharedVector3 _spawnPoint; public SharedBool _isSpawnPointSet; public override void OnAwake() { if (!_isSpawnPointSet.Value) { _spawnPoint.Value = transform.position; _isSpawnPointSet.Value = true; } } public override TaskStatus OnUpdate() { if (_isSpawnPointSet.Value) { return TaskStatus.Success; } return TaskStatus.Failure; } } }",
          "content_tokens": 128,
          "embedding": []
        }
      ],
      "length": 484
    },
    {
      "filename": "SetTargetFirstFromSurround",
      "content": "using System.Linq; using My.BehaviorTree.Actions; namespace Zomb.BehaviorTree.Actions { public class SetTargetFirstFromSurround : AIAction { public override void OnStart() { var firstTarget = _aiUnit.PlayersWithinSight.FirstOrDefault(); _aiUnit.UpdateTarget(firstTarget); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SetTargetFirstFromSurround",
          "content": "using System.Linq; using My.BehaviorTree.Actions; namespace Zomb.BehaviorTree.Actions { public class SetTargetFirstFromSurround : AIAction { public override void OnStart() { var firstTarget = _aiUnit.PlayersWithinSight.FirstOrDefault(); _aiUnit.UpdateTarget(firstTarget); } } }",
          "content_tokens": 77,
          "embedding": []
        }
      ],
      "length": 277
    },
    {
      "filename": "Shoot",
      "content": "using BehaviorDesigner.Runtime.Tasks; using FishnetInvector; using UnityEngine; namespace My.BehaviorTree.Actions { public class Shoot : AIAction { private FNvShooterManager _shooterManager; public override void OnAwake() { base.OnAwake(); _shooterManager = GetComponent<FNvShooterManager>(); } public override void OnStart() { Vector3 aimPosition = _aiUnit.GetTargetTransform().position + Vector3.up * 1.5f; _shooterManager.Shoot(aimPosition); } public override TaskStatus OnUpdate() { if (!_aiUnit.IsPlayingAttackAnimation) return TaskStatus.Running; return TaskStatus.Success; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Shoot",
          "content": "using BehaviorDesigner.Runtime.Tasks; using FishnetInvector; using UnityEngine; namespace My.BehaviorTree.Actions { public class Shoot : AIAction { private FNvShooterManager _shooterManager; public override void OnAwake() { base.OnAwake(); _shooterManager = GetComponent<FNvShooterManager>(); } public override void OnStart() { Vector3 aimPosition = _aiUnit.GetTargetTransform().position + Vector3.up * 1.5f; _shooterManager.Shoot(aimPosition); } public override TaskStatus OnUpdate() { if (!_aiUnit.IsPlayingAttackAnimation) return TaskStatus.Running; return TaskStatus.Success; } } }",
          "content_tokens": 157,
          "embedding": []
        }
      ],
      "length": 585
    },
    {
      "filename": "SlimeManSpawnSlime",
      "content": "using _ZombieRoyale.Scripts.AI.Boss_Perks; namespace My.BehaviorTree.Actions{ public class SlimeManSpawnSlime : AIAction { private SlimeSpawner _slimeSpawner; public override void OnAwake() { base.OnAwake(); _slimeSpawner = GetComponent<SlimeSpawner>(); } public override void OnStart() { base.OnStart(); _slimeSpawner.SpawnSlime(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SlimeManSpawnSlime",
          "content": "using _ZombieRoyale.Scripts.AI.Boss_Perks; namespace My.BehaviorTree.Actions{ public class SlimeManSpawnSlime : AIAction { private SlimeSpawner _slimeSpawner; public override void OnAwake() { base.OnAwake(); _slimeSpawner = GetComponent<SlimeSpawner>(); } public override void OnStart() { base.OnStart(); _slimeSpawner.SpawnSlime(); } } }",
          "content_tokens": 104,
          "embedding": []
        }
      ],
      "length": 338
    },
    {
      "filename": "StopMoving",
      "content": " namespace My.BehaviorTree.Actions { public class StopMoving : AIAction { public override void OnStart() { _aiUnit.AstarAINavigation.Stop(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "StopMoving",
          "content": "namespace My.BehaviorTree.Actions { public class StopMoving : AIAction { public override void OnStart() { _aiUnit.AstarAINavigation.Stop(); } } }",
          "content_tokens": 42,
          "embedding": []
        }
      ],
      "length": 146
    },
    {
      "filename": "StageBasedSelector",
      "content": " using UnityEngine; using System.Collections.Generic; using System.Linq; namespace BehaviorDesigner.Runtime.Tasks { [TaskDescription(\"Similar to the selector task, the random selector task will return success as soon as a child task returns success. \" + \"The difference is that the random selector class will run its children in a random order. The selector task is deterministic \" + \"in that it will always run the tasks from left to right within the tree. The random selector task shuffles the child tasks up and then begins \" + \"execution in a random order. Other than that the random selector class is the same as the selector class. It will continue running tasks \" + \"until a task completes successfully. If no child tasks return success then it will return failure.\")] [TaskIcon(\"{SkinColor}RandomSelectorIcon.png\")] public class StageBasedSelector : Composite { public SharedInt CurrentStage; public List<string> IncludedTasksPerStage; [Tooltip(\"Seed the random number generator to make things easier to debug\")] public int seed = 0; [Tooltip(\"Do we want to use the seed?\")] public bool useSeed = false; // A list of indexes of every child task. This list is used by the Fischer-Yates shuffle algorithm. private List<int> childIndexList = new List<int>(); // The random child index execution order. private Stack<int> childrenExecutionOrder = new Stack<int>(); // The task status of the last child ran. private TaskStatus executionStatus = TaskStatus.Inactive; public override void OnAwake() { // If specified, use the seed provided. if (useSeed) { Random.InitState(seed); } } public override void OnStart() { //Select considered child indices based on the current stage childIndexList.Clear(); childIndexList = IncludedTasksPerStage[CurrentStage.Value].Split(',').Select(int.Parse).ToList(); // Randomize the indecies ShuffleChilden(); } public override int CurrentChildIndex() { // Peek will return the index at the top of the stack. return childrenExecutionOrder.Peek(); } public override bool CanExecute() { // Continue exectuion if no task has return success and indexes still exist on the stack. return childrenExecutionOrder.Count > 0 && executionStatus != TaskStatus.Success; } public override void OnChildExecuted(TaskStatus childStatus) { // Pop the top index from the stack and set the execution status. if (childrenExecutionOrder.Count > 0) { childrenExecutionOrder.Pop(); } executionStatus = childStatus; } public override void OnConditionalAbort(int childIndex) { // Start from the beginning on an abort childrenExecutionOrder.Clear(); executionStatus = TaskStatus.Inactive; ShuffleChilden(); } public override void OnEnd() { // All of the children have run. Reset the variables back to their starting values. executionStatus = TaskStatus.Inactive; childrenExecutionOrder.Clear(); } public override void OnReset() { // Reset the public properties back to their original values seed = 0; useSeed = false; } private void ShuffleChilden() { // Use Fischer-Yates shuffle to randomize the child index order. for (int i = childIndexList.Count; i > 0; --i) { int j = Random.Range(0, i); int index = childIndexList[j]; childrenExecutionOrder.Push(index); childIndexList[j] = childIndexList[i - 1]; childIndexList[i - 1] = index; } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "StageBasedSelector",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "StageBasedSelector",
          "content": " using UnityEngine; using System.Collections.Generic; using System.Linq; namespace BehaviorDesigner.Runtime.Tasks { [TaskDescription(\"Similar to the selector task, the random selector task will return success as soon as a child task returns success. \" + \"The difference is that the random selector class will run its children in a random order. The selector task is deterministic \" + \"in that it will always run the tasks from left to right within the tree. The random selector task shuffles the child tasks up and then begins \" + \"execution in a random order. Other than that the random selector class is the same as the selector class. It will continue running tasks \" + \"until a task completes successfully. If no child tasks return success then it will return failure.\")] [TaskIcon(\"{SkinColor}RandomSelectorIcon.png\")] public class StageBasedSelector : Composite { public SharedInt CurrentStage; public List<string> IncludedTasksPerStage; [Tooltip(\"Seed the random number generator to make things easier to debug\")] public int seed = 0; [Tooltip(\"Do we want to use the seed?\")] public bool useSeed = false; // A list of indexes of every child task. This list is used by the Fischer-Yates shuffle algorithm. private List<int> childIndexList = new List<int>(); // The random child index execution order. private Stack<int> childrenExecutionOrder = new Stack<int>(); // The task status of the last child ran. private TaskStatus executionStatus = TaskStatus.Inactive; public override void OnAwake() { // If specified, use the seed provided. if (useSeed) { Random.InitState(seed); } } public override void OnStart() { //Select considered child indices based on the current stage childIndexList.Clear(); childIndexList = IncludedTasksPerStage[CurrentStage.Value].Split(',').Select(int.Parse).ToList(); // Randomize the indecies ShuffleChilden(); } public override int CurrentChildIndex() { // Peek will return the index at the top of the stack. return childrenExecutionOrder.Peek(); } public override bool CanExecute() { // Continue exectuion if no task has return success and indexes still exist on the stack. return childrenExecutionOrder.Count > 0 && executionStatus != TaskStatus.Success; } public override void OnChildExecuted(TaskStatus childStatus) { // Pop the top index from the stack and set the execution status. if (childrenExecutionOrder.Count > 0) { childrenExecutionOrder.Pop(); } executionStatus = childStatus; } public override void OnConditionalAbort(int childIndex) { // Start from the beginning on an abort childrenExecutionOrder.Clear(); executionStatus = TaskStatus.Inactive; ShuffleChilden(); } public override void OnEnd() { // All of the children have run. Reset the variables back to their starting values. executionStatus = TaskStatus.Inactive; childrenExecutionOrder.Clear(); } public override void OnReset() { // Reset the public properties back to their original values seed = 0; useSeed = false;  ",
          "content_tokens": 681,
          "embedding": []
        },
        {
          "cs_scriptfile": "StageBasedSelector",
          "content": "private void ShuffleChilden() { // Use Fischer-Yates shuffle to randomize the child index order. for (int i = childIndexList.Count; i > 0; --i) { int j = Random.Range(0, i); int index = childIndexList[j]; childrenExecutionOrder.Push(index); childIndexList[j] = childIndexList[i - 1]; childIndexList[i - 1] = index; } } } }",
          "content_tokens": 101,
          "embedding": []
        }
      ],
      "length": 3250
    },
    {
      "filename": "AIConditional",
      "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class AIConditional : Conditional { protected AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AIConditional",
          "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class AIConditional : Conditional { protected AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } } }",
          "content_tokens": 59,
          "embedding": []
        }
      ],
      "length": 215
    },
    {
      "filename": "BossRockGolemMovingStonesIsKillable",
      "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.AI.Boss_Perks; using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; using UnityEngine; namespace Zomb.BehaviorTree.Actions { public class BossRockGolemMovingStonesKillable : AIConditional { private MovingStones _movingStones; public override void OnAwake() { base.OnAwake(); _movingStones = GetComponent<MovingStones>(); } public override TaskStatus OnUpdate() { if (_movingStones.IsStonesKillable) { return TaskStatus.Success; } return TaskStatus.Failure; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BossRockGolemMovingStonesIsKillable",
          "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.AI.Boss_Perks; using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; using UnityEngine; namespace Zomb.BehaviorTree.Actions { public class BossRockGolemMovingStonesKillable : AIConditional { private MovingStones _movingStones; public override void OnAwake() { base.OnAwake(); _movingStones = GetComponent<MovingStones>(); } public override TaskStatus OnUpdate() { if (_movingStones.IsStonesKillable) { return TaskStatus.Success; } return TaskStatus.Failure; } } }",
          "content_tokens": 158,
          "embedding": []
        }
      ],
      "length": 566
    },
    {
      "filename": "BossRockGolemMovingStonesReady",
      "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.AI.Boss_Perks; using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; using UnityEngine; namespace Zomb.BehaviorTree.Actions { public class BossRockGolemMovingStonesReady : AIConditional { private MovingStones _movingStones; public override void OnAwake() { base.OnAwake(); _movingStones = GetComponent<MovingStones>(); } public override TaskStatus OnUpdate() { if (_movingStones.IsOnCooldown) { return TaskStatus.Failure; } return TaskStatus.Success; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BossRockGolemMovingStonesReady",
          "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.AI.Boss_Perks; using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; using UnityEngine; namespace Zomb.BehaviorTree.Actions { public class BossRockGolemMovingStonesReady : AIConditional { private MovingStones _movingStones; public override void OnAwake() { base.OnAwake(); _movingStones = GetComponent<MovingStones>(); } public override TaskStatus OnUpdate() { if (_movingStones.IsOnCooldown) { return TaskStatus.Failure; } return TaskStatus.Success; } } }",
          "content_tokens": 155,
          "embedding": []
        }
      ],
      "length": 559
    },
    {
      "filename": "DontHaveTarget",
      "content": "using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; namespace Zomb.BehaviorTree.Actions { public class DontHaveTarget : AIConditional { public override TaskStatus OnUpdate() { return _aiUnit.IsHaveTarget ? TaskStatus.Failure : TaskStatus.Success; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DontHaveTarget",
          "content": "using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; namespace Zomb.BehaviorTree.Actions { public class DontHaveTarget : AIConditional { public override TaskStatus OnUpdate() { return _aiUnit.IsHaveTarget ? TaskStatus.Failure : TaskStatus.Success; } } }",
          "content_tokens": 73,
          "embedding": []
        }
      ],
      "length": 269
    },
    {
      "filename": "OnUnitHealthDropsBelowPercent",
      "content": "using UnityEngine; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; namespace ZomFI.BehaviorTree.Events { [TaskDescription(\"Returns success as soon as the event specified by eventName has been received.\")] [TaskIcon(\"{SkinColor}HasReceivedEventIcon.png\")] public class OnUnitHealthDropsBelowPercent : AIConditional { [BehaviorDesigner.Runtime.Tasks.Tooltip(\"The name of the event to receive\")] public SharedString eventName = \"\"; public SharedInt HealthPercent; private bool registered = false; private bool eventReceived = false; public override void OnStart() { // Let the behavior tree know that we are interested in receiving the event specified if (!registered) { Owner.RegisterEvent<object>(eventName.Value, ReceivedEvent); registered = true; } } public override TaskStatus OnUpdate() { return eventReceived ? TaskStatus.Success : TaskStatus.Failure; } public override void OnEnd() { if (eventReceived) { Owner.UnregisterEvent<object>(eventName.Value, ReceivedEvent); registered = false; } eventReceived = false; } private void ReceivedEvent() => eventReceived = true; private void ReceivedEvent(object arg1) { int healthPercent = (int)arg1; if (HealthPercent.Value == healthPercent) { ReceivedEvent(); } Debug.Log($\"[OnUnitHealthBelowPercent] Event Received data: {healthPercent}\"); } public override void OnBehaviorComplete() { // Stop receiving the event when the behavior tree is complete Owner.UnregisterEvent(eventName.Value, ReceivedEvent); eventReceived = false; registered = false; } // Reset the properties back to their original values public override void OnReset() { eventName = \"\"; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "OnUnitHealthDropsBelowPercent",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "OnUnitHealthDropsBelowPercent",
          "content": "using UnityEngine; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; namespace ZomFI.BehaviorTree.Events { [TaskDescription(\"Returns success as soon as the event specified by eventName has been received.\")] [TaskIcon(\"{SkinColor}HasReceivedEventIcon.png\")] public class OnUnitHealthDropsBelowPercent : AIConditional { [BehaviorDesigner.Runtime.Tasks.Tooltip(\"The name of the event to receive\")] public SharedString eventName = \"\"; public SharedInt HealthPercent; private bool registered = false; private bool eventReceived = false; public override void OnStart() { // Let the behavior tree know that we are interested in receiving the event specified if (!registered) { Owner.RegisterEvent<object>(eventName.Value, ReceivedEvent); registered = true; } } public override TaskStatus OnUpdate() { return eventReceived ? TaskStatus.Success : TaskStatus.Failure; } public override void OnEnd() { if (eventReceived) { Owner.UnregisterEvent<object>(eventName.Value, ReceivedEvent); registered = false; } eventReceived = false;  ",
          "content_tokens": 260,
          "embedding": []
        },
        {
          "cs_scriptfile": "OnUnitHealthDropsBelowPercent",
          "content": "private void ReceivedEvent() => eventReceived = true; private void ReceivedEvent(object arg1) { int healthPercent = (int)arg1; if (HealthPercent.Value == healthPercent) { ReceivedEvent(); } Debug.Log($\"[OnUnitHealthBelowPercent] Event Received data: {healthPercent}\"); } public override void OnBehaviorComplete() { // Stop receiving the event when the behavior tree is complete Owner.UnregisterEvent(eventName.Value, ReceivedEvent); eventReceived = false; registered = false; } // Reset the properties back to their original values public override void OnReset() { eventName = \"\"; } } }",
          "content_tokens": 138,
          "embedding": []
        }
      ],
      "length": 1659
    },
    {
      "filename": "OnUnitHeardSound",
      "content": "using UnityEngine; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; namespace ZomFI.BehaviorTree.Events { [TaskDescription(\"Returns success as soon as the event specified by eventName has been received.\")] [TaskIcon(\"{SkinColor}HasReceivedEventIcon.png\")] public class OnUnitHeardSound : Conditional { [BehaviorDesigner.Runtime.Tasks.Tooltip(\"The name of the event to receive\")] public SharedString eventName = \"\"; public SharedVector3 interestPos; public SharedBool didHearSound; private bool registered = false; private bool eventReceived = false; public override void OnStart() { // Let the behavior tree know that we are interested in receiving the event specified if (!registered) { Owner.RegisterEvent<object>(eventName.Value, ReceivedEvent); registered = true; } } public override TaskStatus OnUpdate() { return eventReceived ? TaskStatus.Success : TaskStatus.Failure; } public override void OnEnd() { if (eventReceived) { Owner.UnregisterEvent<object>(eventName.Value, ReceivedEvent); registered = false; } eventReceived = false; } private void ReceivedEvent() => eventReceived = true; private void ReceivedEvent(object arg1) { didHearSound.Value = true; ReceivedEvent(); interestPos.Value = arg1 is Vector3 ? (Vector3) arg1 : default; } public override void OnBehaviorComplete() { // Stop receiving the event when the behavior tree is complete Owner.UnregisterEvent(eventName.Value, ReceivedEvent); eventReceived = false; registered = false; } // Reset the properties back to their original values public override void OnReset() { eventName = \"\"; } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "OnUnitHeardSound",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "OnUnitHeardSound",
          "content": "using UnityEngine; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; namespace ZomFI.BehaviorTree.Events { [TaskDescription(\"Returns success as soon as the event specified by eventName has been received.\")] [TaskIcon(\"{SkinColor}HasReceivedEventIcon.png\")] public class OnUnitHeardSound : Conditional { [BehaviorDesigner.Runtime.Tasks.Tooltip(\"The name of the event to receive\")] public SharedString eventName = \"\"; public SharedVector3 interestPos; public SharedBool didHearSound; private bool registered = false; private bool eventReceived = false; public override void OnStart() { // Let the behavior tree know that we are interested in receiving the event specified if (!registered) { Owner.RegisterEvent<object>(eventName.Value, ReceivedEvent); registered = true; } } public override TaskStatus OnUpdate() { return eventReceived ? TaskStatus.Success : TaskStatus.Failure; } public override void OnEnd() { if (eventReceived) { Owner.UnregisterEvent<object>(eventName.Value, ReceivedEvent); registered = false; } eventReceived = false;  ",
          "content_tokens": 256,
          "embedding": []
        },
        {
          "cs_scriptfile": "OnUnitHeardSound",
          "content": "private void ReceivedEvent() => eventReceived = true; private void ReceivedEvent(object arg1) { didHearSound.Value = true; ReceivedEvent(); interestPos.Value = arg1 is Vector3 ? (Vector3) arg1 : default; } public override void OnBehaviorComplete() { // Stop receiving the event when the behavior tree is complete Owner.UnregisterEvent(eventName.Value, ReceivedEvent); eventReceived = false; registered = false; } // Reset the properties back to their original values public override void OnReset() { eventName = \"\"; } } }",
          "content_tokens": 125,
          "embedding": []
        }
      ],
      "length": 1583
    },
    {
      "filename": "OnUnitTakeDamage",
      "content": "using UnityEngine; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; namespace ZomFI.BehaviorTree.Events { [TaskDescription(\"Returns success as soon as the event specified by eventName has been received.\")] [TaskIcon(\"{SkinColor}HasReceivedEventIcon.png\")] public class OnUnitTakeDamage : Conditional { [BehaviorDesigner.Runtime.Tasks.Tooltip(\"The name of the event to receive\")] public SharedString eventName = \"\"; private AIUnit _aiUnit; public SharedTransform Target; private bool registered = false; private bool eventReceived = false; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } public override void OnStart() { // Let the behavior tree know that we are interested in receiving the event specified if (!registered) { Owner.RegisterEvent<object>(eventName.Value, ReceivedEvent); registered = true; } } public override TaskStatus OnUpdate() { return eventReceived ? TaskStatus.Success : TaskStatus.Failure; } public override void OnEnd() { if (eventReceived) { Owner.UnregisterEvent<object>(eventName.Value, ReceivedEvent); registered = false; } eventReceived = false; } private void ReceivedEvent() => eventReceived = true; private void ReceivedEvent(object objectId) { ReceivedEvent(); _aiUnit.UpdateTarget((int)objectId); //Target.Value = arg1 is int ? (int)arg1 : null; Debug.Log($\"[OnUnitTakeDamage] Event Received data: {objectId}. Transform.Value is set.\"); } public override void OnBehaviorComplete() { // Stop receiving the event when the behavior tree is complete Owner.UnregisterEvent(eventName.Value, ReceivedEvent); eventReceived = false; registered = false; } // Reset the properties back to their original values public override void OnReset() { eventName = \"\"; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "OnUnitTakeDamage",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "OnUnitTakeDamage",
          "content": "using UnityEngine; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; namespace ZomFI.BehaviorTree.Events { [TaskDescription(\"Returns success as soon as the event specified by eventName has been received.\")] [TaskIcon(\"{SkinColor}HasReceivedEventIcon.png\")] public class OnUnitTakeDamage : Conditional { [BehaviorDesigner.Runtime.Tasks.Tooltip(\"The name of the event to receive\")] public SharedString eventName = \"\"; private AIUnit _aiUnit; public SharedTransform Target; private bool registered = false; private bool eventReceived = false; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } public override void OnStart() { // Let the behavior tree know that we are interested in receiving the event specified if (!registered) { Owner.RegisterEvent<object>(eventName.Value, ReceivedEvent); registered = true; } } public override TaskStatus OnUpdate() { return eventReceived ? TaskStatus.Success : TaskStatus.Failure; } public override void OnEnd() { if (eventReceived) { Owner.UnregisterEvent<object>(eventName.Value, ReceivedEvent); registered = false; } eventReceived = false;  ",
          "content_tokens": 271,
          "embedding": []
        },
        {
          "cs_scriptfile": "OnUnitTakeDamage",
          "content": "private void ReceivedEvent() => eventReceived = true; private void ReceivedEvent(object objectId) { ReceivedEvent(); _aiUnit.UpdateTarget((int)objectId); //Target.Value = arg1 is int ? (int)arg1 : null; Debug.Log($\"[OnUnitTakeDamage] Event Received data: {objectId}. Transform.Value is set.\"); } public override void OnBehaviorComplete() { // Stop receiving the event when the behavior tree is complete Owner.UnregisterEvent(eventName.Value, ReceivedEvent); eventReceived = false; registered = false; } // Reset the properties back to their original values public override void OnReset() { eventName = \"\"; } } }",
          "content_tokens": 151,
          "embedding": []
        }
      ],
      "length": 1730
    },
    {
      "filename": "IsAnybodyWithinSight",
      "content": "using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using UnityEngine; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; namespace Zomb.BehaviorTree.Actions { public class IsAnybodyWithinSight : Conditional { public SharedFloat ViewDistance; public string TargetTag = \"Player\"; public string[] Obstacles = new[] {\"Obstacle\", \"Default\"}; public SharedTransform Target; public SharedVector3 InterestPos; private List<Transform> _possibleTargets; private AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } private void UpdateTargetsList() { var targets = _aiUnit.GetAllPlayers(); _possibleTargets = new List<Transform>(); foreach (var tar in targets) { if (tar.FishnetInvectorHealthController.IsDead) { continue; } _possibleTargets.Add(tar.transform); } } public override void OnStart() { UpdateTargetsList(); } public override TaskStatus OnUpdate() { var playersWithinSight = _aiUnit.PlayersWithinSight; foreach (int playerObjectId in playersWithinSight) { Vector3 startRayPos; Vector3 direction; var player = GameplayManager.Instance.GetUnitComponentsServerAndClient(playerObjectId); if (player.HealthController.IsDead) continue; if (!IsInFrontOfAI(player.HealthController.transform.position, out startRayPos, out direction)) continue; _aiUnit.UpdateTarget(playerObjectId); InterestPos.Value = player.HealthController.transform.position; _aiUnit.CombatEnter(); //Debug.Log($\"[{possibleTarget.name}] is within sight of [{gameObject.name}]\"); return TaskStatus.Success; } Target.Value = null; return TaskStatus.Failure; } private bool IsInFrontOfAI(Vector3 targetPos, out Vector3 startRayPos, out Vector3 direction) { startRayPos = transform.position - transform.forward * 1f + new Vector3(0, 1.3f, 0); direction = targetPos - startRayPos; float angle = Vector3.Angle(direction, transform.forward); //Debug.Log($\"[WithinSight] {gameObject.name} angle: {angle}\"); if (angle < _aiUnit.EnemyDefinition.FieldOfView * 0.5f) return true; return false; } public override void OnReset() { TargetTag = \"Player\"; Target = null; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IsAnybodyWithinSight",
          "content": "using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using UnityEngine; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; namespace Zomb.BehaviorTree.Actions { public class IsAnybodyWithinSight : Conditional { public SharedFloat ViewDistance; public string TargetTag = \"Player\"; public string[] Obstacles = new[] {\"Obstacle\", \"Default\"}; public SharedTransform Target; public SharedVector3 InterestPos; private List<Transform> _possibleTargets; private AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>();  ",
          "content_tokens": 165,
          "embedding": []
        },
        {
          "cs_scriptfile": "IsAnybodyWithinSight",
          "content": "private void UpdateTargetsList() { var targets = _aiUnit.GetAllPlayers(); _possibleTargets = new List<Transform>(); foreach (var tar in targets) { if (tar.FishnetInvectorHealthController.IsDead) { continue; } _possibleTargets.Add(tar.transform); } } public override void OnStart() { UpdateTargetsList(); } public override TaskStatus OnUpdate() { var playersWithinSight = _aiUnit.PlayersWithinSight; foreach (int playerObjectId in playersWithinSight) { Vector3 startRayPos; Vector3 direction; var player = GameplayManager.Instance.GetUnitComponentsServerAndClient(playerObjectId); if (player.HealthController.IsDead) continue; if (!IsInFrontOfAI(player.HealthController.transform.position, out startRayPos, out direction)) continue; _aiUnit.UpdateTarget(playerObjectId); InterestPos.Value = player.HealthController.transform.position; _aiUnit.CombatEnter(); //Debug.Log($\"[{possibleTarget.name}] is within sight of [{gameObject.name}]\"); return TaskStatus.Success; } Target.Value = null; return TaskStatus.Failure;  ",
          "content_tokens": 276,
          "embedding": []
        },
        {
          "cs_scriptfile": "IsAnybodyWithinSight",
          "content": "private bool IsInFrontOfAI(Vector3 targetPos, out Vector3 startRayPos, out Vector3 direction) { startRayPos = transform.position - transform.forward * 1f + new Vector3(0, 1.3f, 0); direction = targetPos - startRayPos; float angle = Vector3.Angle(direction, transform.forward); //Debug.Log($\"[WithinSight] {gameObject.name} angle: {angle}\"); if (angle < _aiUnit.EnemyDefinition.FieldOfView * 0.5f) return true; return false; } public override void OnReset() { TargetTag = \"Player\"; Target = null; } } }",
          "content_tokens": 149,
          "embedding": []
        }
      ],
      "length": 2146
    },
    {
      "filename": "IsAttackInCooldown",
      "content": "using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; namespace Zomb.BehaviorTree.Actions { public class IsAttackInCooldown : AIConditional { public override TaskStatus OnUpdate() { if (_aiUnit.IsAttackOnCooldown) { return TaskStatus.Success; } return TaskStatus.Failure; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IsAttackInCooldown",
          "content": "using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; namespace Zomb.BehaviorTree.Actions { public class IsAttackInCooldown : AIConditional { public override TaskStatus OnUpdate() { if (_aiUnit.IsAttackOnCooldown) { return TaskStatus.Success; } return TaskStatus.Failure; } } }",
          "content_tokens": 78,
          "embedding": []
        }
      ],
      "length": 292
    },
    {
      "filename": "IsAttackNotInCooldown",
      "content": "using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; namespace Zomb.BehaviorTree.Actions { public class IsAttackNotInCooldown : AIConditional { public override TaskStatus OnUpdate() { if (_aiUnit.IsAttackOnCooldown) { return TaskStatus.Failure; } return TaskStatus.Success; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IsAttackNotInCooldown",
          "content": "using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; namespace Zomb.BehaviorTree.Actions { public class IsAttackNotInCooldown : AIConditional { public override TaskStatus OnUpdate() { if (_aiUnit.IsAttackOnCooldown) { return TaskStatus.Failure; } return TaskStatus.Success; } } }",
          "content_tokens": 79,
          "embedding": []
        }
      ],
      "length": 295
    },
    {
      "filename": "IsCombatReady",
      "content": "using UnityEngine; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class IsCombatReady : Conditional { public override TaskStatus OnUpdate() { //TODO: Check if AI is stunned, silenced, etc. return TaskStatus.Success; } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IsCombatReady",
          "content": "using UnityEngine; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class IsCombatReady : Conditional { public override TaskStatus OnUpdate() { //TODO: Check if AI is stunned, silenced, etc. return TaskStatus.Success; } } }",
          "content_tokens": 72,
          "embedding": []
        }
      ],
      "length": 288
    },
    {
      "filename": "IsDead",
      "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class IsDead : Conditional { private AIUnit _aiController; public override void OnAwake() { _aiController = GetComponent<AIUnit>(); } public override TaskStatus OnUpdate() { return _aiController.HealthController.IsDead ? TaskStatus.Success : TaskStatus.Failure; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IsDead",
          "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class IsDead : Conditional { private AIUnit _aiController; public override void OnAwake() { _aiController = GetComponent<AIUnit>(); } public override TaskStatus OnUpdate() { return _aiController.HealthController.IsDead ? TaskStatus.Success : TaskStatus.Failure; } } }",
          "content_tokens": 87,
          "embedding": []
        }
      ],
      "length": 348
    },
    {
      "filename": "IsHaveTarget",
      "content": "using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; namespace Zomb.BehaviorTree.Actions { public class IsHaveTarget : AIConditional { public override TaskStatus OnUpdate() { return _aiUnit.IsHaveTarget ? TaskStatus.Success : TaskStatus.Failure ; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IsHaveTarget",
          "content": "using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; namespace Zomb.BehaviorTree.Actions { public class IsHaveTarget : AIConditional { public override TaskStatus OnUpdate() { return _aiUnit.IsHaveTarget ? TaskStatus.Success : TaskStatus.Failure ; } } }",
          "content_tokens": 72,
          "embedding": []
        }
      ],
      "length": 268
    },
    {
      "filename": "IsInCombatMultipleOfTime",
      "content": "using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class IsInCombatMultipleOfTime : AIConditional { public SharedFloat EveryXSeconds; public override TaskStatus OnUpdate() { if (_aiUnit.TimeInCombat % EveryXSeconds.Value == 0) { return TaskStatus.Success; } return TaskStatus.Failure; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IsInCombatMultipleOfTime",
          "content": "using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class IsInCombatMultipleOfTime : AIConditional { public SharedFloat EveryXSeconds; public override TaskStatus OnUpdate() { if (_aiUnit.TimeInCombat % EveryXSeconds.Value == 0) { return TaskStatus.Success; } return TaskStatus.Failure; } } }",
          "content_tokens": 92,
          "embedding": []
        }
      ],
      "length": 352
    },
    {
      "filename": "IsMovingStonesSpawned",
      "content": "using _ZombieRoyale.Scripts.AI.Boss_Perks; using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class IsMovingStonesSpawned : Conditional { private MovingStones _movingStones; public override void OnAwake() { _movingStones = GetComponent<MovingStones>(); } public override TaskStatus OnUpdate() { if (_movingStones.IsStonesSpawned) { return TaskStatus.Success; } return TaskStatus.Failure; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IsMovingStonesSpawned",
          "content": "using _ZombieRoyale.Scripts.AI.Boss_Perks; using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class IsMovingStonesSpawned : Conditional { private MovingStones _movingStones; public override void OnAwake() { _movingStones = GetComponent<MovingStones>(); } public override TaskStatus OnUpdate() { if (_movingStones.IsStonesSpawned) { return TaskStatus.Success; } return TaskStatus.Failure; } } }",
          "content_tokens": 117,
          "embedding": []
        }
      ],
      "length": 423
    },
    {
      "filename": "IsNotPlayingAttackAnimation",
      "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class IsNotPlayingAttackAnimation : AIConditional { public override TaskStatus OnUpdate() { if (_aiUnit.IsPlayingAttackAnimation) { return TaskStatus.Failure; } return TaskStatus.Success; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IsNotPlayingAttackAnimation",
          "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class IsNotPlayingAttackAnimation : AIConditional { public override TaskStatus OnUpdate() { if (_aiUnit.IsPlayingAttackAnimation) { return TaskStatus.Failure; } return TaskStatus.Success; } } }",
          "content_tokens": 68,
          "embedding": []
        }
      ],
      "length": 274
    },
    {
      "filename": "IsPaused",
      "content": "using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; namespace Zomb.BehaviorTree.Actions { public class IsPaused : AIConditional { public override TaskStatus OnUpdate() { if (_aiUnit.IsPaused) { return TaskStatus.Success; } return TaskStatus.Failure; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IsPaused",
          "content": "using BehaviorDesigner.Runtime.Tasks; using My.BehaviorTree.Actions; namespace Zomb.BehaviorTree.Actions { public class IsPaused : AIConditional { public override TaskStatus OnUpdate() { if (_aiUnit.IsPaused) { return TaskStatus.Success; } return TaskStatus.Failure; } } }",
          "content_tokens": 76,
          "embedding": []
        }
      ],
      "length": 272
    },
    {
      "filename": "IsPlayingAttackAnimation",
      "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class IsPlayingAttackAnimation : AIConditional { public override TaskStatus OnUpdate() { if (_aiUnit.IsPlayingAttackAnimation) { return TaskStatus.Success; } return TaskStatus.Failure; } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IsPlayingAttackAnimation",
          "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class IsPlayingAttackAnimation : AIConditional { public override TaskStatus OnUpdate() { if (_aiUnit.IsPlayingAttackAnimation) { return TaskStatus.Success; } return TaskStatus.Failure; } } }",
          "content_tokens": 67,
          "embedding": []
        }
      ],
      "length": 272
    },
    {
      "filename": "IsRecentlyFought",
      "content": "using BehaviorDesigner.Runtime.Tasks; namespace Zomb.BehaviorTree.Actions { public class IsRecentlyFought : Conditional { private AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } public override TaskStatus OnUpdate() { if (_aiUnit.IsAware) return TaskStatus.Success; return TaskStatus.Failure; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IsRecentlyFought",
          "content": "using BehaviorDesigner.Runtime.Tasks; namespace Zomb.BehaviorTree.Actions { public class IsRecentlyFought : Conditional { private AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } public override TaskStatus OnUpdate() { if (_aiUnit.IsAware) return TaskStatus.Success; return TaskStatus.Failure; } } }",
          "content_tokens": 90,
          "embedding": []
        }
      ],
      "length": 335
    },
    {
      "filename": "IsTargetAlive",
      "content": "using _ZombieRoyale.Scripts.Core; using BehaviorDesigner.Runtime.Tasks; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishnetInvector; using My.BehaviorTree.Actions; namespace Zomb.BehaviorTree.Actions { public class IsTargetAlive : AIConditional { private int _targetObjectId; private FishnetInvectorHealthController _targetHealthController; public override void OnStart() { _targetObjectId = _aiUnit.GetTargetId(); var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(_targetObjectId); _targetHealthController = unitComps.HealthController; } public override TaskStatus OnUpdate() { if (_targetHealthController == null) { DebugWrite.LogError($\"[IsTargetDead] CriticalError! targetHealthController is null for #{_targetObjectId}\", gameObject); return TaskStatus.Failure; } if (_targetHealthController.IsDead) { return TaskStatus.Failure; } return TaskStatus.Success; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IsTargetAlive",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "IsTargetAlive",
          "content": "using _ZombieRoyale.Scripts.Core; using BehaviorDesigner.Runtime.Tasks; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishnetInvector; using My.BehaviorTree.Actions; namespace Zomb.BehaviorTree.Actions { public class IsTargetAlive : AIConditional { private int _targetObjectId; private FishnetInvectorHealthController _targetHealthController; public override void OnStart() { _targetObjectId = _aiUnit.GetTargetId(); var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(_targetObjectId); _targetHealthController = unitComps.HealthController; } public override TaskStatus OnUpdate() { if (_targetHealthController == null) { DebugWrite.LogError($\"[IsTargetDead] CriticalError! targetHealthController is null for #{_targetObjectId}\", gameObject); return TaskStatus.Failure;  ",
          "content_tokens": 216,
          "embedding": []
        },
        {
          "cs_scriptfile": "IsTargetAlive",
          "content": "if (_targetHealthController.IsDead) { return TaskStatus.Failure; } return TaskStatus.Success; } } }",
          "content_tokens": 26,
          "embedding": []
        }
      ],
      "length": 936
    },
    {
      "filename": "IsTargetDead",
      "content": "using _ZombieRoyale.Scripts.Core; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; namespace My.BehaviorTree.Actions { public class IsTargetDead : Conditional { public SharedTransform Target; private AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } public override TaskStatus OnUpdate() { int targetObjectId = _aiUnit.GetTargetId(); if (targetObjectId < 1) { //Debug.LogError($\"[IsTargetDead] CriticalError! targetObjectId: {targetObjectId} not found in PlayerPositions\", gameObject); return TaskStatus.Success; } var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetObjectId); var targetHealthController = unitComps.HealthController; if (targetHealthController == null) { Debug.LogError($\"[IsTargetDead] CriticalError! targetHealthController is null for #{targetObjectId}\", gameObject); return TaskStatus.Success; } if (targetHealthController.IsDead) { Debug.Log($\"[IsTargetDead] #{targetObjectId} is dead: {targetHealthController.IsDead}\"); return TaskStatus.Success; } return TaskStatus.Failure; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IsTargetDead",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "IsTargetDead",
          "content": "using _ZombieRoyale.Scripts.Core; using BehaviorDesigner.Runtime; using BehaviorDesigner.Runtime.Tasks; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; namespace My.BehaviorTree.Actions { public class IsTargetDead : Conditional { public SharedTransform Target; private AIUnit _aiUnit; public override void OnAwake() { _aiUnit = GetComponent<AIUnit>(); } public override TaskStatus OnUpdate() { int targetObjectId = _aiUnit.GetTargetId(); if (targetObjectId < 1) { //Debug.LogError($\"[IsTargetDead] CriticalError! targetObjectId: {targetObjectId} not found in PlayerPositions\", gameObject); return TaskStatus.Success; } var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetObjectId); var targetHealthController = unitComps.HealthController; if (targetHealthController == null) { Debug.LogError($\"[IsTargetDead] CriticalError! targetHealthController is null for #{targetObjectId}\", gameObject); return TaskStatus.Success;  ",
          "content_tokens": 253,
          "embedding": []
        },
        {
          "cs_scriptfile": "IsTargetDead",
          "content": "if (targetHealthController.IsDead) { Debug.Log($\"[IsTargetDead] #{targetObjectId} is dead: {targetHealthController.IsDead}\"); return TaskStatus.Success; } return TaskStatus.Failure; } } }",
          "content_tokens": 53,
          "embedding": []
        }
      ],
      "length": 1163
    },
    {
      "filename": "NotWithinAttackRange",
      "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class NotWithinAttackRange : AIConditional { public override TaskStatus OnUpdate() { if (_aiUnit.IsTargetWithinAttackDistance()) { return TaskStatus.Failure; } return TaskStatus.Success; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "NotWithinAttackRange",
          "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class NotWithinAttackRange : AIConditional { public override TaskStatus OnUpdate() { if (_aiUnit.IsTargetWithinAttackDistance()) { return TaskStatus.Failure; } return TaskStatus.Success; } } }",
          "content_tokens": 68,
          "embedding": []
        }
      ],
      "length": 273
    },
    {
      "filename": "WithinAttackRange",
      "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class WithinAttackRange : AIConditional { public override TaskStatus OnUpdate() { if (_aiUnit.IsTargetWithinAttackDistance()) { return TaskStatus.Success; } return TaskStatus.Failure; } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "WithinAttackRange",
          "content": "using BehaviorDesigner.Runtime.Tasks; namespace My.BehaviorTree.Actions { public class WithinAttackRange : AIConditional { public override TaskStatus OnUpdate() { if (_aiUnit.IsTargetWithinAttackDistance()) { return TaskStatus.Success; } return TaskStatus.Failure; } } }",
          "content_tokens": 67,
          "embedding": []
        }
      ],
      "length": 271
    },
    {
      "filename": "MovingStones",
      "content": "using System; using System.Collections; using System.Collections.Generic; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using UnityEngine; using Random = UnityEngine.Random; namespace _ZombieRoyale.Scripts.AI.Boss_Perks { public class MovingStones : UnitBehaviour { private static int MAXIMUM_STONES = 8; private static float STONES_LIFETIME_IN_FLIGHT = 7f; private static float SPAWN_STONES_COOLDOWN = 25.0f; /// <summary> /// Must be lower than SPAWN_STONES_COOLDOWN - TIME_TO_SHOOT_STONES - STONES_LIFETIME_IN_FLIGHT /// 25 - 3 - 7 = 15 > 10 - Good! /// </summary> private static float MINIMUM_MOVING_STONES_LIFETIME = 10.0f; private static float ABOVE_GROUND_METERS = .5f; [SerializeField] private FNvMeleeAttackObject[] _stonePrefabs; private static float STONES_SPAWN_RADIUS = 1.5f; private static float STONE_MOVING_SPEED = 300.0f; private static float STONE_ROTATING_SPEED = 300.0f; private static float NOVA_FORCE = 8.0f; private static float TIME_TO_SHOOT_STONES = 3.0f; public bool IsShooting => _isShooting; public bool IsOnCooldown => _isCooldown; public bool IsStonesSpawned => _isStonesSpawned; public bool IsStonesKillable => _isStonesKillable; private bool _isStonesSpawned = false; private bool _movingInCircle = false; private bool _isShooting; private Queue<Stone> _unusedStonesPool = new Queue<Stone>(); private List<Stone> _usedStonesPool = new List<Stone>(); private bool _isCooldown = false; private bool _isStonesKillable = false; [SerializeField] private bool _isDebug = true; private void Start() { for (int i = 0; i < _stonePrefabs.Length; i++) { InstantiateNewStone(); } SpawnStones(); } private void LateUpdate() { if (_isStonesSpawned) { if (_movingInCircle) { MoveStonesInCircle(); } } } [Server] public void SpawnStones() { if (!_isStonesSpawned) { _isStonesSpawned = true; StartCoroutine(StartCooldownTimer()); StartCoroutine(StartMovingStonesTimer()); ObserverSpawnStones(); } } [ObserversRpc(RunLocally = false)] private void ObserverSpawnStones() { for (int i = 0; i < MAXIMUM_STONES; i++) { float angle = i * 360.0f / MAXIMUM_STONES; float height = Random.Range(-.5f, .5f); Vector3 upPos = new Vector3(transform.position.x, transform.position.y + ABOVE_GROUND_METERS + height, transform.position.z); Vector3 spawnPos = upPos + Quaternion.Euler(0, angle, 0) * (Vector3.forward * STONES_SPAWN_RADIUS); var stone = AllocateStone(spawnPos); DebugWrite.Log($\"[MovingStones] Golem pos: {transform.position}; stone pos: {spawnPos}\", stone.StoneObject.gameObject, _isDebug); } _movingInCircle = true; _isStonesSpawned = true; } public void MoveStonesInCircle() { for (int i = 0; i < _usedStonesPool.Count; i++) { float angle = i * 360.0f / MAXIMUM_STONES + Time.time * STONE_MOVING_SPEED; Stone stone = _usedStonesPool[i]; ActivateDamageAtTheEndOfMovingCircle(angle, stone); Transform stoneTransform = stone.StoneObject.transform; Vector3 posWithStaticHeight = new Vector3(transform.position.x, stone.Height, transform.position.z); Vector3 newPos = posWithStaticHeight + Quaternion.Euler(0, angle, 0) * (Vector3.forward * STONES_SPAWN_RADIUS); stoneTransform.position = newPos; stoneTransform.Rotate(Vector3.up, Time.deltaTime * STONE_ROTATING_SPEED); } } private void ActivateDamageAtTheEndOfMovingCircle(float angle, Stone stone) { if (angle % 350f < 5f) { if (!stone.IsDamageAlreadyActivated) { DebugWrite.Log($\"[MovingStones] Activating damage for stone {stone.StoneObject.gameObject.name}\", stone.StoneObject.gameObject, _isDebug); stone.StoneObject.SetActiveDamage(true); stone.IsDamageAlreadyActivated = true; } } else { stone.IsDamageAlreadyActivated = false; } } [Server] public void StopAndShootStones() { ObserverStopAndShootStones(); StartCoroutine(CorIsShootingSwitcher()); } [ObserversRpc(RunLocally = false)] private void ObserverStopAndShootStones() { StartCoroutine(CorStopAndShootStones()); } private IEnumerator CorIsShootingSwitcher() { _isShooting = true; yield return new WaitForSeconds(TIME_TO_SHOOT_STONES); _isShooting = false; yield return new WaitForSeconds(STONES_LIFETIME_IN_FLIGHT); _isStonesSpawned = false; } private IEnumerator CorStopAndShootStones() { _movingInCircle = false; yield return new WaitForSeconds(TIME_TO_SHOOT_STONES); for (int i = 0; i < _usedStonesPool.Count; i++) { Vector3 direction = (_usedStonesPool[i].StoneObject.transform.position - transform.position).normalized; _usedStonesPool[i].RigidBody.isKinematic = false; _usedStonesPool[i].RigidBody.AddForce(direction * NOVA_FORCE, ForceMode.Impulse); } yield return new WaitForSeconds(STONES_LIFETIME_IN_FLIGHT); for (int i = 0; i < _usedStonesPool.Count; i++) { DeallocateStone(_usedStonesPool[i]); } _isStonesSpawned = false; yield return null; } [Server] private IEnumerator StartCooldownTimer() { var time = new WaitForSeconds(SPAWN_STONES_COOLDOWN); _isCooldown = true; yield return time; _isCooldown = false; } [Server] private IEnumerator StartMovingStonesTimer() { var time = new WaitForSeconds(MINIMUM_MOVING_STONES_LIFETIME); _isStonesKillable = false; yield return time; _isStonesKillable = true; } private Stone AllocateStone(Vector3 spawnPos) { if (_unusedStonesPool.Count == 0) { InstantiateNewStone(); } Stone stone = _unusedStonesPool.Dequeue(); stone.StoneObject.transform.position = spawnPos; stone.StoneObject.gameObject.SetActive(true); stone.RigidBody.isKinematic = true; stone.StoneObject.SetActiveDamage(true); stone.Height = spawnPos.y; _usedStonesPool.Add(stone); return stone; } private Stone InstantiateNewStone() { int id = Random.Range(0, _stonePrefabs.Length); var stone = Instantiate(_stonePrefabs[id]); foreach (var hitBox in stone.hitBoxes) { hitBox.Init(_meleeManager); } stone.transform.parent = transform; stone.gameObject.SetActive(false); Stone newStone = new Stone(stone, stone.GetComponent<Rigidbody>()); _unusedStonesPool.Enqueue(newStone); return newStone; } private void DeallocateStone(Stone stone) { _usedStonesPool.Remove(stone); _unusedStonesPool.Enqueue(stone); stone.RigidBody.isKinematic = true; stone.StoneObject.SetActiveDamage(false); stone.StoneObject.gameObject.SetActive(false); } [Serializable] public class Stone { public FNvMeleeAttackObject StoneObject; public Rigidbody RigidBody; public float Height; public bool IsDamageAlreadyActivated; public Stone(FNvMeleeAttackObject stoneObject, Rigidbody rigidBody) { StoneObject = stoneObject; RigidBody = rigidBody; } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MovingStones",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "MovingStones",
          "content": "using System; using System.Collections; using System.Collections.Generic; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using UnityEngine; using Random = UnityEngine.Random; namespace _ZombieRoyale.Scripts.AI.Boss_Perks { public class MovingStones : UnitBehaviour { private static int MAXIMUM_STONES = 8; private static float STONES_LIFETIME_IN_FLIGHT = 7f; private static float SPAWN_STONES_COOLDOWN = 25.0f; /// <summary> /// Must be lower than SPAWN_STONES_COOLDOWN - TIME_TO_SHOOT_STONES - STONES_LIFETIME_IN_FLIGHT /// 25 - 3 - 7 = 15 > 10 - Good! /// </summary> private static float MINIMUM_MOVING_STONES_LIFETIME = 10.0f; private static float ABOVE_GROUND_METERS = .5f; [SerializeField] private FNvMeleeAttackObject[] _stonePrefabs; private static float STONES_SPAWN_RADIUS = 1.5f; private static float STONE_MOVING_SPEED = 300.0f; private static float STONE_ROTATING_SPEED = 300.0f; private static float NOVA_FORCE = 8.0f; private static float TIME_TO_SHOOT_STONES = 3.0f; public bool IsShooting => _isShooting; public bool IsOnCooldown => _isCooldown; public bool IsStonesSpawned => _isStonesSpawned; public bool IsStonesKillable => _isStonesKillable; private bool _isStonesSpawned = false; private bool _movingInCircle = false; private bool _isShooting; private Queue<Stone> _unusedStonesPool = new Queue<Stone>(); private List<Stone> _usedStonesPool = new List<Stone>(); private bool _isCooldown = false; private bool _isStonesKillable = false; [SerializeField] private bool _isDebug = true; private void Start() { for (int i = 0; i < _stonePrefabs.Length; i++) { InstantiateNewStone();  ",
          "content_tokens": 522,
          "embedding": []
        },
        {
          "cs_scriptfile": "MovingStones",
          "content": "SpawnStones();  ",
          "content_tokens": 6,
          "embedding": []
        },
        {
          "cs_scriptfile": "MovingStones",
          "content": "private void LateUpdate() { if (_isStonesSpawned) { if (_movingInCircle) { MoveStonesInCircle(); } } } [Server] public void SpawnStones() { if (!_isStonesSpawned) { _isStonesSpawned = true; StartCoroutine(StartCooldownTimer()); StartCoroutine(StartMovingStonesTimer()); ObserverSpawnStones(); } } [ObserversRpc(RunLocally = false)] private void ObserverSpawnStones() { for (int i = 0; i < MAXIMUM_STONES; i++) { float angle = i * 360.0f / MAXIMUM_STONES; float height = Random.Range(-.5f, .5f); Vector3 upPos = new Vector3(transform.position.x, transform.position.y + ABOVE_GROUND_METERS + height, transform.position.z); Vector3 spawnPos = upPos + Quaternion.Euler(0, angle, 0) * (Vector3.forward * STONES_SPAWN_RADIUS); var stone = AllocateStone(spawnPos); DebugWrite.Log($\"[MovingStones] Golem pos: {transform.position}; stone pos: {spawnPos}\", stone.StoneObject.gameObject, _isDebug); } _movingInCircle = true; _isStonesSpawned = true;  ",
          "content_tokens": 305,
          "embedding": []
        },
        {
          "cs_scriptfile": "MovingStones",
          "content": "public void MoveStonesInCircle() { for (int i = 0; i < _usedStonesPool.Count; i++) { float angle = i * 360.0f / MAXIMUM_STONES + Time.time * STONE_MOVING_SPEED; Stone stone = _usedStonesPool[i]; ActivateDamageAtTheEndOfMovingCircle(angle, stone); Transform stoneTransform = stone.StoneObject.transform; Vector3 posWithStaticHeight = new Vector3(transform.position.x, stone.Height, transform.position.z); Vector3 newPos = posWithStaticHeight + Quaternion.Euler(0, angle, 0) * (Vector3.forward * STONES_SPAWN_RADIUS); stoneTransform.position = newPos; stoneTransform.Rotate(Vector3.up, Time.deltaTime * STONE_ROTATING_SPEED); }  ",
          "content_tokens": 204,
          "embedding": []
        },
        {
          "cs_scriptfile": "MovingStones",
          "content": "private void ActivateDamageAtTheEndOfMovingCircle(float angle, Stone stone) { if (angle % 350f < 5f) { if (!stone.IsDamageAlreadyActivated) { DebugWrite.Log($\"[MovingStones] Activating damage for stone {stone.StoneObject.gameObject.name}\", stone.StoneObject.gameObject, _isDebug); stone.StoneObject.SetActiveDamage(true); stone.IsDamageAlreadyActivated = true; } } else { stone.IsDamageAlreadyActivated = false; } } [Server] public void StopAndShootStones() { ObserverStopAndShootStones(); StartCoroutine(CorIsShootingSwitcher()); } [ObserversRpc(RunLocally = false)] private void ObserverStopAndShootStones() { StartCoroutine(CorStopAndShootStones()); } private IEnumerator CorIsShootingSwitcher() { _isShooting = true; yield return new WaitForSeconds(TIME_TO_SHOOT_STONES); _isShooting = false; yield return new WaitForSeconds(STONES_LIFETIME_IN_FLIGHT); _isStonesSpawned = false; } private IEnumerator CorStopAndShootStones() { _movingInCircle = false; yield return new WaitForSeconds(TIME_TO_SHOOT_STONES); for (int i = 0; i < _usedStonesPool.Count; i++) { Vector3 direction = (_usedStonesPool[i].StoneObject.transform.position - transform.position).normalized; _usedStonesPool[i].RigidBody.isKinematic = false; _usedStonesPool[i].RigidBody.AddForce(direction * NOVA_FORCE, ForceMode.Impulse); } yield return new WaitForSeconds(STONES_LIFETIME_IN_FLIGHT); for (int i = 0; i < _usedStonesPool.Count; i++) { DeallocateStone(_usedStonesPool[i]); } _isStonesSpawned = false; yield return null; } [Server] private IEnumerator StartCooldownTimer() { var time = new WaitForSeconds(SPAWN_STONES_COOLDOWN); _isCooldown = true; yield return time; _isCooldown = false; } [Server] private IEnumerator StartMovingStonesTimer() { var time = new WaitForSeconds(MINIMUM_MOVING_STONES_LIFETIME); _isStonesKillable = false; yield return time; _isStonesKillable = true; } private Stone AllocateStone(Vector3 spawnPos) { if (_unusedStonesPool.Count == 0) { InstantiateNewStone(); } Stone stone = _unusedStonesPool.Dequeue(); stone.StoneObject.transform.position = spawnPos; stone.StoneObject.gameObject.SetActive(true); stone.RigidBody.isKinematic = true; stone.StoneObject.SetActiveDamage(true); stone.Height = spawnPos.y; _usedStonesPool.Add(stone); return stone; } private Stone InstantiateNewStone() { int id = Random.Range(0, _stonePrefabs.Length); var stone = Instantiate(_stonePrefabs[id]); foreach (var hitBox in stone.hitBoxes) { hitBox.Init(_meleeManager); } stone.transform.parent = transform; stone.gameObject.SetActive(false); Stone newStone = new Stone(stone, stone.GetComponent<Rigidbody>()); _unusedStonesPool.Enqueue(newStone); return newStone;  ",
          "content_tokens": 817,
          "embedding": []
        },
        {
          "cs_scriptfile": "MovingStones",
          "content": "private void DeallocateStone(Stone stone) { _usedStonesPool.Remove(stone); _unusedStonesPool.Enqueue(stone); stone.RigidBody.isKinematic = true; stone.StoneObject.SetActiveDamage(false); stone.StoneObject.gameObject.SetActive(false); } [Serializable] public class Stone { public FNvMeleeAttackObject StoneObject; public Rigidbody RigidBody; public float Height; public bool IsDamageAlreadyActivated; public Stone(FNvMeleeAttackObject stoneObject, Rigidbody rigidBody) { StoneObject = stoneObject; RigidBody = rigidBody; } } } }",
          "content_tokens": 146,
          "embedding": []
        }
      ],
      "length": 6420
    },
    {
      "filename": "PolarDragonFlying",
      "content": "using System; using System.Collections; using System.Linq; using _ZombieRoyale.Scripts.AI.Boss_Perks; using _ZombieRoyale.Scripts.Core; using DG.Tweening; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using UnityEngine; using UnityEngine.Serialization; public class PolarDragonFlying : UnitBehaviour { [SerializeField] private AnimationClip _spreadFrozenBreathAnimation; [FormerlySerializedAs(\"_FXFrostThrower\")] [SerializeField] private ParticleSystem _fxFrostThrower; private float _spreadFrozenBreathAnimationLength; public Action OnBreathingFinished; [field:SerializeField] public bool IsBreathOnCooldown { get; private set; } [field:SerializeField] public bool IsBreathing { get; private set; } private Transform _target; private float _rotationSpeed = 1.0f; protected override void Awake() { base.Awake(); _spreadFrozenBreathAnimationLength = _spreadFrozenBreathAnimation.length; } [Server] public void DoBreathing() { _aiUnit.OrderToFly(); _aiUnit.OnStateFlying += StartBreathingRoutine; } private void StartBreathingRoutine() { StartCoroutine(BreathingRoutine()); } private IEnumerator BreathingRoutine() { yield return new WaitUntil(() => _aiUnit.PlayersWithinSight.FirstOrDefault() > 0); _aiUnit.OnStateFlying -= StartBreathingRoutine; int firstTarget = _aiUnit.PlayersWithinSight.FirstOrDefault(); UnitComponents unitComponents = GameplayManager.Instance.GetUnitComponentsServerAndClient(firstTarget); _target = unitComponents.HealthController.transform; RotateTowardsTarget(false); yield return new WaitForSeconds(1f); Breathing(true); yield return new WaitForSeconds(_spreadFrozenBreathAnimationLength); Breathing(false); DoLanding(); yield return new WaitForSeconds(5.0f); IsBreathOnCooldown = false; } private void RotateTowardsTarget(bool isBreathingRotation) { if (_target != null) { // Calculate the direction from the dragon to the target Vector3 directionToTarget = _target.position - transform.position; if (directionToTarget != Vector3.zero) { // Calculate the rotation angle Quaternion targetRotation = Quaternion.LookRotation(directionToTarget); // Use DOTween to smoothly rotate the dragon transform.DORotateQuaternion(targetRotation, 1.0f / _rotationSpeed) .SetEase(Ease.Linear) .OnComplete(() => { // Continue rotating while breathing fire if (isBreathingRotation && IsBreathing) RotateTowardsTarget(true); }); } } } private void Breathing(bool isOn) { IsBreathing = isOn; _aiUnit.AnimatorDecorator.SetBool(\"IsBreathing\", isOn); if (isOn) { IsBreathOnCooldown = true; PlayFX(); RotateTowardsTarget(true); } else { OnBreathingFinished?.Invoke(); StopFX(); } } [ObserversRpc] private void PlayFX() => _fxFrostThrower.Play(); [ObserversRpc] private void StopFX() => _fxFrostThrower.Stop(); [Server] public void DoLanding() => _aiUnit.SetState(AIUnit.AIState.Landing); } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PolarDragonFlying",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "PolarDragonFlying",
          "content": "using System; using System.Collections; using System.Linq; using _ZombieRoyale.Scripts.AI.Boss_Perks; using _ZombieRoyale.Scripts.Core; using DG.Tweening; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using UnityEngine; using UnityEngine.Serialization; public class PolarDragonFlying : UnitBehaviour { [SerializeField] private AnimationClip _spreadFrozenBreathAnimation; [FormerlySerializedAs(\"_FXFrostThrower\")] [SerializeField] private ParticleSystem _fxFrostThrower; private float _spreadFrozenBreathAnimationLength; public Action OnBreathingFinished; [field:SerializeField] public bool IsBreathOnCooldown { get; private set; } [field:SerializeField] public bool IsBreathing { get; private set; } private Transform _target; private float _rotationSpeed = 1.0f; protected override void Awake() { base.Awake(); _spreadFrozenBreathAnimationLength = _spreadFrozenBreathAnimation.length; } [Server] public void DoBreathing() { _aiUnit.OrderToFly(); _aiUnit.OnStateFlying += StartBreathingRoutine;  ",
          "content_tokens": 290,
          "embedding": []
        },
        {
          "cs_scriptfile": "PolarDragonFlying",
          "content": "private void StartBreathingRoutine() { StartCoroutine(BreathingRoutine()); } private IEnumerator BreathingRoutine() { yield return new WaitUntil(() => _aiUnit.PlayersWithinSight.FirstOrDefault() > 0); _aiUnit.OnStateFlying -= StartBreathingRoutine; int firstTarget = _aiUnit.PlayersWithinSight.FirstOrDefault(); UnitComponents unitComponents = GameplayManager.Instance.GetUnitComponentsServerAndClient(firstTarget); _target = unitComponents.HealthController.transform; RotateTowardsTarget(false); yield return new WaitForSeconds(1f); Breathing(true); yield return new WaitForSeconds(_spreadFrozenBreathAnimationLength); Breathing(false); DoLanding(); yield return new WaitForSeconds(5.0f); IsBreathOnCooldown = false;  ",
          "content_tokens": 197,
          "embedding": []
        },
        {
          "cs_scriptfile": "PolarDragonFlying",
          "content": "private void RotateTowardsTarget(bool isBreathingRotation) { if (_target != null) { // Calculate the direction from the dragon to the target Vector3 directionToTarget = _target.position - transform.position; if (directionToTarget != Vector3.zero) { // Calculate the rotation angle Quaternion targetRotation = Quaternion.LookRotation(directionToTarget); // Use DOTween to smoothly rotate the dragon transform.DORotateQuaternion(targetRotation, 1.0f / _rotationSpeed) .SetEase(Ease.Linear) .OnComplete(() => { // Continue rotating while breathing fire if (isBreathingRotation && IsBreathing) RotateTowardsTarget(true); }); } }  ",
          "content_tokens": 173,
          "embedding": []
        },
        {
          "cs_scriptfile": "PolarDragonFlying",
          "content": "private void Breathing(bool isOn) { IsBreathing = isOn; _aiUnit.AnimatorDecorator.SetBool(\"IsBreathing\", isOn); if (isOn) { IsBreathOnCooldown = true; PlayFX(); RotateTowardsTarget(true); } else { OnBreathingFinished?.Invoke(); StopFX(); } } [ObserversRpc] private void PlayFX() => _fxFrostThrower.Play(); [ObserversRpc] private void StopFX() => _fxFrostThrower.Stop(); [Server] public void DoLanding() => _aiUnit.SetState(AIUnit.AIState.Landing); }",
          "content_tokens": 156,
          "embedding": []
        }
      ],
      "length": 2826
    },
    {
      "filename": "UnitBehaviour",
      "content": " using System; using FishNet.Object; using FishnetInvector; using Pathfinding; using UnityEngine; namespace _ZombieRoyale.Scripts.AI.Boss_Perks { public class UnitBehaviour: NetworkBehaviour { [SerializeField] protected AIUnit _aiUnit; [SerializeField] protected FNvMeleeManager _meleeManager; [SerializeField] protected AIPath _aiPath; protected override void OnValidate() { base.OnValidate(); _aiUnit ??= GetComponent<AIUnit>(); _meleeManager ??= GetComponent<FNvMeleeManager>(); _aiPath ??= GetComponent<AIPath>(); } protected virtual void Awake() { _aiUnit ??= GetComponent<AIUnit>(); _meleeManager ??= GetComponent<FNvMeleeManager>(); _aiPath ??= GetComponent<AIPath>(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "UnitBehaviour",
          "content": "using System; using FishNet.Object; using FishnetInvector; using Pathfinding; using UnityEngine; namespace _ZombieRoyale.Scripts.AI.Boss_Perks { public class UnitBehaviour: NetworkBehaviour { [SerializeField] protected AIUnit _aiUnit; [SerializeField] protected FNvMeleeManager _meleeManager; [SerializeField] protected AIPath _aiPath; protected override void OnValidate() { base.OnValidate(); _aiUnit ??= GetComponent<AIUnit>(); _meleeManager ??= GetComponent<FNvMeleeManager>(); _aiPath ??= GetComponent<AIPath>(); } protected virtual void Awake() { _aiUnit ??= GetComponent<AIUnit>(); _meleeManager ??= GetComponent<FNvMeleeManager>(); _aiPath ??= GetComponent<AIPath>(); } } }",
          "content_tokens": 198,
          "embedding": []
        }
      ],
      "length": 681
    },
    {
      "filename": "AnimatorDecorator",
      "content": "using System.Collections; using DungeonScrollerCore; using FishNet.Component.Animating; using UnityEngine; namespace Zomb.Creatures.Helpers { public class AnimatorDecorator : MonoBehaviour { public Animator Animator => _animator; [SerializeField] private Animator _animator; [SerializeField] private bool _isDebug = false; private NavMeshAgentDecorator _navMeshAgentDecorator; private NetworkAnimator _networkAnimator; private const string SPEED_NAME = \"Speed\"; private void Awake() { AnimatorBinding(); _navMeshAgentDecorator = GetComponent<NavMeshAgentDecorator>(); } private void Update() { //UpdateSpeed(); } public void UpdateSpeed(string variableName, float modifier) { _animator.SetFloat(variableName, modifier); } #region AI-specific private void AnimatorBinding() { if (_animator == null) { _animator = GetComponent<Animator>(); if (_animator == null) { transform.GetComponentInChildren<Animator>(); } } TryGetComponent(out _networkAnimator); } #endregion #region Publics public void SetFloat(int id, float value) { _animator.SetFloat(id, value); } public void SetFloat(int id, float value, float dampTime, float deltaTime) { _animator.SetFloat(id, value, dampTime, deltaTime); } public void SetBool(int id, bool value) { if (_animator.GetBool(id) == value) return; DebugWrite.Log($\"[AnimatorDecorator] {gameObject} SetBool: {id} {value}\", gameObject, _isDebug); _animator.SetBool(id, value); } public void SetBoolTimed(int id, bool value, float time) { SetBool(id, value); StartCoroutine(ResetBool(id, time, !value)); } private IEnumerator ResetBool(int id, float time, bool value) { yield return new WaitForSeconds(time); SetBool(id, value); } public void SetBool(string name, bool value) { _animator.SetBool(name, value); } public void SetFloat(string name, float value) { _animator.SetFloat(name, value); } public void SetInteger(string name, int value) { _animator.SetInteger(name, value); } public void SetInteger(int id, int value) { _animator.SetInteger(id, value); } #region Triggers /// <summary> /// Triggers should be played through NetworkAnimator /// </summary> public void SetTrigger(string name) { _animator.SetTrigger(name); if (_networkAnimator) _networkAnimator.SetTrigger(name); } public void SetTriggerNonSync(int id) { _animator.SetTrigger(id); } public void SetTrigger(int id) { _animator.SetTrigger(id); _networkAnimator.SetTrigger(id); } public void ResetTrigger(string name) { _animator.ResetTrigger(name); _networkAnimator.ResetTrigger(name); } #endregion public void Play(string name) { _networkAnimator.Play(name); } public void Play(string name, int layer) { _networkAnimator.Play(name, layer); } public void Play(string name, int layer, float normalizedTime) { _networkAnimator.Play(name, layer, normalizedTime); } public void PlayInFixedTime(string name) { _animator.PlayInFixedTime(name); } public void PlayInFixedTime(string name, int layer) { _animator.PlayInFixedTime(name, layer); } public void PlayInFixedTime(string name, int layer, float normalizedTime) { _animator.PlayInFixedTime(name, layer, normalizedTime); } public void CrossFade(string name, float transitionDuration) { _animator.CrossFade(name, transitionDuration); } public void CrossFade(string name, float transitionDuration, int layer) { _animator.CrossFade(name, transitionDuration, layer); } public void CrossFade(string name, float transitionDuration, int layer, float normalizedTime) { _animator.CrossFade(name, transitionDuration, layer, normalizedTime); } public void CrossFadeInFixedTime(string name, float transitionDuration) { _animator.CrossFadeInFixedTime(name, transitionDuration); } public void CrossFadeInFixedTime(string name, float transitionDuration, int layer) { _animator.CrossFadeInFixedTime(name, transitionDuration, layer); } public void CrossFadeInFixedTime(string name, float transitionDuration, int layer, float normalizedTime) { _animator.CrossFadeInFixedTime(name, transitionDuration, layer, normalizedTime); } public void StopPlayback() { _animator.StopPlayback(); } public void StartPlayback() { _animator.StartPlayback(); } public void StopRecording() { _animator.StopRecording(); } public void StartRecording(int frameCount) { _animator.StartRecording(frameCount); } public void Rebind() { _animator.Rebind(); } public void ApplyBuiltinRootMotion() { _animator.applyRootMotion = true; } public bool GetBool(int stringHash) { return _animator.GetBool(stringHash); } public void SetAnimator(Animator animator) { _animator = animator; } #endregion } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AnimatorDecorator",
          "content": "using System.Collections; using DungeonScrollerCore; using FishNet.Component.Animating; using UnityEngine; namespace Zomb.Creatures.Helpers { public class AnimatorDecorator : MonoBehaviour { public Animator Animator => _animator; [SerializeField] private Animator _animator; [SerializeField] private bool _isDebug = false; private NavMeshAgentDecorator _navMeshAgentDecorator; private NetworkAnimator _networkAnimator; private const string SPEED_NAME = \"Speed\"; private void Awake() { AnimatorBinding(); _navMeshAgentDecorator = GetComponent<NavMeshAgentDecorator>();  private void Update() { //UpdateSpeed();  ",
          "content_tokens": 159,
          "embedding": []
        },
        {
          "cs_scriptfile": "AnimatorDecorator",
          "content": "public void UpdateSpeed(string variableName, float modifier) { _animator.SetFloat(variableName, modifier); } #region AI-specific private void AnimatorBinding() { if (_animator == null) { _animator = GetComponent<Animator>(); if (_animator == null) { transform.GetComponentInChildren<Animator>(); }  TryGetComponent(out _networkAnimator); } #endregion #region Publics public void SetFloat(int id, float value) { _animator.SetFloat(id, value);  public void SetFloat(int id, float value, float dampTime, float deltaTime) { _animator.SetFloat(id, value, dampTime, deltaTime);  ",
          "content_tokens": 160,
          "embedding": []
        },
        {
          "cs_scriptfile": "AnimatorDecorator",
          "content": "public void SetBool(int id, bool value) { if (_animator.GetBool(id) == value) return; DebugWrite.Log($\"[AnimatorDecorator] {gameObject} SetBool: {id} {value}\", gameObject, _isDebug); _animator.SetBool(id, value);  public void SetBoolTimed(int id, bool value, float time) { SetBool(id, value); StartCoroutine(ResetBool(id, time, !value)); } private IEnumerator ResetBool(int id, float time, bool value) { yield return new WaitForSeconds(time); SetBool(id, value);  public void SetBool(string name, bool value) { _animator.SetBool(name, value);  ",
          "content_tokens": 184,
          "embedding": []
        },
        {
          "cs_scriptfile": "AnimatorDecorator",
          "content": "public void SetFloat(string name, float value) { _animator.SetFloat(name, value);  public void SetInteger(string name, int value) { _animator.SetInteger(name, value);  public void SetInteger(int id, int value) { _animator.SetInteger(id, value); } #region Triggers /// <summary> /// Triggers should be played through NetworkAnimator /// </summary> public void SetTrigger(string name) { _animator.SetTrigger(name); if (_networkAnimator) _networkAnimator.SetTrigger(name);  public void SetTriggerNonSync(int id) { _animator.SetTrigger(id);  public void SetTrigger(int id) { _animator.SetTrigger(id); _networkAnimator.SetTrigger(id);  ",
          "content_tokens": 182,
          "embedding": []
        },
        {
          "cs_scriptfile": "AnimatorDecorator",
          "content": "public void ResetTrigger(string name) { _animator.ResetTrigger(name); _networkAnimator.ResetTrigger(name); } #endregion public void Play(string name) { _networkAnimator.Play(name);  public void Play(string name, int layer) { _networkAnimator.Play(name, layer);  public void Play(string name, int layer, float normalizedTime) { _networkAnimator.Play(name, layer, normalizedTime);  public void PlayInFixedTime(string name) { _animator.PlayInFixedTime(name);  public void PlayInFixedTime(string name, int layer) { _animator.PlayInFixedTime(name, layer);  public void PlayInFixedTime(string name, int layer, float normalizedTime) { _animator.PlayInFixedTime(name, layer, normalizedTime);  ",
          "content_tokens": 192,
          "embedding": []
        },
        {
          "cs_scriptfile": "AnimatorDecorator",
          "content": "public void CrossFade(string name, float transitionDuration) { _animator.CrossFade(name, transitionDuration);  public void CrossFade(string name, float transitionDuration, int layer) { _animator.CrossFade(name, transitionDuration, layer);  public void CrossFade(string name, float transitionDuration, int layer, float normalizedTime) { _animator.CrossFade(name, transitionDuration, layer, normalizedTime);  public void CrossFadeInFixedTime(string name, float transitionDuration) { _animator.CrossFadeInFixedTime(name, transitionDuration);  public void CrossFadeInFixedTime(string name, float transitionDuration, int layer) { _animator.CrossFadeInFixedTime(name, transitionDuration, layer);  ",
          "content_tokens": 175,
          "embedding": []
        },
        {
          "cs_scriptfile": "AnimatorDecorator",
          "content": "public void CrossFadeInFixedTime(string name, float transitionDuration, int layer, float normalizedTime) { _animator.CrossFadeInFixedTime(name, transitionDuration, layer, normalizedTime);  public void StopPlayback() { _animator.StopPlayback();  public void StartPlayback() { _animator.StartPlayback();  public void StopRecording() { _animator.StopRecording();  public void StartRecording(int frameCount) { _animator.StartRecording(frameCount);  public void Rebind() { _animator.Rebind();  public void ApplyBuiltinRootMotion() { _animator.applyRootMotion = true;  public bool GetBool(int stringHash) { return _animator.GetBool(stringHash);  ",
          "content_tokens": 176,
          "embedding": []
        },
        {
          "cs_scriptfile": "AnimatorDecorator",
          "content": "public void SetAnimator(Animator animator) { _animator = animator; } #endregion } }",
          "content_tokens": 25,
          "embedding": []
        }
      ],
      "length": 4490
    },
    {
      "filename": "CreaturesFactory",
      "content": "using System; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Object; using UnityEngine; using UnityEngine.SceneManagement; /* * In FishNet you have to set the active scene. * If you need them to spawn in a scene other than active, * then move them to that scene after instantiating but before server spawning. */ namespace Zomb.Creatures.Module { public class CreaturesFactory : RoomManager { public struct PooledCreature { public GameObject Go; public AIUnit Controller; public bool IsInUse; } private Dictionary<ushort, List<PooledCreature>> creaturesPool = new Dictionary<ushort, List<PooledCreature>>(); public ushort UsedCreaturesCount => _usedCreaturesCount; private ushort _usedCreaturesCount = 0; private ushort _unusedCreaturesCount = 0; private enum Folder { Used, Unused } private static string USED_CREATURES_FOLDER_NAME = \"Used Creatures\"; private static string UNUSED_CREATURES_FOLDER_NAME = \"Unused Creatures\"; [SerializeField] private EnemyDefinitionsHolderSO enemyDefinitionsHolderSO; [SerializeField] private Transform _usedCreaturesFolder; [SerializeField] private Transform _unusedCreaturesFolder; [SerializeField] private bool IsShowInfoAboutUsedCreatures = true; public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer || IsHost) { } } private void ModifyUsedCreaturesCound(int value) { _usedCreaturesCount += (ushort)value; if (IsShowInfoAboutUsedCreatures) { Debug.Log($\"[CreaturesFactory] Used creatures count: {_usedCreaturesCount}\"); } } public PooledCreature AllocateCreature(ushort creatureType, Vector3 position, GameplayManager gpm) { PooledCreature creature = GetUnusedCreature(creatureType); if (creature.Go != null) { ReviveCreature(creature.Go, creature.Controller, position); PoolUseCreature(creatureType, creature); _unusedCreaturesCount--; } else { creature = CreateCreature(creatureType, position, gpm); } Debug.Log($\"[CreaturesFactory][AllocateCreature] {creature.Go.name} typeid: #{creatureType} at {position}\"); ModifyUsedCreaturesCound(1); return creature; } public void DeallocateCreature(AIUnit controller) { ModifyUsedCreaturesCound(-1); _unusedCreaturesCount++; if (controller == null) return; ushort creatureType = controller.EnemyDefinition.Id; GameObject creatureGO = controller.gameObject; UpdateFoldersNames(); MoveCreatureToFolder(controller, Folder.Unused); PoolUnuseCreature(creatureType, creatureGO, controller); GameplayManager.RemoveDespawnedUnit(controller.NetworkObject); DespawnCreature(controller.NetworkObject); } private void DespawnCreature(NetworkObject creatureNO) { creatureNO.Despawn(); } private void ReviveCreature(GameObject creatureGO, AIUnit controller, Vector3 position) { creatureGO.SetActive(true); controller.Revive(); creatureGO.transform.position = position; } private PooledCreature CreateCreature(ushort creatureType, Vector3 position, GameplayManager gpm) { EnemyDefinition enemyDefinition = enemyDefinitionsHolderSO.GetEnemyDefinition(creatureType); AIUnit enemyController = Instantiate(enemyDefinition.VisualPrefab, position, Quaternion.identity, transform); MoveCreatureToFolder(enemyController, Folder.Used); NetworkObject nob = enemyController.GetComponent<NetworkObject>(); InstanceFinder.ServerManager.Spawn(nob); enemyController.transform.position = position; //NetworkObject nob = InstanceFinder.ServerManager.NetworkManager.GetPooledInstantiated(prefabNO, true); //GameObject enemyInstance = nob.gameObject; PooledCreature creature = new PooledCreature() { Go = enemyController.gameObject, Controller = enemyController, IsInUse = true }; //InstanceFinder.ServerManager.Spawn(nob); PoolAddCreature(creatureType, creature.Go, enemyController, true); enemyController.OnHideCreature += EnemyController_OnHideCreature; return creature; try { } catch (Exception ex) { Debug.LogError($\"[RespawnManager] {ex.Message}\"); } return new PooledCreature(); } private void EnemyController_OnHideCreature(AIUnit controller) { DeallocateCreature(controller); } private void RemoveCreature(AIUnit controller) { controller.OnHideCreature -= EnemyController_OnHideCreature; DeallocateCreature(controller); RemoveFromPool(controller); } private void RemoveFromPool(AIUnit controller) { ushort creatureType = controller.EnemyDefinition.Id; List<PooledCreature> creatures = creaturesPool[creatureType]; for (int i = creatures.Count - 1; i >= 0; i--) { PooledCreature creature = creatures[i]; if (creature.Controller == controller) { creatures.RemoveAt(i); break; } } } private void PoolAddCreature(ushort creatureType, GameObject go, AIUnit controller, bool isInUse) { PooledCreature creature = new PooledCreature() { Go = go, Controller = controller, IsInUse = isInUse }; if (!creaturesPool.ContainsKey(creatureType)) { creaturesPool.Add(creatureType, new List<PooledCreature>()); } creaturesPool[creatureType].Add(creature); } private PooledCreature GetUnusedCreature(ushort creatureType) { Debug.Log($\"[CreaturesFactory] GetUnusedCreature {creatureType}\"); if (creaturesPool.ContainsKey(creatureType)) { List<PooledCreature> creatures = creaturesPool[creatureType]; for (int i = 0; i < creatures.Count; i++) { if (!creatures[i].IsInUse) { return creatures[i]; } } } return new PooledCreature(); } private void PoolUnuseCreature(ushort creatureType, GameObject go, AIUnit controller) { if (!creaturesPool.ContainsKey(creatureType)) { creaturesPool[creatureType] = new List<PooledCreature>(); PoolAddCreature(creatureType, go, controller, false); } else { for (int i = 0; i < creaturesPool[creatureType].Count; i++) { PooledCreature creature = creaturesPool[creatureType][i]; if (creature.Go == go) { creature.IsInUse = false; creaturesPool[creatureType][i] = creature; break; } } } } private void PoolUseCreature(ushort creatureType, PooledCreature creature) { for (int i = 0; i < creaturesPool[creatureType].Count; i++) { PooledCreature tempCreature = creaturesPool[creatureType][i]; if (tempCreature.Go == creature.Go) { tempCreature.IsInUse = true; creaturesPool[creatureType][i] = tempCreature; break; } } } private void MoveCreatureToFolder(AIUnit creatureGO, Folder folderType) { bool isFolderExists = _usedCreaturesFolder != null; if (!isFolderExists) return; if (folderType == Folder.Used) { creatureGO.transform.SetParent(_usedCreaturesFolder); } else { creatureGO.transform.SetParent(_unusedCreaturesFolder); } UpdateFoldersNames(); } private void UpdateFoldersNames() { int totalCreaturesCount = _usedCreaturesCount + _unusedCreaturesCount; _usedCreaturesFolder.name = $\"------{USED_CREATURES_FOLDER_NAME}({_usedCreaturesCount}/{totalCreaturesCount})------\"; _unusedCreaturesFolder.name = $\"------{UNUSED_CREATURES_FOLDER_NAME}({_unusedCreaturesCount}/{totalCreaturesCount})------\"; } [Server] public void ClearAllDeadBodies() { var deadBodies = FindObjectsOfType<DeadBody>(); for (int i = 0; i < deadBodies.Length; i++) { deadBodies[i].Despawn(); } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CreaturesFactory",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "CreaturesFactory",
          "content": "using System; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Object; using UnityEngine; using UnityEngine.SceneManagement; /* * In FishNet you have to set the active scene. * If you need them to spawn in a scene other than active, * then move them to that scene after instantiating but before server spawning. */ namespace Zomb.Creatures.Module { public class CreaturesFactory : RoomManager { public struct PooledCreature { public GameObject Go; public AIUnit Controller; public bool IsInUse; } private Dictionary<ushort, List<PooledCreature>> creaturesPool = new Dictionary<ushort, List<PooledCreature>>(); public ushort UsedCreaturesCount => _usedCreaturesCount; private ushort _usedCreaturesCount = 0; private ushort _unusedCreaturesCount = 0; private enum Folder { Used, Unused } private static string USED_CREATURES_FOLDER_NAME = \"Used Creatures\"; private static string UNUSED_CREATURES_FOLDER_NAME = \"Unused Creatures\"; [SerializeField] private EnemyDefinitionsHolderSO enemyDefinitionsHolderSO; [SerializeField] private Transform _usedCreaturesFolder; [SerializeField] private Transform _unusedCreaturesFolder; [SerializeField] private bool IsShowInfoAboutUsedCreatures = true; public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer || IsHost) { }  ",
          "content_tokens": 354,
          "embedding": []
        },
        {
          "cs_scriptfile": "CreaturesFactory",
          "content": "private void ModifyUsedCreaturesCound(int value) { _usedCreaturesCount += (ushort)value; if (IsShowInfoAboutUsedCreatures) { Debug.Log($\"[CreaturesFactory] Used creatures count: {_usedCreaturesCount}\"); } } public PooledCreature AllocateCreature(ushort creatureType, Vector3 position, GameplayManager gpm) { PooledCreature creature = GetUnusedCreature(creatureType); if (creature.Go != null) { ReviveCreature(creature.Go, creature.Controller, position); PoolUseCreature(creatureType, creature); _unusedCreaturesCount--; } else { creature = CreateCreature(creatureType, position, gpm); } Debug.Log($\"[CreaturesFactory][AllocateCreature] {creature.Go.name} typeid: #{creatureType} at {position}\"); ModifyUsedCreaturesCound(1); return creature;  ",
          "content_tokens": 217,
          "embedding": []
        },
        {
          "cs_scriptfile": "CreaturesFactory",
          "content": "public void DeallocateCreature(AIUnit controller) { ModifyUsedCreaturesCound(-1); _unusedCreaturesCount++; if (controller == null) return; ushort creatureType = controller.EnemyDefinition.Id; GameObject creatureGO = controller.gameObject; UpdateFoldersNames(); MoveCreatureToFolder(controller, Folder.Unused); PoolUnuseCreature(creatureType, creatureGO, controller); GameplayManager.RemoveDespawnedUnit(controller.NetworkObject); DespawnCreature(controller.NetworkObject);  private void DespawnCreature(NetworkObject creatureNO) { creatureNO.Despawn();  ",
          "content_tokens": 147,
          "embedding": []
        },
        {
          "cs_scriptfile": "CreaturesFactory",
          "content": "private void ReviveCreature(GameObject creatureGO, AIUnit controller, Vector3 position) { creatureGO.SetActive(true); controller.Revive(); creatureGO.transform.position = position; } private PooledCreature CreateCreature(ushort creatureType, Vector3 position, GameplayManager gpm) { EnemyDefinition enemyDefinition = enemyDefinitionsHolderSO.GetEnemyDefinition(creatureType); AIUnit enemyController = Instantiate(enemyDefinition.VisualPrefab, position, Quaternion.identity, transform); MoveCreatureToFolder(enemyController, Folder.Used); NetworkObject nob = enemyController.GetComponent<NetworkObject>(); InstanceFinder.ServerManager.Spawn(nob); enemyController.transform.position = position; //NetworkObject nob = InstanceFinder.ServerManager.NetworkManager.GetPooledInstantiated(prefabNO, true); //GameObject enemyInstance = nob.gameObject; PooledCreature creature = new PooledCreature() { Go = enemyController.gameObject, Controller = enemyController, IsInUse = true }; //InstanceFinder.ServerManager.Spawn(nob); PoolAddCreature(creatureType, creature.Go, enemyController, true); enemyController.OnHideCreature += EnemyController_OnHideCreature; return creature; try {  ",
          "content_tokens": 288,
          "embedding": []
        },
        {
          "cs_scriptfile": "CreaturesFactory",
          "content": "catch (Exception ex) { Debug.LogError($\"[RespawnManager] {ex.Message}\"); } return new PooledCreature();  private void EnemyController_OnHideCreature(AIUnit controller) { DeallocateCreature(controller);  private void RemoveCreature(AIUnit controller) { controller.OnHideCreature -= EnemyController_OnHideCreature; DeallocateCreature(controller); RemoveFromPool(controller);  private void RemoveFromPool(AIUnit controller) { ushort creatureType = controller.EnemyDefinition.Id; List<PooledCreature> creatures = creaturesPool[creatureType]; for (int i = creatures.Count - 1; i >= 0; i--) { PooledCreature creature = creatures[i]; if (creature.Controller == controller) { creatures.RemoveAt(i); break; } }  ",
          "content_tokens": 189,
          "embedding": []
        },
        {
          "cs_scriptfile": "CreaturesFactory",
          "content": "private void PoolAddCreature(ushort creatureType, GameObject go, AIUnit controller, bool isInUse) { PooledCreature creature = new PooledCreature() { Go = go, Controller = controller, IsInUse = isInUse }; if (!creaturesPool.ContainsKey(creatureType)) { creaturesPool.Add(creatureType, new List<PooledCreature>()); } creaturesPool[creatureType].Add(creature); } private PooledCreature GetUnusedCreature(ushort creatureType) { Debug.Log($\"[CreaturesFactory] GetUnusedCreature {creatureType}\"); if (creaturesPool.ContainsKey(creatureType)) { List<PooledCreature> creatures = creaturesPool[creatureType]; for (int i = 0; i < creatures.Count; i++) { if (!creatures[i].IsInUse) { return creatures[i]; } } } return new PooledCreature();  ",
          "content_tokens": 215,
          "embedding": []
        },
        {
          "cs_scriptfile": "CreaturesFactory",
          "content": "private void PoolUnuseCreature(ushort creatureType, GameObject go, AIUnit controller) { if (!creaturesPool.ContainsKey(creatureType)) { creaturesPool[creatureType] = new List<PooledCreature>(); PoolAddCreature(creatureType, go, controller, false); } else { for (int i = 0; i < creaturesPool[creatureType].Count; i++) { PooledCreature creature = creaturesPool[creatureType][i]; if (creature.Go == go) { creature.IsInUse = false; creaturesPool[creatureType][i] = creature; break; } } }  ",
          "content_tokens": 145,
          "embedding": []
        },
        {
          "cs_scriptfile": "CreaturesFactory",
          "content": "private void PoolUseCreature(ushort creatureType, PooledCreature creature) { for (int i = 0; i < creaturesPool[creatureType].Count; i++) { PooledCreature tempCreature = creaturesPool[creatureType][i]; if (tempCreature.Go == creature.Go) { tempCreature.IsInUse = true; creaturesPool[creatureType][i] = tempCreature; break; } }  private void MoveCreatureToFolder(AIUnit creatureGO, Folder folderType) { bool isFolderExists = _usedCreaturesFolder != null; if (!isFolderExists) return; if (folderType == Folder.Used) { creatureGO.transform.SetParent(_usedCreaturesFolder); } else { creatureGO.transform.SetParent(_unusedCreaturesFolder);  UpdateFoldersNames();  ",
          "content_tokens": 189,
          "embedding": []
        },
        {
          "cs_scriptfile": "CreaturesFactory",
          "content": "private void UpdateFoldersNames() { int totalCreaturesCount = _usedCreaturesCount + _unusedCreaturesCount; _usedCreaturesFolder.name = $\"------{USED_CREATURES_FOLDER_NAME}({_usedCreaturesCount}/{totalCreaturesCount})------\"; _unusedCreaturesFolder.name = $\"------{UNUSED_CREATURES_FOLDER_NAME}({_unusedCreaturesCount}/{totalCreaturesCount})------\"; } [Server] public void ClearAllDeadBodies() { var deadBodies = FindObjectsOfType<DeadBody>(); for (int i = 0; i < deadBodies.Length; i++) { deadBodies[i].Despawn(); } } } }",
          "content_tokens": 171,
          "embedding": []
        }
      ],
      "length": 6964
    },
    {
      "filename": "CreaturesNetworkedObjectPool",
      "content": "using System.Collections.Generic; using FishNet.Object; using FishNet.Utility.Extension; using GameKit.Utilities; public class CreaturesNetworkedObjectPool : FishNet.Utility.Performance.ObjectPool { private Dictionary<int, Stack<NetworkObject>> _cached = new Dictionary<int, Stack<NetworkObject>>(); /// <summary> /// Returns an object that has been stored. A new object will be created if no stored objects are available. /// </summary> /// <param name=\"prefabId\">PrefabId of the object to return.</param> /// <param name=\"asServer\">True if being called on the server side.</param> /// <returns></returns> public override NetworkObject RetrieveObject(int prefabId, bool asServer) { Stack<NetworkObject> cache; //No cache for prefabId yet, make one. if (!_cached.TryGetValueIL2CPP(prefabId, out cache)) { cache = new Stack<NetworkObject>(); _cached[prefabId] = cache; } NetworkObject nob; //Iterate until nob is populated just in case cache entries have been destroyed. do { if (cache.Count == 0) { NetworkObject prefab = base.NetworkManager.SpawnablePrefabs.GetObject(asServer, prefabId); /* A null nob should never be returned from spawnables. This means something * else broke, likely unrelated to the object pool. */ nob = Instantiate(prefab); //Can break instantly since we know nob is not null. break; } else { nob = cache.Pop(); } } while (nob == null); nob.gameObject.SetActive(true); return nob; } /// <summary> /// Stores an object into the pool. /// </summary> /// <param name=\"instantiated\">Object to store.</param> /// <param name=\"prefabId\">PrefabId of the object.</param> /// <param name=\"asServer\">True if being called on the server side.</param> /// <returns></returns> public override void StoreObject(NetworkObject instantiated, bool asServer) { Stack<NetworkObject> cache; if (!_cached.TryGetValue(instantiated.ObjectId, out cache)) { cache = new Stack<NetworkObject>(); _cached[instantiated.ObjectId] = cache; } instantiated.gameObject.SetActive(false); cache.Push(instantiated); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CreaturesNetworkedObjectPool",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "CreaturesNetworkedObjectPool",
          "content": "using System.Collections.Generic; using FishNet.Object; using FishNet.Utility.Extension; using GameKit.Utilities; public class CreaturesNetworkedObjectPool : FishNet.Utility.Performance.ObjectPool { private Dictionary<int, Stack<NetworkObject>> _cached = new Dictionary<int, Stack<NetworkObject>>(); /// <summary> /// Returns an object that has been stored. A new object will be created if no stored objects are available. /// </summary> /// <param name=\"prefabId\">PrefabId of the object to return.</param> /// <param name=\"asServer\">True if being called on the server side.</param> /// <returns></returns> public override NetworkObject RetrieveObject(int prefabId, bool asServer) { Stack<NetworkObject> cache; //No cache for prefabId yet, make one. if (!_cached.TryGetValueIL2CPP(prefabId, out cache)) { cache = new Stack<NetworkObject>(); _cached[prefabId] = cache; } NetworkObject nob; //Iterate until nob is populated just in case cache entries have been destroyed. do { if (cache.Count == 0) { NetworkObject prefab = base.NetworkManager.SpawnablePrefabs.GetObject(asServer, prefabId); /* A null nob should never be returned from spawnables. This means something * else broke, likely unrelated to the object pool. */ nob = Instantiate(prefab); //Can break instantly since we know nob is not null. break; } else { nob = cache.Pop(); }  ",
          "content_tokens": 349,
          "embedding": []
        },
        {
          "cs_scriptfile": "CreaturesNetworkedObjectPool",
          "content": "while (nob == null); nob.gameObject.SetActive(true); return nob; } /// <summary> /// Stores an object into the pool. /// </summary> /// <param name=\"instantiated\">Object to store.</param> /// <param name=\"prefabId\">PrefabId of the object.</param> /// <param name=\"asServer\">True if being called on the server side.</param> /// <returns></returns> public override void StoreObject(NetworkObject instantiated, bool asServer) { Stack<NetworkObject> cache; if (!_cached.TryGetValue(instantiated.ObjectId, out cache)) { cache = new Stack<NetworkObject>(); _cached[instantiated.ObjectId] = cache; } instantiated.gameObject.SetActive(false); cache.Push(instantiated); } }",
          "content_tokens": 185,
          "embedding": []
        }
      ],
      "length": 2004
    },
    {
      "filename": "BehaviourDesignerHelpers",
      "content": "using System.Text; using UnityEditor; using UnityEngine; using BehaviorDesigner.Runtime; [CustomEditor(typeof(BehaviorTree))] public class BehaviourDesignerHelpers : Editor { private BehaviorTree _behaviorTree; private CharacterController _characterController; private void OnEnable() { _behaviorTree = (BehaviorTree)target; _characterController = _behaviorTree.GetComponent<CharacterController>(); } private void OnSceneGUI() { var tr = _behaviorTree.transform; var pos = tr.position; var color = new Color(.5f, .8f, .5f, .5f); GUI.color = color; NavMeshDebugHelpers.drawString(GetInfoText(), new Vector3(pos.x, pos.y, pos.z), Color.blue); } private string GetInfoText() { StringBuilder str = new StringBuilder(); if (Application.isPlaying) { str.Append($\"SpawnPoint: {_behaviorTree.GetVariable(\"SpawnPoint\").GetValue()}\\n\"); str.Append($\"PatrolPointVar: {_behaviorTree.GetVariable(\"PatrolPointVar\").GetValue()}\\n\"); str.Append($\"InterestPos: {_behaviorTree.GetVariable(\"InterestPos\").GetValue()}\\n\"); str.Append($\"DidHearSound: {_behaviorTree.GetVariable(\"DidHearSound\").GetValue()}\\n\"); } return str.ToString(); } private void GetMoveVariable() { _behaviorTree.FindTask<MoveTowards>(); _behaviorTree.GetVariable(\"InterestPos\").GetValue().ToString(); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BehaviourDesignerHelpers",
          "content": "using System.Text; using UnityEditor; using UnityEngine; using BehaviorDesigner.Runtime; [CustomEditor(typeof(BehaviorTree))] public class BehaviourDesignerHelpers : Editor { private BehaviorTree _behaviorTree; private CharacterController _characterController; private void OnEnable() { _behaviorTree = (BehaviorTree)target; _characterController = _behaviorTree.GetComponent<CharacterController>();  private void OnSceneGUI() { var tr = _behaviorTree.transform; var pos = tr.position; var color = new Color(.5f, .8f, .5f, .5f); GUI.color = color; NavMeshDebugHelpers.drawString(GetInfoText(), new Vector3(pos.x, pos.y, pos.z), Color.blue);  ",
          "content_tokens": 176,
          "embedding": []
        },
        {
          "cs_scriptfile": "BehaviourDesignerHelpers",
          "content": "private string GetInfoText() { StringBuilder str = new StringBuilder(); if (Application.isPlaying) { str.Append($\"SpawnPoint: {_behaviorTree.GetVariable(\"SpawnPoint\").GetValue()}\\n\"); str.Append($\"PatrolPointVar: {_behaviorTree.GetVariable(\"PatrolPointVar\").GetValue()}\\n\"); str.Append($\"InterestPos: {_behaviorTree.GetVariable(\"InterestPos\").GetValue()}\\n\"); str.Append($\"DidHearSound: {_behaviorTree.GetVariable(\"DidHearSound\").GetValue()}\\n\"); } return str.ToString();  private void GetMoveVariable() { _behaviorTree.FindTask<MoveTowards>(); _behaviorTree.GetVariable(\"InterestPos\").GetValue().ToString(); } }",
          "content_tokens": 181,
          "embedding": []
        }
      ],
      "length": 1256
    },
    {
      "filename": "EnemyDefinitionsHolderSOEditor",
      "content": "#if UNITY_EDITOR using UnityEditor; using UnityEngine; [CustomEditor(typeof(EnemyDefinitionsHolderSO))] public class EnemyDefinitionsHolderSOEditor : Editor { private string _jsonRepresentation; public override void OnInspectorGUI() { base.OnInspectorGUI(); // Get the scriptable object instance EnemyDefinitionsHolderSO definitionsHolder = (EnemyDefinitionsHolderSO)target; // Serialize the enemy definitions to JSON when the button is clicked if (GUILayout.Button(\"Serialize to JSON\")) { _jsonRepresentation = definitionsHolder.SerializeToJson(); } // Display the JSON in a text area with 5 rows _jsonRepresentation = EditorGUILayout.TextArea(_jsonRepresentation, GUILayout.MinHeight(5 * EditorGUIUtility.singleLineHeight)); if (definitionsHolder.EnemyDefinitions != null) { // Set the Id for each enemyDefinition based on their position. for(byte i = 0; i < definitionsHolder.EnemyDefinitions.Length; i++) { definitionsHolder.EnemyDefinitions[i].Id = i; } // Mark the scriptable object as dirty so changes persist EditorUtility.SetDirty(definitionsHolder); for (byte i = 0; i < definitionsHolder.EnemyDefinitions.Length; i++) { EditorUtility.SetDirty(definitionsHolder.EnemyDefinitions[i]); } } } } #endif",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "EnemyDefinitionsHolderSOEditor",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "EnemyDefinitionsHolderSOEditor",
          "content": "#if UNITY_EDITOR using UnityEditor; using UnityEngine; [CustomEditor(typeof(EnemyDefinitionsHolderSO))] public class EnemyDefinitionsHolderSOEditor : Editor { private string _jsonRepresentation; public override void OnInspectorGUI() { base.OnInspectorGUI(); // Get the scriptable object instance EnemyDefinitionsHolderSO definitionsHolder = (EnemyDefinitionsHolderSO)target; // Serialize the enemy definitions to JSON when the button is clicked if (GUILayout.Button(\"Serialize to JSON\")) { _jsonRepresentation = definitionsHolder.SerializeToJson(); } // Display the JSON in a text area with 5 rows _jsonRepresentation = EditorGUILayout.TextArea(_jsonRepresentation, GUILayout.MinHeight(5 * EditorGUIUtility.singleLineHeight)); if (definitionsHolder.EnemyDefinitions != null) { // Set the Id for each enemyDefinition based on their position. for(byte i = 0; i < definitionsHolder.EnemyDefinitions.Length; i++) { definitionsHolder.EnemyDefinitions[i].Id = i; } // Mark the scriptable object as dirty so changes persist EditorUtility.SetDirty(definitionsHolder); for (byte i = 0; i < definitionsHolder.EnemyDefinitions.Length; i++) { EditorUtility.SetDirty(definitionsHolder.EnemyDefinitions[i]); } } } } #endif}",
          "content_tokens": 329,
          "embedding": []
        }
      ],
      "length": 1208
    },
    {
      "filename": "NavMeshDebugHelpers",
      "content": "using System.Text; using UnityEngine; using UnityEditor; using UnityEngine.AI; using Zomb.Creatures.Helpers; [CustomEditor(typeof(NavMeshAgentDecorator))] public class NavMeshDebugHelpers : Editor { private NavMeshAgent _agent; private NavMeshAgentDecorator _decorator; private void OnEnable() { _decorator = (NavMeshAgentDecorator)target; _agent = _decorator.GetComponent<NavMeshAgent>(); } private void OnSceneGUI() { if (_agent == null) { return; } if (!_agent.enabled) { return; } var tr = _decorator.transform; var pos = tr.position; // display an orange disc where the object is var color = new Color(1, 0.8f, 0.4f, 1); Handles.color = color; Handles.DrawWireDisc(pos, tr.up, _agent.radius); // display object \"value\" in scene GUI.color = color; drawString(GetInfoText(_agent, tr), new Vector3(tr.position.x-1.5f, tr.position.y, tr.position.z), Color.black); } private string GetInfoText(NavMeshAgent navMeshAgent, Transform tr) { StringBuilder str = new StringBuilder(); str.Append($\"dest: {navMeshAgent.destination}\\n\"); if (Application.isPlaying) str.Append($\"remainDist: {navMeshAgent.remainingDistance}\\n\"); str.Append($\"stpDist: {navMeshAgent.stoppingDistance}\\n\"); str.Append($\"spd: {navMeshAgent.speed}\\n\"); str.Append($\"angSpeed: {navMeshAgent.angularSpeed}\\n\"); str.Append($\"accel: {navMeshAgent.acceleration}\\n\"); str.Append($\"AutoBrake: {navMeshAgent.autoBraking}\\n\"); str.Append($\"autoRepath: {navMeshAgent.autoRepath}\\n\"); str.Append($\"vel: {_decorator.VelocityMagnitude}\\n\"); str.Append($\"velTest: {_decorator.TestVelocityMagnitude}\\n\"); str.Append($\"arrived: {_decorator.HasArrived()}\"); return str.ToString(); } static public void drawString(string text, Vector3 worldPos, Color? colour = null) { Handles.BeginGUI(); var restoreColor = GUI.color; if (colour.HasValue) GUI.color = colour.Value; var view = SceneView.currentDrawingSceneView; Vector3 screenPos = view.camera.WorldToScreenPoint(worldPos); if (screenPos.y < 0 || screenPos.y > Screen.height || screenPos.x < 0 || screenPos.x > Screen.width || screenPos.z < 0) { GUI.color = restoreColor; Handles.EndGUI(); return; } Vector2 size = GUI.skin.label.CalcSize(new GUIContent(text)); GUI.Label(new Rect(screenPos.x - (size.x / 2), -screenPos.y + view.position.height + 4, size.x, size.y), text); GUI.color = restoreColor; Handles.EndGUI(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "NavMeshDebugHelpers",
          "content": "using System.Text; using UnityEngine; using UnityEditor; using UnityEngine.AI; using Zomb.Creatures.Helpers; [CustomEditor(typeof(NavMeshAgentDecorator))] public class NavMeshDebugHelpers : Editor { private NavMeshAgent _agent; private NavMeshAgentDecorator _decorator; private void OnEnable() { _decorator = (NavMeshAgentDecorator)target; _agent = _decorator.GetComponent<NavMeshAgent>();  private void OnSceneGUI() { if (_agent == null) { return;  ",
          "content_tokens": 129,
          "embedding": []
        },
        {
          "cs_scriptfile": "NavMeshDebugHelpers",
          "content": "if (!_agent.enabled) { return; } var tr = _decorator.transform; var pos = tr.position; // display an orange disc where the object is var color = new Color(1, 0.8f, 0.4f, 1); Handles.color = color; Handles.DrawWireDisc(pos, tr.up, _agent.radius); // display object \"value\" in scene GUI.color = color; drawString(GetInfoText(_agent, tr), new Vector3(tr.position.x-1.5f, tr.position.y, tr.position.z), Color.black);  ",
          "content_tokens": 140,
          "embedding": []
        },
        {
          "cs_scriptfile": "NavMeshDebugHelpers",
          "content": "private string GetInfoText(NavMeshAgent navMeshAgent, Transform tr) { StringBuilder str = new StringBuilder(); str.Append($\"dest: {navMeshAgent.destination}\\n\"); if (Application.isPlaying) str.Append($\"remainDist: {navMeshAgent.remainingDistance}\\n\"); str.Append($\"stpDist: {navMeshAgent.stoppingDistance}\\n\"); str.Append($\"spd: {navMeshAgent.speed}\\n\"); str.Append($\"angSpeed: {navMeshAgent.angularSpeed}\\n\"); str.Append($\"accel: {navMeshAgent.acceleration}\\n\"); str.Append($\"AutoBrake: {navMeshAgent.autoBraking}\\n\"); str.Append($\"autoRepath: {navMeshAgent.autoRepath}\\n\"); str.Append($\"vel: {_decorator.VelocityMagnitude}\\n\"); str.Append($\"velTest: {_decorator.TestVelocityMagnitude}\\n\"); str.Append($\"arrived: {_decorator.HasArrived()}\"); return str.ToString(); } static public void drawString(string text, Vector3 worldPos, Color? colour = null) { Handles.BeginGUI(); var restoreColor = GUI.color; if (colour.HasValue) GUI.color = colour.Value; var view = SceneView.currentDrawingSceneView; Vector3 screenPos = view.camera.WorldToScreenPoint(worldPos); if (screenPos.y < 0 || screenPos.y > Screen.height || screenPos.x < 0 || screenPos.x > Screen.width || screenPos.z < 0) { GUI.color = restoreColor; Handles.EndGUI(); return; } Vector2 size = GUI.skin.label.CalcSize(new GUIContent(text)); GUI.Label(new Rect(screenPos.x - (size.x / 2), -screenPos.y + view.position.height + 4, size.x, size.y), text); GUI.color = restoreColor; Handles.EndGUI(); } }",
          "content_tokens": 479,
          "embedding": []
        }
      ],
      "length": 2323
    },
    {
      "filename": "EnemyDefinitionsHolderSO",
      "content": "using System.Text; using DungeonScrollerCore; using UnityEngine; using UnityEngine.Serialization; [CreateAssetMenu(fileName = \"EnemyDefinitionsHolder\", menuName = \"ScriptableObjects/EnemyDefinitionsHolderSO\")] public class EnemyDefinitionsHolderSO : ScriptableObject { public EnemyDefinition[] EnemyDefinitions => _enemyDefinitions; [SerializeField] private EnemyDefinition[] _enemyDefinitions; private EnemyDefinition[] _sortedEnemyDefinitions; public EnemyDefinition[] GetSortedEnemyDefinitions() { if (_sortedEnemyDefinitions == null || _sortedEnemyDefinitions.Length == 0) { _sortedEnemyDefinitions = new EnemyDefinition[EnemyDefinitions.Length]; for (int i = 0; i < EnemyDefinitions.Length; i++) { _sortedEnemyDefinitions[i] = EnemyDefinitions[i]; } //sort asscending System.Array.Sort(_sortedEnemyDefinitions, (x, y) => x.ChanceToSpawn.CompareTo(y.ChanceToSpawn)); } return _sortedEnemyDefinitions; } /// <summary> /// Returns enemy with highest chance to spawn according to random value from 0f to 1f. Drop chance should not be equal between enemies. /// </summary> /// <param name=\"type\"></param> /// <returns></returns> public byte GetRandomEnemyId(EnemyDefinition.Type type) { byte result = 255; byte any = 255; float roll = Random.Range(0.0f, 1.0f); //EnemyDefinition[] sorted = GetSortedEnemyDefinitions(); if (type == EnemyDefinition.Type.Boss) { DebugWrite.Log(\"Boss\"); } for (byte id = 0; id < GetSortedEnemyDefinitions().Length; id++){ if (GetSortedEnemyDefinitions()[id].EnemyType != type) continue; any = GetSortedEnemyDefinitions()[id].Id; if (any == 2) { DebugWrite.Log(\"Any\"); } if (roll < GetSortedEnemyDefinitions()[id].ChanceToSpawn) { result = GetSortedEnemyDefinitions()[id].Id; break; } } if (result != 255) return result; return any; } public EnemyDefinition GetEnemyDefinition(int id){ for(int i = 0; i < GetSortedEnemyDefinitions().Length; i++){ if(GetSortedEnemyDefinitions()[i].Id == id){ return GetSortedEnemyDefinitions()[i]; } } DebugWrite.LogError($\"EnemyDefinition with id {id} not found\"); return null; } public byte GetId(EnemyDefinition enemyDefinition){ for(int i = 0; i < _enemyDefinitions.Length; i++){ if(_enemyDefinitions[i] == enemyDefinition){ return _enemyDefinitions[i].Id; } } return 0; } #if UNITY_EDITOR public void SetEnemyDefinitions(EnemyDefinition[] enemyDefinitions){ _enemyDefinitions = enemyDefinitions; } #endif public string SerializeToJson() { StringBuilder jsonBuilder = new StringBuilder(); jsonBuilder.Append(\"[\"); for (int i = 0; i < _enemyDefinitions.Length; i++) { jsonBuilder.Append(_enemyDefinitions[i].GetJsonRepresentation()); if (i < _enemyDefinitions.Length - 1) jsonBuilder.Append(\",\"); } jsonBuilder.Append(\"]\"); return jsonBuilder.ToString(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "EnemyDefinitionsHolderSO",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "EnemyDefinitionsHolderSO",
          "content": "using System.Text; using DungeonScrollerCore; using UnityEngine; using UnityEngine.Serialization; [CreateAssetMenu(fileName = \"EnemyDefinitionsHolder\", menuName = \"ScriptableObjects/EnemyDefinitionsHolderSO\")] public class EnemyDefinitionsHolderSO : ScriptableObject { public EnemyDefinition[] EnemyDefinitions => _enemyDefinitions; [SerializeField] private EnemyDefinition[] _enemyDefinitions; private EnemyDefinition[] _sortedEnemyDefinitions; public EnemyDefinition[] GetSortedEnemyDefinitions() { if (_sortedEnemyDefinitions == null || _sortedEnemyDefinitions.Length == 0) { _sortedEnemyDefinitions = new EnemyDefinition[EnemyDefinitions.Length]; for (int i = 0; i < EnemyDefinitions.Length; i++) { _sortedEnemyDefinitions[i] = EnemyDefinitions[i]; } //sort asscending System.Array.Sort(_sortedEnemyDefinitions, (x, y) => x.ChanceToSpawn.CompareTo(y.ChanceToSpawn)); } return _sortedEnemyDefinitions; } /// <summary> /// Returns enemy with highest chance to spawn according to random value from 0f to 1f. Drop chance should not be equal between enemies. /// </summary> /// <param name=\"type\"></param> /// <returns></returns> public byte GetRandomEnemyId(EnemyDefinition.Type type) { byte result = 255; byte any = 255; float roll = Random.Range(0.0f, 1.0f); //EnemyDefinition[] sorted = GetSortedEnemyDefinitions(); if (type == EnemyDefinition.Type.Boss) { DebugWrite.Log(\"Boss\");  ",
          "content_tokens": 382,
          "embedding": []
        },
        {
          "cs_scriptfile": "EnemyDefinitionsHolderSO",
          "content": "for (byte id = 0; id < GetSortedEnemyDefinitions().Length; id++){ if (GetSortedEnemyDefinitions()[id].EnemyType != type) continue; any = GetSortedEnemyDefinitions()[id].Id; if (any == 2) { DebugWrite.Log(\"Any\");  if (roll < GetSortedEnemyDefinitions()[id].ChanceToSpawn) { result = GetSortedEnemyDefinitions()[id].Id; break; }  ",
          "content_tokens": 113,
          "embedding": []
        },
        {
          "cs_scriptfile": "EnemyDefinitionsHolderSO",
          "content": "if (result != 255) return result; return any; } public EnemyDefinition GetEnemyDefinition(int id){ for(int i = 0; i < GetSortedEnemyDefinitions().Length; i++){ if(GetSortedEnemyDefinitions()[i].Id == id){ return GetSortedEnemyDefinitions()[i]; } } DebugWrite.LogError($\"EnemyDefinition with id {id} not found\"); return null;  ",
          "content_tokens": 100,
          "embedding": []
        },
        {
          "cs_scriptfile": "EnemyDefinitionsHolderSO",
          "content": "public byte GetId(EnemyDefinition enemyDefinition){ for(int i = 0; i < _enemyDefinitions.Length; i++){ if(_enemyDefinitions[i] == enemyDefinition){ return _enemyDefinitions[i].Id; } } return 0; } #if UNITY_EDITOR public void SetEnemyDefinitions(EnemyDefinition[] enemyDefinitions){ _enemyDefinitions = enemyDefinitions; } #endif public string SerializeToJson() { StringBuilder jsonBuilder = new StringBuilder(); jsonBuilder.Append(\"[\"); for (int i = 0; i < _enemyDefinitions.Length; i++) { jsonBuilder.Append(_enemyDefinitions[i].GetJsonRepresentation()); if (i < _enemyDefinitions.Length - 1) jsonBuilder.Append(\",\"); } jsonBuilder.Append(\"]\"); return jsonBuilder.ToString(); } }",
          "content_tokens": 195,
          "embedding": []
        }
      ],
      "length": 2724
    },
    {
      "filename": "FishnetSoundsSenderToZombieManager",
      "content": "using System.Collections; using System.Collections.Generic; using FishNet.Object; using UnityEngine; public class FishnetSoundsSenderToZombieManager : NetworkBehaviour { public static FishnetSoundsSenderToZombieManager Instance { get; private set; } private void Awake() { if (Instance != null && Instance != this) { Destroy(this); return; } Instance = this; } public void SendSoundToZombieManager(Vector3 position, float radius) { if (IsServer) { } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "FishnetSoundsSenderToZombieManager",
          "content": "using System.Collections; using System.Collections.Generic; using FishNet.Object; using UnityEngine; public class FishnetSoundsSenderToZombieManager : NetworkBehaviour { public static FishnetSoundsSenderToZombieManager Instance { get; private set; } private void Awake() { if (Instance != null && Instance != this) { Destroy(this); return; } Instance = this; } public void SendSoundToZombieManager(Vector3 position, float radius) { if (IsServer) { } } }",
          "content_tokens": 117,
          "embedding": []
        }
      ],
      "length": 454
    },
    {
      "filename": "NavMeshAgentAnimationsCaller",
      "content": "using UnityEngine; using Zomb.Creatures.Helpers; public class NavMeshAgentAnimationsCaller : MonoBehaviour { private NavMeshAgentDecorator _navMeshAgentDecorator; private AnimatorDecorator _animatorDecorator; #region animation IDs private int _animIDSpeed; private int _animIDGrounded; private int _animIDJump; private int _animIDFire; private int _animIDReload; private int _animIDFreeFall; private int _animIDHorizontal; private int _animIDVertical; private int _animIDAim; private int _animIDHorAngle; private int _animIDVerAngle; private int _animIDIsMoving; private int _animIDIsDead; private int _animIDIsAttacking; private float _canMoveAt; private float _canActAt; private float _canWanderAt; private bool _isWanderState; #endregion void Awake() { _navMeshAgentDecorator = GetComponent<NavMeshAgentDecorator>(); _animatorDecorator = GetComponent<AnimatorDecorator>(); _navMeshAgentDecorator.OnVelocityChanged += OnVelocityChanged; _animIDSpeed = Animator.StringToHash(\"Speed\"); _animIDIsMoving = Animator.StringToHash(\"IsMoving\"); } private void OnVelocityChanged(float newSpeed) { _animatorDecorator.SetBool(_animIDIsMoving, (newSpeed > .01f)); _animatorDecorator.SetFloat(_animIDSpeed, newSpeed); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "NavMeshAgentAnimationsCaller",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "NavMeshAgentAnimationsCaller",
          "content": "using UnityEngine; using Zomb.Creatures.Helpers; public class NavMeshAgentAnimationsCaller : MonoBehaviour { private NavMeshAgentDecorator _navMeshAgentDecorator; private AnimatorDecorator _animatorDecorator; #region animation IDs private int _animIDSpeed; private int _animIDGrounded; private int _animIDJump; private int _animIDFire; private int _animIDReload; private int _animIDFreeFall; private int _animIDHorizontal; private int _animIDVertical; private int _animIDAim; private int _animIDHorAngle; private int _animIDVerAngle; private int _animIDIsMoving; private int _animIDIsDead; private int _animIDIsAttacking; private float _canMoveAt; private float _canActAt; private float _canWanderAt; private bool _isWanderState; #endregion void Awake() { _navMeshAgentDecorator = GetComponent<NavMeshAgentDecorator>(); _animatorDecorator = GetComponent<AnimatorDecorator>(); _navMeshAgentDecorator.OnVelocityChanged += OnVelocityChanged; _animIDSpeed = Animator.StringToHash(\"Speed\"); _animIDIsMoving = Animator.StringToHash(\"IsMoving\");  ",
          "content_tokens": 295,
          "embedding": []
        },
        {
          "cs_scriptfile": "NavMeshAgentAnimationsCaller",
          "content": "private void OnVelocityChanged(float newSpeed) { _animatorDecorator.SetBool(_animIDIsMoving, (newSpeed > .01f)); _animatorDecorator.SetFloat(_animIDSpeed, newSpeed); } }",
          "content_tokens": 55,
          "embedding": []
        }
      ],
      "length": 1211
    },
    {
      "filename": "NavMeshAgentDecorator",
      "content": "using System; using UnityEngine; using UnityEngine.AI; using UnityEngine.Events; using DDCore; namespace Zomb.Creatures.Helpers { public class NavMeshAgentDecorator : MonoBehaviour { private float arriveDistance = .2f; public UnityAction OnArrive; public NavMeshAgent NavMeshAgent { get; private set; } public float VelocityMagnitude { get; private set; } public float TestVelocityMagnitude { get; private set; } private float _prevVelocity = .0f; public UnityAction<float> OnVelocityChanged; public UnityEvent OnStopMove; public UnityEvent OnStartMove; private void Awake() { NavMeshAgent = GetComponent<NavMeshAgent>(); SetStoppingDistance(arriveDistance); } private void Update() { VelocityMagnitude = NavMeshAgent.velocity.magnitude; if (!Mathf.Approximately(_prevVelocity, VelocityMagnitude)) { OnVelocityChanged?.Invoke(VelocityMagnitude); _prevVelocity = VelocityMagnitude; } TestVelocityMagnitude = Vector3.Project(NavMeshAgent.desiredVelocity, transform.forward).magnitude; } public void SetDestination(Vector3 newPos) { //Debug.Log($\"[Client] Setting NavMeshAgent destination of {gameObject.name} to {newPos}\", gameObject); Resume(); NavMeshAgent.destination = newPos; OnStartMove?.Invoke(); } private void OnDrawGizmos() { Gizmos.color = Color.red; Gizmos.DrawWireSphere(GetComponent<NavMeshAgent>().destination, 0.2f); } public void DisableNavMeshAgent() => NavMeshAgent.enabled = false; public void EnableNavMeshAgent() => NavMeshAgent.enabled = true; public void Reset() { NavMeshAgent.ResetPath(); } public void Stop() { if (NavMeshAgent.hasPath) NavMeshAgent.isStopped = true; OnStopMove?.Invoke(); } public void Resume() { NavMeshAgent.isStopped = false; } public void SetSpeed(float speed) { NavMeshAgent.speed = speed; } public void SetAngularSpeed(float angularSpeed) { NavMeshAgent.angularSpeed = angularSpeed; } public void SetAcceleration(float acceleration) { NavMeshAgent.acceleration = acceleration; } public void SetAutoBraking(bool autoBraking) { NavMeshAgent.autoBraking = autoBraking; } public void SetAutoRepath(bool autoRepath) { NavMeshAgent.autoRepath = autoRepath; } public void SetStoppingDistance(float stoppingDistance) { arriveDistance = stoppingDistance; NavMeshAgent.stoppingDistance = stoppingDistance; } public void SetPath(NavMeshPath path) { NavMeshAgent.SetPath(path); } /// <summary> /// Has the agent arrived at the destination? /// </summary> /// <returns>True if the agent has arrived at the destination.</returns> public bool HasArrived() { if (!Application.isPlaying) return false; // The path hasn't been computed yet if the path is pending. float remainingDistance; if (NavMeshAgent.pathPending) { remainingDistance = float.PositiveInfinity; OnArrive?.Invoke(); OnStopMove?.Invoke(); } else { remainingDistance = NavMeshAgent.remainingDistance; } //Debug.Log($\"[HasArrived] {remainingDistance <= arriveDistance}(remainingDistance: {remainingDistance})\"); return remainingDistance <= arriveDistance; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "NavMeshAgentDecorator",
          "content": "using System; using UnityEngine; using UnityEngine.AI; using UnityEngine.Events; using DDCore; namespace Zomb.Creatures.Helpers { public class NavMeshAgentDecorator : MonoBehaviour { private float arriveDistance = .2f; public UnityAction OnArrive; public NavMeshAgent NavMeshAgent { get; private set; } public float VelocityMagnitude { get; private set; } public float TestVelocityMagnitude { get; private set; } private float _prevVelocity = .0f; public UnityAction<float> OnVelocityChanged; public UnityEvent OnStopMove; public UnityEvent OnStartMove; private void Awake() { NavMeshAgent = GetComponent<NavMeshAgent>(); SetStoppingDistance(arriveDistance);  ",
          "content_tokens": 168,
          "embedding": []
        },
        {
          "cs_scriptfile": "NavMeshAgentDecorator",
          "content": "private void Update() { VelocityMagnitude = NavMeshAgent.velocity.magnitude; if (!Mathf.Approximately(_prevVelocity, VelocityMagnitude)) { OnVelocityChanged?.Invoke(VelocityMagnitude); _prevVelocity = VelocityMagnitude; } TestVelocityMagnitude = Vector3.Project(NavMeshAgent.desiredVelocity, transform.forward).magnitude;  public void SetDestination(Vector3 newPos) { //Debug.Log($\"[Client] Setting NavMeshAgent destination of {gameObject.name} to {newPos}\", gameObject); Resume(); NavMeshAgent.destination = newPos; OnStartMove?.Invoke();  private void OnDrawGizmos() { Gizmos.color = Color.red; Gizmos.DrawWireSphere(GetComponent<NavMeshAgent>().destination, 0.2f);  ",
          "content_tokens": 198,
          "embedding": []
        },
        {
          "cs_scriptfile": "NavMeshAgentDecorator",
          "content": "public void DisableNavMeshAgent() => NavMeshAgent.enabled = false; public void EnableNavMeshAgent() => NavMeshAgent.enabled = true; public void Reset() { NavMeshAgent.ResetPath();  public void Stop() { if (NavMeshAgent.hasPath) NavMeshAgent.isStopped = true; OnStopMove?.Invoke();  public void Resume() { NavMeshAgent.isStopped = false;  public void SetSpeed(float speed) { NavMeshAgent.speed = speed;  public void SetAngularSpeed(float angularSpeed) { NavMeshAgent.angularSpeed = angularSpeed;  public void SetAcceleration(float acceleration) { NavMeshAgent.acceleration = acceleration;  public void SetAutoBraking(bool autoBraking) { NavMeshAgent.autoBraking = autoBraking;  ",
          "content_tokens": 186,
          "embedding": []
        },
        {
          "cs_scriptfile": "NavMeshAgentDecorator",
          "content": "public void SetAutoRepath(bool autoRepath) { NavMeshAgent.autoRepath = autoRepath;  public void SetStoppingDistance(float stoppingDistance) { arriveDistance = stoppingDistance; NavMeshAgent.stoppingDistance = stoppingDistance;  ",
          "content_tokens": 57,
          "embedding": []
        },
        {
          "cs_scriptfile": "NavMeshAgentDecorator",
          "content": "public void SetPath(NavMeshPath path) { NavMeshAgent.SetPath(path); } /// <summary> /// Has the agent arrived at the destination? /// </summary> /// <returns>True if the agent has arrived at the destination.</returns> public bool HasArrived() { if (!Application.isPlaying) return false; // The path hasn't been computed yet if the path is pending. float remainingDistance; if (NavMeshAgent.pathPending) { remainingDistance = float.PositiveInfinity; OnArrive?.Invoke(); OnStopMove?.Invoke(); } else { remainingDistance = NavMeshAgent.remainingDistance; } //Debug.Log($\"[HasArrived] {remainingDistance <= arriveDistance}(remainingDistance: {remainingDistance})\"); return remainingDistance <= arriveDistance; } } }",
          "content_tokens": 182,
          "embedding": []
        }
      ],
      "length": 2958
    },
    {
      "filename": "SpawnPoint",
      "content": "using System; using UnityEngine; using UnityEngine.Serialization; [Serializable] public class SpawnPoint { [SerializeField] private ushort id; [SerializeField] private ushort type; [SerializeField] private ushort chunkId; [SerializeField] private Vector3 position; [SerializeField] private bool isAlive; [SerializeField] private float respawnTime; [SerializeField] private bool isUsed; [SerializeField] private float _closestPlayerDistance; private SpawnPointForJob _spawnPointForJob; public AIUnit SpawnedAI => spawnedAI; [SerializeField] private AIUnit spawnedAI; [FormerlySerializedAs(\"IsNeighbouringPoint\")] public bool IsUsedAsNeighbourToOtherPoint; public bool IsUsed => isUsed; public ushort Id => id; public Vector3 Position => position; public void SetUsedAs(bool isOn) { this.isUsed = isOn; } public void UpdateClosestPlayerDistance(float distance) { if (distance < _closestPlayerDistance) { _closestPlayerDistance = distance; } } public ushort GetCreatureType() => type; public SpawnPoint(ushort id, byte type, Vector3 position, float respawnTime) { this.id = id; this.type = type; this.position = position; isAlive = false; this.respawnTime = respawnTime; } public void StoreAIUnit(AIUnit aiUnit) { spawnedAI = aiUnit; isAlive = true; } public void RemoveAIUnit() { spawnedAI = null; isAlive = false; } } public struct SpawnPointForJob { public ushort id; public ushort type; public Vector3 position; public bool isUsed; public int spawnedAIObjectId; public bool IsUsedAsNeighbourToOtherPoint; }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SpawnPoint",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "SpawnPoint",
          "content": "using System; using UnityEngine; using UnityEngine.Serialization; [Serializable] public class SpawnPoint { [SerializeField] private ushort id; [SerializeField] private ushort type; [SerializeField] private ushort chunkId; [SerializeField] private Vector3 position; [SerializeField] private bool isAlive; [SerializeField] private float respawnTime; [SerializeField] private bool isUsed; [SerializeField] private float _closestPlayerDistance; private SpawnPointForJob _spawnPointForJob; public AIUnit SpawnedAI => spawnedAI; [SerializeField] private AIUnit spawnedAI; [FormerlySerializedAs(\"IsNeighbouringPoint\")] public bool IsUsedAsNeighbourToOtherPoint; public bool IsUsed => isUsed; public ushort Id => id; public Vector3 Position => position; public void SetUsedAs(bool isOn) { this.isUsed = isOn;  ",
          "content_tokens": 213,
          "embedding": []
        },
        {
          "cs_scriptfile": "SpawnPoint",
          "content": "public void UpdateClosestPlayerDistance(float distance) { if (distance < _closestPlayerDistance) { _closestPlayerDistance = distance; } } public ushort GetCreatureType() => type; public SpawnPoint(ushort id, byte type, Vector3 position, float respawnTime) { this.id = id; this.type = type; this.position = position; isAlive = false; this.respawnTime = respawnTime;  public void StoreAIUnit(AIUnit aiUnit) { spawnedAI = aiUnit; isAlive = true;  public void RemoveAIUnit() { spawnedAI = null; isAlive = false; } } public struct SpawnPointForJob { public ushort id; public ushort type; public Vector3 position; public bool isUsed; public int spawnedAIObjectId; public bool IsUsedAsNeighbourToOtherPoint; }",
          "content_tokens": 197,
          "embedding": []
        }
      ],
      "length": 1507
    },
    {
      "filename": "ZombieEars",
      "content": "using UnityEngine; using UnityEngine.Events; public class ZombieEars : MonoBehaviour { public UnityAction<Vector3> OnHeardSomething; public void HearSound(Vector3 soundPosition) { OnHeardSomething?.Invoke(soundPosition); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ZombieEars",
          "content": "using UnityEngine; using UnityEngine.Events; public class ZombieEars : MonoBehaviour { public UnityAction<Vector3> OnHeardSomething; public void HearSound(Vector3 soundPosition) { OnHeardSomething?.Invoke(soundPosition); } }",
          "content_tokens": 57,
          "embedding": []
        }
      ],
      "length": 225
    },
    {
      "filename": "DeadBody",
      "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using Org.BouncyCastle.Crypto.Tls; using UnityEngine; using Zomb.Creatures.Helpers; public class DeadBody : NetworkBehaviour { public AttachmentPoints MyAttachementPoints => attachmentPoints; [SerializeField] private EnemyDefinition _enemyDefinition; [SerializeField] private AnimatorDecorator _animatorDecorator; [SerializeField] private AudioClip[] deathSounds; [SerializeField] private AudioSource audioSource; [SerializeField] private AttachmentPoints attachmentPoints; private GameplayManager _gameplayManager; protected override void OnValidate() { base.OnValidate(); audioSource ??= GetComponent<AudioSource>(); attachmentPoints ??= GetComponent<AttachmentPoints>(); } public void SetupAnimatorDecorator() { if (_animatorDecorator == null) { _animatorDecorator = GetComponent<AnimatorDecorator>(); } } public void Init(GameplayManager gpm, AnimatorDecorator realUnitAnimator) { _gameplayManager = gpm; //synchronize animations from real unit to AnimatorDecorator } public override void OnStartNetwork() { base.OnStartNetwork(); SetName(); } public override void OnStartServer() { base.OnStartServer(); PlayDeathSound(); } [ObserversRpc(ExcludeServer = true)] private void PlayDeathSound() { var sound = deathSounds[Random.Range(0, deathSounds.Length)]; if (sound != null) audioSource.PlayOneShot(sound); } private void SetName() { gameObject.name = $\"DeadBody_{_enemyDefinition.name} #{base.ObjectId}\"; } private void Start() { _animatorDecorator.SetBool(\"IsDead\", true); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DeadBody",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "DeadBody",
          "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using Org.BouncyCastle.Crypto.Tls; using UnityEngine; using Zomb.Creatures.Helpers; public class DeadBody : NetworkBehaviour { public AttachmentPoints MyAttachementPoints => attachmentPoints; [SerializeField] private EnemyDefinition _enemyDefinition; [SerializeField] private AnimatorDecorator _animatorDecorator; [SerializeField] private AudioClip[] deathSounds; [SerializeField] private AudioSource audioSource; [SerializeField] private AttachmentPoints attachmentPoints; private GameplayManager _gameplayManager; protected override void OnValidate() { base.OnValidate(); audioSource ??= GetComponent<AudioSource>(); attachmentPoints ??= GetComponent<AttachmentPoints>();  ",
          "content_tokens": 202,
          "embedding": []
        },
        {
          "cs_scriptfile": "DeadBody",
          "content": "public void SetupAnimatorDecorator() { if (_animatorDecorator == null) { _animatorDecorator = GetComponent<AnimatorDecorator>(); }  public void Init(GameplayManager gpm, AnimatorDecorator realUnitAnimator) { _gameplayManager = gpm; //synchronize animations from real unit to AnimatorDecorator } public override void OnStartNetwork() { base.OnStartNetwork(); SetName(); } public override void OnStartServer() { base.OnStartServer(); PlayDeathSound(); } [ObserversRpc(ExcludeServer = true)] private void PlayDeathSound() { var sound = deathSounds[Random.Range(0, deathSounds.Length)]; if (sound != null) audioSource.PlayOneShot(sound);  ",
          "content_tokens": 175,
          "embedding": []
        },
        {
          "cs_scriptfile": "DeadBody",
          "content": "private void SetName() { gameObject.name = $\"DeadBody_{_enemyDefinition.name} #{base.ObjectId}\";  private void Start() { _animatorDecorator.SetBool(\"IsDead\", true); } }",
          "content_tokens": 54,
          "embedding": []
        }
      ],
      "length": 1595
    },
    {
      "filename": "AIUnitEditor",
      "content": "using System; using System.Collections.Generic; using System.Text; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Component.Animating; using FishNet.Object; using FishnetInvector; using Pathfinding; using Pathfinding.RVO; using UnityEditor; using UnityEngine; [CustomEditor(typeof(AIUnit))] public class AIUnitEditor : Editor { private MonoBehaviour _monoBehaviour; private BehavioursSwitcher _behSwitcher; private SerializedProperty properties; private bool showProperties = true; // toggle variable private string[] propertyNames = new string[] { \"_animatorDecorator\", //\"_navMeshAgent\", \"_navMeshAgentDecorator\", \"_zombieEars\", \"_behaviorTree\", \"_moanAudio\", \"_statsController\", \"_astarAI\", \"_meleeManager\" }; private SerializedProperty[] _properties; private AIUnit _aiUnit; private CharacterController _characterController; private void OnEnable() { _aiUnit = (AIUnit)target; _characterController = _aiUnit.GetComponent<CharacterController>(); _properties = new SerializedProperty[propertyNames.Length]; if (_aiUnit.Head == null) { var availableTransforms = _aiUnit.GetComponent<AttachmentPoints>().PointTransforms; //loop through available transforms and find the head for (int i = 0; i < availableTransforms.Length; i++) { if (availableTransforms[i].point == AttachmentPoints.Point.Head) { _aiUnit.SetHeadTransform(availableTransforms[i].trans); break; // You found the head, exit the loop } } } if (_aiUnit.AnimatorDecorator.Animator == null) { _aiUnit.AnimatorDecorator.SetAnimator(_aiUnit.GetComponentInChildren<Animator>()); } if (_aiUnit.GetComponent<NetworkAnimator>().Animator == null) { _aiUnit.GetComponent<NetworkAnimator>().SetAnimator(_aiUnit.AnimatorDecorator.Animator); } for (int i = 0; i < propertyNames.Length; i++) _properties[i] = serializedObject.FindProperty(propertyNames[i]); } public override void OnInspectorGUI() { serializedObject.Update(); // Draw the default inspector without our custom properties DrawPropertiesExcluding(serializedObject, propertyNames); showProperties = EditorGUILayout.Foldout(showProperties, \"Custom Properties\"); EditorGUILayout.LabelField(\"Players Within Sight: \"); EditorGUI.indentLevel++; int count = 0; foreach (int playerId in _aiUnit.PlayersWithinSight) { EditorGUILayout.LabelField($\"{count}: {playerId}\"); count++; } EditorGUI.indentLevel--; if (showProperties) { for (int i = 0; i < _properties.Length; i++) { EditorGUILayout.PropertyField(_properties[i]); } } //DrawDefaultInspector(); if (_monoBehaviour == null) { _monoBehaviour = (MonoBehaviour)target; } if (_behSwitcher == null) { _behSwitcher = _monoBehaviour.GetComponent<BehavioursSwitcher>(); } if (GUILayout.Button(\"Reassign Behaviours in Behaviours Switcher\")) { _behSwitcher.ClearAllBehaviours(); AssignBehaviours(_behSwitcher); } if (GUILayout.Button(\"Store Renderers and Colors\")) { _aiUnit.StoreRendererColors(); } if (_behSwitcher.IsRequireInitialization) { AssignBehaviours(_behSwitcher); } _aiUnit.StoreComponents(); serializedObject.ApplyModifiedProperties(); } private void AssignBehaviours(BehavioursSwitcher behSwitcher) { List<Behaviour> serverComponents = BehavioursSwitcherUtility.DefineBehaviours(_monoBehaviour, new List<Type>() { typeof(ZombieEars), typeof(BehaviorDesigner.Runtime.BehaviorTree), //typeof(NavMeshAgent), //typeof(NavMeshAgentDecorator), typeof(AIPath), typeof(Seeker), typeof(AstarAI), typeof(RVOController), typeof(FNvMeleeManager) }); List<Behaviour> observerComponents = BehavioursSwitcherUtility.DefineBehaviours(_monoBehaviour, new List<Type>() { typeof(EnemyMoanAudio) }); behSwitcher.AddConnectionSpecificBehaviours(BehavioursSwitcher.connectionType.Server, serverComponents); behSwitcher.AddConnectionSpecificBehaviours(BehavioursSwitcher.connectionType.Observer, observerComponents); } private void OnSceneGUI() { var tr = _aiUnit.transform; var pos = tr.position; var color = new Color(1, 0.8f, 0.4f, 1); GUI.color = color; NavMeshDebugHelpers.drawString(GetInfoText(tr), new Vector3(pos.x+1.5f, pos.y, pos.z), Color.black); } private string GetInfoText(Transform tr) { StringBuilder str = new StringBuilder(); if (Application.isPlaying) { int targetId = _aiUnit.GetTargetId(); str.Append($\"{tr.name}\"); if (_aiUnit.IsInCombat) { str.Append($\" (Combat)\"); } str.Append($\"\\npos: {tr.position}\\n\"); str.Append($\"hp: {_aiUnit.HealthController.CurrentHealth}\\n\"); str.Append($\"Anim(IsMoving): {_aiUnit.AnimatorDecorator.GetBool(_aiUnit.AnimIDIsMoving)}\\n\"); if (targetId > -1) { var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetId); if (targetComps == null) { str.Append($\"Target: null\\n\"); return str.ToString(); } Transform targetTr = targetComps.HealthController.transform; str.Append($\"Target: {targetTr.name}\\n\"); str.Append($\"Distance: {Mathf.Sqrt(Vector3.SqrMagnitude(_aiUnit.transform.position - targetTr.position))} ({_aiUnit.IsTargetWithinAttackDistance()})\\n\"); } else { str.Append($\"Target: -\\n\"); } str.Append($\"IsAttackCooldown: {_aiUnit.IsAttackOnCooldown}\\n\"); str.Append($\"Anim(IsInCombat): {_aiUnit.AnimatorDecorator.GetBool(_aiUnit.AnimIDIsInCombat)}\"); str.Append($\"velocity: {_characterController.velocity}\\n\"); } return str.ToString(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AIUnitEditor",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnitEditor",
          "content": "using System; using System.Collections.Generic; using System.Text; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Component.Animating; using FishNet.Object; using FishnetInvector; using Pathfinding; using Pathfinding.RVO; using UnityEditor; using UnityEngine; [CustomEditor(typeof(AIUnit))] public class AIUnitEditor : Editor { private MonoBehaviour _monoBehaviour; private BehavioursSwitcher _behSwitcher; private SerializedProperty properties; private bool showProperties = true; // toggle variable private string[] propertyNames = new string[] { \"_animatorDecorator\", //\"_navMeshAgent\", \"_navMeshAgentDecorator\", \"_zombieEars\", \"_behaviorTree\", \"_moanAudio\", \"_statsController\", \"_astarAI\", \"_meleeManager\" }; private SerializedProperty[] _properties; private AIUnit _aiUnit; private CharacterController _characterController; private void OnEnable() { _aiUnit = (AIUnit)target; _characterController = _aiUnit.GetComponent<CharacterController>(); _properties = new SerializedProperty[propertyNames.Length]; if (_aiUnit.Head == null) { var availableTransforms = _aiUnit.GetComponent<AttachmentPoints>().PointTransforms; //loop through available transforms and find the head for (int i = 0; i < availableTransforms.Length; i++) { if (availableTransforms[i].point == AttachmentPoints.Point.Head) { _aiUnit.SetHeadTransform(availableTransforms[i].trans); break; // You found the head, exit the loop } }  ",
          "content_tokens": 379,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnitEditor",
          "content": "if (_aiUnit.AnimatorDecorator.Animator == null) { _aiUnit.AnimatorDecorator.SetAnimator(_aiUnit.GetComponentInChildren<Animator>());  if (_aiUnit.GetComponent<NetworkAnimator>().Animator == null) { _aiUnit.GetComponent<NetworkAnimator>().SetAnimator(_aiUnit.AnimatorDecorator.Animator);  ",
          "content_tokens": 93,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnitEditor",
          "content": "for (int i = 0; i < propertyNames.Length; i++) _properties[i] = serializedObject.FindProperty(propertyNames[i]); } public override void OnInspectorGUI() { serializedObject.Update(); // Draw the default inspector without our custom properties DrawPropertiesExcluding(serializedObject, propertyNames); showProperties = EditorGUILayout.Foldout(showProperties, \"Custom Properties\"); EditorGUILayout.LabelField(\"Players Within Sight: \"); EditorGUI.indentLevel++; int count = 0; foreach (int playerId in _aiUnit.PlayersWithinSight) { EditorGUILayout.LabelField($\"{count}: {playerId}\"); count++; } EditorGUI.indentLevel--; if (showProperties) { for (int i = 0; i < _properties.Length; i++) { EditorGUILayout.PropertyField(_properties[i]); } } //DrawDefaultInspector(); if (_monoBehaviour == null) { _monoBehaviour = (MonoBehaviour)target;  ",
          "content_tokens": 240,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnitEditor",
          "content": "if (_behSwitcher == null) { _behSwitcher = _monoBehaviour.GetComponent<BehavioursSwitcher>();  if (GUILayout.Button(\"Reassign Behaviours in Behaviours Switcher\")) { _behSwitcher.ClearAllBehaviours(); AssignBehaviours(_behSwitcher);  if (GUILayout.Button(\"Store Renderers and Colors\")) { _aiUnit.StoreRendererColors();  if (_behSwitcher.IsRequireInitialization) { AssignBehaviours(_behSwitcher); } _aiUnit.StoreComponents(); serializedObject.ApplyModifiedProperties();  ",
          "content_tokens": 148,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnitEditor",
          "content": "private void AssignBehaviours(BehavioursSwitcher behSwitcher) { List<Behaviour> serverComponents = BehavioursSwitcherUtility.DefineBehaviours(_monoBehaviour, new List<Type>() { typeof(ZombieEars), typeof(BehaviorDesigner.Runtime.BehaviorTree), //typeof(NavMeshAgent), //typeof(NavMeshAgentDecorator), typeof(AIPath), typeof(Seeker), typeof(AstarAI), typeof(RVOController), typeof(FNvMeleeManager) }); List<Behaviour> observerComponents = BehavioursSwitcherUtility.DefineBehaviours(_monoBehaviour, new List<Type>() { typeof(EnemyMoanAudio) }); behSwitcher.AddConnectionSpecificBehaviours(BehavioursSwitcher.connectionType.Server, serverComponents); behSwitcher.AddConnectionSpecificBehaviours(BehavioursSwitcher.connectionType.Observer, observerComponents);  ",
          "content_tokens": 231,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnitEditor",
          "content": "private void OnSceneGUI() { var tr = _aiUnit.transform; var pos = tr.position; var color = new Color(1, 0.8f, 0.4f, 1); GUI.color = color; NavMeshDebugHelpers.drawString(GetInfoText(tr), new Vector3(pos.x+1.5f, pos.y, pos.z), Color.black);  ",
          "content_tokens": 91,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIUnitEditor",
          "content": "private string GetInfoText(Transform tr) { StringBuilder str = new StringBuilder(); if (Application.isPlaying) { int targetId = _aiUnit.GetTargetId(); str.Append($\"{tr.name}\"); if (_aiUnit.IsInCombat) { str.Append($\" (Combat)\"); } str.Append($\"\\npos: {tr.position}\\n\"); str.Append($\"hp: {_aiUnit.HealthController.CurrentHealth}\\n\"); str.Append($\"Anim(IsMoving): {_aiUnit.AnimatorDecorator.GetBool(_aiUnit.AnimIDIsMoving)}\\n\"); if (targetId > -1) { var targetComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetId); if (targetComps == null) { str.Append($\"Target: null\\n\"); return str.ToString(); } Transform targetTr = targetComps.HealthController.transform; str.Append($\"Target: {targetTr.name}\\n\"); str.Append($\"Distance: {Mathf.Sqrt(Vector3.SqrMagnitude(_aiUnit.transform.position - targetTr.position))} ({_aiUnit.IsTargetWithinAttackDistance()})\\n\"); } else { str.Append($\"Target: -\\n\"); } str.Append($\"IsAttackCooldown: {_aiUnit.IsAttackOnCooldown}\\n\"); str.Append($\"Anim(IsInCombat): {_aiUnit.AnimatorDecorator.GetBool(_aiUnit.AnimIDIsInCombat)}\"); str.Append($\"velocity: {_characterController.velocity}\\n\"); } return str.ToString(); } }",
          "content_tokens": 390,
          "embedding": []
        }
      ],
      "length": 5222
    },
    {
      "filename": "AstarAIEditor",
      "content": "using System.Text; using Pathfinding; using UnityEditor; using UnityEngine; [CustomEditor(typeof(AstarAI))] public class AstarAIEditor : Editor { private AstarAI _astarAI; private AIPath _aiPath; private void OnEnable() { _astarAI = (AstarAI)target; _aiPath = _astarAI.GetComponent<AIPath>(); } private void OnSceneGUI() { var tr = _astarAI.transform; var pos = tr.position; var color = new Color(.5f, .8f, .5f, .5f); GUI.color = color; NavMeshDebugHelpers.drawString(GetInfoText(), new Vector3(pos.x-2.0f, pos.y, pos.z), Color.blue); } private string GetInfoText() { StringBuilder str = new StringBuilder(); if (Application.isPlaying) { str.Append($\"destination: {_aiPath.destination}\\n\"); str.Append($\"speed: {_aiPath.maxSpeed}\\n\"); str.Append($\"HasArrived: {_astarAI.HasArrived()}\\n\"); str.Append($\"reachedDestination: >{_aiPath.reachedDestination}<\\n\"); str.Append($\"reachedEndOfPath: {_aiPath.reachedEndOfPath}\\n\"); str.Append($\"hasPath: {_aiPath.hasPath}\\n\"); str.Append($\"pathPending: {_aiPath.pathPending}\\n\"); str.Append($\"velocity: {_aiPath.velocity}\\n\"); } return str.ToString(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AstarAIEditor",
          "content": "using System.Text; using Pathfinding; using UnityEditor; using UnityEngine; [CustomEditor(typeof(AstarAI))] public class AstarAIEditor : Editor { private AstarAI _astarAI; private AIPath _aiPath; private void OnEnable() { _astarAI = (AstarAI)target; _aiPath = _astarAI.GetComponent<AIPath>();  private void OnSceneGUI() { var tr = _astarAI.transform; var pos = tr.position; var color = new Color(.5f, .8f, .5f, .5f); GUI.color = color; NavMeshDebugHelpers.drawString(GetInfoText(), new Vector3(pos.x-2.0f, pos.y, pos.z), Color.blue);  ",
          "content_tokens": 183,
          "embedding": []
        },
        {
          "cs_scriptfile": "AstarAIEditor",
          "content": "private string GetInfoText() { StringBuilder str = new StringBuilder(); if (Application.isPlaying) { str.Append($\"destination: {_aiPath.destination}\\n\"); str.Append($\"speed: {_aiPath.maxSpeed}\\n\"); str.Append($\"HasArrived: {_astarAI.HasArrived()}\\n\"); str.Append($\"reachedDestination: >{_aiPath.reachedDestination}<\\n\"); str.Append($\"reachedEndOfPath: {_aiPath.reachedEndOfPath}\\n\"); str.Append($\"hasPath: {_aiPath.hasPath}\\n\"); str.Append($\"pathPending: {_aiPath.pathPending}\\n\"); str.Append($\"velocity: {_aiPath.velocity}\\n\"); } return str.ToString(); } }",
          "content_tokens": 202,
          "embedding": []
        }
      ],
      "length": 1095
    },
    {
      "filename": "DeadBodyEditor",
      "content": "using System; using System.Collections.Generic; using BehaviorDesigner.Runtime; using FishNet.Component.Animating; using FishNet.Component.Transforming; using FishNet.Object; using FishnetInvector; using Invector.vCharacterController; using Invector.vMelee; using Pathfinding; using Pathfinding.RVO; using Unity.VisualScripting; using UnityEditor; using UnityEngine; [CustomEditor(typeof(DeadBody))] public class DeadBodyEditor : Editor { private DeadBody _deadBody; private MonoBehaviour _monoBehaviour; private void OnEnable() { if (_monoBehaviour == null) { _monoBehaviour = (MonoBehaviour)target; } _deadBody = (DeadBody)target; _deadBody.SetupAnimatorDecorator(); } public override void OnInspectorGUI() { DrawDefaultInspector(); if (Application.isPlaying) { return; } serializedObject.Update(); if (GUILayout.Button(\"Clear Unused Components\")) { AddTriggerCollider(); AssignPrefabToEnemyDefinition(); ClearChildrenComponents(); ClearParentComponents(); _deadBody.gameObject.layer = LayerMask.NameToLayer(\"DeadBody\"); _deadBody.gameObject.tag = \"DeadBody\"; Debug.Log($\"[DeadBodyEditor] Cleared unused components from {_monoBehaviour.name}.\"); } serializedObject.ApplyModifiedProperties(); } private void ClearParentComponents() { List<Behaviour> parentComponentsTypes = GetUnusedParentComponentsTypes(); BehavioursSwitcherUtility.RemoveBehaviours(_monoBehaviour, parentComponentsTypes, true); DestroyImmediate(_deadBody.GetComponent<CharacterController>()); } private void ClearChildrenComponents() { List<Behaviour> whichBehaviours = GetUnusedChildrenComponentsTypes(); BehavioursSwitcherUtility.RemoveBehaviours(_monoBehaviour, whichBehaviours, false); } private List<Behaviour> GetUnusedChildrenComponentsTypes() { List<Behaviour> components = BehavioursSwitcherUtility.DefineBehaviours(_monoBehaviour, new List<Type>() { typeof(vDamageReceiver), typeof(vMeleeAttackObject), typeof(vHitBox), typeof(Collider) }); return components; } private List<Behaviour> GetUnusedParentComponentsTypes() { List<Behaviour> components = BehavioursSwitcherUtility.DefineBehaviours(_monoBehaviour, new List<Type>() { typeof(AIUnit), typeof(ZombieEars), typeof(FNvMeleeManager), typeof(BehaviorTree), typeof(EnemyMoanAudio), typeof(FishnetInvectorHealthController), typeof(FNStatsController), typeof(BehavioursSwitcher), typeof(Seeker), typeof(AIPath), typeof(AstarAI), typeof(FunnelModifier), typeof(RVOController), //typeof(AttachmentPoints), typeof(NetworkAnimator), typeof(NetworkTransform), typeof(CharacterController), }); return components; } private void AssignPrefabToEnemyDefinition() { AIUnit aiUnit = _deadBody.GetComponent<AIUnit>(); if (aiUnit != null) _deadBody.GetComponent<AIUnit>().EnemyDefinition.DeadBodyPrefab = _deadBody; } private void AddTriggerCollider() { if (_deadBody.GetComponent<BoxCollider>() == null) { BoxCollider collider = _deadBody.AddComponent<BoxCollider>(); collider.isTrigger = true; collider.center = new Vector3(0, 0.25f, 0); collider.size = new Vector3(2f, 0.5f, 2f); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DeadBodyEditor",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "DeadBodyEditor",
          "content": "using System; using System.Collections.Generic; using BehaviorDesigner.Runtime; using FishNet.Component.Animating; using FishNet.Component.Transforming; using FishNet.Object; using FishnetInvector; using Invector.vCharacterController; using Invector.vMelee; using Pathfinding; using Pathfinding.RVO; using Unity.VisualScripting; using UnityEditor; using UnityEngine; [CustomEditor(typeof(DeadBody))] public class DeadBodyEditor : Editor { private DeadBody _deadBody; private MonoBehaviour _monoBehaviour; private void OnEnable() { if (_monoBehaviour == null) { _monoBehaviour = (MonoBehaviour)target; } _deadBody = (DeadBody)target; _deadBody.SetupAnimatorDecorator(); } public override void OnInspectorGUI() { DrawDefaultInspector(); if (Application.isPlaying) { return; } serializedObject.Update(); if (GUILayout.Button(\"Clear Unused Components\")) { AddTriggerCollider(); AssignPrefabToEnemyDefinition(); ClearChildrenComponents(); ClearParentComponents(); _deadBody.gameObject.layer = LayerMask.NameToLayer(\"DeadBody\"); _deadBody.gameObject.tag = \"DeadBody\"; Debug.Log($\"[DeadBodyEditor] Cleared unused components from {_monoBehaviour.name}.\"); } serializedObject.ApplyModifiedProperties();  ",
          "content_tokens": 321,
          "embedding": []
        },
        {
          "cs_scriptfile": "DeadBodyEditor",
          "content": "private void ClearParentComponents() { List<Behaviour> parentComponentsTypes = GetUnusedParentComponentsTypes(); BehavioursSwitcherUtility.RemoveBehaviours(_monoBehaviour, parentComponentsTypes, true); DestroyImmediate(_deadBody.GetComponent<CharacterController>());  ",
          "content_tokens": 67,
          "embedding": []
        },
        {
          "cs_scriptfile": "DeadBodyEditor",
          "content": "private void ClearChildrenComponents() { List<Behaviour> whichBehaviours = GetUnusedChildrenComponentsTypes(); BehavioursSwitcherUtility.RemoveBehaviours(_monoBehaviour, whichBehaviours, false); } private List<Behaviour> GetUnusedChildrenComponentsTypes() { List<Behaviour> components = BehavioursSwitcherUtility.DefineBehaviours(_monoBehaviour, new List<Type>() { typeof(vDamageReceiver), typeof(vMeleeAttackObject), typeof(vHitBox), typeof(Collider) }); return components; } private List<Behaviour> GetUnusedParentComponentsTypes() { List<Behaviour> components = BehavioursSwitcherUtility.DefineBehaviours(_monoBehaviour, new List<Type>() { typeof(AIUnit), typeof(ZombieEars), typeof(FNvMeleeManager), typeof(BehaviorTree), typeof(EnemyMoanAudio), typeof(FishnetInvectorHealthController), typeof(FNStatsController), typeof(BehavioursSwitcher), typeof(Seeker), typeof(AIPath), typeof(AstarAI), typeof(FunnelModifier), typeof(RVOController), //typeof(AttachmentPoints), typeof(NetworkAnimator), typeof(NetworkTransform), typeof(CharacterController), }); return components;  ",
          "content_tokens": 316,
          "embedding": []
        },
        {
          "cs_scriptfile": "DeadBodyEditor",
          "content": "private void AssignPrefabToEnemyDefinition() { AIUnit aiUnit = _deadBody.GetComponent<AIUnit>(); if (aiUnit != null) _deadBody.GetComponent<AIUnit>().EnemyDefinition.DeadBodyPrefab = _deadBody;  private void AddTriggerCollider() { if (_deadBody.GetComponent<BoxCollider>() == null) { BoxCollider collider = _deadBody.AddComponent<BoxCollider>(); collider.isTrigger = true; collider.center = new Vector3(0, 0.25f, 0); collider.size = new Vector3(2f, 0.5f, 2f); } } }",
          "content_tokens": 153,
          "embedding": []
        }
      ],
      "length": 3007
    },
    {
      "filename": "EnemyDefinitionEditor",
      "content": "using UnityEngine; using UnityEditor; using System.Text; // Make sure this script is placed under an Editor folder. [CustomEditor(typeof(EnemyDefinition))] public class EnemyDefinitionEditor : Editor { public override void OnInspectorGUI() { // Draw the default inspector DrawDefaultInspector(); // Cast the target to EnemyDefinition EnemyDefinition enemyDef = (EnemyDefinition)target; // Generate the JSON representation of the necessary information string json = enemyDef.GetJsonRepresentation(); // Draw a text area with the JSON representation GUIStyle textAreaStyle = new GUIStyle(EditorStyles.textArea); textAreaStyle.wordWrap = true; EditorGUILayout.LabelField(\"JSON Representation:\", EditorStyles.boldLabel); EditorGUILayout.TextArea(json, textAreaStyle, GUILayout.MinHeight(45)); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "EnemyDefinitionEditor",
          "content": "using UnityEngine; using UnityEditor; using System.Text; // Make sure this script is placed under an Editor folder. [CustomEditor(typeof(EnemyDefinition))] public class EnemyDefinitionEditor : Editor { public override void OnInspectorGUI() { // Draw the default inspector DrawDefaultInspector(); // Cast the target to EnemyDefinition EnemyDefinition enemyDef = (EnemyDefinition)target; // Generate the JSON representation of the necessary information string json = enemyDef.GetJsonRepresentation(); // Draw a text area with the JSON representation GUIStyle textAreaStyle = new GUIStyle(EditorStyles.textArea); textAreaStyle.wordWrap = true; EditorGUILayout.LabelField(\"JSON Representation:\", EditorStyles.boldLabel); EditorGUILayout.TextArea(json, textAreaStyle, GUILayout.MinHeight(45)); } }",
          "content_tokens": 195,
          "embedding": []
        }
      ],
      "length": 792
    },
    {
      "filename": "EnemyDefinition",
      "content": " using System; using System.Collections.Generic; using System.Text; using InRoomSystems; using UnityEngine; using Invector.vItemManager; using Unity.VisualScripting; [CreateAssetMenu(menuName = \"ScriptableObjects/EnemyDefinition\", fileName = \"EnemyDefinition\")] public class EnemyDefinition : ScriptableObject { public byte Id; public AIUnit VisualPrefab; public DeadBody DeadBodyPrefab; public string Name; public int MaxHealth = 100; public float AttackCooldown = 2f; public float MoveSpeed = 1.6f; public float RunSpeed = 1.6f; public float Acceleration = 2.0f; [HideInInspector] public float CurrentRotationSpeed = 0f; public float MaxRotationSpeed = 2.0f; public float FieldOfView = 290.0f; public float ViewDistance = 30.0f; public float AttackDistance = 2.0f; public float MaxDistanceFromSpot = 80.0f; public float MoveSpeedMultiplier = 1.0f; public int Experience = 30; public List<SoundsInfo> Sounds; [Header(\"Should not have duplicative chances. Sorted by chance to spawn.\")] public float ChanceToSpawn = 0.3f; public Type EnemyType; public CratesSystem.Zone LootBagZone = CratesSystem.Zone.level1; public GameObject _bloodPool; public GameObject _bloodSplatter; public HitAnimationClips[] hitAnimations; public int Strength = 10; [Header(\"Loot\")] public PossibleItemRanges[] ItemsDropChances = new []{new PossibleItemRanges(2, 32), new PossibleItemRanges(35, 10000)}; public float LootBagChanceMod = .0f; public int LootBagItemsCount = 1; public float GoldDropChance = .3f; public int MinGoldDrop = 1; public int MaxGoldDrop = 10; public LootDefinition[] Loot; [field:SerializeField] public AnimationClip AnimationTakeOff { get; private set; } [field:SerializeField] public AnimationClip AnimationLanding { get; private set; } [System.Serializable] public class LootDefinition { public vItem Item; public float Chance; public int MinQuantity = 1; public int MaxQuantity = 1; } public enum Type {Monster, Boss, Summon} [System.Serializable] public class SoundsInfo { public enum SoundType { Idle, Attack, Combat, Death, Hit, Moan, Run, Walk } public SoundType Type; public AudioClip[] Clips; public AudioClip GetRandomClip() { return Clips[UnityEngine.Random.Range(0, Clips.Length)]; } } [Serializable] public struct PossibleItemRanges { [Range(0, 20000)] public int FromId; [Range(0, 20000)] public int ToId; public PossibleItemRanges(int fromId, int toId) { FromId = fromId; ToId = toId; } } public string GetJsonRepresentation() { StringBuilder jsonBuilder = new StringBuilder(); jsonBuilder.Append(\"{\\n\"); jsonBuilder.AppendFormat(\" \\\"Name\\\": \\\"{0}\\\",\\n\", Name); jsonBuilder.AppendFormat(\" \\\"Type\\\": \\\"{0}\\\",\\n\", EnemyType.ToString()); jsonBuilder.AppendFormat(\" \\\"Strength\\\": {0},\\n\", Strength); jsonBuilder.AppendFormat(\" \\\"RunSpeed\\\": {0},\\n\", RunSpeed); jsonBuilder.AppendFormat(\" \\\"MaxHealth\\\": {0},\\n\", MaxHealth); jsonBuilder.AppendFormat(\" \\\"Attack cooldown\\\": {0},\\n\", AttackCooldown); jsonBuilder.AppendFormat(\" \\\"Attack distance\\\": {0},\\n\", AttackDistance); jsonBuilder.AppendFormat(\" \\\"Attack animation\\\": {0},\\n\", GetAttackAnimationsLength()); jsonBuilder.AppendFormat(\" \\\"RewardExperience\\\": {0},\\n\", Experience); jsonBuilder.AppendFormat(\" \\\"ChanceToSpawn\\\": {0},\\n\", ChanceToSpawn.ToString(\"F2\")); // Add other necessary fields in the same pattern jsonBuilder.Append(\"}\"); return jsonBuilder.ToString(); } private float GetAttackAnimationsLength() { if (VisualPrefab == null) return 1f; Animator animator = VisualPrefab.GetComponentInChildren<Animator>(); if (animator == null) return 1f; // Dictionary to map animation clips to their corresponding FNvMeleeAttackControl Dictionary<AnimationClip, FNvMeleeAttackControl> attackControlMap = new Dictionary<AnimationClip, FNvMeleeAttackControl>(); // Fill the attackControlMap with the corresponding FNvMeleeAttackControls foreach (var state in animator.runtimeAnimatorController.animationClips) { if (!state.name.Contains(\"ttack\")) { continue; } float length = state.length; return length; float totalLength = 0f; FNvMeleeAttackControl attackControl = GetStateMachineBehaviour<FNvMeleeAttackControl>(animator, state.name); if (attackControl == null) continue; AnimationCurve attackCurve = attackControl.speedCurve; // Applying the curve to the length float maxTime = attackCurve.keys[attackCurve.length - 1] .time; // Assuming the curve goes from 0 to some maximum time float timeIncrement = maxTime / length; // Adjust the time according to the length of the animation float modifiedLength = 0f; for (float t = 0f; t <= maxTime; t += timeIncrement) { float speedMultiplier = attackCurve.Evaluate(t); modifiedLength += timeIncrement / speedMultiplier; } totalLength += modifiedLength; return totalLength; } return 1f; } // Helper method to get StateMachineBehaviour from Animator by state name private T GetStateMachineBehaviour<T>(Animator animator, string stateName) where T : StateMachineBehaviour { foreach (var state in animator.runtimeAnimatorController.animationClips) { if (state.name == stateName) { foreach (var behaviour in animator.GetBehaviours<T>()) { return behaviour; } } } return null; } [Serializable] public struct HitAnimationClips { public AnimationClip clip; public AIUnit.HitDirection hitDir; public float hitHeight; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "EnemyDefinition",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "EnemyDefinition",
          "content": " using System; using System.Collections.Generic; using System.Text; using InRoomSystems; using UnityEngine; using Invector.vItemManager; using Unity.VisualScripting; [CreateAssetMenu(menuName = \"ScriptableObjects/EnemyDefinition\", fileName = \"EnemyDefinition\")] public class EnemyDefinition : ScriptableObject { public byte Id; public AIUnit VisualPrefab; public DeadBody DeadBodyPrefab; public string Name; public int MaxHealth = 100; public float AttackCooldown = 2f; public float MoveSpeed = 1.6f; public float RunSpeed = 1.6f; public float Acceleration = 2.0f; [HideInInspector] public float CurrentRotationSpeed = 0f; public float MaxRotationSpeed = 2.0f; public float FieldOfView = 290.0f; public float ViewDistance = 30.0f; public float AttackDistance = 2.0f; public float MaxDistanceFromSpot = 80.0f; public float MoveSpeedMultiplier = 1.0f; public int Experience = 30; public List<SoundsInfo> Sounds; [Header(\"Should not have duplicative chances. Sorted by chance to spawn.\")] public float ChanceToSpawn = 0.3f; public Type EnemyType; public CratesSystem.Zone LootBagZone = CratesSystem.Zone.level1; public GameObject _bloodPool; public GameObject _bloodSplatter; public HitAnimationClips[] hitAnimations; public int Strength = 10; [Header(\"Loot\")] public PossibleItemRanges[] ItemsDropChances = new []{new PossibleItemRanges(2, 32), new PossibleItemRanges(35, 10000)}; public float LootBagChanceMod = .0f; public int LootBagItemsCount = 1; public float GoldDropChance = .3f; public int MinGoldDrop = 1; public int MaxGoldDrop = 10; public LootDefinition[] Loot; [field:SerializeField] public AnimationClip AnimationTakeOff { get; private set; } [field:SerializeField] public AnimationClip AnimationLanding { get; private set; } [System.Serializable] public class LootDefinition { public vItem Item; public float Chance; public int MinQuantity = 1; public int MaxQuantity = 1; } public enum Type {Monster, Boss, Summon} [System.Serializable] public class SoundsInfo { public enum SoundType { Idle, Attack, Combat, Death, Hit, Moan, Run, Walk } public SoundType Type; public AudioClip[] Clips; public AudioClip GetRandomClip() { return Clips[UnityEngine.Random.Range(0, Clips.Length)]; } } [Serializable] public struct PossibleItemRanges { [Range(0, 20000)] public int FromId; [Range(0, 20000)] public int ToId; public PossibleItemRanges(int fromId, int toId) { FromId = fromId; ToId = toId; }  ",
          "content_tokens": 656,
          "embedding": []
        },
        {
          "cs_scriptfile": "EnemyDefinition",
          "content": "public string GetJsonRepresentation() { StringBuilder jsonBuilder = new StringBuilder(); jsonBuilder.Append(\"{\\n\"); jsonBuilder.AppendFormat(\" \\\"Name\\\": \\\"{0}\\\",\\n\", Name); jsonBuilder.AppendFormat(\" \\\"Type\\\": \\\"{0}\\\",\\n\", EnemyType.ToString()); jsonBuilder.AppendFormat(\" \\\"Strength\\\": {0},\\n\", Strength); jsonBuilder.AppendFormat(\" \\\"RunSpeed\\\": {0},\\n\", RunSpeed); jsonBuilder.AppendFormat(\" \\\"MaxHealth\\\": {0},\\n\", MaxHealth); jsonBuilder.AppendFormat(\" \\\"Attack cooldown\\\": {0},\\n\", AttackCooldown); jsonBuilder.AppendFormat(\" \\\"Attack distance\\\": {0},\\n\", AttackDistance); jsonBuilder.AppendFormat(\" \\\"Attack animation\\\": {0},\\n\", GetAttackAnimationsLength()); jsonBuilder.AppendFormat(\" \\\"RewardExperience\\\": {0},\\n\", Experience); jsonBuilder.AppendFormat(\" \\\"ChanceToSpawn\\\": {0},\\n\", ChanceToSpawn.ToString(\"F2\")); // Add other necessary fields in the same pattern jsonBuilder.Append(\"}\"); return jsonBuilder.ToString();  ",
          "content_tokens": 266,
          "embedding": []
        },
        {
          "cs_scriptfile": "EnemyDefinition",
          "content": "private float GetAttackAnimationsLength() { if (VisualPrefab == null) return 1f; Animator animator = VisualPrefab.GetComponentInChildren<Animator>(); if (animator == null) return 1f; // Dictionary to map animation clips to their corresponding FNvMeleeAttackControl Dictionary<AnimationClip, FNvMeleeAttackControl> attackControlMap = new Dictionary<AnimationClip, FNvMeleeAttackControl>(); // Fill the attackControlMap with the corresponding FNvMeleeAttackControls foreach (var state in animator.runtimeAnimatorController.animationClips) { if (!state.name.Contains(\"ttack\")) { continue; } float length = state.length; return length; float totalLength = 0f; FNvMeleeAttackControl attackControl = GetStateMachineBehaviour<FNvMeleeAttackControl>(animator, state.name); if (attackControl == null) continue; AnimationCurve attackCurve = attackControl.speedCurve; // Applying the curve to the length float maxTime = attackCurve.keys[attackCurve.length - 1] .time; // Assuming the curve goes from 0 to some maximum time float timeIncrement = maxTime / length; // Adjust the time according to the length of the animation float modifiedLength = 0f; for (float t = 0f; t <= maxTime; t += timeIncrement) { float speedMultiplier = attackCurve.Evaluate(t); modifiedLength += timeIncrement / speedMultiplier; } totalLength += modifiedLength; return totalLength; } return 1f; } // Helper method to get StateMachineBehaviour from Animator by state name private T GetStateMachineBehaviour<T>(Animator animator, string stateName) where T : StateMachineBehaviour { foreach (var state in animator.runtimeAnimatorController.animationClips) { if (state.name == stateName) { foreach (var behaviour in animator.GetBehaviours<T>()) { return behaviour; } } } return null; } [Serializable] public struct HitAnimationClips { public AnimationClip clip; public AIUnit.HitDirection hitDir; public float hitHeight; } }",
          "content_tokens": 486,
          "embedding": []
        }
      ],
      "length": 5221
    },
    {
      "filename": "EnemyMoanAudio",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class EnemyMoanAudio : MonoBehaviour { private static float VOICE_PLAY_CHANCE = 0.4f; private AIUnit controller; private AudioSource Audio; private bool _isIdlePlaying = false; private EnemyDefinition _enemyDefinition; private Coroutine _idleAudioCoroutine; void Awake() { controller = GetComponent<AIUnit>(); Audio = GetComponent<AudioSource>(); _enemyDefinition = controller.EnemyDefinition; } public void Init() { _idleAudioCoroutine = StartCoroutine(AudioController()); } private IEnumerator AudioController() { bool isNeedToPlayIdle; while (true) { if (controller.IsDead) { if (_idleAudioCoroutine != null) { StopCoroutine(_idleAudioCoroutine); _idleAudioCoroutine = null; } } isNeedToPlayIdle = !controller.IsInCombat && !_isIdlePlaying; if (isNeedToPlayIdle) { _isIdlePlaying = true; PlayAudioForState(EnemyDefinition.SoundsInfo.SoundType.Idle); } if (controller.IsInCombat) { PlayAudioForState(EnemyDefinition.SoundsInfo.SoundType.Combat); } float randomWaitTime = UnityEngine.Random.Range(15f, 25f); yield return new WaitForSeconds(randomWaitTime); } } private void PlayAudioForState(EnemyDefinition.SoundsInfo.SoundType type) { AudioClip clip = GetRandomForType(type); if (clip == null) return; Audio.PlayOneShot(clip); if (type == EnemyDefinition.SoundsInfo.SoundType.Idle) { _isIdlePlaying = false; } } private AudioClip GetRandomForType(EnemyDefinition.SoundsInfo.SoundType type) { var audioClips = _enemyDefinition.Sounds.Find(x => x.Type == type); if (audioClips == null) return null; return audioClips.GetRandomClip(); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "EnemyMoanAudio",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class EnemyMoanAudio : MonoBehaviour { private static float VOICE_PLAY_CHANCE = 0.4f; private AIUnit controller; private AudioSource Audio; private bool _isIdlePlaying = false; private EnemyDefinition _enemyDefinition; private Coroutine _idleAudioCoroutine; void Awake() { controller = GetComponent<AIUnit>(); Audio = GetComponent<AudioSource>(); _enemyDefinition = controller.EnemyDefinition;  ",
          "content_tokens": 117,
          "embedding": []
        },
        {
          "cs_scriptfile": "EnemyMoanAudio",
          "content": "public void Init() { _idleAudioCoroutine = StartCoroutine(AudioController()); } private IEnumerator AudioController() { bool isNeedToPlayIdle; while (true) { if (controller.IsDead) { if (_idleAudioCoroutine != null) { StopCoroutine(_idleAudioCoroutine); _idleAudioCoroutine = null; } } isNeedToPlayIdle = !controller.IsInCombat && !_isIdlePlaying; if (isNeedToPlayIdle) { _isIdlePlaying = true; PlayAudioForState(EnemyDefinition.SoundsInfo.SoundType.Idle);  if (controller.IsInCombat) { PlayAudioForState(EnemyDefinition.SoundsInfo.SoundType.Combat); } float randomWaitTime = UnityEngine.Random.Range(15f, 25f); yield return new WaitForSeconds(randomWaitTime); }  ",
          "content_tokens": 200,
          "embedding": []
        },
        {
          "cs_scriptfile": "EnemyMoanAudio",
          "content": "private void PlayAudioForState(EnemyDefinition.SoundsInfo.SoundType type) { AudioClip clip = GetRandomForType(type); if (clip == null) return; Audio.PlayOneShot(clip); if (type == EnemyDefinition.SoundsInfo.SoundType.Idle) { _isIdlePlaying = false; } } private AudioClip GetRandomForType(EnemyDefinition.SoundsInfo.SoundType type) { var audioClips = _enemyDefinition.Sounds.Find(x => x.Type == type); if (audioClips == null) return null; return audioClips.GetRandomClip(); } }",
          "content_tokens": 139,
          "embedding": []
        }
      ],
      "length": 1624
    },
    {
      "filename": "MecanimBridgeNetworkedController",
      "content": "using System.Collections; using System.Collections.Generic; using FishNet.Object; //using Pathfinding.Examples; using UnityEngine; public class MecanimBridgeNetworkedController : NetworkBehaviour { [SerializeField] private AIUnit aiUnit; //[SerializeField] private MecanimBridge mecanimBridge; protected override void OnValidate() { base.OnValidate(); aiUnit ??= GetComponent<AIUnit>(); //mecanimBridge ??= GetComponent<MecanimBridge>(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MecanimBridgeNetworkedController",
          "content": "using System.Collections; using System.Collections.Generic; using FishNet.Object; //using Pathfinding.Examples; using UnityEngine; public class MecanimBridgeNetworkedController : NetworkBehaviour { [SerializeField] private AIUnit aiUnit; //[SerializeField] private MecanimBridge mecanimBridge; protected override void OnValidate() { base.OnValidate(); aiUnit ??= GetComponent<AIUnit>(); //mecanimBridge ??= GetComponent<MecanimBridge>(); } }",
          "content_tokens": 116,
          "embedding": []
        }
      ],
      "length": 442
    },
    {
      "filename": "Npc",
      "content": "using System; using System.Collections; using _ZombieRoyale.Scripts.Clients; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using Proyecto26; using UnityEngine; using Zomb.Creatures.Helpers; using Random = UnityEngine.Random; public class Npc : Unit { [SerializeField] private AnimatorDecorator animatorDecorator; [SyncVar] private int _characterId; private bool _isBusy; void OnValidate() { audioSource ??= GetComponent<AudioSource>(); animatorDecorator ??= GetComponent<AnimatorDecorator>(); } public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { _characterId = Random.Range(0, 3); } } public void Init(int newCharacterId) { _characterId = newCharacterId; } [Client] public void RequestDialogue(string question) { if (InternalCheckIfBusy()) return; Debug.Log($\"[Npc] {_characterId} is not busy\"); GenerateAnswer(question); } [ServerRpc(RequireOwnership = false)] public void GenerateAnswer(string question, NetworkConnection conn = null) { if (InternalCheckIfBusy()) return; _isBusy = true; Action<RequestException, ResponseHelper, string> onReceiveAnswerAudioFileName = (error, response, body) => { if (error != null) { Debug.LogError($\"[SpeechPlayTest] Error: {error}\"); return; } Debug.Log($\"[SpeechPlayTest] Response: {response}; Body: {body}\"); ReportDialogueAudioFileName(body); }; BackendReadWrites.AiDoDialog(question, GetAskerCharacterId(conn), _characterId, onReceiveAnswerAudioFileName); } [ObserversRpc] private void ReportDialogueAudioFileName(string audioFileName) { Debug.Log($\"[Npc] ReportDialogueAudioFileName {audioFileName}\"); DownloadAndPlay(audioFileName); } [Client] public void DownloadAndPlay(string audioFileName = \"1\") { var startTime = DateTime.Now; BackendReadWrites.GetAudioFile(\"dialogues\", audioFileName, PlayAudio, error => Debug.LogError(\"Error: \" + error)); Debug.Log($\"[SpeechPlayTest] DownloadAndPlay took {(DateTime.Now - startTime).TotalMilliseconds} ms\"); } private int GetAskerCharacterId(NetworkConnection conn) { CharacterData charData = ServerPlayerManager.GetCharacterData(conn); return charData.id; } public void PlayAudio(AudioClip clip) { SetTalkingAnimation(true); audioSource.clip = clip; audioSource.Play(); StartCoroutine(StopTalkingAfter(clip.length)); } private IEnumerator StopTalkingAfter(float seconds) { yield return new WaitForSeconds(seconds); SetTalkingAnimation(false); } private void SetTalkingAnimation(bool isTalking) { animatorDecorator.SetBool(\"Talk\", isTalking); } private bool InternalCheckIfBusy() { if (_isBusy) { Debug.Log($\"[Npc] {_characterId} is busy\"); return true; } return false; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Npc",
          "content": "using System; using System.Collections; using _ZombieRoyale.Scripts.Clients; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using Proyecto26; using UnityEngine; using Zomb.Creatures.Helpers; using Random = UnityEngine.Random; public class Npc : Unit { [SerializeField] private AnimatorDecorator animatorDecorator; [SyncVar] private int _characterId; private bool _isBusy; void OnValidate() { audioSource ??= GetComponent<AudioSource>(); animatorDecorator ??= GetComponent<AnimatorDecorator>(); } public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { _characterId = Random.Range(0, 3); }  ",
          "content_tokens": 184,
          "embedding": []
        },
        {
          "cs_scriptfile": "Npc",
          "content": "public void Init(int newCharacterId) { _characterId = newCharacterId; } [Client] public void RequestDialogue(string question) { if (InternalCheckIfBusy()) return; Debug.Log($\"[Npc] {_characterId} is not busy\"); GenerateAnswer(question); } [ServerRpc(RequireOwnership = false)] public void GenerateAnswer(string question, NetworkConnection conn = null) { if (InternalCheckIfBusy()) return; _isBusy = true; Action<RequestException, ResponseHelper, string> onReceiveAnswerAudioFileName = (error, response, body) => { if (error != null) { Debug.LogError($\"[SpeechPlayTest] Error: {error}\"); return; } Debug.Log($\"[SpeechPlayTest] Response: {response}; Body: {body}\"); ReportDialogueAudioFileName(body); }; BackendReadWrites.AiDoDialog(question, GetAskerCharacterId(conn), _characterId, onReceiveAnswerAudioFileName); } [ObserversRpc] private void ReportDialogueAudioFileName(string audioFileName) { Debug.Log($\"[Npc] ReportDialogueAudioFileName {audioFileName}\"); DownloadAndPlay(audioFileName); } [Client] public void DownloadAndPlay(string audioFileName = \"1\") { var startTime = DateTime.Now; BackendReadWrites.GetAudioFile(\"dialogues\", audioFileName, PlayAudio, error => Debug.LogError(\"Error: \" + error)); Debug.Log($\"[SpeechPlayTest] DownloadAndPlay took {(DateTime.Now - startTime).TotalMilliseconds} ms\");  ",
          "content_tokens": 371,
          "embedding": []
        },
        {
          "cs_scriptfile": "Npc",
          "content": "private int GetAskerCharacterId(NetworkConnection conn) { CharacterData charData = ServerPlayerManager.GetCharacterData(conn); return charData.id;  public void PlayAudio(AudioClip clip) { SetTalkingAnimation(true); audioSource.clip = clip; audioSource.Play(); StartCoroutine(StopTalkingAfter(clip.length)); } private IEnumerator StopTalkingAfter(float seconds) { yield return new WaitForSeconds(seconds); SetTalkingAnimation(false);  private void SetTalkingAnimation(bool isTalking) { animatorDecorator.SetBool(\"Talk\", isTalking);  private bool InternalCheckIfBusy() { if (_isBusy) { Debug.Log($\"[Npc] {_characterId} is busy\"); return true; } return false; } }",
          "content_tokens": 175,
          "embedding": []
        }
      ],
      "length": 2625
    },
    {
      "filename": "AIPoisonNovaController",
      "content": "using System.Collections; using FishNet.Object; using UnityEngine; namespace _ZombieRoyale.Scripts.AI.Boss_Perks { [RequireComponent(typeof(FNAbilityController))] public class AIPoisonNovaController : UnitBehaviour { private readonly int POISON_NOVA_ID = 14; private readonly float NOVA_CAST_TIME = 2f; protected override void Awake() { base.Awake(); //_slimeBubblesPool = new ObjectsPool<Rigidbody>(_bubblePrefab, _maxSlimeCount); } [Server] public void SpawnNova() { SpawnIndicator(); _aiUnit.PauseTimed(NOVA_CAST_TIME); StartCoroutine(CastNova()); } [Server] private IEnumerator CastNova() { yield return new WaitForSeconds(NOVA_CAST_TIME); AbilityManager.Instance.InitAbility(NetworkObject.ObjectId, POISON_NOVA_ID); } [ObserversRpc] private void SpawnIndicator() { StartCoroutine(IndicatorCoroutine()); } [Client] private IEnumerator IndicatorCoroutine() { StatusIndicatorManager.InitArea(transform, 5f, PoisonNova.NOVA_RADIUS, NOVA_CAST_TIME); yield break; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AIPoisonNovaController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "AIPoisonNovaController",
          "content": "using System.Collections; using FishNet.Object; using UnityEngine; namespace _ZombieRoyale.Scripts.AI.Boss_Perks { [RequireComponent(typeof(FNAbilityController))] public class AIPoisonNovaController : UnitBehaviour { private readonly int POISON_NOVA_ID = 14; private readonly float NOVA_CAST_TIME = 2f; protected override void Awake() { base.Awake(); //_slimeBubblesPool = new ObjectsPool<Rigidbody>(_bubblePrefab, _maxSlimeCount); } [Server] public void SpawnNova() { SpawnIndicator(); _aiUnit.PauseTimed(NOVA_CAST_TIME); StartCoroutine(CastNova()); } [Server] private IEnumerator CastNova() { yield return new WaitForSeconds(NOVA_CAST_TIME); AbilityManager.Instance.InitAbility(NetworkObject.ObjectId, POISON_NOVA_ID); } [ObserversRpc] private void SpawnIndicator() { StartCoroutine(IndicatorCoroutine()); } [Client] private IEnumerator IndicatorCoroutine() { StatusIndicatorManager.InitArea(transform, 5f, PoisonNova.NOVA_RADIUS, NOVA_CAST_TIME); yield break; } } }",
          "content_tokens": 298,
          "embedding": []
        }
      ],
      "length": 968
    },
    {
      "filename": "SlimeSpawner",
      "content": "using System; using System.Collections; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using UnityEngine; using UnityEngine.Serialization; using Random = UnityEngine.Random; namespace _ZombieRoyale.Scripts.AI.Boss_Perks { public class SlimeSpawner : UnitBehaviour { [SerializeField] private Rigidbody _bubblePrefab; [SerializeField] private bool _isDebug = true; [SerializeField] private EnemyDefinition _slimeDefinition; [SerializeField] private int _maxSlimeCount = 3; [FormerlySerializedAs(\"_slimeBirthAnimationTime\")] [SerializeField] private float SLIME_BIRTH_ANIMATION_TIME = 1.767f; private bool _isSlimeSpawned; private ObjectsPool<Rigidbody> _slimeBubblesPool; private Vector3 _lastLaunchedBubbleFallPosition; protected override void Awake() { base.Awake(); //_slimeBubblesPool = new ObjectsPool<Rigidbody>(_bubblePrefab, _maxSlimeCount); } [Server] public void SpawnSlime() { float angle = Random.Range(-45f, 45f); int targetId = _aiUnit.GetTargetId(); DebugWrite.Log($\"[SlimeSpawner] targetId: {targetId}\", isShowLog: _isDebug); //BubbleFlyingVisual(angle); //TargetNotifyThatNeedReportBack(targetConn); SpawnSlimeling(transform.position); } [ObserversRpc] private void BubbleFlyingVisual(float angleModifier) { var bubble = _slimeBubblesPool.Allocate(); bubble.transform.position = transform.position + Vector3.up * 1f; bubble.transform.parent = transform; //rotate bubble 45 degrees up, look as transform.forward + angleModifier and shoot in that direction bubble.transform.rotation = Quaternion.LookRotation(transform.forward + new Vector3(-45f, angleModifier, 0f)); bubble.AddForce(bubble.transform.forward * 2f, ForceMode.Impulse); bubble.AddTorque(Vector3.up * 2f, ForceMode.Impulse); bubble.AddTorque(Vector3.right * 2f, ForceMode.Impulse); bubble.AddTorque(Vector3.forward * 2f, ForceMode.Impulse); StartCoroutine(RecordBubbleFallPosition()); } [TargetRpc] private void TargetNotifyThatNeedReportBack(NetworkConnection conn) { StartCoroutine(ReportBack()); } [Client] private IEnumerator RecordBubbleFallPosition() { yield return new WaitForSeconds(1f); _lastLaunchedBubbleFallPosition = transform.position; } [Client] private IEnumerator ReportBack() { yield return new WaitForSeconds(1.1f); CmdReportBubbleCoords(_lastLaunchedBubbleFallPosition); } [ServerRpc(RequireOwnership = false)] private void CmdReportBubbleCoords(Vector3 pos) { DebugWrite.Log($\"[SlimeSpawner] Bubble coords: {pos}\", gameObject, _isDebug); SpawnSlimeling(pos); } private void SpawnSlimeling(Vector3 pos) { var creature = GameplayManager.Instance.CreaturesFactory.AllocateCreature(_slimeDefinition.Id, pos, GameplayManager.Instance); creature.Controller.AnimatorDecorator.SetTrigger(\"Birth\"); creature.Controller.PauseTimed(SLIME_BIRTH_ANIMATION_TIME); } [Serializable] public class BubbleSlime { public Transform Transform; public Rigidbody RigidBody; public BubbleSlime(Transform transform, Rigidbody rigidBody) { Transform = transform; RigidBody = rigidBody; } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SlimeSpawner",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "SlimeSpawner",
          "content": "using System; using System.Collections; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using UnityEngine; using UnityEngine.Serialization; using Random = UnityEngine.Random; namespace _ZombieRoyale.Scripts.AI.Boss_Perks { public class SlimeSpawner : UnitBehaviour { [SerializeField] private Rigidbody _bubblePrefab; [SerializeField] private bool _isDebug = true; [SerializeField] private EnemyDefinition _slimeDefinition; [SerializeField] private int _maxSlimeCount = 3; [FormerlySerializedAs(\"_slimeBirthAnimationTime\")] [SerializeField] private float SLIME_BIRTH_ANIMATION_TIME = 1.767f; private bool _isSlimeSpawned; private ObjectsPool<Rigidbody> _slimeBubblesPool; private Vector3 _lastLaunchedBubbleFallPosition; protected override void Awake() { base.Awake(); //_slimeBubblesPool = new ObjectsPool<Rigidbody>(_bubblePrefab, _maxSlimeCount); } [Server] public void SpawnSlime() { float angle = Random.Range(-45f, 45f); int targetId = _aiUnit.GetTargetId(); DebugWrite.Log($\"[SlimeSpawner] targetId: {targetId}\", isShowLog: _isDebug); //BubbleFlyingVisual(angle); //TargetNotifyThatNeedReportBack(targetConn); SpawnSlimeling(transform.position); } [ObserversRpc] private void BubbleFlyingVisual(float angleModifier) { var bubble = _slimeBubblesPool.Allocate(); bubble.transform.position = transform.position + Vector3.up * 1f; bubble.transform.parent = transform; //rotate bubble 45 degrees up, look as transform.forward + angleModifier and shoot in that direction bubble.transform.rotation = Quaternion.LookRotation(transform.forward + new Vector3(-45f, angleModifier, 0f)); bubble.AddForce(bubble.transform.forward * 2f, ForceMode.Impulse); bubble.AddTorque(Vector3.up * 2f, ForceMode.Impulse); bubble.AddTorque(Vector3.right * 2f, ForceMode.Impulse); bubble.AddTorque(Vector3.forward * 2f, ForceMode.Impulse); StartCoroutine(RecordBubbleFallPosition()); } [TargetRpc] private void TargetNotifyThatNeedReportBack(NetworkConnection conn) { StartCoroutine(ReportBack()); } [Client] private IEnumerator RecordBubbleFallPosition() { yield return new WaitForSeconds(1f); _lastLaunchedBubbleFallPosition = transform.position; } [Client] private IEnumerator ReportBack() { yield return new WaitForSeconds(1.1f); CmdReportBubbleCoords(_lastLaunchedBubbleFallPosition); } [ServerRpc(RequireOwnership = false)] private void CmdReportBubbleCoords(Vector3 pos) { DebugWrite.Log($\"[SlimeSpawner] Bubble coords: {pos}\", gameObject, _isDebug); SpawnSlimeling(pos);  ",
          "content_tokens": 758,
          "embedding": []
        },
        {
          "cs_scriptfile": "SlimeSpawner",
          "content": "private void SpawnSlimeling(Vector3 pos) { var creature = GameplayManager.Instance.CreaturesFactory.AllocateCreature(_slimeDefinition.Id, pos, GameplayManager.Instance); creature.Controller.AnimatorDecorator.SetTrigger(\"Birth\"); creature.Controller.PauseTimed(SLIME_BIRTH_ANIMATION_TIME); } [Serializable] public class BubbleSlime { public Transform Transform; public Rigidbody RigidBody; public BubbleSlime(Transform transform, Rigidbody rigidBody) { Transform = transform; RigidBody = rigidBody; } } } }",
          "content_tokens": 133,
          "embedding": []
        }
      ],
      "length": 3082
    },
    {
      "filename": "Unit",
      "content": "using System; using System.Collections; using System.Collections.Generic; using Character; using FishNet.Object; using FishNet.Object.Synchronizing; using FishnetInvector; using Invector; using RootMotion.FinalIK; using UnityEditor; using UnityEngine; using UnityEngine.Serialization; using Random = UnityEngine.Random; [RequireComponent(typeof(FishnetInvectorHealthController))] public abstract class Unit : NetworkBehaviour { public virtual string CreatureName => gameObject.name; [SerializeField] protected GameObject _bloodAttachPrefab; [SerializeField] protected GameObject _bloodFXPrefab; [field:SerializeField] public FishnetInvectorHealthController HealthController { get; private set; } [SerializeField] protected FNStatsController _statsController; [SerializeField] protected AudioSource audioSource; [SerializeField] protected AimIK headAimIK; //TODO add missing sound triggers public enum SoundType { Hit, Attack, AttackHard, AlmostDied, Idle, Running, Death, Jump } //Female by default [field:SerializeField] public SoundClips[] soundClips { get; protected set; } [SerializeField] protected SoundClips[] maleSoundClips; [SerializeField] protected SoundClips[] femaleSoundClips; protected bool _isDoHeadFollow; #region Initialization protected virtual void OnValidate() { AssignComponentsIfNull(); } private void AssignComponentsIfNull() { HealthController ??= GetComponent<FishnetInvectorHealthController>(); audioSource ??= GetComponent<AudioSource>(); _statsController ??= GetComponent<FNStatsController>(); headAimIK ??= GetComponentInChildren<AimIK>(); } protected virtual void Awake() { if (headAimIK != null) { _isDoHeadFollow = true; } AssignComponentsIfNull(); } #endregion public override void OnStartServer() { HealthController.OnDead += PlayDeadSound; HealthController.OnTakeDamage += PlayTakeDamageSound; } #region Sounds public void PlayAttackSoundNonNetworked() { int index = GetSoundIndex(SoundType.Attack); if (index == -1) return; float chanceToPlay = Random.Range(0f, 1f); Debug.Log(\"chanceToPlay: \" + chanceToPlay); if (chanceToPlay > 0.3f) { NonNetworkedPlaySound(SoundType.Attack); } } public void PlayAttackHardSoundNonNetworked() { int index = GetSoundIndex(SoundType.AttackHard); if (index == -1) return; float chanceToPlay = Random.Range(0f, 1f); Debug.Log(\"chanceToPlay: \" + chanceToPlay); if (chanceToPlay > 0.6f) { NonNetworkedPlaySound(SoundType.AttackHard); } } public void PlayAttackSound() { int index = GetSoundIndex(SoundType.Attack); if (index == -1) return; PlaySound(SoundType.Attack); } public void PlayJumpSound() { if (!IsClient || !IsHost) return; int index = GetSoundIndex(SoundType.Jump); if (index == -1) return; NonNetworkedPlaySound(SoundType.Jump); } public void PlayTakeDamageSound(vDamage damage) { int index = GetSoundIndex(SoundType.Hit); if (index == -1) return; PlaySound(SoundType.Hit); } public void PlayDeadSound(vDamage damage) { int index = GetSoundIndex(SoundType.Death); if (index == -1) return; PlaySound(SoundType.Death); } [ObserversRpc] private void PlaySound(SoundType type) { if (audioSource == null) { return; } int index = GetSoundIndex(type); if (index == -1) return; var clips = soundClips[index].clips; if (clips.Length < 0) { return; } audioSource.PlayOneShot(clips[Random.Range(0, clips.Length)]); } private void NonNetworkedPlaySound(SoundType type) { if (audioSource == null) { return; } int index = GetSoundIndex(type); if (index == -1) return; var clips = soundClips[index].clips; if (clips.Length < 0) { return; } //randomize pitch var pitch = Random.Range(0.9f, 1.1f); audioSource.pitch = pitch; audioSource.PlayOneShot(clips[Random.Range(0, clips.Length)]); } private int GetSoundIndex(SoundType type) { for (int i = 0; i < soundClips.Length; i++) { if (soundClips[i].soundType != type) continue; return i; } return -1; } protected void UpdateGenderVoices(int genderId) { if ((CharacterSkinData.Gender)genderId == CharacterSkinData.Gender.Male) { soundClips = maleSoundClips; } else { soundClips = femaleSoundClips; } Debug.Log($\"[Unit][UpdateGenderVoices] Updated to {(CharacterSkinData.Gender)genderId} voices\"); } #endregion public static Transform GetTransformByName(Transform t, string transformName) { Transform result = t.Find(transformName); if (result == null) { for (int it = 0; it < t.childCount; ++it) { Transform child = t.GetChild(it); result = GetTransformByName(child, transformName); if (result != null) { return result; } } } return result; } [ObserversRpc(ExcludeOwner = true)] public void AddBloodOnObservers(Vector3 localHitPoint, Vector3 hitNormal, string partName) { float angle = Mathf.Atan2(hitNormal.x, hitNormal.z) * Mathf.Rad2Deg + 180; Transform hitTransform = GetTransformByName(transform, partName); if (hitTransform != null) { Vector3 hitPoint = localHitPoint + hitTransform.position; //TODO replace instantiating with object pooling var instance = Instantiate(_bloodFXPrefab, hitPoint, Quaternion.Euler(0, angle + 90, 0)); Destroy(instance, 20); } } public static Vector3 GetRandomPosInCircleShapeAround(Vector3 fromPoint, float radius, int maxCallCount = 10) { for (int i = 0; i < maxCallCount; i++) { float angle = Random.Range(0, 2 * Mathf.PI); Vector3 randomPosInCircle = new Vector3(Mathf.Cos(angle) * radius, 0, Mathf.Sin(angle) * radius); Vector3 randomPosInCircleWorld = fromPoint + randomPosInCircle; // Check if point inside any game object Collider[] colliders = Physics.OverlapBox(randomPosInCircleWorld, Vector3.one * 0.1f); if (colliders.Length == 0) { return randomPosInCircleWorld; } } // If after maxCallCount iterations no valid position is found, return the last position attempted return fromPoint; } [Serializable] public class RendererColor { public List<Material> Material = new List<Material>(); public List<Texture> OriginalTexture = new List<Texture>(); public List<Color> Colors = new List<Color>(); public RendererColor (List<Material> material, List<Color> color) { Material = material; Colors = color; } } [Serializable] public struct SoundClips { public SoundType soundType; public AudioClip[] clips; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Unit",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "Unit",
          "content": "using System; using System.Collections; using System.Collections.Generic; using Character; using FishNet.Object; using FishNet.Object.Synchronizing; using FishnetInvector; using Invector; using RootMotion.FinalIK; using UnityEditor; using UnityEngine; using UnityEngine.Serialization; using Random = UnityEngine.Random; [RequireComponent(typeof(FishnetInvectorHealthController))] public abstract class Unit : NetworkBehaviour { public virtual string CreatureName => gameObject.name; [SerializeField] protected GameObject _bloodAttachPrefab; [SerializeField] protected GameObject _bloodFXPrefab; [field:SerializeField] public FishnetInvectorHealthController HealthController { get; private set; } [SerializeField] protected FNStatsController _statsController; [SerializeField] protected AudioSource audioSource; [SerializeField] protected AimIK headAimIK; //TODO add missing sound triggers public enum SoundType { Hit, Attack, AttackHard, AlmostDied, Idle, Running, Death, Jump } //Female by default [field:SerializeField] public SoundClips[] soundClips { get; protected set; } [SerializeField] protected SoundClips[] maleSoundClips; [SerializeField] protected SoundClips[] femaleSoundClips; protected bool _isDoHeadFollow; #region Initialization protected virtual void OnValidate() { AssignComponentsIfNull();  ",
          "content_tokens": 316,
          "embedding": []
        },
        {
          "cs_scriptfile": "Unit",
          "content": "private void AssignComponentsIfNull() { HealthController ??= GetComponent<FishnetInvectorHealthController>(); audioSource ??= GetComponent<AudioSource>(); _statsController ??= GetComponent<FNStatsController>(); headAimIK ??= GetComponentInChildren<AimIK>(); } protected virtual void Awake() { if (headAimIK != null) { _isDoHeadFollow = true;  ",
          "content_tokens": 90,
          "embedding": []
        },
        {
          "cs_scriptfile": "Unit",
          "content": "AssignComponentsIfNull(); } #endregion public override void OnStartServer() { HealthController.OnDead += PlayDeadSound; HealthController.OnTakeDamage += PlayTakeDamageSound; } #region Sounds public void PlayAttackSoundNonNetworked() { int index = GetSoundIndex(SoundType.Attack); if (index == -1) return; float chanceToPlay = Random.Range(0f, 1f); Debug.Log(\"chanceToPlay: \" + chanceToPlay); if (chanceToPlay > 0.3f) { NonNetworkedPlaySound(SoundType.Attack); }  ",
          "content_tokens": 131,
          "embedding": []
        },
        {
          "cs_scriptfile": "Unit",
          "content": "public void PlayAttackHardSoundNonNetworked() { int index = GetSoundIndex(SoundType.AttackHard); if (index == -1) return; float chanceToPlay = Random.Range(0f, 1f); Debug.Log(\"chanceToPlay: \" + chanceToPlay); if (chanceToPlay > 0.6f) { NonNetworkedPlaySound(SoundType.AttackHard); }  public void PlayAttackSound() { int index = GetSoundIndex(SoundType.Attack); if (index == -1) return; PlaySound(SoundType.Attack);  public void PlayJumpSound() { if (!IsClient || !IsHost) return; int index = GetSoundIndex(SoundType.Jump); if (index == -1) return; NonNetworkedPlaySound(SoundType.Jump);  ",
          "content_tokens": 177,
          "embedding": []
        },
        {
          "cs_scriptfile": "Unit",
          "content": "public void PlayTakeDamageSound(vDamage damage) { int index = GetSoundIndex(SoundType.Hit); if (index == -1) return; PlaySound(SoundType.Hit);  public void PlayDeadSound(vDamage damage) { int index = GetSoundIndex(SoundType.Death); if (index == -1) return; PlaySound(SoundType.Death); } [ObserversRpc] private void PlaySound(SoundType type) { if (audioSource == null) { return; } int index = GetSoundIndex(type); if (index == -1) return; var clips = soundClips[index].clips; if (clips.Length < 0) { return; } audioSource.PlayOneShot(clips[Random.Range(0, clips.Length)]);  ",
          "content_tokens": 174,
          "embedding": []
        },
        {
          "cs_scriptfile": "Unit",
          "content": "private void NonNetworkedPlaySound(SoundType type) { if (audioSource == null) { return; } int index = GetSoundIndex(type); if (index == -1) return; var clips = soundClips[index].clips; if (clips.Length < 0) { return; } //randomize pitch var pitch = Random.Range(0.9f, 1.1f); audioSource.pitch = pitch; audioSource.PlayOneShot(clips[Random.Range(0, clips.Length)]);  private int GetSoundIndex(SoundType type) { for (int i = 0; i < soundClips.Length; i++) { if (soundClips[i].soundType != type) continue; return i; } return -1;  ",
          "content_tokens": 169,
          "embedding": []
        },
        {
          "cs_scriptfile": "Unit",
          "content": "protected void UpdateGenderVoices(int genderId) { if ((CharacterSkinData.Gender)genderId == CharacterSkinData.Gender.Male) { soundClips = maleSoundClips; } else { soundClips = femaleSoundClips; } Debug.Log($\"[Unit][UpdateGenderVoices] Updated to {(CharacterSkinData.Gender)genderId} voices\"); } #endregion public static Transform GetTransformByName(Transform t, string transformName) { Transform result = t.Find(transformName); if (result == null) { for (int it = 0; it < t.childCount; ++it) { Transform child = t.GetChild(it); result = GetTransformByName(child, transformName); if (result != null) { return result; } } } return result; } [ObserversRpc(ExcludeOwner = true)] public void AddBloodOnObservers(Vector3 localHitPoint, Vector3 hitNormal, string partName) { float angle = Mathf.Atan2(hitNormal.x, hitNormal.z) * Mathf.Rad2Deg + 180; Transform hitTransform = GetTransformByName(transform, partName); if (hitTransform != null) { Vector3 hitPoint = localHitPoint + hitTransform.position; //TODO replace instantiating with object pooling var instance = Instantiate(_bloodFXPrefab, hitPoint, Quaternion.Euler(0, angle + 90, 0)); Destroy(instance, 20); } } public static Vector3 GetRandomPosInCircleShapeAround(Vector3 fromPoint, float radius, int maxCallCount = 10) { for (int i = 0; i < maxCallCount; i++) { float angle = Random.Range(0, 2 * Mathf.PI); Vector3 randomPosInCircle = new Vector3(Mathf.Cos(angle) * radius, 0, Mathf.Sin(angle) * radius); Vector3 randomPosInCircleWorld = fromPoint + randomPosInCircle; // Check if point inside any game object Collider[] colliders = Physics.OverlapBox(randomPosInCircleWorld, Vector3.one * 0.1f); if (colliders.Length == 0) { return randomPosInCircleWorld; } } // If after maxCallCount iterations no valid position is found, return the last position attempted return fromPoint; } [Serializable] public class RendererColor { public List<Material> Material = new List<Material>(); public List<Texture> OriginalTexture = new List<Texture>(); public List<Color> Colors = new List<Color>(); public RendererColor (List<Material> material, List<Color> color) { Material = material; Colors = color; } } [Serializable] public struct SoundClips { public SoundType soundType; public AudioClip[] clips; } }",
          "content_tokens": 621,
          "embedding": []
        }
      ],
      "length": 6062
    },
    {
      "filename": "ZombieDamageDealingSource",
      "content": "using System; using System.Collections; using UnityEngine; public class ZombieDamageDealingSource : MonoBehaviour { private bool _canDealDamage = false; public Action<Collider> OnDamageDealt; public void TurnOnDamage(float time = .5f) { _canDealDamage = true; StartCoroutine(TimedDamageDealingEligibility(time)); } private IEnumerator TimedDamageDealingEligibility(float time) { yield return new WaitForSeconds(time); _canDealDamage = false; } private void OnTriggerEnter(Collider other) { if (!_canDealDamage) { return; } if (other.CompareTag(\"Player\")) { OnDamageDealt?.Invoke(other); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ZombieDamageDealingSource",
          "content": "using System; using System.Collections; using UnityEngine; public class ZombieDamageDealingSource : MonoBehaviour { private bool _canDealDamage = false; public Action<Collider> OnDamageDealt; public void TurnOnDamage(float time = .5f) { _canDealDamage = true; StartCoroutine(TimedDamageDealingEligibility(time)); } private IEnumerator TimedDamageDealingEligibility(float time) { yield return new WaitForSeconds(time); _canDealDamage = false; } private void OnTriggerEnter(Collider other) { if (!_canDealDamage) { return; } if (other.CompareTag(\"Player\")) { OnDamageDealt?.Invoke(other); } } }",
          "content_tokens": 164,
          "embedding": []
        }
      ],
      "length": 593
    },
    {
      "filename": "AttachmentPoints",
      "content": "using System; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; public class AttachmentPoints : MonoBehaviour { public enum Point { Head, Chest, Overhead, Origin, LeftHand, RightHand } public PointTransform[] PointTransforms=>_pointTransforms; [SerializeField] private PointTransform[] _pointTransforms; private UnitComponents _unitComponents; public Transform GetAttachmentPoint(Point which) { PointTransform pointTransform = Array.Find(_pointTransforms, x => x.point == which); if (pointTransform == null) { DebugWrite.LogError($\"[AttachmentPoints] PointTransform not found: {which}\"); return transform; } Transform result = pointTransform.trans; return result; } public void SetupUnitComponents(UnitComponents unitComponents) { _unitComponents = unitComponents; } [Serializable] public class PointTransform { public Transform trans; public Point point; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AttachmentPoints",
          "content": "using System; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; public class AttachmentPoints : MonoBehaviour { public enum Point { Head, Chest, Overhead, Origin, LeftHand, RightHand } public PointTransform[] PointTransforms=>_pointTransforms; [SerializeField] private PointTransform[] _pointTransforms; private UnitComponents _unitComponents; public Transform GetAttachmentPoint(Point which) { PointTransform pointTransform = Array.Find(_pointTransforms, x => x.point == which); if (pointTransform == null) { DebugWrite.LogError($\"[AttachmentPoints] PointTransform not found: {which}\"); return transform; } Transform result = pointTransform.trans; return result;  ",
          "content_tokens": 185,
          "embedding": []
        },
        {
          "cs_scriptfile": "AttachmentPoints",
          "content": "public void SetupUnitComponents(UnitComponents unitComponents) { _unitComponents = unitComponents; } [Serializable] public class PointTransform { public Transform trans; public Point point; } }",
          "content_tokens": 44,
          "embedding": []
        }
      ],
      "length": 946
    },
    {
      "filename": "BackendReadWrites",
      "content": "using System; using System.Collections.Generic; using System.Diagnostics; using System.Text; using _ZombieRoyale.Scripts.Clients; using Newtonsoft.Json; using Proyecto26; using SingletonsExtension; using UnityEngine; using UnityEngine.Networking; using UnityEngine.Serialization; using Debug = UnityEngine.Debug; public static class BackendReadWrites { #region open data private static readonly string BACKEND_URL = \"http://64.226.78.97:3000/\";//\"http://localhost:3000/\";// private static readonly string GET_ABILITY_STACKS = \"character/get_ability_stacks/\"; private static readonly string REGISTER_CHARACTER = \"character/new-character\"; private static readonly string CHARACTER_GET_SKIN = \"character/get_skin/\"; private static readonly string CHARACTER_GET_PLAYER_NAME = \"character/get_player_name/\"; private static readonly string GET_CHARACTER = \"character/0\"; private static readonly string GET_FIRST_CHARACTER = \"character/server_get_first_character\"; private static readonly string CHANGE_EMAIL_PASSWORD = \"player/change_email_password/\"; private static readonly string REGISTER_USER = \"player/register/\"; private static readonly string LOGIN_USER = \"auth/login/\"; private static readonly string GET_ALL_SERVERS = \"server/get_all_servers\"; private static readonly string GET_AVAILABLE_SERVERS = \"server/get_servers_by_version/\"; #if UNITY_EDITOR || UNITY_SERVER || UNITY_STANDALONE_LINUX private static readonly string HATHORA_GET_ROOM_ID = \"https://api.hathora.dev/rooms/v2/\";//\"https://api.hathora.dev/rooms/v2/app-60bc431b-e9b7-4139-845d-2b9899e026cd/list/\"; private static readonly string HATHORA_GET_CONNECTION_INFO = \"https://api.hathora.dev/rooms/v2/\";//\"https://api.hathora.dev/rooms/v2/app-60bc431b-e9b7-4139-845d-2b9899e026cd/connectioninfo/\"; private static readonly string HATHORA_TOKEN = \"_Chky51qPZz-q7wz7YPcPZZrEeI8UoayOhnkG2CsSZdXf\";//\"jlZ-xwlRF8_3BufxnI1MEwHr57Mgm4G-wN3WGXJ6RMWDu\"; private static readonly string SET_CHARACTER_ABILITY_STACKS = \"character/set_ability_stacks/\"; private static readonly string ADD_CHARACTER_INVENTORY = \"character/add_inventory\"; private static readonly string DELETE_CHARACTER_INVENTORY = \"character/remove_inventory\"; #endif private static string GetMyProcessID() { // Gets the current process var currentProcess = Process.GetCurrentProcess(); // Returns the process ID as a string return currentProcess.Id.ToString(); } public static Action<CharacterSkinData> OnCharacterCreated; #endregion #region closed data #if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX private static readonly string SAVE_USER_DATA_TO_BACKEND = \"character/\"; private static readonly string POST_REGISTER_SERVER = \"server/register_server\"; private static readonly string POST_UNREGISTER_SERVER = \"server/unregister_server\"; #endif #endregion public static void GetPlayerNameBasedOnCharacterId(int id, Action<string> callback) { RequestHelper requestHelper = new RequestHelper { Uri = $\"{BACKEND_URL}{CHARACTER_GET_PLAYER_NAME}{id}\" }; DefaultGetRequest(requestHelper, (exception, response, body) => { if (exception != null) { Debug.LogError(\"Error geting character: \" + exception.Message); return; } Debug.Log($\"[BackendReadWrites] GetPlayerNameBasedOnCharacterId for id #{id}: {body}\"); callback?.Invoke(body); }); } public static void GetCharacterSkin(int id, Action<CharacterSkinData> callback) { RequestHelper requestHelper = new RequestHelper { Uri = $\"{BACKEND_URL}{CHARACTER_GET_SKIN}{id}\" }; CharacterSkinData skinData = new CharacterSkinData(); DefaultGetRequest(requestHelper, (exception, response, body) => { if (exception != null) { Debug.LogError(\"Error geting character: \" + exception.Message); return; } Debug.Log($\"[BackendReadWrites] GetCharacterSkin for id #{id}: {body}\"); skinData = JsonConvert.DeserializeObject<CharacterSkinData>(body); Debug.Log($\"[BackendReadWrites] GetCharacterSkin check class: {skinData.ToString()}\"); StringBuilder sb = new StringBuilder($\"[BackendReadWrites] GetCharacterSkin for id #{id}: {skinData}\"); callback?.Invoke(skinData); if (skinData.Id == 0) { sb.Append($\"Character not found\"); Debug.LogError(sb); } else { Debug.Log(sb); } }); } public static void SetAbilityStacks(string token, AbilityInfo[] abilityInfos, Action<int> callback) { #if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{SET_CHARACTER_ABILITY_STACKS}\", BodyString = JsonConvert.SerializeObject(abilityInfos), Headers = new Dictionary<string, string>() { [\"authorization\"] = \"Bearer \" + token } }; RestClient.Post(request).Then(response => { int responseInt = int.Parse(response.Text); string result = responseInt > 0 ? \"success\" : \"Character not found!\"; Debug.Log($\"[BackendReadWrites.SetCharacterAbilityStacks] {response.StatusCode}. {request.Uri} result: {result}; response: {response.Text}\"); callback?.Invoke(responseInt); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}\"); var requestException = new RequestException(error.Message); }); #endif } public static void AddInventory(CharacterDataDTO characterData, Action<int> callback) { #if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX string secretKey = \"SanatMadina\";//Environment.GetEnvironmentVariable //async addInventory(@Body() characterData: CharacterDataDTO, secretKey: string): Promise<number> RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{ADD_CHARACTER_INVENTORY}\", BodyString = JsonConvert.SerializeObject(characterData), Headers = new Dictionary<string, string>() { [\"authorization\"] = \"Bearer \" + secretKey } }; RestClient.Post(request).Then(response => { int responseInt = int.Parse(response.Text); string result = responseInt > 0 ? \"success\" : \"Character not found!\"; Debug.Log($\"[BackendReadWrites.AddInventory] {response.StatusCode}. {request.Uri} result: {result}; response: {response.Text}\"); callback?.Invoke(responseInt); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.AddInventory] {request.Uri} response error: {error.Message} {error.StackTrace}\"); var requestException = new RequestException(error.Message); }); #endif } public static void DeleteInventory(CharacterDataDTO characterData, Action<int> callback) { #if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX string secretKey = \"SanatMadina\";//Environment.GetEnvironmentVariable //async addInventory(@Body() characterData: CharacterDataDTO, secretKey: string): Promise<number> RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{DELETE_CHARACTER_INVENTORY}\", BodyString = JsonConvert.SerializeObject(characterData), Headers = new Dictionary<string, string>() { [\"authorization\"] = \"Bearer \" + secretKey } }; RestClient.Post(request).Then(response => { int responseInt = int.Parse(response.Text); string result = responseInt > 0 ? \"success\" : \"Character not found!\"; Debug.Log($\"[BackendReadWrites.DeleteInventory] {response.StatusCode}. {request.Uri} result: {result}; response: {response.Text}\"); callback?.Invoke(responseInt); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.DeleteInventory] {request.Uri} response error: {error.Message} {error.StackTrace}\"); var requestException = new RequestException(error.Message); }); #endif } public static void GetAbilityStacksForCharacter(int characterId, byte abilityId, Action<AbilityInfo> callback) { string url = $\"{BACKEND_URL}{GET_ABILITY_STACKS}{characterId}/{abilityId}\"; Debug.Log($\"[BackendReadWrites] GetAbilityStacksForCharacter {url} for character #{characterId} and ability #{abilityId}\"); RequestHelper requestHelper = new RequestHelper { Uri = $\"{url}\" }; DefaultGetRequest(requestHelper, (exception, response, body) => { AbilityInfo abilityInfo = new AbilityInfo(); abilityInfo.Id = abilityId; abilityInfo.Rank = 1; if (exception != null) { Debug.LogError(\"Error geting ability rank: \" + exception.Message); callback?.Invoke(abilityInfo); return; } Debug.Log($\"[BackendReadWrites] GetAbilityRankForPlayer for ability #{abilityId}: {body}\"); abilityInfo = JsonConvert.DeserializeObject<AbilityInfo>(body); abilityInfo.Id = abilityId; abilityInfo.Rank = 1; callback?.Invoke(abilityInfo); }); } public static string RegisterCharacter(CharacterSkinData skinData) { string jsonBody = JsonConvert.SerializeObject(skinData); RequestHelper requestHelper = new RequestHelper { Uri = $\"{BACKEND_URL}{REGISTER_CHARACTER}\", BodyString = jsonBody, EnableDebug = true, Headers = new Dictionary<string, string>() { //authorization bearer token [\"authorization\"] = \"Bearer \" + PlayerData.Instance.Token // [\"unique_user_id\"] = playerRegisterData.unique_user_id, // [\"password_hash\"] = playerRegisterData.password_hash },// + WebsiteRestConfig.Profile.token }; DefaultPostRequest(requestHelper, (exception, response, body) => { if (exception != null) { Debug.LogError(\"Error registering character: \" + exception.Message); return; } int responseInt = int.Parse(body); if (responseInt > 0) { Debug.Log(\"Character registered with id:\" + body); skinData.Id = responseInt; OnCharacterCreated?.Invoke(skinData); }else { Debug.Log(\"Character not registered. Code #\" + body); } }); return \"\"; } //https://hathora.dev/api#tag/RoomV2/operation/GetActiveRoomsForProcess public static void GetHathoraRoomId(Action<RequestException, ResponseHelper, string> callback) { #if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX string currentProcessHathoraId = Environment.GetEnvironmentVariable(\"HATHORA_PROCESS_ID\"); string appId = Environment.GetEnvironmentVariable(\"HATHORA_APP_ID\"); string token = Environment.GetEnvironmentVariable(\"HATHORA_APP_SECRET\"); Debug.Log($\"[BackendReadWrites] GetHathoraRoomId for process #{currentProcessHathoraId}; token: {token}\"); RequestHelper requestHelper = new RequestHelper { Uri = $\"{HATHORA_GET_ROOM_ID}{appId}/list/{currentProcessHathoraId}/active\", Headers = new Dictionary<string, string>() { [\"Authorization\"] = \"Bearer \" + HATHORA_TOKEN}, }; RestClient.Get(requestHelper).Then(response => { Debug.Log($\"[BackendReadWrites.GetHathoraRoomId] {requestHelper.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }); #endif } public static void GetHathoraConnectionInfo(string roomId, Action<RequestException, ResponseHelper, string> callback) { #if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX Debug.Log($\"[BackendReadWrites] GetHathoraConnectionInfo\"); string appId = Environment.GetEnvironmentVariable(\"HATHORA_APP_ID\"); RequestHelper requestHelper = new RequestHelper { Uri = $\"{HATHORA_GET_CONNECTION_INFO}{appId}/connectioninfo/{roomId}\", }; RestClient.Get(requestHelper).Then(response => { Debug.Log($\"[BackendReadWrites.GetHathoraConnectionInfo] {requestHelper.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.GetHathoraConnectionInfo] {requestHelper.Uri} response error: {error.Message} {error.StackTrace}\"); //callback?.Invoke(null, null, \"error\"); }); #endif } #region PlayerData public static void RegisterUser(Player playerData, Action<RequestException, ResponseHelper, string> callback) { string jsonBody = JsonConvert.SerializeObject(playerData); RequestHelper requestHelper = new RequestHelper { Uri = $\"{BACKEND_URL}{REGISTER_USER}\", BodyString = jsonBody, EnableDebug = true //Headers = new Dictionary<string, string>() { [\"Authorization\"] = \"Bearer \"},// + WebsiteRestConfig.Profile.token }; DefaultPostRequest(requestHelper, callback); } public static void Login(Player playerData, Action<RequestException, ResponseHelper, string> callback) { string jsonBody = JsonConvert.SerializeObject(playerData); RequestHelper requestHelper = new RequestHelper { Uri = $\"{BACKEND_URL}{LOGIN_USER}\", BodyString = jsonBody, EnableDebug = true //Headers = new Dictionary<string, string>() { [\"Authorization\"] = \"Bearer \"},// + WebsiteRestConfig.Profile.token }; RestClient.Post(requestHelper).Then(response => { Debug.Log($\"[BackendReadWrites.Login] {requestHelper.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.Login] {requestHelper.Uri} response error: {error.Message} {error.StackTrace}\"); RequestException requestException = new RequestException(error.Message); callback?.Invoke(requestException, null, \"error\"); }) .Finally(() => { }); } public static void ChangePlayerData(string token, string newUsername, string newEmail, string newPassword, Action<RequestException, ResponseHelper, string> callback) { string jsonBody = JsonConvert.SerializeObject(new { username = newUsername, email = newEmail, password = newPassword }); RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{CHANGE_EMAIL_PASSWORD}\", BodyString = jsonBody, Headers = new Dictionary<string, string>() { [\"authorization\"] = \"Bearer \" + token } }; RestClient.Post(request).Then(response => { Debug.Log($\"[BackendReadWrites.ChangePlayerData] {response.StatusCode} {request.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}\"); RequestException requestException = new RequestException(error.Message); callback?.Invoke(requestException, null, \"error\"); }) .Finally(() => { }); } #endregion //TODO: Create GetCharacterData to load several characters with several included tokens public static void GetCharacterData(string token, Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{GET_FIRST_CHARACTER}\", Headers = new Dictionary<string, string>() { [\"authorization\"] = \"Bearer \" + token } }; RestClient.Get(request).Then(response => { Debug.Log($\"[BackendReadWrites.GetCharacterData] {response.StatusCode} {request.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}\"); //callback?.Invoke(null, null, \"error\"); }) .Finally(() => { }); } public static void GetCharacterData(PlayerData.PlayerRegisterData playerRegisterData, Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{GET_CHARACTER}\", BodyString = JsonConvert.SerializeObject(playerRegisterData), Headers = new Dictionary<string, string> { [\"authorization\"] = \"Bearer \" + PlayerData.Instance.Token } }; RestClient.Get(request).Then(response => { Debug.Log($\"[BackendReadWrites.GetCharacterData] {response.StatusCode} {request.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}\"); var requestException = new RequestException(error.Message); callback?.Invoke(requestException, null, error.Message); }) .Finally(() => { }); } public static void AiDoDialog(string m_question, int m_asker, int m_answerer, Action<RequestException, ResponseHelper, string> callback) { string jsonBody = JsonConvert.SerializeObject(new { question = m_question, asker = m_asker, answerer = m_answerer }); Debug.Log($\"[BackendReadWrites.AiDoDialog] url: {BACKEND_URL}ai/do-dialog; jsonBody: {jsonBody}\"); RequestHelper requestHelper = new RequestHelper { Uri = $\"{BACKEND_URL}ai/do-dialog\", BodyString = jsonBody, EnableDebug = true //Headers = new Dictionary<string, string>() { [\"Authorization\"] = \"Bearer \"},// + WebsiteRestConfig.Profile.token }; DefaultPostRequest(requestHelper, callback); } public static void GetAudioFile(string audioFilePath, string audioFileName, Action<AudioClip> onSuccess, Action<string> onError) { string url = $\"{BACKEND_URL}audio\"; var audioData = new { path = audioFilePath, filename = audioFileName + \".mp3\" }; Debug.Log($\"[BackendReadWrites.GetAudioFile] url: {url}, audioData: {audioData}\"); string jsonBody = JsonConvert.SerializeObject(audioData); RestClient.Get(new RequestHelper { Uri = url, BodyString = jsonBody, DownloadHandler = new DownloadHandlerAudioClip(url, AudioType.MPEG) // Adjust AudioType based on your file format }).Then(response => { AudioClip audioClip = ((DownloadHandlerAudioClip)response.Request.downloadHandler).audioClip; onSuccess?.Invoke(audioClip); }).Catch(error => { onError?.Invoke(error.Message); }); } #region ServerData public static void RegisterServer(string JSON, Action<RequestException, ResponseHelper, string> callback) { #if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{POST_REGISTER_SERVER}\", BodyString = JSON }; DefaultPostRequest(request, callback); #endif } public static void UnregisterServer(string JSON, Action<RequestException, ResponseHelper, string> callback) { #if UNITY_SERVER || UNITY_EDITOR RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{POST_REGISTER_SERVER}\", BodyString = JSON }; DefaultPostRequest(request, callback); #endif } public static void GetServersByVersion(string version, Action<RequestException, ResponseHelper, string> callback) { RequestHelper requestHelper = new RequestHelper { Uri = $\"{BACKEND_URL}{GET_AVAILABLE_SERVERS}{version}\", Timeout = 50, }; RestClient.Get(requestHelper).Then(response => { Debug.Log($\"[BackendReadWrites.DefaultGetRequest] {requestHelper.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.DefaultGetRequest] {requestHelper.Uri} response error: {error.Message} {error.StackTrace}\"); RequestException requestException = new RequestException(error.Message); callback?.Invoke(requestException, null, \"error\"); }); } #endregion #region Default Post/Get private static void DefaultPostRequest(RequestHelper request, Action<RequestException, ResponseHelper, string> callback) { RestClient.Post(request).Then(response => { Debug.Log($\"[BackendReadWrites.Post] {request.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.Post] {request.Uri} response error: {error.Message} {error.StackTrace}\"); //callback?.Invoke(null, null, \"error\"); }) .Finally(() => { }); } private static void DefaultGetRequest(RequestHelper request, Action<RequestException, ResponseHelper, string> callback) { RestClient.Get(request).Then(response => { Debug.Log($\"[BackendReadWrites.DefaultGetRequest] {request.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.DefaultGetRequest] {request.Uri} response error: {error.Message} {error.StackTrace}\"); RequestException requestException = new RequestException(error.Message); callback?.Invoke(requestException, null, \"error\"); }) .Finally(() => { }); } #endregion [Serializable] public class Player { public string username; public string password; public string email; } [Serializable] public class Token { public string username; public string access_token; } public class CharacterDataDTO { public int id; public SlotItem[] bank_items; public SlotItem[] backpack_items; public SlotItem[] equipment_items; } [Serializable] public class SlotItem{ public int slotId; public int itemId; public int amount; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BackendReadWrites",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "BackendReadWrites",
          "content": "using System; using System.Collections.Generic; using System.Diagnostics; using System.Text; using _ZombieRoyale.Scripts.Clients; using Newtonsoft.Json; using Proyecto26; using SingletonsExtension; using UnityEngine; using UnityEngine.Networking; using UnityEngine.Serialization; using Debug = UnityEngine.Debug; public static class BackendReadWrites { #region open data private static readonly string BACKEND_URL = \"http://64.226.78.97:3000/\";//\"http://localhost:3000/\";// private static readonly string GET_ABILITY_STACKS = \"character/get_ability_stacks/\"; private static readonly string REGISTER_CHARACTER = \"character/new-character\"; private static readonly string CHARACTER_GET_SKIN = \"character/get_skin/\"; private static readonly string CHARACTER_GET_PLAYER_NAME = \"character/get_player_name/\"; private static readonly string GET_CHARACTER = \"character/0\"; private static readonly string GET_FIRST_CHARACTER = \"character/server_get_first_character\"; private static readonly string CHANGE_EMAIL_PASSWORD = \"player/change_email_password/\"; private static readonly string REGISTER_USER = \"player/register/\"; private static readonly string LOGIN_USER = \"auth/login/\"; private static readonly string GET_ALL_SERVERS = \"server/get_all_servers\"; private static readonly string GET_AVAILABLE_SERVERS = \"server/get_servers_by_version/\"; #if UNITY_EDITOR || UNITY_SERVER || UNITY_STANDALONE_LINUX private static readonly string HATHORA_GET_ROOM_ID = \"https://api.hathora.dev/rooms/v2/\";//\"https://api.hathora.dev/rooms/v2/app-60bc431b-e9b7-4139-845d-2b9899e026cd/list/\"; private static readonly string HATHORA_GET_CONNECTION_INFO = \"https://api.hathora.dev/rooms/v2/\";//\"https://api.hathora.dev/rooms/v2/app-60bc431b-e9b7-4139-845d-2b9899e026cd/connectioninfo/\"; private static readonly string HATHORA_TOKEN = \"_Chky51qPZz-q7wz7YPcPZZrEeI8UoayOhnkG2CsSZdXf\";//\"jlZ-xwlRF8_3BufxnI1MEwHr57Mgm4G-wN3WGXJ6RMWDu\"; private static readonly string SET_CHARACTER_ABILITY_STACKS = \"character/set_ability_stacks/\"; private static readonly string ADD_CHARACTER_INVENTORY = \"character/add_inventory\"; private static readonly string DELETE_CHARACTER_INVENTORY = \"character/remove_inventory\"; #endif private static string GetMyProcessID() { // Gets the current process var currentProcess = Process.GetCurrentProcess(); // Returns the process ID as a string return currentProcess.Id.ToString(); } public static Action<CharacterSkinData> OnCharacterCreated; #endregion #region closed data #if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX private static readonly string SAVE_USER_DATA_TO_BACKEND = \"character/\"; private static readonly string POST_REGISTER_SERVER = \"server/register_server\"; private static readonly string POST_UNREGISTER_SERVER = \"server/unregister_server\"; #endif #endregion public static void GetPlayerNameBasedOnCharacterId(int id, Action<string> callback) { RequestHelper requestHelper = new RequestHelper { Uri = $\"{BACKEND_URL}{CHARACTER_GET_PLAYER_NAME}{id}\" }; DefaultGetRequest(requestHelper, (exception, response, body) => { if (exception != null) { Debug.LogError(\"Error geting character: \" + exception.Message); return; } Debug.Log($\"[BackendReadWrites] GetPlayerNameBasedOnCharacterId for id #{id}: {body}\"); callback?.Invoke(body); }); } public static void GetCharacterSkin(int id, Action<CharacterSkinData> callback) { RequestHelper requestHelper = new RequestHelper { Uri = $\"{BACKEND_URL}{CHARACTER_GET_SKIN}{id}\" }; CharacterSkinData skinData = new CharacterSkinData(); DefaultGetRequest(requestHelper, (exception, response, body) => { if (exception != null) { Debug.LogError(\"Error geting character: \" + exception.Message); return; } Debug.Log($\"[BackendReadWrites] GetCharacterSkin for id #{id}: {body}\"); skinData = JsonConvert.DeserializeObject<CharacterSkinData>(body); Debug.Log($\"[BackendReadWrites] GetCharacterSkin check class: {skinData.ToString()}\"); StringBuilder sb = new StringBuilder($\"[BackendReadWrites] GetCharacterSkin for id #{id}: {skinData}\"); callback?.Invoke(skinData); if (skinData.Id == 0) { sb.Append($\"Character not found\"); Debug.LogError(sb); } else { Debug.Log(sb); } }); } public static void SetAbilityStacks(string token, AbilityInfo[] abilityInfos, Action<int> callback) { #if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{SET_CHARACTER_ABILITY_STACKS}\", BodyString = JsonConvert.SerializeObject(abilityInfos), Headers = new Dictionary<string, string>() { [\"authorization\"] = \"Bearer \" + token } }; RestClient.Post(request).Then(response => { int responseInt = int.Parse(response.Text); string result = responseInt > 0 ? \"success\" : \"Character not found!\"; Debug.Log($\"[BackendReadWrites.SetCharacterAbilityStacks] {response.StatusCode}. {request.Uri} result: {result}; response: {response.Text}\"); callback?.Invoke(responseInt); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}\"); var requestException = new RequestException(error.Message); }); #endif } public static void AddInventory(CharacterDataDTO characterData, Action<int> callback) { #if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX string secretKey = \"SanatMadina\";//Environment.GetEnvironmentVariable //async addInventory(@Body() characterData: CharacterDataDTO, secretKey: string): Promise<number> RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{ADD_CHARACTER_INVENTORY}\", BodyString = JsonConvert.SerializeObject(characterData), Headers = new Dictionary<string, string>() { [\"authorization\"] = \"Bearer \" + secretKey } }; RestClient.Post(request).Then(response => { int responseInt = int.Parse(response.Text); string result = responseInt > 0 ? \"success\" : \"Character not found!\"; Debug.Log($\"[BackendReadWrites.AddInventory] {response.StatusCode}. {request.Uri} result: {result}; response: {response.Text}\"); callback?.Invoke(responseInt); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.AddInventory] {request.Uri} response error: {error.Message} {error.StackTrace}\"); var requestException = new RequestException(error.Message); }); #endif } public static void DeleteInventory(CharacterDataDTO characterData, Action<int> callback) { #if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX string secretKey = \"SanatMadina\";//Environment.GetEnvironmentVariable //async addInventory(@Body() characterData: CharacterDataDTO, secretKey: string): Promise<number> RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{DELETE_CHARACTER_INVENTORY}\", BodyString = JsonConvert.SerializeObject(characterData), Headers = new Dictionary<string, string>() { [\"authorization\"] = \"Bearer \" + secretKey } }; RestClient.Post(request).Then(response => { int responseInt = int.Parse(response.Text); string result = responseInt > 0 ? \"success\" : \"Character not found!\"; Debug.Log($\"[BackendReadWrites.DeleteInventory] {response.StatusCode}. {request.Uri} result: {result}; response: {response.Text}\"); callback?.Invoke(responseInt); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.DeleteInventory] {request.Uri} response error: {error.Message} {error.StackTrace}\"); var requestException = new RequestException(error.Message); }); #endif } public static void GetAbilityStacksForCharacter(int characterId, byte abilityId, Action<AbilityInfo> callback) { string url = $\"{BACKEND_URL}{GET_ABILITY_STACKS}{characterId}/{abilityId}\"; Debug.Log($\"[BackendReadWrites] GetAbilityStacksForCharacter {url} for character #{characterId} and ability #{abilityId}\"); RequestHelper requestHelper = new RequestHelper { Uri = $\"{url}\" }; DefaultGetRequest(requestHelper, (exception, response, body) => { AbilityInfo abilityInfo = new AbilityInfo(); abilityInfo.Id = abilityId; abilityInfo.Rank = 1; if (exception != null) { Debug.LogError(\"Error geting ability rank: \" + exception.Message); callback?.Invoke(abilityInfo); return; } Debug.Log($\"[BackendReadWrites] GetAbilityRankForPlayer for ability #{abilityId}: {body}\"); abilityInfo = JsonConvert.DeserializeObject<AbilityInfo>(body); abilityInfo.Id = abilityId; abilityInfo.Rank = 1; callback?.Invoke(abilityInfo); }); } public static string RegisterCharacter(CharacterSkinData skinData) { string jsonBody = JsonConvert.SerializeObject(skinData); RequestHelper requestHelper = new RequestHelper { Uri = $\"{BACKEND_URL}{REGISTER_CHARACTER}\", BodyString = jsonBody, EnableDebug = true, Headers = new Dictionary<string, string>() { //authorization bearer token [\"authorization\"] = \"Bearer \" + PlayerData.Instance.Token // [\"unique_user_id\"] = playerRegisterData.unique_user_id, // [\"password_hash\"] = playerRegisterData.password_hash },// + WebsiteRestConfig.Profile.token }; DefaultPostRequest(requestHelper, (exception, response, body) => { if (exception != null) { Debug.LogError(\"Error registering character: \" + exception.Message); return; } int responseInt = int.Parse(body); if (responseInt > 0) { Debug.Log(\"Character registered with id:\" + body); skinData.Id = responseInt; OnCharacterCreated?.Invoke(skinData); }else { Debug.Log(\"Character not registered. Code #\" + body); } }); return \"\"; } //https://hathora.dev/api#tag/RoomV2/operation/GetActiveRoomsForProcess public static void GetHathoraRoomId(Action<RequestException, ResponseHelper, string> callback) { #if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX string currentProcessHathoraId = Environment.GetEnvironmentVariable(\"HATHORA_PROCESS_ID\"); string appId = Environment.GetEnvironmentVariable(\"HATHORA_APP_ID\"); string token = Environment.GetEnvironmentVariable(\"HATHORA_APP_SECRET\"); Debug.Log($\"[BackendReadWrites] GetHathoraRoomId for process #{currentProcessHathoraId}; token: {token}\"); RequestHelper requestHelper = new RequestHelper { Uri = $\"{HATHORA_GET_ROOM_ID}{appId}/list/{currentProcessHathoraId}/active\", Headers = new Dictionary<string, string>() { [\"Authorization\"] = \"Bearer \" + HATHORA_TOKEN}, }; RestClient.Get(requestHelper).Then(response => { Debug.Log($\"[BackendReadWrites.GetHathoraRoomId] {requestHelper.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }); #endif } public static void GetHathoraConnectionInfo(string roomId, Action<RequestException, ResponseHelper, string> callback) { #if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX Debug.Log($\"[BackendReadWrites] GetHathoraConnectionInfo\"); string appId = Environment.GetEnvironmentVariable(\"HATHORA_APP_ID\"); RequestHelper requestHelper = new RequestHelper { Uri = $\"{HATHORA_GET_CONNECTION_INFO}{appId}/connectioninfo/{roomId}\", }; RestClient.Get(requestHelper).Then(response => { Debug.Log($\"[BackendReadWrites.GetHathoraConnectionInfo] {requestHelper.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.GetHathoraConnectionInfo] {requestHelper.Uri} response error: {error.Message} {error.StackTrace}\"); //callback?.Invoke(null, null, \"error\"); }); #endif } #region PlayerData public static void RegisterUser(Player playerData, Action<RequestException, ResponseHelper, string> callback) { string jsonBody = JsonConvert.SerializeObject(playerData); RequestHelper requestHelper = new RequestHelper { Uri = $\"{BACKEND_URL}{REGISTER_USER}\", BodyString = jsonBody, EnableDebug = true //Headers = new Dictionary<string, string>() { [\"Authorization\"] = \"Bearer \"},// + WebsiteRestConfig.Profile.token }; DefaultPostRequest(requestHelper, callback); } public static void Login(Player playerData, Action<RequestException, ResponseHelper, string> callback) { string jsonBody = JsonConvert.SerializeObject(playerData); RequestHelper requestHelper = new RequestHelper { Uri = $\"{BACKEND_URL}{LOGIN_USER}\", BodyString = jsonBody, EnableDebug = true //Headers = new Dictionary<string, string>() { [\"Authorization\"] = \"Bearer \"},// + WebsiteRestConfig.Profile.token }; RestClient.Post(requestHelper).Then(response => { Debug.Log($\"[BackendReadWrites.Login] {requestHelper.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.Login] {requestHelper.Uri} response error: {error.Message} {error.StackTrace}\"); RequestException requestException = new RequestException(error.Message); callback?.Invoke(requestException, null, \"error\"); }) .Finally(() => { }); } public static void ChangePlayerData(string token, string newUsername, string newEmail, string newPassword, Action<RequestException, ResponseHelper, string> callback) { string jsonBody = JsonConvert.SerializeObject(new { username = newUsername, email = newEmail, password = newPassword }); RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{CHANGE_EMAIL_PASSWORD}\", BodyString = jsonBody, Headers = new Dictionary<string, string>() { [\"authorization\"] = \"Bearer \" + token } }; RestClient.Post(request).Then(response => { Debug.Log($\"[BackendReadWrites.ChangePlayerData] {response.StatusCode} {request.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}\"); RequestException requestException = new RequestException(error.Message); callback?.Invoke(requestException, null, \"error\"); }) .Finally(() => { }); } #endregion //TODO: Create GetCharacterData to load several characters with several included tokens public static void GetCharacterData(string token, Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{GET_FIRST_CHARACTER}\", Headers = new Dictionary<string, string>() { [\"authorization\"] = \"Bearer \" + token } }; RestClient.Get(request).Then(response => { Debug.Log($\"[BackendReadWrites.GetCharacterData] {response.StatusCode} {request.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}\"); //callback?.Invoke(null, null, \"error\"); }) .Finally(() => { }); } public static void GetCharacterData(PlayerData.PlayerRegisterData playerRegisterData, Action<RequestException, ResponseHelper, string> callback) { RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{GET_CHARACTER}\", BodyString = JsonConvert.SerializeObject(playerRegisterData), Headers = new Dictionary<string, string> { [\"authorization\"] = \"Bearer \" + PlayerData.Instance.Token } }; RestClient.Get(request).Then(response => { Debug.Log($\"[BackendReadWrites.GetCharacterData] {response.StatusCode} {request.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.GetCharacterData] {request.Uri} response error: {error.Message} {error.StackTrace}\"); var requestException = new RequestException(error.Message); callback?.Invoke(requestException, null, error.Message); }) .Finally(() => { }); } public static void AiDoDialog(string m_question, int m_asker, int m_answerer, Action<RequestException, ResponseHelper, string> callback) { string jsonBody = JsonConvert.SerializeObject(new { question = m_question, asker = m_asker, answerer = m_answerer }); Debug.Log($\"[BackendReadWrites.AiDoDialog] url: {BACKEND_URL}ai/do-dialog; jsonBody: {jsonBody}\"); RequestHelper requestHelper = new RequestHelper { Uri = $\"{BACKEND_URL}ai/do-dialog\", BodyString = jsonBody, EnableDebug = true //Headers = new Dictionary<string, string>() { [\"Authorization\"] = \"Bearer \"},// + WebsiteRestConfig.Profile.token }; DefaultPostRequest(requestHelper, callback); } public static void GetAudioFile(string audioFilePath, string audioFileName, Action<AudioClip> onSuccess, Action<string> onError) { string url = $\"{BACKEND_URL}audio\"; var audioData = new { path = audioFilePath, filename = audioFileName + \".mp3\" }; Debug.Log($\"[BackendReadWrites.GetAudioFile] url: {url}, audioData: {audioData}\"); string jsonBody = JsonConvert.SerializeObject(audioData); RestClient.Get(new RequestHelper { Uri = url, BodyString = jsonBody, DownloadHandler = new DownloadHandlerAudioClip(url, AudioType.MPEG) // Adjust AudioType based on your file format }).Then(response => { AudioClip audioClip = ((DownloadHandlerAudioClip)response.Request.downloadHandler).audioClip; onSuccess?.Invoke(audioClip); }).Catch(error => { onError?.Invoke(error.Message); }); } #region ServerData public static void RegisterServer(string JSON, Action<RequestException, ResponseHelper, string> callback) { #if UNITY_SERVER || UNITY_EDITOR || UNITY_STANDALONE_LINUX RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{POST_REGISTER_SERVER}\", BodyString = JSON }; DefaultPostRequest(request, callback); #endif } public static void UnregisterServer(string JSON, Action<RequestException, ResponseHelper, string> callback) { #if UNITY_SERVER || UNITY_EDITOR RequestHelper request = new RequestHelper { Uri = $\"{BACKEND_URL}{POST_REGISTER_SERVER}\", BodyString = JSON }; DefaultPostRequest(request, callback); #endif } public static void GetServersByVersion(string version, Action<RequestException, ResponseHelper, string> callback) { RequestHelper requestHelper = new RequestHelper { Uri = $\"{BACKEND_URL}{GET_AVAILABLE_SERVERS}{version}\", Timeout = 50, }; RestClient.Get(requestHelper).Then(response => { Debug.Log($\"[BackendReadWrites.DefaultGetRequest] {requestHelper.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.DefaultGetRequest] {requestHelper.Uri} response error: {error.Message} {error.StackTrace}\"); RequestException requestException = new RequestException(error.Message); callback?.Invoke(requestException, null, \"error\"); }); } #endregion #region Default Post/Get private static void DefaultPostRequest(RequestHelper request, Action<RequestException, ResponseHelper, string> callback) { RestClient.Post(request).Then(response => { Debug.Log($\"[BackendReadWrites.Post] {request.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.Post] {request.Uri} response error: {error.Message} {error.StackTrace}\"); //callback?.Invoke(null, null, \"error\"); }) .Finally(() => { }); } private static void DefaultGetRequest(RequestHelper request, Action<RequestException, ResponseHelper, string> callback) { RestClient.Get(request).Then(response => { Debug.Log($\"[BackendReadWrites.DefaultGetRequest] {request.Uri} response success: {response.Text}\"); callback?.Invoke(null, response, response.Text); }) .Catch(error => { Debug.Log($\"[BackendReadWrites.DefaultGetRequest] {request.Uri} response error: {error.Message} {error.StackTrace}\"); RequestException requestException = new RequestException(error.Message); callback?.Invoke(requestException, null, \"error\"); }) .Finally(() => { }); } #endregion [Serializable] public class Player { public string username; public string password; public string email; } [Serializable] public class Token { public string username; public string access_token; } public class CharacterDataDTO { public int id; public SlotItem[] bank_items; public SlotItem[] backpack_items; public SlotItem[] equipment_items; } [Serializable] public class SlotItem{ public int slotId; public int itemId; public int amount; } }",
          "content_tokens": 5558,
          "embedding": []
        }
      ],
      "length": 19454
    },
    {
      "filename": "HathoraData",
      "content": "using System.Collections.Generic; namespace Hathora{ [System.Serializable] public class RoomData { public string _id; public string appId; public string roomId; public string roomConfig; public string status; public AllocationData currentAllocation; } [System.Serializable] public class AllocationData { public string roomAllocationId; public string processId; public string scheduledAt; public string unscheduledAt; } [System.Serializable] public class RoomDataList { public List<RoomData> rooms; } [System.Serializable] public class ConnectionInfo { public List<ExposedPort> additionalExposedPorts; public ExposedPort exposedPort; public string status; public string roomId; } [System.Serializable] public class ExposedPort { public string host; public string name; public ushort port; public string transportType; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "HathoraData",
          "content": "using System.Collections.Generic; namespace Hathora{ [System.Serializable] public class RoomData { public string _id; public string appId; public string roomId; public string roomConfig; public string status; public AllocationData currentAllocation; } [System.Serializable] public class AllocationData { public string roomAllocationId; public string processId; public string scheduledAt; public string unscheduledAt; } [System.Serializable] public class RoomDataList { public List<RoomData> rooms; } [System.Serializable] public class ConnectionInfo { public List<ExposedPort> additionalExposedPorts; public ExposedPort exposedPort; public string status; public string roomId; } [System.Serializable] public class ExposedPort { public string host; public string name; public ushort port; public string transportType; } }",
          "content_tokens": 188,
          "embedding": []
        }
      ],
      "length": 820
    },
    {
      "filename": "RegistrationController",
      "content": "using System; using TMPro; using UnityEngine; using _ZombieRoyale.Scripts.Clients; using Newtonsoft.Json; using Proyecto26; using UnityEngine.UI; using DDCore; public class RegistrationController : MonoBehaviour { [SerializeField] private UICanvasGroupDecorator _registrationCanvasGroup; [SerializeField] private TMP_InputField _usernameField; [SerializeField] private TMP_InputField _passwordField; [SerializeField] private TMP_InputField _confirmPasswordField; [SerializeField] private TMP_InputField _emailField; [SerializeField] private GameObject _switchToSignInButton; [SerializeField] private GameObject _signInButton; [SerializeField] private GameObject _backButton; [SerializeField] private GameObject _registerButton; [SerializeField] private PlayerData _playerData; [SerializeField] private TextMeshProUGUI _errorText; [SerializeField] private CharCreatorSceneLoader _charCreatorSceneLoader; [SerializeField] private GameObjectDispatcher[] _mainMenuElements; [SerializeField] private MainMenuCameraSpawner mainMenuCameraSpawner; public static RegistrationController Instance { get; private set; } public Action<CharacterData> OnCharacterLoaded; private bool _isCharacterWasLoaded; private void OnValidate() { mainMenuCameraSpawner ??= FindObjectOfType<MainMenuCameraSpawner>(); } private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); }else if (Instance != this) { Destroy(gameObject); } //_backButton.SetActive(false); //_signInButton.SetActive(false); } private void Start() { if (NetworkHudCanvases.Instance.IsAutoStartServer) return; if (!_playerData.IsUsingBackend) { _playerData.OnPlayerLoggedIn?.Invoke(); return; } _playerData.OnPlayerLoggedIn += OnPlayerLoggedIn; //RegisterGuestAccount(); if (_playerData.IsPlayerPersistInPlayerPrefs()) { Debug.Log(\"[RegistrationController] Player persists in player prefs\"); //_registrationCanvasGroup.Hide(); _playerData.LoadPlayerDataFromPlayerPrefs(); _playerData.UpdateToken(); } else { Debug.Log(\"[RegistrationController] Player was not persisted in player prefs\"); RegisterGuestAccount(); //_registrationCanvasGroup.Show(); } } public void SwithButtons(Button[] btns, bool isInterractable) { for (int i = 0; i < btns.Length; i++) { btns[i].interactable = isInterractable; } } public void SwitchMainMenuElements(bool isActive) { for (int i = 0; i < _mainMenuElements.Length; i++) { if (_mainMenuElements[i] == null) continue; if (isActive) { _mainMenuElements[i].Activate(); } else { _mainMenuElements[i].Deactivate(); } } if (isActive) { mainMenuCameraSpawner.SpawnMainMenuCamera(); } else { mainMenuCameraSpawner.DeSpawnMainMenuCamera(); } } private void RegisterGuestAccount() { BackendReadWrites.Player player = new BackendReadWrites.Player(); player.username = UsernameGenerator.GenerateUsername(); player.password = Guid.NewGuid().ToString(); player.email = $\"{player.username}@{player.password.Substring(0, 5)}.com\"; _playerData.RegisterPlayer(player); } private void CharacterDataSuccessfullLoad(string json) { SwitchMainMenuElements(true); Debug.Log($\"[RegistrationController.GetCharacterData] json: {json}\"); CharacterData charData = JsonConvert.DeserializeObject<CharacterData>(json); OnCharacterLoaded?.Invoke(charData); _isCharacterWasLoaded = true; Debug.Log($\"[RegistrationController.GetCharacterData] charData loaded\"); /* * { \"id\": 13, \"realm\": \"D\\u0026D\", \"backstory\": \"\", \"name\": \"\", \"genderId\": 0, \"skinColorId\": 0, \"beardId\": 1, \"bodyArtId\": 0, \"faceId\": 1, \"hairId\": 3, \"hairColorId\": 0, \"age\": null, \"charClass\": \"\", \"level\": 0, \"xp\": 0, \"gold\": 0, \"health\": \"0.00\", \"mana\": \"0.00\", \"stamina\": \"0.00\", \"skill_ids\": [], \"item_ids\": [], \"equipment_ids\": [], \"x\": \"0.00\", \"y\": \"0.00\", \"z\": \"0.00\", \"rotation\": \"0.00\", \"ainpc\": null, \"stats\": null, \"player\": { \"id\": 4, \"username\": \"20230826-182011\", \"email\": \"20230826-182011@8c83a.com\", \"password\": \"$2b$10$6sZ.YPkxXEM12K7kkNmakOAB3yQN2X8RUNs76hny60XBIgTwdcM/G\" } } */ } private void OnPlayerLoggedIn() { var callback = new Action<Exception, ResponseHelper, string>((exception, response, body) => { if (_isCharacterWasLoaded) { Debug.Log($\"[RegistrationController.GetCharacterData] character was loaded. Break.\"); return; } if (exception != null) { Debug.LogError($\"CRITICAL ERROR! [RegistrationController] OnPlayerLoggedIn {exception.Message}. Check Backend logs.\"); return; } Debug.Log($\"[RegistrationController.GetCharacterData] response: {response}, body: {body}\"); bool isPlayerDontHaveChars = body.Substring(0, 2) == \"-1\"; bool isError = body == \"error\"; if (isPlayerDontHaveChars || isError) { Debug.Log($\"[RegistrationController.GetCharacterData] player dont have chars or error\"); _charCreatorSceneLoader.LoadCharacterCreationScene(); SwitchMainMenuElements(false); } else { Debug.Log($\"[RegistrationController.GetCharacterData] player have chars\"); CharacterDataSuccessfullLoad(body); } }); BackendReadWrites.GetCharacterData(_playerData.MyPlayerRegisterData, callback); if (_registrationCanvasGroup != null) _registrationCanvasGroup.Hide(); } public void OnSwitchToSignInClick() { _confirmPasswordField.gameObject.SetActive(false); _usernameField.gameObject.SetActive(false); _backButton.SetActive(true); _registerButton.SetActive(false); _switchToSignInButton.SetActive(false); _signInButton.SetActive(true); } public void OnBackButtonClick() { _backButton.SetActive(false); _registerButton.SetActive(true); _switchToSignInButton.SetActive(true); _signInButton.SetActive(false); } bool IsFieldValid(TMP_InputField which) { if (which.text.Length > 0) { return true; } return false; } public void OnRegisterClick() { if (IsFieldValid(_usernameField) && IsFieldValid(_passwordField) && IsFieldValid(_confirmPasswordField) && IsFieldValid(_emailField)) { if (_passwordField.text == _confirmPasswordField.text) { BackendReadWrites.Player player = new BackendReadWrites.Player(); player.username = _usernameField.text; player.password = _passwordField.text; player.email = _emailField.text; _playerData.RegisterPlayer(player); } } } public void OnSignInClick() { if (!(IsFieldValid(_passwordField) || IsFieldValid(_emailField))) { return; } BackendReadWrites.Player player = new BackendReadWrites.Player(); player.password = _passwordField.text; player.email = _emailField.text; _playerData.LoginPlayer(player); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RegistrationController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "RegistrationController",
          "content": "using System; using TMPro; using UnityEngine; using _ZombieRoyale.Scripts.Clients; using Newtonsoft.Json; using Proyecto26; using UnityEngine.UI; using DDCore; public class RegistrationController : MonoBehaviour { [SerializeField] private UICanvasGroupDecorator _registrationCanvasGroup; [SerializeField] private TMP_InputField _usernameField; [SerializeField] private TMP_InputField _passwordField; [SerializeField] private TMP_InputField _confirmPasswordField; [SerializeField] private TMP_InputField _emailField; [SerializeField] private GameObject _switchToSignInButton; [SerializeField] private GameObject _signInButton; [SerializeField] private GameObject _backButton; [SerializeField] private GameObject _registerButton; [SerializeField] private PlayerData _playerData; [SerializeField] private TextMeshProUGUI _errorText; [SerializeField] private CharCreatorSceneLoader _charCreatorSceneLoader; [SerializeField] private GameObjectDispatcher[] _mainMenuElements; [SerializeField] private MainMenuCameraSpawner mainMenuCameraSpawner; public static RegistrationController Instance { get; private set; } public Action<CharacterData> OnCharacterLoaded; private bool _isCharacterWasLoaded; private void OnValidate() { mainMenuCameraSpawner ??= FindObjectOfType<MainMenuCameraSpawner>();  ",
          "content_tokens": 334,
          "embedding": []
        },
        {
          "cs_scriptfile": "RegistrationController",
          "content": "private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); }else if (Instance != this) { Destroy(gameObject); } //_backButton.SetActive(false); //_signInButton.SetActive(false);  ",
          "content_tokens": 65,
          "embedding": []
        },
        {
          "cs_scriptfile": "RegistrationController",
          "content": "private void Start() { if (NetworkHudCanvases.Instance.IsAutoStartServer) return; if (!_playerData.IsUsingBackend) { _playerData.OnPlayerLoggedIn?.Invoke(); return; } _playerData.OnPlayerLoggedIn += OnPlayerLoggedIn; //RegisterGuestAccount(); if (_playerData.IsPlayerPersistInPlayerPrefs()) { Debug.Log(\"[RegistrationController] Player persists in player prefs\"); //_registrationCanvasGroup.Hide(); _playerData.LoadPlayerDataFromPlayerPrefs(); _playerData.UpdateToken(); } else { Debug.Log(\"[RegistrationController] Player was not persisted in player prefs\"); RegisterGuestAccount(); //_registrationCanvasGroup.Show(); }  ",
          "content_tokens": 169,
          "embedding": []
        },
        {
          "cs_scriptfile": "RegistrationController",
          "content": "public void SwithButtons(Button[] btns, bool isInterractable) { for (int i = 0; i < btns.Length; i++) { btns[i].interactable = isInterractable; }  public void SwitchMainMenuElements(bool isActive) { for (int i = 0; i < _mainMenuElements.Length; i++) { if (_mainMenuElements[i] == null) continue; if (isActive) { _mainMenuElements[i].Activate(); } else { _mainMenuElements[i].Deactivate(); }  if (isActive) { mainMenuCameraSpawner.SpawnMainMenuCamera(); } else { mainMenuCameraSpawner.DeSpawnMainMenuCamera(); }  ",
          "content_tokens": 170,
          "embedding": []
        },
        {
          "cs_scriptfile": "RegistrationController",
          "content": "private void RegisterGuestAccount() { BackendReadWrites.Player player = new BackendReadWrites.Player(); player.username = UsernameGenerator.GenerateUsername(); player.password = Guid.NewGuid().ToString(); player.email = $\"{player.username}@{player.password.Substring(0, 5)}.com\"; _playerData.RegisterPlayer(player);  ",
          "content_tokens": 89,
          "embedding": []
        },
        {
          "cs_scriptfile": "RegistrationController",
          "content": "private void CharacterDataSuccessfullLoad(string json) { SwitchMainMenuElements(true); Debug.Log($\"[RegistrationController.GetCharacterData] json: {json}\"); CharacterData charData = JsonConvert.DeserializeObject<CharacterData>(json); OnCharacterLoaded?.Invoke(charData); _isCharacterWasLoaded = true; Debug.Log($\"[RegistrationController.GetCharacterData] charData loaded\"); /* * { \"id\": 13, \"realm\": \"D\\u0026D\", \"backstory\": \"\", \"name\": \"\", \"genderId\": 0, \"skinColorId\": 0, \"beardId\": 1, \"bodyArtId\": 0, \"faceId\": 1, \"hairId\": 3, \"hairColorId\": 0, \"age\": null, \"charClass\": \"\", \"level\": 0, \"xp\": 0, \"gold\": 0, \"health\": \"0.00\", \"mana\": \"0.00\", \"stamina\": \"0.00\", \"skill_ids\": [], \"item_ids\": [], \"equipment_ids\": [], \"x\": \"0.00\", \"y\": \"0.00\", \"z\": \"0.00\", \"rotation\": \"0.00\", \"ainpc\": null, \"stats\": null, \"player\": { \"id\": 4, \"username\": \"20230826-182011\", \"email\": \"20230826-182011@8c83a.com\", \"password\": \"$2b$10$6sZ.YPkxXEM12K7kkNmakOAB3yQN2X8RUNs76hny60XBIgTwdcM/G\" } } */  ",
          "content_tokens": 382,
          "embedding": []
        },
        {
          "cs_scriptfile": "RegistrationController",
          "content": "private void OnPlayerLoggedIn() { var callback = new Action<Exception, ResponseHelper, string>((exception, response, body) => { if (_isCharacterWasLoaded) { Debug.Log($\"[RegistrationController.GetCharacterData] character was loaded. Break.\"); return;  ",
          "content_tokens": 64,
          "embedding": []
        },
        {
          "cs_scriptfile": "RegistrationController",
          "content": "if (exception != null) { Debug.LogError($\"CRITICAL ERROR! [RegistrationController] OnPlayerLoggedIn {exception.Message}. Check Backend logs.\"); return; } Debug.Log($\"[RegistrationController.GetCharacterData] response: {response}, body: {body}\"); bool isPlayerDontHaveChars = body.Substring(0, 2) == \"-1\"; bool isError = body == \"error\"; if (isPlayerDontHaveChars || isError) { Debug.Log($\"[RegistrationController.GetCharacterData] player dont have chars or error\"); _charCreatorSceneLoader.LoadCharacterCreationScene(); SwitchMainMenuElements(false); } else { Debug.Log($\"[RegistrationController.GetCharacterData] player have chars\"); CharacterDataSuccessfullLoad(body); } }); BackendReadWrites.GetCharacterData(_playerData.MyPlayerRegisterData, callback); if (_registrationCanvasGroup != null) _registrationCanvasGroup.Hide();  ",
          "content_tokens": 221,
          "embedding": []
        },
        {
          "cs_scriptfile": "RegistrationController",
          "content": "public void OnSwitchToSignInClick() { _confirmPasswordField.gameObject.SetActive(false); _usernameField.gameObject.SetActive(false); _backButton.SetActive(true); _registerButton.SetActive(false); _switchToSignInButton.SetActive(false); _signInButton.SetActive(true);  public void OnBackButtonClick() { _backButton.SetActive(false); _registerButton.SetActive(true); _switchToSignInButton.SetActive(true); _signInButton.SetActive(false);  bool IsFieldValid(TMP_InputField which) { if (which.text.Length > 0) { return true; } return false;  ",
          "content_tokens": 159,
          "embedding": []
        },
        {
          "cs_scriptfile": "RegistrationController",
          "content": "public void OnRegisterClick() { if (IsFieldValid(_usernameField) && IsFieldValid(_passwordField) && IsFieldValid(_confirmPasswordField) && IsFieldValid(_emailField)) { if (_passwordField.text == _confirmPasswordField.text) { BackendReadWrites.Player player = new BackendReadWrites.Player(); player.username = _usernameField.text; player.password = _passwordField.text; player.email = _emailField.text; _playerData.RegisterPlayer(player); } }  public void OnSignInClick() { if (!(IsFieldValid(_passwordField) || IsFieldValid(_emailField))) { return; } BackendReadWrites.Player player = new BackendReadWrites.Player(); player.password = _passwordField.text; player.email = _emailField.text; _playerData.LoginPlayer(player); } }",
          "content_tokens": 198,
          "embedding": []
        }
      ],
      "length": 6294
    },
    {
      "filename": "ServerBackendController",
      "content": "using System; using System.Collections; using System.IO; using FishNet; using FishNet.Transporting; using Newtonsoft.Json; using UnityEngine; using DDCore; public class ServerBackendController : MonoBehaviour { [SerializeField] private string _version; private float REGISTRATION_COOLDOWN = 60f; private string SERVER_DATA_FILE = \"server-config.json\"; private bool _isOnline; public static ServerBackendController Instance { get; private set; } private Coroutine _serverRegistrationRoutine; public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); private string _className; private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); }else if (Instance != this){ Destroy(gameObject);} } public ServerData LoadDataFromFile() { string json = File.ReadAllText($\"{Application.streamingAssetsPath}/{SERVER_DATA_FILE}\"); ServerData serverData = JsonConvert.DeserializeObject<ServerData>(json); return serverData; } public void WriteDataToFile(string m_serverName, string m_description, string m_ip, ushort m_port, string m_version, int m_maxPlayers) { ServerData serverData; if (!File.Exists($\"{Application.streamingAssetsPath}/{SERVER_DATA_FILE}\")) { serverData = CreateFile(m_serverName, m_description, m_ip, m_port, m_version, m_maxPlayers); } else { string json = File.ReadAllText($\"{Application.streamingAssetsPath}/{SERVER_DATA_FILE}\"); serverData = JsonConvert.DeserializeObject<ServerData>(json); serverData.name = m_serverName; serverData.description = m_description; serverData.ip = m_ip; serverData.port = m_port; serverData.version = m_version; serverData.max_players = m_maxPlayers; json = JsonConvert.SerializeObject(serverData); File.WriteAllText($\"{Application.streamingAssetsPath}/{SERVER_DATA_FILE}\", json); } Debug.Log($\"[ServerBackendController] Server data updated. name: {serverData.name}, description: {serverData.description}, ip: {serverData.ip}, port: {serverData.port}, version: {serverData.version}, max_players: {serverData.max_players}\"); } private ServerData CreateFile(string m_serverName, string m_description, string m_ip, ushort m_port, string version, int maxPlayers) { var filePath = $\"{Application.streamingAssetsPath}/{SERVER_DATA_FILE}\"; ServerData serverData = new ServerData(); serverData.name = m_serverName; serverData.description = m_description; serverData.ip = m_ip; serverData.port = m_port; serverData.version = version; serverData.max_players = maxPlayers; string jsonToPut = JsonConvert.SerializeObject(serverData); File.WriteAllText(filePath, jsonToPut); return serverData; } public void UnregisterThisServer() { string serverJson = GetThisServerJdata(); BackendReadWrites.UnregisterServer(serverJson, ((exception, helper, result) => { Debug.Log($\"[ServerBackendController] Server unregistered with result: {result}\"); })); } public void StartServerRegistrationRoutine() { _serverRegistrationRoutine = StartCoroutine(ServerRegistrationRoutine()); } private IEnumerator ServerRegistrationRoutine() { var time = new WaitForSeconds(REGISTRATION_COOLDOWN); while (CustomServerManager.CurrentState == CustomServerManager.ServerState.WaitingForPlayers) { RegisterThisServer(); yield return time; } } public void RegisterThisServer() { var serverJson = GetThisServerJdata(); Debug.Log($\"{ClassName} [ServerBackendController] Registering server with json: {serverJson}\"); BackendReadWrites.RegisterServer(serverJson, ((exception, helper, result) => { Debug.Log($\"{ClassName} [ServerBackendController] Server registered with result: {result}\"); })); } private string GetThisServerJdata() { ServerData serverData = LoadDataFromFile(); serverData.version = _version == \"\" ? Application.version : _version; serverData.players = InstanceFinder.ServerManager.Clients.Count; serverData.max_players = InstanceFinder.NetworkManager.TransportManager.Transport.GetMaximumClients(); //serverData.port = InstanceFinder.NetworkManager.TransportManager.Transport.GetPort(); string json = JsonConvert.SerializeObject(serverData); return json; } public void GetServerByVersion(string version, Action<string> jsonCallback) { BackendReadWrites.GetServersByVersion(version, ((exception, helper, result) => { Debug.Log($\"[ServerBackendController] GetServersByVersion: {result}\"); jsonCallback?.Invoke(result); })); } public void StopServerRegistrationRoutine() { if (_serverRegistrationRoutine != null) { StopCoroutine(_serverRegistrationRoutine); } UnregisterThisServer(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ServerBackendController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "ServerBackendController",
          "content": "using System; using System.Collections; using System.IO; using FishNet; using FishNet.Transporting; using Newtonsoft.Json; using UnityEngine; using DDCore; public class ServerBackendController : MonoBehaviour { [SerializeField] private string _version; private float REGISTRATION_COOLDOWN = 60f; private string SERVER_DATA_FILE = \"server-config.json\"; private bool _isOnline; public static ServerBackendController Instance { get; private set; } private Coroutine _serverRegistrationRoutine; public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); private string _className; private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); }else if (Instance != this){ Destroy(gameObject);} } public ServerData LoadDataFromFile() { string json = File.ReadAllText($\"{Application.streamingAssetsPath}/{SERVER_DATA_FILE}\"); ServerData serverData = JsonConvert.DeserializeObject<ServerData>(json); return serverData;  ",
          "content_tokens": 259,
          "embedding": []
        },
        {
          "cs_scriptfile": "ServerBackendController",
          "content": "public void WriteDataToFile(string m_serverName, string m_description, string m_ip, ushort m_port, string m_version, int m_maxPlayers) { ServerData serverData; if (!File.Exists($\"{Application.streamingAssetsPath}/{SERVER_DATA_FILE}\")) { serverData = CreateFile(m_serverName, m_description, m_ip, m_port, m_version, m_maxPlayers); } else { string json = File.ReadAllText($\"{Application.streamingAssetsPath}/{SERVER_DATA_FILE}\"); serverData = JsonConvert.DeserializeObject<ServerData>(json); serverData.name = m_serverName; serverData.description = m_description; serverData.ip = m_ip; serverData.port = m_port; serverData.version = m_version; serverData.max_players = m_maxPlayers; json = JsonConvert.SerializeObject(serverData); File.WriteAllText($\"{Application.streamingAssetsPath}/{SERVER_DATA_FILE}\", json); } Debug.Log($\"[ServerBackendController] Server data updated. name: {serverData.name}, description: {serverData.description}, ip: {serverData.ip}, port: {serverData.port}, version: {serverData.version}, max_players: {serverData.max_players}\"); } private ServerData CreateFile(string m_serverName, string m_description, string m_ip, ushort m_port, string version, int maxPlayers) { var filePath = $\"{Application.streamingAssetsPath}/{SERVER_DATA_FILE}\"; ServerData serverData = new ServerData(); serverData.name = m_serverName; serverData.description = m_description; serverData.ip = m_ip; serverData.port = m_port; serverData.version = version; serverData.max_players = maxPlayers; string jsonToPut = JsonConvert.SerializeObject(serverData); File.WriteAllText(filePath, jsonToPut); return serverData;  ",
          "content_tokens": 487,
          "embedding": []
        },
        {
          "cs_scriptfile": "ServerBackendController",
          "content": "public void UnregisterThisServer() { string serverJson = GetThisServerJdata(); BackendReadWrites.UnregisterServer(serverJson, ((exception, helper, result) => { Debug.Log($\"[ServerBackendController] Server unregistered with result: {result}\"); }));  public void StartServerRegistrationRoutine() { _serverRegistrationRoutine = StartCoroutine(ServerRegistrationRoutine()); } private IEnumerator ServerRegistrationRoutine() { var time = new WaitForSeconds(REGISTRATION_COOLDOWN); while (CustomServerManager.CurrentState == CustomServerManager.ServerState.WaitingForPlayers) { RegisterThisServer(); yield return time; }  ",
          "content_tokens": 153,
          "embedding": []
        },
        {
          "cs_scriptfile": "ServerBackendController",
          "content": "public void RegisterThisServer() { var serverJson = GetThisServerJdata(); Debug.Log($\"{ClassName} [ServerBackendController] Registering server with json: {serverJson}\"); BackendReadWrites.RegisterServer(serverJson, ((exception, helper, result) => { Debug.Log($\"{ClassName} [ServerBackendController] Server registered with result: {result}\"); }));  ",
          "content_tokens": 96,
          "embedding": []
        },
        {
          "cs_scriptfile": "ServerBackendController",
          "content": "private string GetThisServerJdata() { ServerData serverData = LoadDataFromFile(); serverData.version = _version == \"\" ? Application.version : _version; serverData.players = InstanceFinder.ServerManager.Clients.Count; serverData.max_players = InstanceFinder.NetworkManager.TransportManager.Transport.GetMaximumClients(); //serverData.port = InstanceFinder.NetworkManager.TransportManager.Transport.GetPort(); string json = JsonConvert.SerializeObject(serverData); return json;  public void GetServerByVersion(string version, Action<string> jsonCallback) { BackendReadWrites.GetServersByVersion(version, ((exception, helper, result) => { Debug.Log($\"[ServerBackendController] GetServersByVersion: {result}\"); jsonCallback?.Invoke(result); }));  ",
          "content_tokens": 199,
          "embedding": []
        },
        {
          "cs_scriptfile": "ServerBackendController",
          "content": "public void StopServerRegistrationRoutine() { if (_serverRegistrationRoutine != null) { StopCoroutine(_serverRegistrationRoutine);  UnregisterThisServer(); } }",
          "content_tokens": 36,
          "embedding": []
        }
      ],
      "length": 4465
    },
    {
      "filename": "ServerData",
      "content": "using System; using System.Collections; using System.Collections.Generic; using UnityEngine; [Serializable] public class ServerData { public string name; public string ip; public ushort port; public string description; public string version; public int players; public int max_players; public bool online; public DateTime last_update; public DateTime last_online; } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ServerData",
          "content": "using System; using System.Collections; using System.Collections.Generic; using UnityEngine; [Serializable] public class ServerData { public string name; public string ip; public ushort port; public string description; public string version; public int players; public int max_players; public bool online; public DateTime last_update; public DateTime last_online; }",
          "content_tokens": 81,
          "embedding": []
        }
      ],
      "length": 366
    },
    {
      "filename": "Buff",
      "content": "using System; using System.Collections; using System.Collections.Generic; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Object; using Invector; using UnityEngine; public abstract class Buff : NetworkBehaviour { public AbilityDefinition AbilityDefinition => _abilityDefinition; [SerializeField] protected AbilityDefinition _abilityDefinition; public BuffDefinition BuffDefinition => _buffDefinition; [SerializeField] protected BuffDefinition _buffDefinition; protected GameplayManager _gameplayManager; public bool IsStacking { get; protected set; } public Dictionary<int, List<BuffData>> ThisBuffsDictionary => _thisBuffsDictionary; protected Dictionary<int, List<BuffData>> _thisBuffsDictionary = new Dictionary<int, List<BuffData>>(); protected bool _isDebug = true; public Action<int, BuffType> OnBuffExpired; public enum BuffType { Poisoned, EnergyShield, Stun, Slow, Freezed, DivineShield, Burning, Regeneration, } public static int BuffTypeToAbilityId(BuffType buffType) { foreach (var buffs in AbilityManager.Instance.Buffs) { if (buffs.BuffDefinition.buffType == buffType) { return buffs.AbilityDefinition.Id; } } Debug.LogError($\"[Buff] BuffTypeToAbilityId: Ability not found for {buffType}\"); return -1; } public class BuffInfo { public int abilityId; public float FinishAtServerTime; [NonSerialized] public List<GameObject> SpawnedEffects = new(); public BuffInfo(){} } public void Init(GameplayManager gameplayManager) { _gameplayManager = gameplayManager; //TODO Preload effect DebugWrite.Log($\"[Buff][{_abilityDefinition.Name}] Initialized with Gameplay Manager\", gameObject, _isDebug); } [Server] public virtual void Activate(BuffData casterBuffData, int[] targetNetId, float duration = 1, vDamage damage = null) { StringBuilder sb = new StringBuilder($\"[Buff] Activate [{BuffDefinition.Name}] Caster id: {casterBuffData.ObjectId}->\"); var rankData = _abilityDefinition.RanksDatas[casterBuffData.Rank]; bool isHaveTargetNotCaster = rankData.targetEffectsApplied.Count > 0 && targetNetId.Length > 0; if (isHaveTargetNotCaster) { sb.Append($\"targetNetId({targetNetId.Length}x):\"); for (int i = 0; i < rankData.targetEffectsApplied.Count; i++) { for (int j = 0; j < targetNetId.Length; j++) { AddBuffToTarget(casterBuffData, targetNetId[j], duration); sb.Append($\"{targetNetId[j]};\"); } } } bool isSelfCast = rankData.casterEffectsApplied.Count > 0; if (isSelfCast) { sb.Append($\"selfcast\"); for (int j = 0; j < rankData.casterEffectsApplied.Count; j++) { AddBuffToTarget(casterBuffData, casterBuffData.ObjectId, duration); } } Debug.Log(sb); } public bool IsBuffedByCaster(int casterNetId, int targetNetId) { DebugWrite.Log($\"[Buff][{_abilityDefinition.Name}] Checking if target {targetNetId} is buffed by caster {casterNetId}\", gameObject, _isDebug); if (!ThisBuffsDictionary.ContainsKey(targetNetId)) return false; for (int i = 0; i < ThisBuffsDictionary[targetNetId].Count; i++) { if (ThisBuffsDictionary[targetNetId][i].ObjectId == casterNetId) return true; } return false; } protected virtual void AddBuffToTarget(BuffData casterBuffData, int targetNetId, float duration, vDamage damage = null) { Debug.Log($\"[Buff][{_abilityDefinition.Name}] Adding Buff to target {targetNetId} from caster {casterBuffData.ObjectId}\", gameObject); var targetUnitComps = _gameplayManager.GetUnitComponentsServerAndClient(targetNetId); BuffInfo buffInfo = new BuffInfo() { abilityId = casterBuffData.abilityId, FinishAtServerTime = GameplayManager.GetCurrentServerTime() + duration }; if (!ThisBuffsDictionary.ContainsKey(targetNetId)) { _thisBuffsDictionary.Add(targetNetId, new List<BuffData>(){casterBuffData}); targetUnitComps.BuffController.ActivateBuff(BuffDefinition.buffType, buffInfo); StartBuffTimer(casterBuffData, targetNetId, duration, damage); OnBuffApplied(targetNetId, casterBuffData); return; } bool wasBuffedButNowDontHaveThatBuff = ThisBuffsDictionary[targetNetId].Count == 0; if (wasBuffedButNowDontHaveThatBuff) { ApplyBuff(casterBuffData, targetNetId, duration, damage, targetUnitComps, buffInfo); return; } int existingCasterDataId = GetThisCasterData(casterBuffData.ObjectId, targetNetId); if (existingCasterDataId == -1) { ApplyBuff(casterBuffData, targetNetId, duration, damage, targetUnitComps, buffInfo); } else { BuffData existingCasterData = ThisBuffsDictionary[targetNetId][existingCasterDataId]; if (IsStacking) { existingCasterData.Value += casterBuffData.Value; if (damage != null) damage.damageValue = (int)existingCasterData.Value; } CancelPreviousBuff(existingCasterData); StartBuffTimer(existingCasterData, targetNetId, duration, damage); } } protected void ApplyBuff(BuffData casterBuffData, int targetNetId, float duration, vDamage damage, UnitComponents targetUnitComps, BuffInfo buffInfo) { BuffData casterData = CreateNewBuffData(casterBuffData); _thisBuffsDictionary[targetNetId].Add(casterData); targetUnitComps.BuffController.ActivateBuff(BuffDefinition.buffType, buffInfo); StartBuffTimer(casterData, targetNetId, duration, damage); OnBuffApplied(targetNetId, casterBuffData); } protected virtual void StartBuffTimer(BuffData casterData, int targetNetId, float duration, vDamage damage) { if (casterData == null) { DebugWrite.LogError($\"[Buff][{_abilityDefinition.Name}] casterData is null\", gameObject, _isDebug); return; } casterData.Timer = StartCoroutine(DamageTimer(casterData.ObjectId, targetNetId, duration, damage)); } protected virtual IEnumerator DamageTimer(int casterNetId, int targetNetId, float timeout, vDamage damage) { yield return new WaitForSeconds(timeout); RemoveBuff(casterNetId, targetNetId); } protected int GetThisCasterData(int casterNetId, int targetNetId) { List<BuffData> storedData = ThisBuffsDictionary[targetNetId]; int index = -1; for (int i = 0; i < storedData.Count; i++) { if (storedData[i].ObjectId == casterNetId) { index = i; break; } } return index; } public bool IsTargetBuffed(int targetNetId) { if (ThisBuffsDictionary.ContainsKey(targetNetId)) { if (ThisBuffsDictionary[targetNetId].Count > 0) { return true; } } return false; } public virtual vDamage GetTickDamage(UnitComponents casterUnit, BuffData casterData, vDamage.DamageType type) { vDamage damage = new vDamage(); damage.damageValue = (int)casterData.Value; damage.Sender = casterUnit.HealthController.transform; damage.senderNetworkObjectID = casterUnit.HealthController.NetworkObject.ObjectId; damage.type = type; return damage; } protected void CancelPreviousBuff(BuffData casterData) { StopCoroutine(casterData.Timer); casterData.Timer = null; } protected BuffData CreateNewBuffData(BuffData casterBuffData) { return new BuffData(casterBuffData.ObjectId, casterBuffData.Tag, casterBuffData.FinishAtServerTime, casterBuffData.abilityId, casterBuffData.Rank, casterBuffData.Timer, casterBuffData.Effect, casterBuffData.Value); } protected void DestroyBuff(int casterNetId, int targetNetId) { DebugWrite.Log($\"[Buff][{_abilityDefinition.Name}] Destroying Buff from target {targetNetId} from caster {casterNetId}\", gameObject, _isDebug); if (IsTargetBuffed(targetNetId)) { List<BuffData> storedData = ThisBuffsDictionary[targetNetId]; for (int i = 0; i < storedData.Count; i++) { if (storedData[i].ObjectId == casterNetId) { RemoveBuff(casterNetId, targetNetId); break; } } } } protected void RemoveBuff(int casterNetId, int targetNetId) { DebugWrite.Log($\"[Buff][{_abilityDefinition.Name}] Removing Buff from target {targetNetId} from caster {casterNetId}\", gameObject, _isDebug); if (HasOnlyOneBuffWithSameEffect(targetNetId)) { if (ThisBuffsDictionary[targetNetId].Count > 0) { if (ThisBuffsDictionary[targetNetId][0] != null) if (ThisBuffsDictionary[targetNetId][0].Effect != null) Destroy(ThisBuffsDictionary[targetNetId][0].Effect); } OnBuffFxExpired(targetNetId); } OnBuffExpired?.Invoke(targetNetId, BuffDefinition.buffType); _thisBuffsDictionary[targetNetId].RemoveAll(x => x.ObjectId == casterNetId); } protected virtual void OnBuffFxExpired(int targetNetId) { var unitComps = _gameplayManager.GetUnitComponentsServerAndClient(targetNetId); unitComps.BuffController.DeactivateBuff(BuffDefinition.buffType); DebugWrite.Log($\"Buff expired for target {targetNetId}\", gameObject, _isDebug); } protected virtual void OnBuffApplied(int targetNetId, BuffData casterBuffData) { DebugWrite.Log($\"Buff applied for target {targetNetId}\", gameObject, _isDebug); } protected bool HasOnlyOneBuffWithSameEffect(int targetNetId) { if (ThisBuffsDictionary[targetNetId].Count > 1) return false; return true; } public void SetAsStacking() { IsStacking = true; } public class BuffData { public int ObjectId; public float FinishAtServerTime; public int abilityId; public string Tag; public int Rank; [NonSerialized] public Coroutine Timer; [NonSerialized] public GameObject Effect; public float Value; public BuffData(int casterNetId, string tag) { ObjectId = casterNetId; Tag = tag; } public BuffData(int casterNetId, string tag, float finishAtServerTime, int abilityId, int rank, Coroutine timer, GameObject effect, float value) { ObjectId = casterNetId; Tag = tag; Rank = rank; this.abilityId = abilityId; Timer = timer; Effect = effect; Value = value; FinishAtServerTime = finishAtServerTime; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Buff",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "Buff",
          "content": "using System; using System.Collections; using System.Collections.Generic; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Object; using Invector; using UnityEngine; public abstract class Buff : NetworkBehaviour { public AbilityDefinition AbilityDefinition => _abilityDefinition; [SerializeField] protected AbilityDefinition _abilityDefinition; public BuffDefinition BuffDefinition => _buffDefinition; [SerializeField] protected BuffDefinition _buffDefinition; protected GameplayManager _gameplayManager; public bool IsStacking { get; protected set; } public Dictionary<int, List<BuffData>> ThisBuffsDictionary => _thisBuffsDictionary; protected Dictionary<int, List<BuffData>> _thisBuffsDictionary = new Dictionary<int, List<BuffData>>(); protected bool _isDebug = true; public Action<int, BuffType> OnBuffExpired; public enum BuffType { Poisoned, EnergyShield, Stun, Slow, Freezed, DivineShield, Burning, Regeneration, } public static int BuffTypeToAbilityId(BuffType buffType) { foreach (var buffs in AbilityManager.Instance.Buffs) { if (buffs.BuffDefinition.buffType == buffType) { return buffs.AbilityDefinition.Id; } } Debug.LogError($\"[Buff] BuffTypeToAbilityId: Ability not found for {buffType}\"); return -1; } public class BuffInfo { public int abilityId; public float FinishAtServerTime; [NonSerialized] public List<GameObject> SpawnedEffects = new(); public BuffInfo(){}  ",
          "content_tokens": 373,
          "embedding": []
        },
        {
          "cs_scriptfile": "Buff",
          "content": "public void Init(GameplayManager gameplayManager) { _gameplayManager = gameplayManager; //TODO Preload effect DebugWrite.Log($\"[Buff][{_abilityDefinition.Name}] Initialized with Gameplay Manager\", gameObject, _isDebug); } [Server] public virtual void Activate(BuffData casterBuffData, int[] targetNetId, float duration = 1, vDamage damage = null) { StringBuilder sb = new StringBuilder($\"[Buff] Activate [{BuffDefinition.Name}] Caster id: {casterBuffData.ObjectId}->\"); var rankData = _abilityDefinition.RanksDatas[casterBuffData.Rank]; bool isHaveTargetNotCaster = rankData.targetEffectsApplied.Count > 0 && targetNetId.Length > 0; if (isHaveTargetNotCaster) { sb.Append($\"targetNetId({targetNetId.Length}x):\"); for (int i = 0; i < rankData.targetEffectsApplied.Count; i++) { for (int j = 0; j < targetNetId.Length; j++) { AddBuffToTarget(casterBuffData, targetNetId[j], duration); sb.Append($\"{targetNetId[j]};\"); } } } bool isSelfCast = rankData.casterEffectsApplied.Count > 0; if (isSelfCast) { sb.Append($\"selfcast\"); for (int j = 0; j < rankData.casterEffectsApplied.Count; j++) { AddBuffToTarget(casterBuffData, casterBuffData.ObjectId, duration); } } Debug.Log(sb);  ",
          "content_tokens": 360,
          "embedding": []
        },
        {
          "cs_scriptfile": "Buff",
          "content": "public bool IsBuffedByCaster(int casterNetId, int targetNetId) { DebugWrite.Log($\"[Buff][{_abilityDefinition.Name}] Checking if target {targetNetId} is buffed by caster {casterNetId}\", gameObject, _isDebug); if (!ThisBuffsDictionary.ContainsKey(targetNetId)) return false; for (int i = 0; i < ThisBuffsDictionary[targetNetId].Count; i++) { if (ThisBuffsDictionary[targetNetId][i].ObjectId == casterNetId) return true; } return false; } protected virtual void AddBuffToTarget(BuffData casterBuffData, int targetNetId, float duration, vDamage damage = null) { Debug.Log($\"[Buff][{_abilityDefinition.Name}] Adding Buff to target {targetNetId} from caster {casterBuffData.ObjectId}\", gameObject); var targetUnitComps = _gameplayManager.GetUnitComponentsServerAndClient(targetNetId); BuffInfo buffInfo = new BuffInfo() { abilityId = casterBuffData.abilityId, FinishAtServerTime = GameplayManager.GetCurrentServerTime() + duration }; if (!ThisBuffsDictionary.ContainsKey(targetNetId)) { _thisBuffsDictionary.Add(targetNetId, new List<BuffData>(){casterBuffData}); targetUnitComps.BuffController.ActivateBuff(BuffDefinition.buffType, buffInfo); StartBuffTimer(casterBuffData, targetNetId, duration, damage); OnBuffApplied(targetNetId, casterBuffData); return; } bool wasBuffedButNowDontHaveThatBuff = ThisBuffsDictionary[targetNetId].Count == 0; if (wasBuffedButNowDontHaveThatBuff) { ApplyBuff(casterBuffData, targetNetId, duration, damage, targetUnitComps, buffInfo); return; } int existingCasterDataId = GetThisCasterData(casterBuffData.ObjectId, targetNetId); if (existingCasterDataId == -1) { ApplyBuff(casterBuffData, targetNetId, duration, damage, targetUnitComps, buffInfo); } else { BuffData existingCasterData = ThisBuffsDictionary[targetNetId][existingCasterDataId]; if (IsStacking) { existingCasterData.Value += casterBuffData.Value; if (damage != null) damage.damageValue = (int)existingCasterData.Value;  ",
          "content_tokens": 549,
          "embedding": []
        },
        {
          "cs_scriptfile": "Buff",
          "content": "CancelPreviousBuff(existingCasterData); StartBuffTimer(existingCasterData, targetNetId, duration, damage); }  ",
          "content_tokens": 30,
          "embedding": []
        },
        {
          "cs_scriptfile": "Buff",
          "content": "protected void ApplyBuff(BuffData casterBuffData, int targetNetId, float duration, vDamage damage, UnitComponents targetUnitComps, BuffInfo buffInfo) { BuffData casterData = CreateNewBuffData(casterBuffData); _thisBuffsDictionary[targetNetId].Add(casterData); targetUnitComps.BuffController.ActivateBuff(BuffDefinition.buffType, buffInfo); StartBuffTimer(casterData, targetNetId, duration, damage); OnBuffApplied(targetNetId, casterBuffData); } protected virtual void StartBuffTimer(BuffData casterData, int targetNetId, float duration, vDamage damage) { if (casterData == null) { DebugWrite.LogError($\"[Buff][{_abilityDefinition.Name}] casterData is null\", gameObject, _isDebug); return; } casterData.Timer = StartCoroutine(DamageTimer(casterData.ObjectId, targetNetId, duration, damage)); } protected virtual IEnumerator DamageTimer(int casterNetId, int targetNetId, float timeout, vDamage damage) { yield return new WaitForSeconds(timeout); RemoveBuff(casterNetId, targetNetId);  ",
          "content_tokens": 259,
          "embedding": []
        },
        {
          "cs_scriptfile": "Buff",
          "content": "protected int GetThisCasterData(int casterNetId, int targetNetId) { List<BuffData> storedData = ThisBuffsDictionary[targetNetId]; int index = -1; for (int i = 0; i < storedData.Count; i++) { if (storedData[i].ObjectId == casterNetId) { index = i; break; } } return index;  ",
          "content_tokens": 89,
          "embedding": []
        },
        {
          "cs_scriptfile": "Buff",
          "content": "public bool IsTargetBuffed(int targetNetId) { if (ThisBuffsDictionary.ContainsKey(targetNetId)) { if (ThisBuffsDictionary[targetNetId].Count > 0) { return true; } } return false; } public virtual vDamage GetTickDamage(UnitComponents casterUnit, BuffData casterData, vDamage.DamageType type) { vDamage damage = new vDamage(); damage.damageValue = (int)casterData.Value; damage.Sender = casterUnit.HealthController.transform; damage.senderNetworkObjectID = casterUnit.HealthController.NetworkObject.ObjectId; damage.type = type; return damage;  ",
          "content_tokens": 149,
          "embedding": []
        },
        {
          "cs_scriptfile": "Buff",
          "content": "protected void CancelPreviousBuff(BuffData casterData) { StopCoroutine(casterData.Timer); casterData.Timer = null; } protected BuffData CreateNewBuffData(BuffData casterBuffData) { return new BuffData(casterBuffData.ObjectId, casterBuffData.Tag, casterBuffData.FinishAtServerTime, casterBuffData.abilityId, casterBuffData.Rank, casterBuffData.Timer, casterBuffData.Effect, casterBuffData.Value);  ",
          "content_tokens": 104,
          "embedding": []
        },
        {
          "cs_scriptfile": "Buff",
          "content": "protected void DestroyBuff(int casterNetId, int targetNetId) { DebugWrite.Log($\"[Buff][{_abilityDefinition.Name}] Destroying Buff from target {targetNetId} from caster {casterNetId}\", gameObject, _isDebug); if (IsTargetBuffed(targetNetId)) { List<BuffData> storedData = ThisBuffsDictionary[targetNetId]; for (int i = 0; i < storedData.Count; i++) { if (storedData[i].ObjectId == casterNetId) { RemoveBuff(casterNetId, targetNetId); break; } } }  ",
          "content_tokens": 138,
          "embedding": []
        },
        {
          "cs_scriptfile": "Buff",
          "content": "protected void RemoveBuff(int casterNetId, int targetNetId) { DebugWrite.Log($\"[Buff][{_abilityDefinition.Name}] Removing Buff from target {targetNetId} from caster {casterNetId}\", gameObject, _isDebug); if (HasOnlyOneBuffWithSameEffect(targetNetId)) { if (ThisBuffsDictionary[targetNetId].Count > 0) { if (ThisBuffsDictionary[targetNetId][0] != null) if (ThisBuffsDictionary[targetNetId][0].Effect != null) Destroy(ThisBuffsDictionary[targetNetId][0].Effect);  ",
          "content_tokens": 142,
          "embedding": []
        },
        {
          "cs_scriptfile": "Buff",
          "content": "OnBuffFxExpired(targetNetId); } OnBuffExpired?.Invoke(targetNetId, BuffDefinition.buffType); _thisBuffsDictionary[targetNetId].RemoveAll(x => x.ObjectId == casterNetId); } protected virtual void OnBuffFxExpired(int targetNetId) { var unitComps = _gameplayManager.GetUnitComponentsServerAndClient(targetNetId); unitComps.BuffController.DeactivateBuff(BuffDefinition.buffType); DebugWrite.Log($\"Buff expired for target {targetNetId}\", gameObject, _isDebug); } protected virtual void OnBuffApplied(int targetNetId, BuffData casterBuffData) { DebugWrite.Log($\"Buff applied for target {targetNetId}\", gameObject, _isDebug);  ",
          "content_tokens": 181,
          "embedding": []
        },
        {
          "cs_scriptfile": "Buff",
          "content": "protected bool HasOnlyOneBuffWithSameEffect(int targetNetId) { if (ThisBuffsDictionary[targetNetId].Count > 1) return false; return true;  public void SetAsStacking() { IsStacking = true; } public class BuffData { public int ObjectId; public float FinishAtServerTime; public int abilityId; public string Tag; public int Rank; [NonSerialized] public Coroutine Timer; [NonSerialized] public GameObject Effect; public float Value; public BuffData(int casterNetId, string tag) { ObjectId = casterNetId; Tag = tag;  ",
          "content_tokens": 135,
          "embedding": []
        },
        {
          "cs_scriptfile": "Buff",
          "content": "public BuffData(int casterNetId, string tag, float finishAtServerTime, int abilityId, int rank, Coroutine timer, GameObject effect, float value) { ObjectId = casterNetId; Tag = tag; Rank = rank; this.abilityId = abilityId; Timer = timer; Effect = effect; Value = value; FinishAtServerTime = finishAtServerTime; } } }",
          "content_tokens": 86,
          "embedding": []
        }
      ],
      "length": 9260
    },
    {
      "filename": "BuffBreathOfFire",
      "content": "using System.Collections; public class BuffBreathOfFire : Buff { }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BuffBreathOfFire",
          "content": "using System.Collections; public class BuffBreathOfFire : Buff { }",
          "content_tokens": 17,
          "embedding": []
        }
      ],
      "length": 66
    },
    {
      "filename": "BuffCrystalNova",
      "content": "using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using Invector; using System; using System.Collections; using UnityEngine; public class BuffCrystalNova : Buff { [SerializeField] private Material _coldMat; private readonly float MOVEMENT_SLOW = 0.25f; private static Stat.STAT_TYPE STAT = Stat.STAT_TYPE.MOVEMENT_SPEED; private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Magic; [Server] public override void Activate(BuffData casterBuffData, int[] targetNetId, float duration = 1, vDamage damage = null) { Debug.Log($\"[Buff][{_abilityDefinition.Name}] Activating Buff with caster {casterBuffData.ObjectId} and targetNetId count {targetNetId.Length}\", gameObject); for (int i = 0; i < targetNetId.Length; i++) { GameplayManager.UnitComponents targetUnitComps = _gameplayManager.GetUnitComponentsServerAndClient(targetNetId[i]); if (targetUnitComps == null) { DebugWrite.LogError($\"[Buff][{_abilityDefinition.Name}] targetUnitComps is null\", gameObject, _isDebug); continue; } AddBuffToTarget(casterBuffData, targetNetId[i], duration, damage); } } protected override IEnumerator DamageTimer(int casterNetId, int targetNetId, float timeout, vDamage damage) { float timePassed = 0; int casterDataId = GetThisCasterData(casterNetId, targetNetId); if (casterDataId == -1) { Debug.LogError($\"[Buff][{_abilityDefinition.Name}] casterDataId is -1\", gameObject); yield break; } BuffData casterData = ThisBuffsDictionary[targetNetId][casterDataId]; var casterUnit = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); var targetHealth = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId).HealthController; if (damage == null) { damage = new vDamage(); damage.damageValue = (int)casterData.Value; damage.Sender = casterUnit.HealthController.transform; damage.senderNetworkObjectID = casterNetId; damage.receiver = targetHealth.transform; damage.type = DAMAGE_TYPE; } Debug.Log($\"[Buff][{_abilityDefinition.Name}] Starting Buff Timer for caster {casterNetId} and target {targetNetId} with timeout {timeout}\", gameObject); while (timePassed < timeout) { targetHealth.TakeDamage(damage); yield return new WaitForSeconds(.9f); timePassed += 1f; } RemoveBuff(casterNetId, targetNetId); } protected override void OnBuffFxExpired(int targetNetId) { base.OnBuffFxExpired(targetNetId); GameplayManager.UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); foreach (var mesh in unitComps.AIUnit.AIMeshes) { Material[] materials = mesh.materials; System.Array.Resize(ref materials, materials.Length - 1); mesh.materials = materials; } unitComps.StatsController.RemoveChanges(STAT, CombatEntityStat.From.Bonus, -MOVEMENT_SLOW); } protected override void OnBuffApplied(int targetNetId, BuffData casterData) { base.OnBuffApplied(targetNetId, casterData); GameplayManager.UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); foreach (var mesh in unitComps.AIUnit.AIMeshes) { Material[] materials = mesh.materials; System.Array.Resize(ref materials, materials.Length + 1); materials[materials.Length - 1] = _coldMat; mesh.materials = materials; } unitComps.StatsController.AddChanges(STAT, CombatEntityStat.From.Bonus, -MOVEMENT_SLOW); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BuffCrystalNova",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffCrystalNova",
          "content": "using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using Invector; using System; using System.Collections; using UnityEngine; public class BuffCrystalNova : Buff { [SerializeField] private Material _coldMat; private readonly float MOVEMENT_SLOW = 0.25f; private static Stat.STAT_TYPE STAT = Stat.STAT_TYPE.MOVEMENT_SPEED; private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Magic; [Server] public override void Activate(BuffData casterBuffData, int[] targetNetId, float duration = 1, vDamage damage = null) { Debug.Log($\"[Buff][{_abilityDefinition.Name}] Activating Buff with caster {casterBuffData.ObjectId} and targetNetId count {targetNetId.Length}\", gameObject); for (int i = 0; i < targetNetId.Length; i++) { GameplayManager.UnitComponents targetUnitComps = _gameplayManager.GetUnitComponentsServerAndClient(targetNetId[i]); if (targetUnitComps == null) { DebugWrite.LogError($\"[Buff][{_abilityDefinition.Name}] targetUnitComps is null\", gameObject, _isDebug); continue;  ",
          "content_tokens": 295,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffCrystalNova",
          "content": "AddBuffToTarget(casterBuffData, targetNetId[i], duration, damage); } } protected override IEnumerator DamageTimer(int casterNetId, int targetNetId, float timeout, vDamage damage) { float timePassed = 0; int casterDataId = GetThisCasterData(casterNetId, targetNetId); if (casterDataId == -1) { Debug.LogError($\"[Buff][{_abilityDefinition.Name}] casterDataId is -1\", gameObject); yield break; } BuffData casterData = ThisBuffsDictionary[targetNetId][casterDataId]; var casterUnit = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); var targetHealth = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId).HealthController; if (damage == null) { damage = new vDamage(); damage.damageValue = (int)casterData.Value; damage.Sender = casterUnit.HealthController.transform; damage.senderNetworkObjectID = casterNetId; damage.receiver = targetHealth.transform; damage.type = DAMAGE_TYPE; } Debug.Log($\"[Buff][{_abilityDefinition.Name}] Starting Buff Timer for caster {casterNetId} and target {targetNetId} with timeout {timeout}\", gameObject); while (timePassed < timeout) { targetHealth.TakeDamage(damage); yield return new WaitForSeconds(.9f); timePassed += 1f;  ",
          "content_tokens": 331,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffCrystalNova",
          "content": "RemoveBuff(casterNetId, targetNetId); } protected override void OnBuffFxExpired(int targetNetId) { base.OnBuffFxExpired(targetNetId); GameplayManager.UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); foreach (var mesh in unitComps.AIUnit.AIMeshes) { Material[] materials = mesh.materials; System.Array.Resize(ref materials, materials.Length - 1); mesh.materials = materials; } unitComps.StatsController.RemoveChanges(STAT, CombatEntityStat.From.Bonus, -MOVEMENT_SLOW); } protected override void OnBuffApplied(int targetNetId, BuffData casterData) { base.OnBuffApplied(targetNetId, casterData); GameplayManager.UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); foreach (var mesh in unitComps.AIUnit.AIMeshes) { Material[] materials = mesh.materials; System.Array.Resize(ref materials, materials.Length + 1); materials[materials.Length - 1] = _coldMat; mesh.materials = materials; } unitComps.StatsController.AddChanges(STAT, CombatEntityStat.From.Bonus, -MOVEMENT_SLOW); } }",
          "content_tokens": 309,
          "embedding": []
        }
      ],
      "length": 3316
    },
    {
      "filename": "BuffDefinition",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; [CreateAssetMenu(fileName = \"New Buff\", menuName = \"ScriptableObjects/Buff\")] public class BuffDefinition : ScriptableObject { public int effectID = -1; public Buff.BuffType buffType; public string Name; public string Description; public Sprite Icon; public List<AttachmentPoints.Point> EffectAttachmentPoints; public AudioClip Sound; public GameObject EffectPrefab; public float chance = 100f; public int effectRank; public bool isSpread; public float spreadDistanceMax; public int spreadUnitMax; public float delay; public string tooltipText; } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BuffDefinition",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; [CreateAssetMenu(fileName = \"New Buff\", menuName = \"ScriptableObjects/Buff\")] public class BuffDefinition : ScriptableObject { public int effectID = -1; public Buff.BuffType buffType; public string Name; public string Description; public Sprite Icon; public List<AttachmentPoints.Point> EffectAttachmentPoints; public AudioClip Sound; public GameObject EffectPrefab; public float chance = 100f; public int effectRank; public bool isSpread; public float spreadDistanceMax; public int spreadUnitMax; public float delay; public string tooltipText; }",
          "content_tokens": 145,
          "embedding": []
        }
      ],
      "length": 626
    },
    {
      "filename": "BuffDivineShield",
      "content": "using System; using System.Collections.Generic; public class BuffDivineShield : Buff { private Action<float> _onAbsorbtionsCountChanged; private Stat.STAT_TYPE _buffStatType = Stat.STAT_TYPE.ABILITY_ENERGY_SHIELD_ABSORBTIONS; private Dictionary<int, bool> _isSubscriptionActive = new Dictionary<int, bool>(); public static BuffDivineShield Instance { get; private set; } private void Awake() { Instance = this; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BuffDivineShield",
          "content": "using System; using System.Collections.Generic; public class BuffDivineShield : Buff { private Action<float> _onAbsorbtionsCountChanged; private Stat.STAT_TYPE _buffStatType = Stat.STAT_TYPE.ABILITY_ENERGY_SHIELD_ABSORBTIONS; private Dictionary<int, bool> _isSubscriptionActive = new Dictionary<int, bool>(); public static BuffDivineShield Instance { get; private set; } private void Awake() { Instance = this; } }",
          "content_tokens": 116,
          "embedding": []
        }
      ],
      "length": 414
    },
    {
      "filename": "BuffEnergyShield",
      "content": "using System; using System.Collections.Generic; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using Invector; public class BuffEnergyShield : Buff { private Action<float> _onAbsorbtionsCountChanged; private Stat.STAT_TYPE _buffStatType = Stat.STAT_TYPE.ABILITY_ENERGY_SHIELD_ABSORBTIONS; private Dictionary<int, bool> _isSubscriptionActive = new Dictionary<int, bool>(); [Server] public override void Activate(BuffData casterBuffData, int[] targetNetId, float duration = 0, vDamage damage = null) { base.Activate(casterBuffData, targetNetId, duration); var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterBuffData.ObjectId); _onAbsorbtionsCountChanged = value => OnAbsorbtionsCountChanged(casterBuffData.ObjectId, value); if (IsCasterAlreadySubscribed(casterBuffData.ObjectId)) { DebugWrite.Log($\"[BuffEnergyShield][Activate] caster {casterBuffData.ObjectId} already subscribed to {_buffStatType}.\"); return; } else { unitComps.StatsController.GetStatByType(_buffStatType).OnStatChanged += _onAbsorbtionsCountChanged; SetCasterSubscription(casterBuffData.ObjectId, true); } } private bool IsCasterAlreadySubscribed(int casterNetId) { if (_isSubscriptionActive.ContainsKey(casterNetId)) { return _isSubscriptionActive[casterNetId]; } return false; } private void SetCasterSubscription(int casterNetId, bool isActive) { if (_isSubscriptionActive.ContainsKey(casterNetId)) { _isSubscriptionActive[casterNetId] = isActive; } else { _isSubscriptionActive.Add(casterNetId, isActive); } } protected override void OnBuffFxExpired(int targetNetId) { base.OnBuffFxExpired(targetNetId); if (base.IsServer) { StringBuilder sb = new StringBuilder(); var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); sb.Append($\"[BuffEnergyShield][OnBuffFxExpired] unit {unitComps.HealthController}; before: {unitComps.StatsController.GetAllCurrentValue(_buffStatType)}\"); if (_onAbsorbtionsCountChanged != null) { unitComps.StatsController.GetStatByType(_buffStatType).OnStatChanged -= _onAbsorbtionsCountChanged; SetCasterSubscription(targetNetId, false); } unitComps.StatsController.RemoveChangesFrom(_buffStatType, CombatEntityStat.From.Timed); sb.Append($\"; after: {unitComps.StatsController.GetAllCurrentValue(_buffStatType)}\"); DebugWrite.Log($\"[BuffEnergyShield][OnBuffFxExpired] {sb}\", unitComps.StatsController.gameObject, _isDebug); } } private void OnAbsorbtionsCountChanged(int casterNetId, float absorbtionsLeft) { if (absorbtionsLeft <= 0) { DestroyBuff(casterNetId, casterNetId); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BuffEnergyShield",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffEnergyShield",
          "content": "using System; using System.Collections.Generic; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using Invector; public class BuffEnergyShield : Buff { private Action<float> _onAbsorbtionsCountChanged; private Stat.STAT_TYPE _buffStatType = Stat.STAT_TYPE.ABILITY_ENERGY_SHIELD_ABSORBTIONS; private Dictionary<int, bool> _isSubscriptionActive = new Dictionary<int, bool>(); [Server] public override void Activate(BuffData casterBuffData, int[] targetNetId, float duration = 0, vDamage damage = null) { base.Activate(casterBuffData, targetNetId, duration); var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterBuffData.ObjectId); _onAbsorbtionsCountChanged = value => OnAbsorbtionsCountChanged(casterBuffData.ObjectId, value); if (IsCasterAlreadySubscribed(casterBuffData.ObjectId)) { DebugWrite.Log($\"[BuffEnergyShield][Activate] caster {casterBuffData.ObjectId} already subscribed to {_buffStatType}.\"); return; } else { unitComps.StatsController.GetStatByType(_buffStatType).OnStatChanged += _onAbsorbtionsCountChanged; SetCasterSubscription(casterBuffData.ObjectId, true); }  ",
          "content_tokens": 341,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffEnergyShield",
          "content": "private bool IsCasterAlreadySubscribed(int casterNetId) { if (_isSubscriptionActive.ContainsKey(casterNetId)) { return _isSubscriptionActive[casterNetId]; } return false;  ",
          "content_tokens": 48,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffEnergyShield",
          "content": "private void SetCasterSubscription(int casterNetId, bool isActive) { if (_isSubscriptionActive.ContainsKey(casterNetId)) { _isSubscriptionActive[casterNetId] = isActive; } else { _isSubscriptionActive.Add(casterNetId, isActive); } } protected override void OnBuffFxExpired(int targetNetId) { base.OnBuffFxExpired(targetNetId); if (base.IsServer) { StringBuilder sb = new StringBuilder(); var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); sb.Append($\"[BuffEnergyShield][OnBuffFxExpired] unit {unitComps.HealthController}; before: {unitComps.StatsController.GetAllCurrentValue(_buffStatType)}\"); if (_onAbsorbtionsCountChanged != null) { unitComps.StatsController.GetStatByType(_buffStatType).OnStatChanged -= _onAbsorbtionsCountChanged; SetCasterSubscription(targetNetId, false); } unitComps.StatsController.RemoveChangesFrom(_buffStatType, CombatEntityStat.From.Timed); sb.Append($\"; after: {unitComps.StatsController.GetAllCurrentValue(_buffStatType)}\"); DebugWrite.Log($\"[BuffEnergyShield][OnBuffFxExpired] {sb}\", unitComps.StatsController.gameObject, _isDebug); }  ",
          "content_tokens": 328,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffEnergyShield",
          "content": "private void OnAbsorbtionsCountChanged(int casterNetId, float absorbtionsLeft) { if (absorbtionsLeft <= 0) { DestroyBuff(casterNetId, casterNetId); } } }",
          "content_tokens": 45,
          "embedding": []
        }
      ],
      "length": 2649
    },
    {
      "filename": "BuffFrostNova",
      "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; public class BuffFrostNova : Buff { private static Stat.STAT_TYPE STAT = Stat.STAT_TYPE.MOVEMENT_SPEED; protected override void OnBuffFxExpired(int targetNetId) { base.OnBuffFxExpired(targetNetId); UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); unitComps.StatsController.RemoveSingleChange(STAT, CombatEntityStat.From.Bonus, -1); } protected override void OnBuffApplied(int targetNetId, BuffData casterData) { base.OnBuffApplied(targetNetId, casterData); UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); unitComps.StatsController.AddChanges(STAT, CombatEntityStat.From.Bonus, -1); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BuffFrostNova",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffFrostNova",
          "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; public class BuffFrostNova : Buff { private static Stat.STAT_TYPE STAT = Stat.STAT_TYPE.MOVEMENT_SPEED; protected override void OnBuffFxExpired(int targetNetId) { base.OnBuffFxExpired(targetNetId); UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); unitComps.StatsController.RemoveSingleChange(STAT, CombatEntityStat.From.Bonus, -1); } protected override void OnBuffApplied(int targetNetId, BuffData casterData) { base.OnBuffApplied(targetNetId, casterData); UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); unitComps.StatsController.AddChanges(STAT, CombatEntityStat.From.Bonus, -1); } }",
          "content_tokens": 224,
          "embedding": []
        }
      ],
      "length": 776
    },
    {
      "filename": "BuffPoisoned",
      "content": "using System; using System.Collections; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Object; using Invector; using UnityEngine; public class BuffPoisoned : Buff { private static Stat.STAT_TYPE STAT = Stat.STAT_TYPE.POISONED; private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.Wisdom; private readonly float BASE_DAMAGE_PER_TICK = 1f; private readonly float BASE_DURATION = 5f; private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Poison; protected override void OnBuffFxExpired(int targetNetId) { base.OnBuffFxExpired(targetNetId); UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); //unitComps.StatsController.RemoveSingleChange(STAT, CombatEntityStat.From.Bonus, -1); } private float CalculateTickDamage(float wisdom) { return BASE_DAMAGE_PER_TICK + wisdom * .1f; } [Server] public override void Activate(BuffData casterBuffData, int[] targetNetId, float duration = 1, vDamage damage = null) { Debug.Log($\"[Buff][{_abilityDefinition.Name}] Activating Buff with caster {casterBuffData.ObjectId} and targetNetId count {targetNetId.Length}\", gameObject); for (int i = 0; i < targetNetId.Length; i++) { UnitComponents targetUnitComps = _gameplayManager.GetUnitComponentsServerAndClient(targetNetId[i]); if (targetUnitComps == null) { DebugWrite.LogError($\"[Buff][{_abilityDefinition.Name}] targetUnitComps is null\", gameObject, _isDebug); continue; } AddBuffToTarget(casterBuffData, targetNetId[i], duration, damage); } } protected override IEnumerator DamageTimer(int casterNetId, int targetNetId, float timeout, vDamage damage) { float timePassed = 0; int casterDataId = GetThisCasterData(casterNetId, targetNetId); if (casterDataId == -1) { Debug.LogError($\"[Buff][{_abilityDefinition.Name}] casterDataId is -1\", gameObject); yield break; } BuffData casterData = ThisBuffsDictionary[targetNetId][casterDataId]; var casterUnit = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); var targetHealth = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId).HealthController; if (damage == null) { damage = new vDamage(); damage.damageValue = (int)casterData.Value; damage.Sender = casterUnit.HealthController.transform; damage.senderNetworkObjectID = casterNetId; damage.receiver = targetHealth.transform; damage.type = DAMAGE_TYPE; } Debug.Log($\"[Buff][{_abilityDefinition.Name}] Starting Buff Timer for caster {casterNetId} and target {targetNetId} with timeout {timeout}\", gameObject); while (timePassed < timeout) { targetHealth.TakeDamage(damage); yield return new WaitForSeconds(.9f); timePassed += 1f; } RemoveBuff(casterNetId, targetNetId); } protected override void OnBuffApplied(int targetNetId, BuffData casterData) { base.OnBuffApplied(targetNetId, casterData); UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); //TODO remove this because logic was changed unitComps.StatsController.AddChanges(STAT, CombatEntityStat.From.Bonus, -1); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BuffPoisoned",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffPoisoned",
          "content": "using System; using System.Collections; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Object; using Invector; using UnityEngine; public class BuffPoisoned : Buff { private static Stat.STAT_TYPE STAT = Stat.STAT_TYPE.POISONED; private readonly Stat.STAT_TYPE AFFECTING_STAT = Stat.STAT_TYPE.Wisdom; private readonly float BASE_DAMAGE_PER_TICK = 1f; private readonly float BASE_DURATION = 5f; private readonly vDamage.DamageType DAMAGE_TYPE = vDamage.DamageType.Poison; protected override void OnBuffFxExpired(int targetNetId) { base.OnBuffFxExpired(targetNetId); UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); //unitComps.StatsController.RemoveSingleChange(STAT, CombatEntityStat.From.Bonus, -1);  ",
          "content_tokens": 249,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffPoisoned",
          "content": "private float CalculateTickDamage(float wisdom) { return BASE_DAMAGE_PER_TICK + wisdom * .1f; } [Server] public override void Activate(BuffData casterBuffData, int[] targetNetId, float duration = 1, vDamage damage = null) { Debug.Log($\"[Buff][{_abilityDefinition.Name}] Activating Buff with caster {casterBuffData.ObjectId} and targetNetId count {targetNetId.Length}\", gameObject); for (int i = 0; i < targetNetId.Length; i++) { UnitComponents targetUnitComps = _gameplayManager.GetUnitComponentsServerAndClient(targetNetId[i]); if (targetUnitComps == null) { DebugWrite.LogError($\"[Buff][{_abilityDefinition.Name}] targetUnitComps is null\", gameObject, _isDebug); continue;  ",
          "content_tokens": 197,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffPoisoned",
          "content": "AddBuffToTarget(casterBuffData, targetNetId[i], duration, damage); } } protected override IEnumerator DamageTimer(int casterNetId, int targetNetId, float timeout, vDamage damage) { float timePassed = 0; int casterDataId = GetThisCasterData(casterNetId, targetNetId); if (casterDataId == -1) { Debug.LogError($\"[Buff][{_abilityDefinition.Name}] casterDataId is -1\", gameObject); yield break; } BuffData casterData = ThisBuffsDictionary[targetNetId][casterDataId]; var casterUnit = GameplayManager.Instance.GetUnitComponentsServerAndClient(casterNetId); var targetHealth = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId).HealthController; if (damage == null) { damage = new vDamage(); damage.damageValue = (int)casterData.Value; damage.Sender = casterUnit.HealthController.transform; damage.senderNetworkObjectID = casterNetId; damage.receiver = targetHealth.transform; damage.type = DAMAGE_TYPE; } Debug.Log($\"[Buff][{_abilityDefinition.Name}] Starting Buff Timer for caster {casterNetId} and target {targetNetId} with timeout {timeout}\", gameObject); while (timePassed < timeout) { targetHealth.TakeDamage(damage); yield return new WaitForSeconds(.9f); timePassed += 1f;  ",
          "content_tokens": 331,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffPoisoned",
          "content": "RemoveBuff(casterNetId, targetNetId); } protected override void OnBuffApplied(int targetNetId, BuffData casterData) { base.OnBuffApplied(targetNetId, casterData); UnitComponents unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); //TODO remove this because logic was changed unitComps.StatsController.AddChanges(STAT, CombatEntityStat.From.Bonus, -1); } }",
          "content_tokens": 105,
          "embedding": []
        }
      ],
      "length": 3110
    },
    {
      "filename": "BuffRegeneration",
      "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using DarkTonic.MasterAudio; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using FishnetInvector; using Invector; using UnityEngine; public class BuffRegeneration : Buff { public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); private string _className; [Server] public override void Activate(BuffData casterBuffData, int[] targetNetId, float duration = 1, vDamage damage = null) { Debug.Log($\"[{ClassName}][{_abilityDefinition.Name}] Activate caster #{casterBuffData.ObjectId}\", gameObject); damage = new vDamage(); damage.damageValue = (int)casterBuffData.Value; AddBuffToTarget(casterBuffData, casterBuffData.ObjectId, duration, damage); } protected override IEnumerator DamageTimer(int casterNetId, int targetNetId, float timeout, vDamage damage) { var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); if (unitComps == null) yield break; if (unitComps.HealthController.IsDead) yield break; float tickCooldown = Regeneration.CalcTickCooldown(unitComps.StatsController); int ticks = (int)(timeout / tickCooldown); for (int i = 0; i < ticks; i++) { if (DoHeal(casterNetId, targetNetId, damage, unitComps)) yield break; yield return new WaitForSeconds(tickCooldown); } if (DoHeal(casterNetId, targetNetId, damage, unitComps)) yield break; RemoveBuff(casterNetId, targetNetId); } private bool DoHeal(int casterNetId, int targetNetId, vDamage damage, UnitComponents unitComps) { if (unitComps == null || unitComps.HealthController == null) return true; if (unitComps.HealthController.IsDead) { RemoveBuff(casterNetId, targetNetId); return true; } var healData = new FishnetInvectorHealthController.HealData(); healData.abilityId = _abilityDefinition.Id; healData.amount = damage.damageValue; unitComps.HealthController.Heal(healData); return false; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BuffRegeneration",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffRegeneration",
          "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using DarkTonic.MasterAudio; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using FishnetInvector; using Invector; using UnityEngine; public class BuffRegeneration : Buff { public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); private string _className; [Server] public override void Activate(BuffData casterBuffData, int[] targetNetId, float duration = 1, vDamage damage = null) { Debug.Log($\"[{ClassName}][{_abilityDefinition.Name}] Activate caster #{casterBuffData.ObjectId}\", gameObject); damage = new vDamage(); damage.damageValue = (int)casterBuffData.Value; AddBuffToTarget(casterBuffData, casterBuffData.ObjectId, duration, damage); } protected override IEnumerator DamageTimer(int casterNetId, int targetNetId, float timeout, vDamage damage) { var unitComps = GameplayManager.Instance.GetUnitComponentsServerAndClient(targetNetId); if (unitComps == null) yield break; if (unitComps.HealthController.IsDead) yield break; float tickCooldown = Regeneration.CalcTickCooldown(unitComps.StatsController); int ticks = (int)(timeout / tickCooldown); for (int i = 0; i < ticks; i++) { if (DoHeal(casterNetId, targetNetId, damage, unitComps)) yield break; yield return new WaitForSeconds(tickCooldown);  ",
          "content_tokens": 373,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffRegeneration",
          "content": "if (DoHeal(casterNetId, targetNetId, damage, unitComps)) yield break; RemoveBuff(casterNetId, targetNetId);  private bool DoHeal(int casterNetId, int targetNetId, vDamage damage, UnitComponents unitComps) { if (unitComps == null || unitComps.HealthController == null) return true; if (unitComps.HealthController.IsDead) { RemoveBuff(casterNetId, targetNetId); return true; } var healData = new FishnetInvectorHealthController.HealData(); healData.abilityId = _abilityDefinition.Id; healData.amount = damage.damageValue; unitComps.HealthController.Heal(healData); return false; } }",
          "content_tokens": 168,
          "embedding": []
        }
      ],
      "length": 1941
    },
    {
      "filename": "CameraShake",
      "content": "using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishnetInvector; using Invector; using Invector.vCharacterController; using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using UnityEngine; public class CameraShake : MonoBehaviour { [SerializeField] private float duration = 0.2f; [SerializeField] private float maxShakeDuration = 1.0f; [SerializeField] private AnimationCurve shakeIntensityCurve; [SerializeField] private AnimationCurve shakeFrequencyCurve; [SerializeField] private float maxRotationAmount = 10.0f; private Quaternion originalCameraRotation; void Start() { // StartCoroutine(SignEvent()); originalCameraRotation = transform.localRotation; } IEnumerator SignEvent() { yield return new WaitUntil(() => GameplayManager.Instance.GetUnitComponents(GameplayManager.Instance.MalePrefab) != null); var unit = GameplayManager.Instance.GetUnitComponents(GameplayManager.Instance.MalePrefab); yield return new WaitUntil(() => unit.HealthController.FNvHealthController != null); // unit.HealthController.IsClientInitialized // unit.HealthController.FNvHealthController.onReceiveDamage.AddListener(Shake); } // Coroutine for camera shake IEnumerator ShakeCoroutine(float duration) { float elapsed = 0.0f; while (elapsed < duration) { // Calculate shake intensity and frequency based on curves float intensity = shakeIntensityCurve.Evaluate(elapsed / duration); float frequency = shakeFrequencyCurve.Evaluate(elapsed / duration); // Calculate random rotation Quaternion randomRotation = Quaternion.Euler(Random.insideUnitSphere * maxRotationAmount * intensity); // Update camera rotation with random rotation transform.localRotation = originalCameraRotation * randomRotation; // Increase elapsed time elapsed += Time.deltaTime * frequency; yield return null; } // Reset camera rotation when shake is finished transform.localRotation = originalCameraRotation; } // Public method to trigger camera shake public void Shake() { StartCoroutine(ShakeCoroutine(Mathf.Min(duration, maxShakeDuration))); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CameraShake",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "CameraShake",
          "content": "using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishnetInvector; using Invector; using Invector.vCharacterController; using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using UnityEngine; public class CameraShake : MonoBehaviour { [SerializeField] private float duration = 0.2f; [SerializeField] private float maxShakeDuration = 1.0f; [SerializeField] private AnimationCurve shakeIntensityCurve; [SerializeField] private AnimationCurve shakeFrequencyCurve; [SerializeField] private float maxRotationAmount = 10.0f; private Quaternion originalCameraRotation; void Start() { // StartCoroutine(SignEvent()); originalCameraRotation = transform.localRotation; } IEnumerator SignEvent() { yield return new WaitUntil(() => GameplayManager.Instance.GetUnitComponents(GameplayManager.Instance.MalePrefab) != null); var unit = GameplayManager.Instance.GetUnitComponents(GameplayManager.Instance.MalePrefab); yield return new WaitUntil(() => unit.HealthController.FNvHealthController != null); // unit.HealthController.IsClientInitialized // unit.HealthController.FNvHealthController.onReceiveDamage.AddListener(Shake); } // Coroutine for camera shake IEnumerator ShakeCoroutine(float duration) { float elapsed = 0.0f; while (elapsed < duration) { // Calculate shake intensity and frequency based on curves float intensity = shakeIntensityCurve.Evaluate(elapsed / duration); float frequency = shakeFrequencyCurve.Evaluate(elapsed / duration); // Calculate random rotation Quaternion randomRotation = Quaternion.Euler(Random.insideUnitSphere * maxRotationAmount * intensity); // Update camera rotation with random rotation transform.localRotation = originalCameraRotation * randomRotation; // Increase elapsed time elapsed += Time.deltaTime * frequency; yield return null; } // Reset camera rotation when shake is finished transform.localRotation = originalCameraRotation; } // Public method to trigger camera shake public void Shake() { StartCoroutine(ShakeCoroutine(Mathf.Min(duration, maxShakeDuration))); } }",
          "content_tokens": 510,
          "embedding": []
        }
      ],
      "length": 2058
    },
    {
      "filename": "CharacterSelectionHairGroup",
      "content": "using Character; using DungeonScrollerCore; using UnityEngine; using UnityEngine.UI; public class CharacterSelectionHairGroup : MonoBehaviour { [SerializeField] private CharacterSkin _characterSkin; [SerializeField] private Button _buttonPrefab; private void Awake() { _characterSkin.OnInitialized += Init; } private void Init() { for (int i = 0; i < _characterSkin.allGender.all_Hair.Count; i++) { int tempId = i; var newButton = Instantiate(_buttonPrefab, transform); newButton.GetComponentInChildren<TMProDecorator>().SetText(i.ToString()); newButton.onClick.AddListener(() => _characterSkin.SetHair(tempId)); newButton.name = $\"Hair {i}\"; } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharacterSelectionHairGroup",
          "content": "using Character; using DungeonScrollerCore; using UnityEngine; using UnityEngine.UI; public class CharacterSelectionHairGroup : MonoBehaviour { [SerializeField] private CharacterSkin _characterSkin; [SerializeField] private Button _buttonPrefab; private void Awake() { _characterSkin.OnInitialized += Init; } private void Init() { for (int i = 0; i < _characterSkin.allGender.all_Hair.Count; i++) { int tempId = i; var newButton = Instantiate(_buttonPrefab, transform); newButton.GetComponentInChildren<TMProDecorator>().SetText(i.ToString()); newButton.onClick.AddListener(() => _characterSkin.SetHair(tempId)); newButton.name = $\"Hair {i}\"; } } }",
          "content_tokens": 183,
          "embedding": []
        }
      ],
      "length": 649
    },
    {
      "filename": "CharacterSkinData",
      "content": "using System; [Serializable] public class CharacterSkinData { public int Id; public int genderId; public int skinColorId; public int beardId; public int bodyArtId; public int faceId; public int hairId; public int hairColorId; public enum Gender {Male, Female} public CharacterSkinData() { genderId = 0; skinColorId = 0; beardId = 0; bodyArtId = 0; faceId = 0; hairId = 0; hairColorId = 0; } public CharacterSkinData(int gender, int hair, int beard, int skin) { genderId = gender; hairId = hair; beardId = beard; skinColorId = skin; bodyArtId = 0; faceId = 0; hairColorId = 0; } public string ToString() { string result = $\"Id: {Id}; genderId: {genderId}; skinColorId: {skinColorId}; beardId: {beardId}; bodyArtId: {bodyArtId}; faceId: {faceId}; hairId: {hairId}; hairColorId: {hairColorId}\"; return result; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharacterSkinData",
          "content": "using System; [Serializable] public class CharacterSkinData { public int Id; public int genderId; public int skinColorId; public int beardId; public int bodyArtId; public int faceId; public int hairId; public int hairColorId; public enum Gender {Male, Female}public CharacterSkinData() { genderId = 0; skinColorId = 0; beardId = 0; bodyArtId = 0; faceId = 0; hairId = 0; hairColorId = 0;  public CharacterSkinData(int gender, int hair, int beard, int skin) { genderId = gender; hairId = hair; beardId = beard; skinColorId = skin; bodyArtId = 0; faceId = 0; hairColorId = 0;  ",
          "content_tokens": 166,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkinData",
          "content": "public string ToString() { string result = $\"Id: {Id}; genderId: {genderId}; skinColorId: {skinColorId}; beardId: {beardId}; bodyArtId: {bodyArtId}; faceId: {faceId}; hairId: {hairId}; hairColorId: {hairColorId}\"; return result; } }",
          "content_tokens": 77,
          "embedding": []
        }
      ],
      "length": 811
    },
    {
      "filename": "CharCreatorSceneLoader",
      "content": "using System; using UnityEngine; using UnityEngine.SceneManagement; public class CharCreatorSceneLoader : MonoBehaviour { private string CHARACTER_CREATION_SCENE_NAME = \"CharacterCreation Stylized\"; public static CharCreatorSceneLoader Instance { get; private set; } public static Action OnCharCreationSceneLoaded; private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); }else if (Instance != this) { Destroy(gameObject); } BackendReadWrites.OnCharacterCreated += OnCharacterCreated; } private void OnCharacterCreated(CharacterSkinData obj) { UnloadCharacterCreationScene(); } public void LoadCharacterCreationScene() { Debug.Log(\"Loading character creation scene\"); SceneManager.LoadScene(CHARACTER_CREATION_SCENE_NAME, LoadSceneMode.Additive); } public void UnloadCharacterCreationScene() { Debug.Log(\"Unloading character creation scene\"); SceneManager.UnloadSceneAsync(CHARACTER_CREATION_SCENE_NAME); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharCreatorSceneLoader",
          "content": "using System; using UnityEngine; using UnityEngine.SceneManagement; public class CharCreatorSceneLoader : MonoBehaviour { private string CHARACTER_CREATION_SCENE_NAME = \"CharacterCreation Stylized\"; public static CharCreatorSceneLoader Instance { get; private set; } public static Action OnCharCreationSceneLoaded; private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); }else if (Instance != this) { Destroy(gameObject); } BackendReadWrites.OnCharacterCreated += OnCharacterCreated;  private void OnCharacterCreated(CharacterSkinData obj) { UnloadCharacterCreationScene();  public void LoadCharacterCreationScene() { Debug.Log(\"Loading character creation scene\"); SceneManager.LoadScene(CHARACTER_CREATION_SCENE_NAME, LoadSceneMode.Additive);  ",
          "content_tokens": 197,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharCreatorSceneLoader",
          "content": "public void UnloadCharacterCreationScene() { Debug.Log(\"Unloading character creation scene\"); SceneManager.UnloadSceneAsync(CHARACTER_CREATION_SCENE_NAME); } }",
          "content_tokens": 42,
          "embedding": []
        }
      ],
      "length": 947
    },
    {
      "filename": "CharSceneLoadedInvoker",
      "content": "using System; using System.Collections; using System.Collections.Generic; using UnityEngine; public class CharSceneLoadedInvoker : MonoBehaviour { private void Start() { CharCreatorSceneLoader.OnCharCreationSceneLoaded?.Invoke(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharSceneLoadedInvoker",
          "content": "using System; using System.Collections; using System.Collections.Generic; using UnityEngine; public class CharSceneLoadedInvoker : MonoBehaviour { private void Start() { CharCreatorSceneLoader.OnCharCreationSceneLoaded?.Invoke(); } }",
          "content_tokens": 59,
          "embedding": []
        }
      ],
      "length": 234
    },
    {
      "filename": "CharSelBeardGroup",
      "content": "using System.Collections.Generic; using Character; using UnityEngine; using UnityEngine.UI; public class CharSelBeardGroup : MonoBehaviour { [SerializeField] private CharacterSkin _characterSkin; [SerializeField] private Button _buttonPrefab; [SerializeField] private Transform _grid; // Start is called before the first frame update private void Awake() { _characterSkin.OnInitialized += Init; } private void Init() { List<GameObject> beards = _characterSkin.male.facialHair; for (int i = 0; i < beards.Count; i++) { int tempId = i; var newButton = Instantiate(_buttonPrefab, _grid); newButton.GetComponentInChildren<TMProDecorator>().SetText(i.ToString()); newButton.onClick.AddListener(() => _characterSkin.SetBeard(tempId)); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharSelBeardGroup",
          "content": "using System.Collections.Generic; using Character; using UnityEngine; using UnityEngine.UI; public class CharSelBeardGroup : MonoBehaviour { [SerializeField] private CharacterSkin _characterSkin; [SerializeField] private Button _buttonPrefab; [SerializeField] private Transform _grid; // Start is called before the first frame update private void Awake() { _characterSkin.OnInitialized += Init;  ",
          "content_tokens": 93,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelBeardGroup",
          "content": "private void Init() { List<GameObject> beards = _characterSkin.male.facialHair; for (int i = 0; i < beards.Count; i++) { int tempId = i; var newButton = Instantiate(_buttonPrefab, _grid); newButton.GetComponentInChildren<TMProDecorator>().SetText(i.ToString()); newButton.onClick.AddListener(() => _characterSkin.SetBeard(tempId)); } } }",
          "content_tokens": 109,
          "embedding": []
        }
      ],
      "length": 735
    },
    {
      "filename": "CharSelBodyArtColorGroup",
      "content": "using System; using System.Collections.Generic; using Character; using UnityEngine; using UnityEngine.UI; public class CharSelBodyArtColorGroup : MonoBehaviour { [SerializeField] private CharacterSkin _characterSkin; [SerializeField] private Toggle _togglePrefab; [SerializeField] private Transform _grid; private List<Toggle> _toggles = new List<Toggle>(); private void Awake() { _characterSkin.OnInitialized += Init; } private void Init() { for (int i = 0; i < _characterSkin.bodyArt.Length; i++) { AllocateToggle(_characterSkin.bodyArt[i], i); } gameObject.SetActive(false); } private void AllocateToggle(Color tempColor, int i) { var newToggle = Instantiate(_togglePrefab, _grid); _toggles.Add(newToggle); int tempGlobalIndex = i; newToggle.onValueChanged.AddListener((value) => { if (value) { CharSelController.Instance.PlayUISound(); _characterSkin.SetBodyArtColor(tempGlobalIndex); foreach (var tgl in _toggles) { if (tgl == newToggle) continue; tgl.isOn = false; } } }); var colorGO = newToggle.transform.GetChild(1).gameObject; var colorImage = colorGO.GetComponent<Image>(); colorImage.color = tempColor; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharSelBodyArtColorGroup",
          "content": "using System; using System.Collections.Generic; using Character; using UnityEngine; using UnityEngine.UI; public class CharSelBodyArtColorGroup : MonoBehaviour { [SerializeField] private CharacterSkin _characterSkin; [SerializeField] private Toggle _togglePrefab; [SerializeField] private Transform _grid; private List<Toggle> _toggles = new List<Toggle>(); private void Awake() { _characterSkin.OnInitialized += Init;  private void Init() { for (int i = 0; i < _characterSkin.bodyArt.Length; i++) { AllocateToggle(_characterSkin.bodyArt[i], i); } gameObject.SetActive(false);  ",
          "content_tokens": 156,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelBodyArtColorGroup",
          "content": "private void AllocateToggle(Color tempColor, int i) { var newToggle = Instantiate(_togglePrefab, _grid); _toggles.Add(newToggle); int tempGlobalIndex = i; newToggle.onValueChanged.AddListener((value) => { if (value) { CharSelController.Instance.PlayUISound(); _characterSkin.SetBodyArtColor(tempGlobalIndex); foreach (var tgl in _toggles) { if (tgl == newToggle) continue; tgl.isOn = false; } } }); var colorGO = newToggle.transform.GetChild(1).gameObject; var colorImage = colorGO.GetComponent<Image>(); colorImage.color = tempColor; } }",
          "content_tokens": 166,
          "embedding": []
        }
      ],
      "length": 1119
    },
    {
      "filename": "CharSelController",
      "content": "using System; using System.Collections; using System.Collections.Generic; using Character; using DarkTonic.MasterAudio; using TMPro; using UnityEngine; using UnityEngine.UI; public class CharSelController : MonoBehaviour { [SerializeField] protected List<CanvasWindow> _canvasGroups = new List<CanvasWindow>(); [SerializeField] protected List<CanvasWindow> _secundaryCanvasGroups = new List<CanvasWindow>(); [SerializeField] protected CharacterSkin _characterSkin; [SerializeField] protected Transform _camera; [SerializeField] protected Vector3 _cameraAllViewPosition; [SerializeField] protected Vector3 _cameraAllViewRotation; [SerializeField] protected Vector3 _cameraFaceViewPosition; [SerializeField] protected Vector3 _cameraFaceViewRotation; [SerializeField] protected Button _confirmBtn; [SerializeField] protected TMP_InputField _nameField; [SerializeField] protected TextMeshProUGUI _errorText; [SerializeField] protected Toggle _maleToggle; [SerializeField] protected Toggle _femaleToggle; [SerializeField] protected GameObject[] _beardGroup; public Action OnGenderChanged; public static CharSelController Instance { get; protected set; } public enum WindowType {Gender, Hair, Face, SkinColor, Beard, HairColor, BodyArt} protected void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); }else if (Instance != this) { Destroy(gameObject); } //_confirmBtn.interactable = false; _maleToggle.onValueChanged.AddListener(OnMaleToggle); _femaleToggle.onValueChanged.AddListener(OnFemaleToggle); } public void PlayUISound() { MasterAudio.PlaySound(\"UI Click Taps\"); } protected virtual void OnFemaleToggle(bool isOn) { if (isOn) { PlayUISound(); _characterSkin.ChangeGender(false); for (int i = 0; i < _beardGroup.Length; i++) _beardGroup[i].SetActive(false); } } protected virtual void OnMaleToggle(bool isOn) { if (isOn) { PlayUISound(); for (int i = 0; i < _beardGroup.Length; i++) _beardGroup[i].SetActive(isOn); _characterSkin.ChangeGender(isOn); } } protected void UpdateName(string next) { if (next.Length > 4) { if (IsNameValid(next)) { _confirmBtn.interactable = true; } else { _confirmBtn.interactable = false; } } } protected bool IsNameValid(string name) { //TODO: check if name is valid return true; } protected IEnumerator MoveCameraToAllView() { //slightly move camera var sqrDistance = Vector3.SqrMagnitude(_camera.localPosition - _cameraAllViewPosition); while (sqrDistance > float.Epsilon) { _camera.localPosition = Vector3.Lerp(_camera.localPosition, _cameraAllViewPosition, 0.1f); _camera.localRotation = Quaternion.Lerp(_camera.localRotation, Quaternion.Euler(_cameraAllViewRotation), 0.1f); yield return null; } } protected IEnumerator MoveCameraToFaceView() { var sqrDistance = Vector3.SqrMagnitude(_camera.localPosition - _cameraAllViewPosition); //slightly move camera while (sqrDistance > float.Epsilon) { _camera.localPosition = Vector3.Lerp(_camera.localPosition, _cameraFaceViewPosition, 0.1f); _camera.localRotation = Quaternion.Lerp(_camera.localRotation, Quaternion.Euler(_cameraFaceViewRotation), 0.1f); yield return null; } } public void SelectSkinColor() { ShowSingleGroup(_canvasGroups, WindowType.SkinColor); HideAllGroups(_secundaryCanvasGroups); SetCameraFullView(); } public void SetCameraFullView() { StartCoroutine(MoveCameraToAllView()); } public void SetCameraFaceView() { StartCoroutine(MoveCameraToFaceView()); } public void SelectHair() { //ShowSingleGroup(_canvasGroups, WindowType.Hair); ShowGroup(_secundaryCanvasGroups, WindowType.HairColor); if (_characterSkin.IsMale) { ShowGroup(_secundaryCanvasGroups, WindowType.Beard); } //HideGroup(_secundaryCanvasGroups, WindowType.BodyArt); SetCameraFaceView(); } public void SelectFace() { ShowSingleGroup(_canvasGroups, WindowType.Face); ShowSingleGroup(_secundaryCanvasGroups, WindowType.BodyArt); StartCoroutine(MoveCameraToFaceView()); } protected void HideGroup(List<CanvasWindow> which, WindowType type) { foreach (var window in which) { if (window.WinType == type) { window.CanGrp.Hide(); break; } } } protected void HideAllGroups(List<CanvasWindow> which) { foreach (var window in which) { window.CanGrp.Hide(); } } protected void ShowGroup(List<CanvasWindow> which, WindowType type) { foreach (var window in which) { if (window.WinType == type) { window.CanGrp.Show(); } } } protected void ShowSingleGroup(List<CanvasWindow> which, WindowType type) { foreach (var window in which) { if (window.WinType == type) { window.CanGrp.Show(); } else { window.CanGrp.Hide(); } } } public virtual void OnConfirm() { CharacterSkinData skinData = _characterSkin.GetSkinData(); Debug.Log($\"Confirming {(CharacterSkinData.Gender)skinData.genderId} character\"); BackendReadWrites.RegisterCharacter(skinData); DiscordController.Instance.UpdateDiscordActivity(); } [Serializable] public class CanvasWindow { public UICanvasGroupDecorator CanGrp; public WindowType WinType; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharSelController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelController",
          "content": "using System; using System.Collections; using System.Collections.Generic; using Character; using DarkTonic.MasterAudio; using TMPro; using UnityEngine; using UnityEngine.UI; public class CharSelController : MonoBehaviour { [SerializeField] protected List<CanvasWindow> _canvasGroups = new List<CanvasWindow>(); [SerializeField] protected List<CanvasWindow> _secundaryCanvasGroups = new List<CanvasWindow>(); [SerializeField] protected CharacterSkin _characterSkin; [SerializeField] protected Transform _camera; [SerializeField] protected Vector3 _cameraAllViewPosition; [SerializeField] protected Vector3 _cameraAllViewRotation; [SerializeField] protected Vector3 _cameraFaceViewPosition; [SerializeField] protected Vector3 _cameraFaceViewRotation; [SerializeField] protected Button _confirmBtn; [SerializeField] protected TMP_InputField _nameField; [SerializeField] protected TextMeshProUGUI _errorText; [SerializeField] protected Toggle _maleToggle; [SerializeField] protected Toggle _femaleToggle; [SerializeField] protected GameObject[] _beardGroup; public Action OnGenderChanged; public static CharSelController Instance { get; protected set; } public enum WindowType {Gender, Hair, Face, SkinColor, Beard, HairColor, BodyArt}",
          "content_tokens": 309,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelController",
          "content": "protected void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); }else if (Instance != this) { Destroy(gameObject); } //_confirmBtn.interactable = false; _maleToggle.onValueChanged.AddListener(OnMaleToggle); _femaleToggle.onValueChanged.AddListener(OnFemaleToggle);  ",
          "content_tokens": 91,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelController",
          "content": "public void PlayUISound() { MasterAudio.PlaySound(\"UI Click Taps\"); } protected virtual void OnFemaleToggle(bool isOn) { if (isOn) { PlayUISound(); _characterSkin.ChangeGender(false); for (int i = 0; i < _beardGroup.Length; i++) _beardGroup[i].SetActive(false); } } protected virtual void OnMaleToggle(bool isOn) { if (isOn) { PlayUISound(); for (int i = 0; i < _beardGroup.Length; i++) _beardGroup[i].SetActive(isOn); _characterSkin.ChangeGender(isOn); }  ",
          "content_tokens": 149,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelController",
          "content": "protected void UpdateName(string next) { if (next.Length > 4) { if (IsNameValid(next)) { _confirmBtn.interactable = true; } else { _confirmBtn.interactable = false; } }  ",
          "content_tokens": 58,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelController",
          "content": "protected bool IsNameValid(string name) { //TODO: check if name is valid return true; } protected IEnumerator MoveCameraToAllView() { //slightly move camera var sqrDistance = Vector3.SqrMagnitude(_camera.localPosition - _cameraAllViewPosition); while (sqrDistance > float.Epsilon) { _camera.localPosition = Vector3.Lerp(_camera.localPosition, _cameraAllViewPosition, 0.1f); _camera.localRotation = Quaternion.Lerp(_camera.localRotation, Quaternion.Euler(_cameraAllViewRotation), 0.1f); yield return null; } } protected IEnumerator MoveCameraToFaceView() { var sqrDistance = Vector3.SqrMagnitude(_camera.localPosition - _cameraAllViewPosition); //slightly move camera while (sqrDistance > float.Epsilon) { _camera.localPosition = Vector3.Lerp(_camera.localPosition, _cameraFaceViewPosition, 0.1f); _camera.localRotation = Quaternion.Lerp(_camera.localRotation, Quaternion.Euler(_cameraFaceViewRotation), 0.1f); yield return null; }  ",
          "content_tokens": 283,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelController",
          "content": "public void SelectSkinColor() { ShowSingleGroup(_canvasGroups, WindowType.SkinColor); HideAllGroups(_secundaryCanvasGroups); SetCameraFullView();  public void SetCameraFullView() { StartCoroutine(MoveCameraToAllView());  public void SetCameraFaceView() { StartCoroutine(MoveCameraToFaceView());  public void SelectHair() { //ShowSingleGroup(_canvasGroups, WindowType.Hair); ShowGroup(_secundaryCanvasGroups, WindowType.HairColor); if (_characterSkin.IsMale) { ShowGroup(_secundaryCanvasGroups, WindowType.Beard); } //HideGroup(_secundaryCanvasGroups, WindowType.BodyArt); SetCameraFaceView();  ",
          "content_tokens": 172,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelController",
          "content": "public void SelectFace() { ShowSingleGroup(_canvasGroups, WindowType.Face); ShowSingleGroup(_secundaryCanvasGroups, WindowType.BodyArt); StartCoroutine(MoveCameraToFaceView());  protected void HideGroup(List<CanvasWindow> which, WindowType type) { foreach (var window in which) { if (window.WinType == type) { window.CanGrp.Hide(); break; } }  protected void HideAllGroups(List<CanvasWindow> which) { foreach (var window in which) { window.CanGrp.Hide(); }  protected void ShowGroup(List<CanvasWindow> which, WindowType type) { foreach (var window in which) { if (window.WinType == type) { window.CanGrp.Show(); } }  ",
          "content_tokens": 183,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelController",
          "content": "protected void ShowSingleGroup(List<CanvasWindow> which, WindowType type) { foreach (var window in which) { if (window.WinType == type) { window.CanGrp.Show(); } else { window.CanGrp.Hide(); } } } public virtual void OnConfirm() { CharacterSkinData skinData = _characterSkin.GetSkinData(); Debug.Log($\"Confirming {(CharacterSkinData.Gender)skinData.genderId} character\"); BackendReadWrites.RegisterCharacter(skinData); DiscordController.Instance.UpdateDiscordActivity(); } [Serializable] public class CanvasWindow { public UICanvasGroupDecorator CanGrp; public WindowType WinType; } }",
          "content_tokens": 159,
          "embedding": []
        }
      ],
      "length": 4898
    },
    {
      "filename": "CharSelFaceGroup",
      "content": "using System.Collections; using System.Collections.Generic; using Character; using UnityEngine; using UnityEngine.UI; public class CharSelFaceGroup : MonoBehaviour { [SerializeField] private CharacterSkin _characterSkin; [SerializeField] private Button _buttonPrefab; private List<Button> _buttons = new List<Button>(); private Gender _oldGender = Gender.Female; private void Awake() { _characterSkin.OnInitialized += Init; _characterSkin.OnGenderChanged += UpdateFacesList; } public void Init() { Gender currentGender = _characterSkin.IsMale ? Gender.Male : Gender.Female; if (currentGender != _oldGender) { foreach (var btn in _buttons) { Destroy(btn); } List<GameObject> faces = _characterSkin.IsMale ? _characterSkin.male.headAllElements : _characterSkin.female.headAllElements; for (int i = 0; i < faces.Count; i++) { int tempId = i; var newButton = Instantiate(_buttonPrefab, transform); newButton.GetComponentInChildren<TMProDecorator>().SetText(i.ToString()); newButton.onClick.AddListener(() => UpdateFace(tempId)); } } } private void UpdateFacesList(int gender) { Init(); } public void UpdateFace(int id) { _characterSkin.SetFace(id); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharSelFaceGroup",
          "content": "using System.Collections; using System.Collections.Generic; using Character; using UnityEngine; using UnityEngine.UI; public class CharSelFaceGroup : MonoBehaviour { [SerializeField] private CharacterSkin _characterSkin; [SerializeField] private Button _buttonPrefab; private List<Button> _buttons = new List<Button>(); private Gender _oldGender = Gender.Female; private void Awake() { _characterSkin.OnInitialized += Init; _characterSkin.OnGenderChanged += UpdateFacesList;  ",
          "content_tokens": 117,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelFaceGroup",
          "content": "public void Init() { Gender currentGender = _characterSkin.IsMale ? Gender.Male : Gender.Female; if (currentGender != _oldGender) { foreach (var btn in _buttons) { Destroy(btn); } List<GameObject> faces = _characterSkin.IsMale ? _characterSkin.male.headAllElements : _characterSkin.female.headAllElements; for (int i = 0; i < faces.Count; i++) { int tempId = i; var newButton = Instantiate(_buttonPrefab, transform); newButton.GetComponentInChildren<TMProDecorator>().SetText(i.ToString()); newButton.onClick.AddListener(() => UpdateFace(tempId)); } }  private void UpdateFacesList(int gender) { Init();  ",
          "content_tokens": 180,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelFaceGroup",
          "content": "public void UpdateFace(int id) { _characterSkin.SetFace(id); } }",
          "content_tokens": 20,
          "embedding": []
        }
      ],
      "length": 1149
    },
    {
      "filename": "CharSelHairColorGrp",
      "content": "using System.Collections.Generic; using Character; using UnityEngine; using UnityEngine.UI; public class CharSelHairColorGrp : MonoBehaviour { [SerializeField] protected CharacterSkin _characterSkin; [SerializeField] protected Toggle _togglePrefab; [SerializeField] protected Transform _grid; protected List<Toggle> _toggles = new List<Toggle>(); protected void Awake() { _characterSkin.OnInitialized += Init; } protected void Init() { int count = 0; for (int i = 0; i < _characterSkin.GHairColors.Length; i++) { Color[] colors = _characterSkin.GHairColors[i].colors; for (int j = 0; j < colors.Length; j++) { Color tempColor = colors[j]; AllocateToggle(tempColor, count); count++; } } gameObject.SetActive(false); } protected void AllocateToggle(Color tempColor, int i) { var newToggle = Instantiate(_togglePrefab, _grid); _toggles.Add(newToggle); int tempGlobalIndex = i; newToggle.onValueChanged.AddListener((value) => { if (value) { CharSelController.Instance.PlayUISound(); _characterSkin.SetHairColor(tempGlobalIndex); foreach (var tgl in _toggles) { if (tgl == newToggle) continue; tgl.isOn = false; } } }); var colorGO = newToggle.transform.GetChild(1).gameObject; var colorImage = colorGO.GetComponent<Image>(); colorImage.color = tempColor; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharSelHairColorGrp",
          "content": "using System.Collections.Generic; using Character; using UnityEngine; using UnityEngine.UI; public class CharSelHairColorGrp : MonoBehaviour { [SerializeField] protected CharacterSkin _characterSkin; [SerializeField] protected Toggle _togglePrefab; [SerializeField] protected Transform _grid; protected List<Toggle> _toggles = new List<Toggle>(); protected void Awake() { _characterSkin.OnInitialized += Init;  ",
          "content_tokens": 103,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelHairColorGrp",
          "content": "protected void Init() { int count = 0; for (int i = 0; i < _characterSkin.GHairColors.Length; i++) { Color[] colors = _characterSkin.GHairColors[i].colors; for (int j = 0; j < colors.Length; j++) { Color tempColor = colors[j]; AllocateToggle(tempColor, count); count++; } } gameObject.SetActive(false);  ",
          "content_tokens": 99,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelHairColorGrp",
          "content": "protected void AllocateToggle(Color tempColor, int i) { var newToggle = Instantiate(_togglePrefab, _grid); _toggles.Add(newToggle); int tempGlobalIndex = i; newToggle.onValueChanged.AddListener((value) => { if (value) { CharSelController.Instance.PlayUISound(); _characterSkin.SetHairColor(tempGlobalIndex); foreach (var tgl in _toggles) { if (tgl == newToggle) continue; tgl.isOn = false; } } }); var colorGO = newToggle.transform.GetChild(1).gameObject; var colorImage = colorGO.GetComponent<Image>(); colorImage.color = tempColor; } }",
          "content_tokens": 166,
          "embedding": []
        }
      ],
      "length": 1254
    },
    {
      "filename": "CharSelSkinColorGroup",
      "content": "using System; using System.Collections.Generic; using Character; using UnityEngine; using UnityEngine.UI; public class CharSelSkinColorGroup : MonoBehaviour { [SerializeField] private CharacterSkin _characterSkin; [SerializeField] private Toggle _togglePrefab; private List<Toggle> _toggles = new List<Toggle>(); private void Awake() { _characterSkin.OnInitialized += Init; } private void Init() { for (int i = 0; i < 4; i++) { Color tempColor = Color.clear; switch (i) { case 0: tempColor = _characterSkin.whiteSkin[0]; break; case 1: tempColor = _characterSkin.brownSkin[0]; break; case 2: tempColor = _characterSkin.blackSkin[0]; break; case 3: tempColor = _characterSkin.elfSkin[0]; break; } AllocateToggle(tempColor, i); } gameObject.SetActive(false); } private void AllocateToggle(Color tempColor, int i) { var newToggle = Instantiate(_togglePrefab, transform); _toggles.Add(newToggle); int tempGlobalIndex = i; newToggle.onValueChanged.AddListener((value) => { if (value) { CharSelController.Instance.PlayUISound(); _characterSkin.SetSkinColor(tempGlobalIndex); foreach (var tgl in _toggles) { if (tgl == newToggle) continue; tgl.isOn = false; } } }); var colorGO = newToggle.transform.GetChild(1).gameObject; var colorImage = colorGO.GetComponent<Image>(); colorImage.color = tempColor; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharSelSkinColorGroup",
          "content": "using System; using System.Collections.Generic; using Character; using UnityEngine; using UnityEngine.UI; public class CharSelSkinColorGroup : MonoBehaviour { [SerializeField] private CharacterSkin _characterSkin; [SerializeField] private Toggle _togglePrefab; private List<Toggle> _toggles = new List<Toggle>(); private void Awake() { _characterSkin.OnInitialized += Init;  private void Init() { for (int i = 0; i < 4; i++) { Color tempColor = Color.clear; switch (i) { case 0: tempColor = _characterSkin.whiteSkin[0]; break; case 1: tempColor = _characterSkin.brownSkin[0]; break; case 2: tempColor = _characterSkin.blackSkin[0]; break; case 3: tempColor = _characterSkin.elfSkin[0]; break;  ",
          "content_tokens": 195,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelSkinColorGroup",
          "content": "AllocateToggle(tempColor, i); } gameObject.SetActive(false);  private void AllocateToggle(Color tempColor, int i) { var newToggle = Instantiate(_togglePrefab, transform); _toggles.Add(newToggle); int tempGlobalIndex = i; newToggle.onValueChanged.AddListener((value) => { if (value) { CharSelController.Instance.PlayUISound(); _characterSkin.SetSkinColor(tempGlobalIndex); foreach (var tgl in _toggles) { if (tgl == newToggle) continue; tgl.isOn = false; } } }); var colorGO = newToggle.transform.GetChild(1).gameObject; var colorImage = colorGO.GetComponent<Image>(); colorImage.color = tempColor; } }",
          "content_tokens": 184,
          "embedding": []
        }
      ],
      "length": 1299
    },
    {
      "filename": "CharSelSwitch",
      "content": "using System.Collections.Generic; using Character; using TMPro; using UnityEngine; using UnityEngine.UI; public abstract class CharSelSwitch : MonoBehaviour { [SerializeField] protected CharacterSkin _characterSkin; [SerializeField] protected TextMeshProUGUI _text; [SerializeField] protected Button _prevButton; [SerializeField] protected Button _nextButton; public int CurrentSelectedIndex => _currentSelectedIndex; protected int _currentSelectedIndex = 0; protected abstract List<GameObject> GetPartList(); protected abstract void SetText(); protected abstract void ActivatePart(); public void OnNextClicked() { _currentSelectedIndex++; if (_currentSelectedIndex >= GetPartList().Count) { _currentSelectedIndex = 0; } ActivatePart(); SetText(); } public void OnPrevClicked() { _currentSelectedIndex--; if (_currentSelectedIndex < 0) { _currentSelectedIndex = GetPartList().Count - 1; } ActivatePart(); SetText(); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharSelSwitch",
          "content": "using System.Collections.Generic; using Character; using TMPro; using UnityEngine; using UnityEngine.UI; public abstract class CharSelSwitch : MonoBehaviour { [SerializeField] protected CharacterSkin _characterSkin; [SerializeField] protected TextMeshProUGUI _text; [SerializeField] protected Button _prevButton; [SerializeField] protected Button _nextButton; public int CurrentSelectedIndex => _currentSelectedIndex; protected int _currentSelectedIndex = 0; protected abstract List<GameObject> GetPartList(); protected abstract void SetText(); protected abstract void ActivatePart(); public void OnNextClicked() { _currentSelectedIndex++; if (_currentSelectedIndex >= GetPartList().Count) { _currentSelectedIndex = 0;  ActivatePart(); SetText();  ",
          "content_tokens": 175,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelSwitch",
          "content": "public void OnPrevClicked() { _currentSelectedIndex--; if (_currentSelectedIndex < 0) { _currentSelectedIndex = GetPartList().Count - 1;  ActivatePart(); SetText(); } }",
          "content_tokens": 48,
          "embedding": []
        }
      ],
      "length": 919
    },
    {
      "filename": "CharSelSwitchBeard",
      "content": "using System.Collections.Generic; using UnityEngine; public class CharSelSwitchBeard : CharSelSwitch { protected override List<GameObject> GetPartList() { return _characterSkin.male.facialHair; } protected override void SetText() { string translateText = I2.Loc.LocalizationManager.GetTermTranslation(\"Beard\").ToUpper(); _text.text = $\"{translateText} {_currentSelectedIndex}\"; } protected override void ActivatePart() { _characterSkin.SetBeard(_currentSelectedIndex); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharSelSwitchBeard",
          "content": "using System.Collections.Generic; using UnityEngine; public class CharSelSwitchBeard : CharSelSwitch { protected override List<GameObject> GetPartList() { return _characterSkin.male.facialHair; } protected override void SetText() { string translateText = I2.Loc.LocalizationManager.GetTermTranslation(\"Beard\").ToUpper(); _text.text = $\"{translateText} {_currentSelectedIndex}\"; } protected override void ActivatePart() { _characterSkin.SetBeard(_currentSelectedIndex); } }",
          "content_tokens": 123,
          "embedding": []
        }
      ],
      "length": 472
    },
    {
      "filename": "CharSelSwitchHair",
      "content": "using System.Collections.Generic; using UnityEngine; public class CharSelSwitchHair : CharSelSwitch { protected override List<GameObject> GetPartList() { return _characterSkin.allGender.all_Hair; } protected override void SetText() { string translateText = I2.Loc.LocalizationManager.GetTermTranslation(\"Hair\").ToUpper(); _text.text = $\"{translateText} {_currentSelectedIndex}\"; } protected override void ActivatePart() { _characterSkin.SetHair(_currentSelectedIndex); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharSelSwitchHair",
          "content": "using System.Collections.Generic; using UnityEngine; public class CharSelSwitchHair : CharSelSwitch { protected override List<GameObject> GetPartList() { return _characterSkin.allGender.all_Hair; } protected override void SetText() { string translateText = I2.Loc.LocalizationManager.GetTermTranslation(\"Hair\").ToUpper(); _text.text = $\"{translateText} {_currentSelectedIndex}\"; } protected override void ActivatePart() { _characterSkin.SetHair(_currentSelectedIndex); } }",
          "content_tokens": 124,
          "embedding": []
        }
      ],
      "length": 473
    },
    {
      "filename": "CharSelSwitchTattoo",
      "content": "using System; using System.Collections.Generic; using UnityEngine; using UnityEngine.PlayerLoop; public class CharSelSwitchTattoo : CharSelSwitch { private int _maleFaceCount; private int _femaleFaceCount; private void Awake() { _characterSkin.OnGenderChanged += UpdateFacesList; _characterSkin.OnInitialized += Init; } private void Init() { _maleFaceCount = _characterSkin.male.headAllElements.Count; _femaleFaceCount = _characterSkin.female.headAllElements.Count; } /// <summary> /// 0 - Male, 1 - Female /// </summary> private void UpdateFacesList(int genderId) { if (genderId == 0) { if (_currentSelectedIndex >= _maleFaceCount) { _currentSelectedIndex = _maleFaceCount - 1; } } else { if (_currentSelectedIndex >= _femaleFaceCount) { _currentSelectedIndex = _femaleFaceCount - 1; } } Debug.Log($\"_currentSelectedIndex = {_currentSelectedIndex}\"); ActivatePart(); SetText(); } protected override List<GameObject> GetPartList() { List<GameObject> faces = _characterSkin.IsMale ? _characterSkin.male.headAllElements : _characterSkin.female.headAllElements; return faces; } protected override void SetText() { string translateText = I2.Loc.LocalizationManager.GetTermTranslation(\"Tattoo\").ToUpper(); _text.text = $\"{translateText} {_currentSelectedIndex}\"; } protected override void ActivatePart() { _characterSkin.SetFace(_currentSelectedIndex); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharSelSwitchTattoo",
          "content": "using System; using System.Collections.Generic; using UnityEngine; using UnityEngine.PlayerLoop; public class CharSelSwitchTattoo : CharSelSwitch { private int _maleFaceCount; private int _femaleFaceCount; private void Awake() { _characterSkin.OnGenderChanged += UpdateFacesList; _characterSkin.OnInitialized += Init;  ",
          "content_tokens": 79,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharSelSwitchTattoo",
          "content": "private void Init() { _maleFaceCount = _characterSkin.male.headAllElements.Count; _femaleFaceCount = _characterSkin.female.headAllElements.Count; } /// <summary> /// 0 - Male, 1 - Female /// </summary> private void UpdateFacesList(int genderId) { if (genderId == 0) { if (_currentSelectedIndex >= _maleFaceCount) { _currentSelectedIndex = _maleFaceCount - 1; } } else { if (_currentSelectedIndex >= _femaleFaceCount) { _currentSelectedIndex = _femaleFaceCount - 1; } } Debug.Log($\"_currentSelectedIndex = {_currentSelectedIndex}\"); ActivatePart(); SetText(); } protected override List<GameObject> GetPartList() { List<GameObject> faces = _characterSkin.IsMale ? _characterSkin.male.headAllElements : _characterSkin.female.headAllElements; return faces; } protected override void SetText() { string translateText = I2.Loc.LocalizationManager.GetTermTranslation(\"Tattoo\").ToUpper(); _text.text = $\"{translateText} {_currentSelectedIndex}\"; } protected override void ActivatePart() { _characterSkin.SetFace(_currentSelectedIndex); } }",
          "content_tokens": 288,
          "embedding": []
        }
      ],
      "length": 1352
    },
    {
      "filename": "StylizedCharSelController",
      "content": "using Character; using NHance.Assets.Scripts; using UnityEngine; public class StylizedCharSelController : CharSelController { [SerializeField] protected NHAvatar maleAvatar; [SerializeField] protected NHAvatar femaleAvatar; [SerializeField] protected CharSelSwitch hair; [SerializeField] protected CharSelSwitch beard; [SerializeField] protected CharSelSwitch skin; public static CharSelController Instance { get; protected set; } public override void OnConfirm() { PlayUISound(); int genderId = _maleToggle.isOn ? 0 : 1; int hairId = hair.CurrentSelectedIndex; int beardId = beard.CurrentSelectedIndex; int skinId = skin.CurrentSelectedIndex; CharacterSkinData skinData = new CharacterSkinData(genderId, hairId, beardId, skinId); Debug.Log($\"Confirming {(CharacterSkinData.Gender)skinData.genderId} character\"); BackendReadWrites.RegisterCharacter(skinData); DiscordController.Instance.UpdateDiscordActivity(); } protected override void OnFemaleToggle(bool isOn) { if (isOn) { PlayUISound(); maleAvatar.gameObject.SetActive(false); femaleAvatar.gameObject.SetActive(true); } } protected override void OnMaleToggle(bool isOn) { if (isOn) { PlayUISound(); femaleAvatar.gameObject.SetActive(false); maleAvatar.gameObject.SetActive(true); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "StylizedCharSelController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "StylizedCharSelController",
          "content": "using Character; using NHance.Assets.Scripts; using UnityEngine; public class StylizedCharSelController : CharSelController { [SerializeField] protected NHAvatar maleAvatar; [SerializeField] protected NHAvatar femaleAvatar; [SerializeField] protected CharSelSwitch hair; [SerializeField] protected CharSelSwitch beard; [SerializeField] protected CharSelSwitch skin; public static CharSelController Instance { get; protected set; } public override void OnConfirm() { PlayUISound(); int genderId = _maleToggle.isOn ? 0 : 1; int hairId = hair.CurrentSelectedIndex; int beardId = beard.CurrentSelectedIndex; int skinId = skin.CurrentSelectedIndex; CharacterSkinData skinData = new CharacterSkinData(genderId, hairId, beardId, skinId); Debug.Log($\"Confirming {(CharacterSkinData.Gender)skinData.genderId} character\"); BackendReadWrites.RegisterCharacter(skinData); DiscordController.Instance.UpdateDiscordActivity(); } protected override void OnFemaleToggle(bool isOn) { if (isOn) { PlayUISound(); maleAvatar.gameObject.SetActive(false); femaleAvatar.gameObject.SetActive(true); } } protected override void OnMaleToggle(bool isOn) { if (isOn) { PlayUISound(); femaleAvatar.gameObject.SetActive(false); maleAvatar.gameObject.SetActive(true); } } }",
          "content_tokens": 335,
          "embedding": []
        }
      ],
      "length": 1241
    },
    {
      "filename": "StylizedCharSelHairColorGrp",
      "content": "using System.Collections.Generic; using Character; using UnityEngine; using UnityEngine.UI; public class StylizedCharSelHairColorGrp : CharSelHairColorGrp { protected void Awake() { _characterSkin.OnInitialized += Init; } protected void Init() { int count = 0; for (int i = 0; i < _characterSkin.GHairColors.Length; i++) { Color[] colors = _characterSkin.GHairColors[i].colors; for (int j = 0; j < colors.Length; j++) { Color tempColor = colors[j]; AllocateToggle(tempColor, count); count++; } } gameObject.SetActive(false); } protected void AllocateToggle(Color tempColor, int i) { var newToggle = Instantiate(_togglePrefab, _grid); _toggles.Add(newToggle); int tempGlobalIndex = i; newToggle.onValueChanged.AddListener((value) => { if (value) { CharSelController.Instance.PlayUISound(); _characterSkin.SetHairColor(tempGlobalIndex); foreach (var tgl in _toggles) { if (tgl == newToggle) continue; tgl.isOn = false; } } }); var colorGO = newToggle.transform.GetChild(1).gameObject; var colorImage = colorGO.GetComponent<Image>(); colorImage.color = tempColor; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "StylizedCharSelHairColorGrp",
          "content": "using System.Collections.Generic; using Character; using UnityEngine; using UnityEngine.UI; public class StylizedCharSelHairColorGrp : CharSelHairColorGrp { protected void Awake() { _characterSkin.OnInitialized += Init;  protected void Init() { int count = 0; for (int i = 0; i < _characterSkin.GHairColors.Length; i++) { Color[] colors = _characterSkin.GHairColors[i].colors; for (int j = 0; j < colors.Length; j++) { Color tempColor = colors[j]; AllocateToggle(tempColor, count); count++; } } gameObject.SetActive(false);  ",
          "content_tokens": 157,
          "embedding": []
        },
        {
          "cs_scriptfile": "StylizedCharSelHairColorGrp",
          "content": "protected void AllocateToggle(Color tempColor, int i) { var newToggle = Instantiate(_togglePrefab, _grid); _toggles.Add(newToggle); int tempGlobalIndex = i; newToggle.onValueChanged.AddListener((value) => { if (value) { CharSelController.Instance.PlayUISound(); _characterSkin.SetHairColor(tempGlobalIndex); foreach (var tgl in _toggles) { if (tgl == newToggle) continue; tgl.isOn = false; } } }); var colorGO = newToggle.transform.GetChild(1).gameObject; var colorImage = colorGO.GetComponent<Image>(); colorImage.color = tempColor; } }",
          "content_tokens": 166,
          "embedding": []
        }
      ],
      "length": 1064
    },
    {
      "filename": "StylizedCharSelSkinColor",
      "content": "using System; using System.Collections.Generic; using NHance.Assets.Scripts; using NHance.Assets.Scripts.Enums; using NHance.Assets.Scripts.Items; using UnityEngine; public class StylizedCharSelSkinColor : CharSelSwitch { [SerializeField] protected SkinColor[] maleColors; [SerializeField] protected SkinColor[] femaleColors; [SerializeField] protected NHAvatar maleAvatar; [SerializeField] protected NHAvatar femaleAvatar; [SerializeField] protected StylizedCharSelController stylizedCharSelController; private void OnValidate() { stylizedCharSelController ??= FindObjectOfType<StylizedCharSelController>(); } protected override void SetText() { string translateText = I2.Loc.LocalizationManager.GetTermTranslation(\"Skin\").ToUpper(); _text.text = $\"{translateText} {_currentSelectedIndex}\"; } private void Awake() { stylizedCharSelController.OnGenderChanged += OnGenderChanged; } private void OnGenderChanged() { SetText(); ActivatePart(); } protected override List<GameObject> GetPartList() { List<GameObject> prefabs = new List<GameObject>(); SkinColor[] targetSkins = femaleColors; if (maleAvatar.gameObject.activeSelf) { targetSkins = maleColors; } for (int i = 0; i < targetSkins.Length; i++) { prefabs.Add(targetSkins[i].ChestSkin.gameObject); } return prefabs; } protected override void ActivatePart() { NHAvatar _instance = femaleAvatar; if (maleAvatar.gameObject.activeSelf) { _instance = maleAvatar; } _instance.SetSkin(_currentSelectedIndex); } [Serializable] public struct SkinColor { public NHItem HeadSkin; public NHItem ChestSkin; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "StylizedCharSelSkinColor",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "StylizedCharSelSkinColor",
          "content": "using System; using System.Collections.Generic; using NHance.Assets.Scripts; using NHance.Assets.Scripts.Enums; using NHance.Assets.Scripts.Items; using UnityEngine; public class StylizedCharSelSkinColor : CharSelSwitch { [SerializeField] protected SkinColor[] maleColors; [SerializeField] protected SkinColor[] femaleColors; [SerializeField] protected NHAvatar maleAvatar; [SerializeField] protected NHAvatar femaleAvatar; [SerializeField] protected StylizedCharSelController stylizedCharSelController; private void OnValidate() { stylizedCharSelController ??= FindObjectOfType<StylizedCharSelController>(); } protected override void SetText() { string translateText = I2.Loc.LocalizationManager.GetTermTranslation(\"Skin\").ToUpper(); _text.text = $\"{translateText} {_currentSelectedIndex}\";  ",
          "content_tokens": 214,
          "embedding": []
        },
        {
          "cs_scriptfile": "StylizedCharSelSkinColor",
          "content": "private void Awake() { stylizedCharSelController.OnGenderChanged += OnGenderChanged;  private void OnGenderChanged() { SetText(); ActivatePart(); } protected override List<GameObject> GetPartList() { List<GameObject> prefabs = new List<GameObject>(); SkinColor[] targetSkins = femaleColors; if (maleAvatar.gameObject.activeSelf) { targetSkins = maleColors;  ",
          "content_tokens": 96,
          "embedding": []
        },
        {
          "cs_scriptfile": "StylizedCharSelSkinColor",
          "content": "for (int i = 0; i < targetSkins.Length; i++) { prefabs.Add(targetSkins[i].ChestSkin.gameObject); } return prefabs; } protected override void ActivatePart() { NHAvatar _instance = femaleAvatar; if (maleAvatar.gameObject.activeSelf) { _instance = maleAvatar; } _instance.SetSkin(_currentSelectedIndex); } [Serializable] public struct SkinColor { public NHItem HeadSkin; public NHItem ChestSkin; } }",
          "content_tokens": 114,
          "embedding": []
        }
      ],
      "length": 1550
    },
    {
      "filename": "StylizedCharSelSwitchBeard",
      "content": "using System.Collections; using System.Collections.Generic; using NHance.Assets.Scripts; using NHance.Assets.Scripts.Enums; using NHance.Assets.Scripts.Items; using UnityEngine; using UnityEngine.Serialization; public class StylizedCharSelSwitchBeard : CharSelSwitchBeard { [SerializeField] protected NHItem[] beards; [SerializeField] protected NHAvatar maleAvatar; [SerializeField] protected StylizedCharSelController stylizedCharSelController; private void OnValidate() { stylizedCharSelController ??= FindObjectOfType<StylizedCharSelController>(); } private void Awake() { stylizedCharSelController.OnGenderChanged += OnGenderChanged; } private void OnGenderChanged() { _currentSelectedIndex = 0; SetText(); ActivatePart(); } protected override List<GameObject> GetPartList() { List<GameObject> resultBeards = new List<GameObject>(); resultBeards.Add(gameObject);//for the no beard option for (int i = 0; i < beards.Length; i++) { resultBeards.Add(beards[i].gameObject); } return resultBeards; } protected override void ActivatePart() { if (!maleAvatar.gameObject.activeSelf) return; maleAvatar.SetEquipmentId(ItemTypeEnum.Beard, _currentSelectedIndex); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "StylizedCharSelSwitchBeard",
          "content": "using System.Collections; using System.Collections.Generic; using NHance.Assets.Scripts; using NHance.Assets.Scripts.Enums; using NHance.Assets.Scripts.Items; using UnityEngine; using UnityEngine.Serialization; public class StylizedCharSelSwitchBeard : CharSelSwitchBeard { [SerializeField] protected NHItem[] beards; [SerializeField] protected NHAvatar maleAvatar; [SerializeField] protected StylizedCharSelController stylizedCharSelController; private void OnValidate() { stylizedCharSelController ??= FindObjectOfType<StylizedCharSelController>();  private void Awake() { stylizedCharSelController.OnGenderChanged += OnGenderChanged;  ",
          "content_tokens": 170,
          "embedding": []
        },
        {
          "cs_scriptfile": "StylizedCharSelSwitchBeard",
          "content": "private void OnGenderChanged() { _currentSelectedIndex = 0; SetText(); ActivatePart(); } protected override List<GameObject> GetPartList() { List<GameObject> resultBeards = new List<GameObject>(); resultBeards.Add(gameObject);//for the no beard option for (int i = 0; i < beards.Length; i++) { resultBeards.Add(beards[i].gameObject); } return resultBeards; } protected override void ActivatePart() { if (!maleAvatar.gameObject.activeSelf) return; maleAvatar.SetEquipmentId(ItemTypeEnum.Beard, _currentSelectedIndex); } }",
          "content_tokens": 149,
          "embedding": []
        }
      ],
      "length": 1161
    },
    {
      "filename": "StylizedCharSelSwitchHair",
      "content": "using System; using System.Collections.Generic; using NHance.Assets.Scripts; using NHance.Assets.Scripts.Enums; using NHance.Assets.Scripts.Items; using UnityEngine; public class StylizedCharSelSwitchHair : CharSelSwitchHair { [SerializeField] protected NHAvatar maleAvatar; [SerializeField] protected NHAvatar femaleAvatar; [SerializeField] protected StylizedCharSelController stylizedCharSelController; private void OnValidate() { stylizedCharSelController ??= FindObjectOfType<StylizedCharSelController>(); } private void Awake() { stylizedCharSelController.OnGenderChanged += OnGenderChanged; } private void OnGenderChanged() { _currentSelectedIndex = 0; SetText(); ActivatePart(); } protected override List<GameObject> GetPartList() { List<GameObject> hairs = new List<GameObject>(); hairs.Add(gameObject);//for the no hair option ItemVisualsForNHAvatar.ItemPrefab[] targetHairs = femaleAvatar.ItemVisuals.GetItemPrefabs(femaleAvatar.Gender, ItemTypeEnum.Hair); if (maleAvatar.gameObject.activeSelf) { targetHairs = maleAvatar.ItemVisuals.GetItemPrefabs(femaleAvatar.Gender, ItemTypeEnum.Hair); } for (int i = 0; i < targetHairs.Length; i++) { hairs.Add(targetHairs[i].prefab.gameObject); } return hairs; } protected override void ActivatePart() { NHAvatar _instance = femaleAvatar; if (maleAvatar.gameObject.activeSelf) { _instance = maleAvatar; } _instance.SetEquipmentId(ItemTypeEnum.Hair, _currentSelectedIndex); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "StylizedCharSelSwitchHair",
          "content": "using System; using System.Collections.Generic; using NHance.Assets.Scripts; using NHance.Assets.Scripts.Enums; using NHance.Assets.Scripts.Items; using UnityEngine; public class StylizedCharSelSwitchHair : CharSelSwitchHair { [SerializeField] protected NHAvatar maleAvatar; [SerializeField] protected NHAvatar femaleAvatar; [SerializeField] protected StylizedCharSelController stylizedCharSelController; private void OnValidate() { stylizedCharSelController ??= FindObjectOfType<StylizedCharSelController>();  private void Awake() { stylizedCharSelController.OnGenderChanged += OnGenderChanged;  ",
          "content_tokens": 161,
          "embedding": []
        },
        {
          "cs_scriptfile": "StylizedCharSelSwitchHair",
          "content": "private void OnGenderChanged() { _currentSelectedIndex = 0; SetText(); ActivatePart(); } protected override List<GameObject> GetPartList() { List<GameObject> hairs = new List<GameObject>(); hairs.Add(gameObject);//for the no hair option ItemVisualsForNHAvatar.ItemPrefab[] targetHairs = femaleAvatar.ItemVisuals.GetItemPrefabs(femaleAvatar.Gender, ItemTypeEnum.Hair); if (maleAvatar.gameObject.activeSelf) { targetHairs = maleAvatar.ItemVisuals.GetItemPrefabs(femaleAvatar.Gender, ItemTypeEnum.Hair);  ",
          "content_tokens": 150,
          "embedding": []
        },
        {
          "cs_scriptfile": "StylizedCharSelSwitchHair",
          "content": "for (int i = 0; i < targetHairs.Length; i++) { hairs.Add(targetHairs[i].prefab.gameObject); } return hairs; } protected override void ActivatePart() { NHAvatar _instance = femaleAvatar; if (maleAvatar.gameObject.activeSelf) { _instance = maleAvatar; } _instance.SetEquipmentId(ItemTypeEnum.Hair, _currentSelectedIndex); } }",
          "content_tokens": 101,
          "embedding": []
        }
      ],
      "length": 1426
    },
    {
      "filename": "AdvUrls",
      "content": "using UnityEngine; public class AdvUrls : MonoBehaviour { private static readonly string GAME_STEAM_LINK = \"https://store.steampowered.com/app/2603930/Dungeons_and_Dangers/\"; private static readonly string GAME_DISCORD_LINK = \"https://discord.gg/rQSuamAJ\"; private static readonly string GAME_PATREON_LINK = \"https://www.patreon.com/user/posts?u=29183208\"; public void OpenSteamPage() { Application.OpenURL(GAME_STEAM_LINK); } public void OpenDiscordServer() { Application.OpenURL(GAME_DISCORD_LINK); } public void OpenPatreon() { Application.OpenURL(GAME_PATREON_LINK); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AdvUrls",
          "content": "using UnityEngine; public class AdvUrls : MonoBehaviour { private static readonly string GAME_STEAM_LINK = \"https://store.steampowered.com/app/2603930/Dungeons_and_Dangers/\"; private static readonly string GAME_DISCORD_LINK = \"https://discord.gg/rQSuamAJ\"; private static readonly string GAME_PATREON_LINK = \"https://www.patreon.com/user/posts?u=29183208\"; public void OpenSteamPage() { Application.OpenURL(GAME_STEAM_LINK); } public void OpenDiscordServer() { Application.OpenURL(GAME_DISCORD_LINK); } public void OpenPatreon() { Application.OpenURL(GAME_PATREON_LINK); } }",
          "content_tokens": 187,
          "embedding": []
        }
      ],
      "length": 574
    },
    {
      "filename": "AllyBar",
      "content": " using DungeonScrollerCore; using FishnetInvector; using UnityEngine; using UnityEngine.UI; namespace _ZombieRoyale.Scripts.Clients { public class AllyBar: MonoBehaviour { [SerializeField] private int allyId; [SerializeField] private Slider _sliderHp; [SerializeField] private TMProDecorator _name; [SerializeField] private TMProDecorator _hp; private FishnetInvectorHealthController _healthController; private bool _isDebug = true; public void Init(int clientId, string name) { DebugWrite.Log($\"[AllyBar] Init for {name}\", gameObject, _isDebug); SetName(name); allyId = clientId; } public void UpdateHP(FishnetInvectorHealthController.HealthType type, float newAmount) { if (type == FishnetInvectorHealthController.HealthType.Current) { _sliderHp.value = newAmount; _hp.SetText($\"{ (int) newAmount}\"); } if (type == FishnetInvectorHealthController.HealthType.Max) { _sliderHp.maxValue = newAmount; } } public void SetName(string name) => _name.SetText(name); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AllyBar",
          "content": " using DungeonScrollerCore; using FishnetInvector; using UnityEngine; using UnityEngine.UI; namespace _ZombieRoyale.Scripts.Clients { public class AllyBar: MonoBehaviour { [SerializeField] private int allyId; [SerializeField] private Slider _sliderHp; [SerializeField] private TMProDecorator _name; [SerializeField] private TMProDecorator _hp; private FishnetInvectorHealthController _healthController; private bool _isDebug = true; public void Init(int clientId, string name) { DebugWrite.Log($\"[AllyBar] Init for {name}\", gameObject, _isDebug); SetName(name); allyId = clientId;  ",
          "content_tokens": 163,
          "embedding": []
        },
        {
          "cs_scriptfile": "AllyBar",
          "content": "public void UpdateHP(FishnetInvectorHealthController.HealthType type, float newAmount) { if (type == FishnetInvectorHealthController.HealthType.Current) { _sliderHp.value = newAmount; _hp.SetText($\"{ (int) newAmount}\");  if (type == FishnetInvectorHealthController.HealthType.Max) { _sliderHp.maxValue = newAmount; }  public void SetName(string name) => _name.SetText(name); } }",
          "content_tokens": 115,
          "embedding": []
        }
      ],
      "length": 963
    },
    {
      "filename": "BloodController",
      "content": "using System; using System.Collections; using UnityEngine; using UnityEngine.Pool; public class BloodController : MonoBehaviour { [SerializeField] private ParticleSystem _bloodPrefab; private ObjectPool<ParticleSystem> _bloodPool; private int amountToPool = 1; private Action<ParticleSystem> _actionOnGet; private Action<ParticleSystem> _actionOnRelease; private void Init() { _actionOnRelease = (particleSystem) => { particleSystem.gameObject.SetActive(false); }; _actionOnGet = (particleSystem) => { particleSystem.gameObject.SetActive(true); }; _bloodPool = new ObjectPool<ParticleSystem>(() => { ParticleSystem blood = Instantiate(_bloodPrefab); blood.transform.parent = transform; blood.transform.localPosition = Vector3.zero; blood.transform.localRotation = Quaternion.identity; blood.gameObject.SetActive(false); return blood; }, _actionOnGet, _actionOnRelease); } public void PlayBloodEffect(Vector3 position) { if (_bloodPool == null) { Init(); } ParticleSystem blood = _bloodPool.Get(); blood.transform.position = position; //rotate to face opposite direction from root blood.transform.rotation = Quaternion.LookRotation(position - transform.position); StartCoroutine(StopBloodAfterDelay(blood)); } private IEnumerator StopBloodAfterDelay(ParticleSystem blood) { yield return new WaitForSeconds(1f); _bloodPool.Release(blood); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BloodController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "BloodController",
          "content": "using System; using System.Collections; using UnityEngine; using UnityEngine.Pool; public class BloodController : MonoBehaviour { [SerializeField] private ParticleSystem _bloodPrefab; private ObjectPool<ParticleSystem> _bloodPool; private int amountToPool = 1; private Action<ParticleSystem> _actionOnGet; private Action<ParticleSystem> _actionOnRelease; private void Init() { _actionOnRelease = (particleSystem) => { particleSystem.gameObject.SetActive(false); }; _actionOnGet = (particleSystem) => { particleSystem.gameObject.SetActive(true); }; _bloodPool = new ObjectPool<ParticleSystem>(() => { ParticleSystem blood = Instantiate(_bloodPrefab); blood.transform.parent = transform; blood.transform.localPosition = Vector3.zero; blood.transform.localRotation = Quaternion.identity; blood.gameObject.SetActive(false); return blood; }, _actionOnGet, _actionOnRelease);  ",
          "content_tokens": 227,
          "embedding": []
        },
        {
          "cs_scriptfile": "BloodController",
          "content": "public void PlayBloodEffect(Vector3 position) { if (_bloodPool == null) { Init(); } ParticleSystem blood = _bloodPool.Get(); blood.transform.position = position; //rotate to face opposite direction from root blood.transform.rotation = Quaternion.LookRotation(position - transform.position); StartCoroutine(StopBloodAfterDelay(blood)); } private IEnumerator StopBloodAfterDelay(ParticleSystem blood) { yield return new WaitForSeconds(1f); _bloodPool.Release(blood); } }",
          "content_tokens": 122,
          "embedding": []
        }
      ],
      "length": 1340
    },
    {
      "filename": "BuffDurationTimerController",
      "content": "using System.Collections.Generic; using UnityEngine; public class BuffDurationTimerController : MonoBehaviour { [SerializeField] private FishnetInvectorBuffController buffController; [SerializeField] private UIBuffDurationTimer uiBuffDurationTimerPrefab; private Dictionary<int, UIBuffDurationTimer> _buffTimers = new (); public string ClassName => _className ??= $\"{StringToHexColor.GetColoredClassName(GetType())}\"; private string _className; private void OnEnable() { buffController.OnBuffAdded += AddOrUpdateBuff; buffController.OnBuffRemoved += RemoveBuff; } private void OnDisable() { buffController.OnBuffAdded -= AddOrUpdateBuff; buffController.OnBuffRemoved -= RemoveBuff; } public void AddOrUpdateBuff(Buff.BuffInfo buffInfo) { if (_buffTimers.ContainsKey(buffInfo.abilityId)) { UpdateBuffTimer(buffInfo); }else { CreateNewBuffTimer(buffInfo); } } private void CreateNewBuffTimer(Buff.BuffInfo buffInfo) { UIBuffDurationTimer buffTimerItem = Instantiate(uiBuffDurationTimerPrefab, transform); buffTimerItem.UpdateVisualTimer(buffInfo); DictAddOrSetBuffTimer(buffInfo.abilityId, buffTimerItem); } public void RemoveBuff(Buff.BuffType buffType) { int abilityId = Buff.BuffTypeToAbilityId(buffType); if (_buffTimers.ContainsKey(abilityId)) { _buffTimers[abilityId].Deallocate(); DictRemoveBuffTimer(abilityId); } } private void UpdateBuffTimer(Buff.BuffInfo buffInfo) { UIBuffDurationTimer buffTimerItem = GetBuffTimerItem(buffInfo.abilityId); if (buffTimerItem == null) return; buffTimerItem.UpdateVisualTimer(buffInfo); DictAddOrSetBuffTimer(buffInfo.abilityId, buffTimerItem); } private UIBuffDurationTimer GetBuffTimerItem(int abilityId) { if (!_buffTimers.ContainsKey(abilityId)) { return null; } return _buffTimers[abilityId]; } private void DictAddOrSetBuffTimer(int abilityId, UIBuffDurationTimer uiBuffDurationTimer) { if (_buffTimers.ContainsKey(abilityId)) { _buffTimers[abilityId] = uiBuffDurationTimer; return; } _buffTimers.Add(abilityId, uiBuffDurationTimer); } private void DictRemoveBuffTimer(int abilityId) { if (!_buffTimers.ContainsKey(abilityId)) { return; } _buffTimers.Remove(abilityId); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BuffDurationTimerController",
          "content": "using System.Collections.Generic; using UnityEngine; public class BuffDurationTimerController : MonoBehaviour { [SerializeField] private FishnetInvectorBuffController buffController; [SerializeField] private UIBuffDurationTimer uiBuffDurationTimerPrefab; private Dictionary<int, UIBuffDurationTimer> _buffTimers = new (); public string ClassName => _className ??= $\"{StringToHexColor.GetColoredClassName(GetType())}\"; private string _className; private void OnEnable() { buffController.OnBuffAdded += AddOrUpdateBuff; buffController.OnBuffRemoved += RemoveBuff;  private void OnDisable() { buffController.OnBuffAdded -= AddOrUpdateBuff; buffController.OnBuffRemoved -= RemoveBuff;  ",
          "content_tokens": 170,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffDurationTimerController",
          "content": "public void AddOrUpdateBuff(Buff.BuffInfo buffInfo) { if (_buffTimers.ContainsKey(buffInfo.abilityId)) { UpdateBuffTimer(buffInfo); }else { CreateNewBuffTimer(buffInfo); }  private void CreateNewBuffTimer(Buff.BuffInfo buffInfo) { UIBuffDurationTimer buffTimerItem = Instantiate(uiBuffDurationTimerPrefab, transform); buffTimerItem.UpdateVisualTimer(buffInfo); DictAddOrSetBuffTimer(buffInfo.abilityId, buffTimerItem);  public void RemoveBuff(Buff.BuffType buffType) { int abilityId = Buff.BuffTypeToAbilityId(buffType); if (_buffTimers.ContainsKey(abilityId)) { _buffTimers[abilityId].Deallocate(); DictRemoveBuffTimer(abilityId); }  ",
          "content_tokens": 184,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffDurationTimerController",
          "content": "private void UpdateBuffTimer(Buff.BuffInfo buffInfo) { UIBuffDurationTimer buffTimerItem = GetBuffTimerItem(buffInfo.abilityId); if (buffTimerItem == null) return; buffTimerItem.UpdateVisualTimer(buffInfo); DictAddOrSetBuffTimer(buffInfo.abilityId, buffTimerItem); } private UIBuffDurationTimer GetBuffTimerItem(int abilityId) { if (!_buffTimers.ContainsKey(abilityId)) { return null; } return _buffTimers[abilityId];  private void DictAddOrSetBuffTimer(int abilityId, UIBuffDurationTimer uiBuffDurationTimer) { if (_buffTimers.ContainsKey(abilityId)) { _buffTimers[abilityId] = uiBuffDurationTimer; return; } _buffTimers.Add(abilityId, uiBuffDurationTimer);  ",
          "content_tokens": 195,
          "embedding": []
        },
        {
          "cs_scriptfile": "BuffDurationTimerController",
          "content": "private void DictRemoveBuffTimer(int abilityId) { if (!_buffTimers.ContainsKey(abilityId)) { return; } _buffTimers.Remove(abilityId); } }",
          "content_tokens": 43,
          "embedding": []
        }
      ],
      "length": 2121
    },
    {
      "filename": "UIBuffDurationTimer",
      "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; using UnityEngine.UI; public class UIBuffDurationTimer : MonoBehaviour { [SerializeField] private Image fillBar; [SerializeField] private Image icon; [SerializeField] private TMProDecorator timerText; [SerializeField] private CanvasGroup canvasGroup; private float _maxDuration; private Coroutine _timerCoroutine; private Buff.BuffInfo _buffInfo; private bool _isInitialized = false; public void Init(Buff.BuffInfo buffInfo) { Ability ability = AbilityManager.Instance.GetAbility(buffInfo.abilityId); if (ability.AbilityDefinition.Icon == null) { Debug.LogError($\"[UIBuffDurationTimer] Init: Icon is null for ability {ability.AbilityDefinition.Name}\"); icon.gameObject.SetActive(false); } else { icon.sprite = ability.AbilityDefinition.Icon; } _buffInfo = buffInfo; float timeLeft = buffInfo.FinishAtServerTime - GameplayManager.GetCurrentServerTime(); _maxDuration = timeLeft; SetTimerTime(timeLeft); _timerCoroutine = StartCoroutine(UpdateTimer()); canvasGroup.alpha = .5f; } public void UpdateVisualTimer(Buff.BuffInfo buffInfo) { if (!_isInitialized) { Init(buffInfo); _isInitialized = true; } else { _buffInfo = buffInfo; _maxDuration = buffInfo.FinishAtServerTime - GameplayManager.GetCurrentServerTime(); } } private IEnumerator UpdateTimer() { float startTime = GameplayManager.GetCurrentServerTime(); float timeLeft = _buffInfo.FinishAtServerTime - startTime; float fillAmount = 1f; var time = new WaitForSeconds(.1f); while (timeLeft > float.Epsilon) { timeLeft = _buffInfo.FinishAtServerTime - GameplayManager.GetCurrentServerTime(); fillAmount = timeLeft / _maxDuration; SetFillBar(fillAmount); SetTimerTime(timeLeft); yield return time; } Destroy(gameObject); } private void SetFillBar(float fillAmount) { fillBar.fillAmount = fillAmount; } private void SetTimerTime(float time) { timerText.SetText(time.ToString(\"F1\")); } public void Deallocate() { if (canvasGroup == null) return; canvasGroup.alpha = 0f; if (_timerCoroutine != null) StopCoroutine(_timerCoroutine); Destroy(gameObject); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "UIBuffDurationTimer",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "UIBuffDurationTimer",
          "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; using UnityEngine.UI; public class UIBuffDurationTimer : MonoBehaviour { [SerializeField] private Image fillBar; [SerializeField] private Image icon; [SerializeField] private TMProDecorator timerText; [SerializeField] private CanvasGroup canvasGroup; private float _maxDuration; private Coroutine _timerCoroutine; private Buff.BuffInfo _buffInfo; private bool _isInitialized = false; public void Init(Buff.BuffInfo buffInfo) { Ability ability = AbilityManager.Instance.GetAbility(buffInfo.abilityId); if (ability.AbilityDefinition.Icon == null) { Debug.LogError($\"[UIBuffDurationTimer] Init: Icon is null for ability {ability.AbilityDefinition.Name}\"); icon.gameObject.SetActive(false); } else { icon.sprite = ability.AbilityDefinition.Icon; } _buffInfo = buffInfo; float timeLeft = buffInfo.FinishAtServerTime - GameplayManager.GetCurrentServerTime(); _maxDuration = timeLeft; SetTimerTime(timeLeft); _timerCoroutine = StartCoroutine(UpdateTimer()); canvasGroup.alpha = .5f;  ",
          "content_tokens": 294,
          "embedding": []
        },
        {
          "cs_scriptfile": "UIBuffDurationTimer",
          "content": "public void UpdateVisualTimer(Buff.BuffInfo buffInfo) { if (!_isInitialized) { Init(buffInfo); _isInitialized = true; } else { _buffInfo = buffInfo; _maxDuration = buffInfo.FinishAtServerTime - GameplayManager.GetCurrentServerTime(); } } private IEnumerator UpdateTimer() { float startTime = GameplayManager.GetCurrentServerTime(); float timeLeft = _buffInfo.FinishAtServerTime - startTime; float fillAmount = 1f; var time = new WaitForSeconds(.1f); while (timeLeft > float.Epsilon) { timeLeft = _buffInfo.FinishAtServerTime - GameplayManager.GetCurrentServerTime(); fillAmount = timeLeft / _maxDuration; SetFillBar(fillAmount); SetTimerTime(timeLeft); yield return time;  Destroy(gameObject);  ",
          "content_tokens": 192,
          "embedding": []
        },
        {
          "cs_scriptfile": "UIBuffDurationTimer",
          "content": "private void SetFillBar(float fillAmount) { fillBar.fillAmount = fillAmount;  private void SetTimerTime(float time) { timerText.SetText(time.ToString(\"F1\"));  public void Deallocate() { if (canvasGroup == null) return; canvasGroup.alpha = 0f; if (_timerCoroutine != null) StopCoroutine(_timerCoroutine); Destroy(gameObject); } }",
          "content_tokens": 95,
          "embedding": []
        }
      ],
      "length": 2140
    },
    {
      "filename": "CallForStart",
      "content": "using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using UnityEngine; public class CallForStart : MonoBehaviour { [SerializeField] private GameObject locationIcon; private void Start() { locationIcon.SetActive(true); } private void OnTriggerEnter(Collider other) { if (other.CompareTag(\"Player\")) { var healthController = GameplayManagerBossBattle.GetInstance.GetHealthController(other); if (healthController == null) return; if (healthController.IsDead) return; if (!healthController.IsOwner) return; locationIcon.SetActive(false); GameplayManagerBossBattle.GetInstance.AddStartCaller(other.gameObject.GetComponent<NetworkObject>()); } } private void OnTriggerExit(Collider other) { if (other.CompareTag(\"Player\")) { var healthController = GameplayManagerBossBattle.GetInstance.GetHealthController(other); if (healthController == null) return; if (healthController.IsDead) return; if (!healthController.IsOwner) return; locationIcon.SetActive(true); GameplayManagerBossBattle.GetInstance.RemoveStartCaller(other.gameObject.GetComponent<NetworkObject>()); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CallForStart",
          "content": "using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using UnityEngine; public class CallForStart : MonoBehaviour { [SerializeField] private GameObject locationIcon; private void Start() { locationIcon.SetActive(true);  private void OnTriggerEnter(Collider other) { if (other.CompareTag(\"Player\")) { var healthController = GameplayManagerBossBattle.GetInstance.GetHealthController(other); if (healthController == null) return; if (healthController.IsDead) return; if (!healthController.IsOwner) return; locationIcon.SetActive(false); GameplayManagerBossBattle.GetInstance.AddStartCaller(other.gameObject.GetComponent<NetworkObject>()); }  ",
          "content_tokens": 169,
          "embedding": []
        },
        {
          "cs_scriptfile": "CallForStart",
          "content": "private void OnTriggerExit(Collider other) { if (other.CompareTag(\"Player\")) { var healthController = GameplayManagerBossBattle.GetInstance.GetHealthController(other); if (healthController == null) return; if (healthController.IsDead) return; if (!healthController.IsOwner) return; locationIcon.SetActive(true); GameplayManagerBossBattle.GetInstance.RemoveStartCaller(other.gameObject.GetComponent<NetworkObject>()); } } }",
          "content_tokens": 106,
          "embedding": []
        }
      ],
      "length": 1089
    },
    {
      "filename": "CharacterData",
      "content": " using System; using System.Collections.Generic; namespace _ZombieRoyale.Scripts.Clients { [Serializable] public class CharacterData { public int id; public int genderId; public int skinColorId; public int beardId; public int bodyArtId; public int faceId; public int hairId; public int hairColorId; public int xp; public int level; public int gold; public List<AbilityInfo> abiliyInfo; public int[] skill_ids; public BackendReadWrites.SlotItem[] bank_items; public BackendReadWrites.SlotItem[] backpack_items; public BackendReadWrites.SlotItem[] equipment_items; public Action<byte, uint> OnAbilityInfoUpdated; public CharacterSkinData GetSkinData() { CharacterSkinData skinData = new CharacterSkinData(); skinData.Id = id; skinData.genderId = genderId; skinData.skinColorId = skinColorId; skinData.beardId = beardId; skinData.bodyArtId = bodyArtId; skinData.faceId = faceId; skinData.hairId = hairId; skinData.hairColorId = hairColorId; return skinData; } public int GetAbilityRank(byte abilityId) { if (abiliyInfo == null) return 0; for (int i = 0; i < abiliyInfo.Count; i++) { if (abiliyInfo[i].Id == abilityId) { return abiliyInfo[i].Rank; } } return 0; } public uint GetAbilityStacks(byte abilityId) { if (abiliyInfo == null) return 0; for (int i = 0; i < abiliyInfo.Count; i++) { if (abiliyInfo[i].Id == abilityId) { return abiliyInfo[i].Stacks; } } return 0; } public uint SetAbilityStacks(byte abilityId, uint stacks) { if (abiliyInfo == null) { abiliyInfo = new List<AbilityInfo>{new AbilityInfo(abilityId, 1, 0)}; } for (int i = 0; i < abiliyInfo.Count; i++) { if (abiliyInfo[i].Id == abilityId) { abiliyInfo[i].Stacks = stacks; OnAbilityInfoUpdated?.Invoke(abilityId, stacks); return abiliyInfo[i].Stacks; } } abiliyInfo.Add(new AbilityInfo(abilityId, 1, stacks)); OnAbilityInfoUpdated?.Invoke(abilityId, stacks); return 0; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharacterData",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterData",
          "content": " using System; using System.Collections.Generic; namespace _ZombieRoyale.Scripts.Clients { [Serializable] public class CharacterData { public int id; public int genderId; public int skinColorId; public int beardId; public int bodyArtId; public int faceId; public int hairId; public int hairColorId; public int xp; public int level; public int gold; public List<AbilityInfo> abiliyInfo; public int[] skill_ids; public BackendReadWrites.SlotItem[] bank_items; public BackendReadWrites.SlotItem[] backpack_items; public BackendReadWrites.SlotItem[] equipment_items; public Action<byte, uint> OnAbilityInfoUpdated; public CharacterSkinData GetSkinData() { CharacterSkinData skinData = new CharacterSkinData(); skinData.Id = id; skinData.genderId = genderId; skinData.skinColorId = skinColorId; skinData.beardId = beardId; skinData.bodyArtId = bodyArtId; skinData.faceId = faceId; skinData.hairId = hairId; skinData.hairColorId = hairColorId; return skinData;  ",
          "content_tokens": 261,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterData",
          "content": "public int GetAbilityRank(byte abilityId) { if (abiliyInfo == null) return 0; for (int i = 0; i < abiliyInfo.Count; i++) { if (abiliyInfo[i].Id == abilityId) { return abiliyInfo[i].Rank; } } return 0; } public uint GetAbilityStacks(byte abilityId) { if (abiliyInfo == null) return 0; for (int i = 0; i < abiliyInfo.Count; i++) { if (abiliyInfo[i].Id == abilityId) { return abiliyInfo[i].Stacks; } } return 0; } public uint SetAbilityStacks(byte abilityId, uint stacks) { if (abiliyInfo == null) { abiliyInfo = new List<AbilityInfo>{new AbilityInfo(abilityId, 1, 0)};  ",
          "content_tokens": 199,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterData",
          "content": "for (int i = 0; i < abiliyInfo.Count; i++) { if (abiliyInfo[i].Id == abilityId) { abiliyInfo[i].Stacks = stacks; OnAbilityInfoUpdated?.Invoke(abilityId, stacks); return abiliyInfo[i].Stacks; } } abiliyInfo.Add(new AbilityInfo(abilityId, 1, stacks)); OnAbilityInfoUpdated?.Invoke(abilityId, stacks); return 0; } } }",
          "content_tokens": 111,
          "embedding": []
        }
      ],
      "length": 1840
    },
    {
      "filename": "CharacterDataController",
      "content": "using _ZombieRoyale.Scripts.Clients; using Character; using NHance.Assets.Scripts; using UnityEngine; public class CharacterDataController : MonoBehaviour { public static CharacterDataController Instance { get; private set; } public CharacterData CharacterData => characterData; [SerializeField] private CharacterData characterData; public CharacterSkinData CharacterSkinData => _characterSkinData; [SerializeField] private CharacterSkinData _characterSkinData; [SerializeField] private CharacterSkin _characterSkin; [SerializeField] protected NHAvatar maleAvatar; [SerializeField] protected NHAvatar femaleAvatar; private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); BackendReadWrites.OnCharacterCreated += OnCharacterCreated; RegistrationController.Instance.OnCharacterLoaded += OnCharacterLoaded; RegistrationController.Instance.SwitchMainMenuElements(false); }else if (Instance != this) { Destroy(gameObject); } } private void OnCharacterLoaded(CharacterData charData) { Debug.Log($\"[CharacterDataController] OnCharacterLoaded\"); characterData = charData; _characterSkinData = charData.GetSkinData(); LoadAvatar(_characterSkinData); } private void LoadAvatar(CharacterSkinData charskinData) { if (_characterSkin != null && _characterSkin.gameObject.activeSelf) { _characterSkin.SetSkinData(charskinData); } else { if (charskinData.genderId == (int)CharacterSkinData.Gender.Male) { femaleAvatar.gameObject.SetActive(false); maleAvatar.gameObject.SetActive(true); maleAvatar.SetSkinData(charskinData); } else { maleAvatar.gameObject.SetActive(false); femaleAvatar.gameObject.SetActive(true); femaleAvatar.SetSkinData(charskinData); } } } private void OnCharacterCreated(CharacterSkinData backendSkinData) { Debug.Log($\"[CharacterDataController] OnCharacterCreated {(CharacterSkinData.Gender)backendSkinData.genderId}\"); _characterSkinData = backendSkinData; RegistrationController.Instance.SwitchMainMenuElements(true); LoadAvatar(_characterSkinData); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharacterDataController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterDataController",
          "content": "using _ZombieRoyale.Scripts.Clients; using Character; using NHance.Assets.Scripts; using UnityEngine; public class CharacterDataController : MonoBehaviour { public static CharacterDataController Instance { get; private set; } public CharacterData CharacterData => characterData; [SerializeField] private CharacterData characterData; public CharacterSkinData CharacterSkinData => _characterSkinData; [SerializeField] private CharacterSkinData _characterSkinData; [SerializeField] private CharacterSkin _characterSkin; [SerializeField] protected NHAvatar maleAvatar; [SerializeField] protected NHAvatar femaleAvatar; private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); BackendReadWrites.OnCharacterCreated += OnCharacterCreated; RegistrationController.Instance.OnCharacterLoaded += OnCharacterLoaded; RegistrationController.Instance.SwitchMainMenuElements(false); }else if (Instance != this) { Destroy(gameObject); }  ",
          "content_tokens": 225,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterDataController",
          "content": "private void OnCharacterLoaded(CharacterData charData) { Debug.Log($\"[CharacterDataController] OnCharacterLoaded\"); characterData = charData; _characterSkinData = charData.GetSkinData(); LoadAvatar(_characterSkinData);  ",
          "content_tokens": 55,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterDataController",
          "content": "private void LoadAvatar(CharacterSkinData charskinData) { if (_characterSkin != null && _characterSkin.gameObject.activeSelf) { _characterSkin.SetSkinData(charskinData); } else { if (charskinData.genderId == (int)CharacterSkinData.Gender.Male) { femaleAvatar.gameObject.SetActive(false); maleAvatar.gameObject.SetActive(true); maleAvatar.SetSkinData(charskinData); } else { maleAvatar.gameObject.SetActive(false); femaleAvatar.gameObject.SetActive(true); femaleAvatar.SetSkinData(charskinData); } }  ",
          "content_tokens": 151,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterDataController",
          "content": "private void OnCharacterCreated(CharacterSkinData backendSkinData) { Debug.Log($\"[CharacterDataController] OnCharacterCreated {(CharacterSkinData.Gender)backendSkinData.genderId}\"); _characterSkinData = backendSkinData; RegistrationController.Instance.SwitchMainMenuElements(true); LoadAvatar(_characterSkinData); } }",
          "content_tokens": 75,
          "embedding": []
        }
      ],
      "length": 1999
    },
    {
      "filename": "CharacterSkin",
      "content": "using System; using System.Collections.Generic; using DungeonScrollerCore; using UnityEngine; using Random = UnityEngine.Random; namespace Character { public class CharacterSkin : MonoBehaviour { public CharacterSkinData skinData; [Header(\"Demo Settings\")] public bool repeatOnPlay = false; public float shuffleSpeed = 0.7f; [Header(\"Material\")] public Material mat; [Header(\"Gear Colors\")] public Color[] primary = { new Color(0.2862745f, 0.4f, 0.4941177f), new Color(0.4392157f, 0.1960784f, 0.172549f), new Color(0.3529412f, 0.3803922f, 0.2705882f), new Color(0.682353f, 0.4392157f, 0.2196079f), new Color(0.4313726f, 0.2313726f, 0.2705882f), new Color(0.5921569f, 0.4941177f, 0.2588235f), new Color(0.482353f, 0.4156863f, 0.3529412f), new Color(0.2352941f, 0.2352941f, 0.2352941f), new Color(0.2313726f, 0.4313726f, 0.4156863f) }; public Color[] secondary = { new Color(0.7019608f, 0.6235294f, 0.4666667f), new Color(0.7372549f, 0.7372549f, 0.7372549f), new Color(0.1647059f, 0.1647059f, 0.1647059f), new Color(0.2392157f, 0.2509804f, 0.1882353f) }; [Header(\"Metal Colors\")] public Color[] metalPrimary = { new Color(0.6705883f, 0.6705883f, 0.6705883f), new Color(0.5568628f, 0.5960785f, 0.6392157f), new Color(0.5568628f, 0.6235294f, 0.6f), new Color(0.6313726f, 0.6196079f, 0.5568628f), new Color(0.6980392f, 0.6509804f, 0.6196079f) }; public Color[] metalSecondary = { new Color(0.3921569f, 0.4039216f, 0.4117647f), new Color(0.4784314f, 0.5176471f, 0.5450981f), new Color(0.3764706f, 0.3607843f, 0.3372549f), new Color(0.3254902f, 0.3764706f, 0.3372549f), new Color(0.4f, 0.4039216f, 0.3568628f) }; [Header(\"Leather Colors\")] public Color[] leatherPrimary; public Color[] leatherSecondary; [Header(\"Skin Colors\")] public Color[] whiteSkin = { new Color(1f, 0.8000001f, 0.682353f) }; public Color[] brownSkin = { new Color(0.8196079f, 0.6352941f, 0.4588236f) }; public Color[] blackSkin = { new Color(0.5647059f, 0.4078432f, 0.3137255f) }; public Color[] elfSkin = { new Color(0.9607844f, 0.7843138f, 0.7294118f) }; [Header(\"Hair Colors\")] public Color[] whiteHair = { new Color(0.3098039f, 0.254902f, 0.1764706f), new Color(0.2196079f, 0.2196079f, 0.2196079f), new Color(0.8313726f, 0.6235294f, 0.3607843f), new Color(0.8901961f, 0.7803922f, 0.5490196f), new Color(0.8000001f, 0.8196079f, 0.8078432f), new Color(0.6862745f, 0.4f, 0.2352941f), new Color(0.5450981f, 0.427451f, 0.2156863f), new Color(0.8470589f, 0.4666667f, 0.2470588f) }; public Color whiteStubble = new Color(0.8039216f, 0.7019608f, 0.6313726f); public Color[] brownHair = { new Color(0.3098039f, 0.254902f, 0.1764706f), new Color(0.1764706f, 0.1686275f, 0.1686275f), new Color(0.3843138f, 0.2352941f, 0.0509804f), new Color(0.6196079f, 0.6196079f, 0.6196079f), new Color(0.6196079f, 0.6196079f, 0.6196079f) }; public Color brownStubble = new Color(0.6588235f, 0.572549f, 0.4627451f); public Color[] blackHair = { new Color(0.2431373f, 0.2039216f, 0.145098f), new Color(0.1764706f, 0.1686275f, 0.1686275f), new Color(0.1764706f, 0.1686275f, 0.1686275f) }; public Color blackStubble = new Color(0.3882353f, 0.2901961f, 0.2470588f); public Color[] elfHair = { new Color(0.9764706f, 0.9686275f, 0.9568628f), new Color(0.1764706f, 0.1686275f, 0.1686275f), new Color(0.8980393f, 0.7764707f, 0.6196079f) }; public Color elfStubble = new Color(0.8627452f, 0.7294118f, 0.6862745f); [Header(\"Scar Colors\")] public Color whiteScar = new Color(0.9294118f, 0.6862745f, 0.5921569f); public Color brownScar = new Color(0.6980392f, 0.5450981f, 0.4f); public Color blackScar = new Color(0.4235294f, 0.3176471f, 0.282353f); public Color elfScar = new Color(0.8745099f, 0.6588235f, 0.6313726f); [Header(\"Body Art Colors\")] public Color[] bodyArt = { new Color(0.0509804f, 0.6745098f, 0.9843138f), new Color(0.7215686f, 0.2666667f, 0.2666667f), new Color(0.3058824f, 0.7215686f, 0.6862745f), new Color(0.9254903f, 0.882353f, 0.8509805f), new Color(0.3098039f, 0.7058824f, 0.3137255f), new Color(0.5294118f, 0.3098039f, 0.6470588f), new Color(0.8666667f, 0.7764707f, 0.254902f), new Color(0.2392157f, 0.4588236f, 0.8156863f) }; // list of enabed objects on character [HideInInspector] public List<GameObject> enabledObjects = new List<GameObject>(); public bool IsMale => _gender == CharacterSkinData.Gender.Male; private CharacterSkinData.Gender _gender = CharacterSkinData.Gender.Male; [SerializeField] private byte[] _femaleArmLowerToHand; [SerializeField] private byte[] _maleArmLowerToHand; public HairColors[] GHairColors => _hairColors; private HairColors[] _hairColors = new HairColors[4]; public enum ColorTypes {White, Brown, Black, Elf} // character object lists // male list [HideInInspector] public CharacterObjectGroups male; // female list [HideInInspector] public CharacterObjectGroups female; // universal list public CharacterObjectListsAllGender allGender; [SerializeField] private bool _isShowBackAttachment = false; public enum BodyPart {Face, Beard, Hair, Eyebrow } public Dictionary<BodyPart, int> BodyPartSelectedIndex => _bodyPartSelectedIndex; private Dictionary<BodyPart, int> _bodyPartSelectedIndex = new Dictionary<BodyPart, int>(); public Action OnInitialized; public Action<int> OnGenderChanged; // randomize character creating button // void OnGUI() // { // if (GUI.Button(new Rect(10, 10, 150, 50), \"Randomize Character\")) // { // // call randomization method // Randomize(); // } // } private void Awake() { StoreAllComponents(); SetupHairColors(); // disable any enabled objects before clear if (enabledObjects.Count != 0) { foreach (GameObject g in enabledObjects) { g.SetActive(false); } } // clear enabled objects list enabledObjects.Clear(); //ActivateDefaultMale(); ActivateDefaultCharacter(); } private void Start() { //Randomize(); // if repeat on play is checked in the inspector, repeat the randomize method based on the shuffle speed, also defined in the inspector //if (repeatOnPlay) InvokeRepeating(\"Randomize\", shuffleSpeed, shuffleSpeed); OnInitialized?.Invoke(); } private void SetupHairColors() { int colorCount = System.Enum.GetNames(typeof(ColorTypes)).Length; for (int i = 0; i < colorCount; i++) { HairColors hairColors = new HairColors(); hairColors.colorType = (ColorTypes)i; switch (hairColors.colorType) { case ColorTypes.White: hairColors.colors = whiteHair; hairColors.stubColor = whiteStubble; break; case ColorTypes.Brown: hairColors.colors = brownHair; hairColors.stubColor = brownStubble; break; case ColorTypes.Black: hairColors.colors = blackHair; hairColors.stubColor = blackStubble; break; case ColorTypes.Elf: hairColors.colors = elfHair; hairColors.stubColor = elfStubble; break; } _hairColors[i] = (hairColors); } } public void ActivateDefaultCharacter() { HideAllBeards(); LoadFace(); ShowChest(0); switch (_gender) { case CharacterSkinData.Gender.Male: ActivateItem(male.arm_Upper_Right[0]); ActivateItem(male.arm_Upper_Left[0]); ActivateItem(male.arm_Lower_Right[0]); ActivateItem(male.arm_Lower_Left[0]); ActivateItem(male.hand_Right[0]); ActivateItem(male.hand_Left[0]); ActivateItem(male.hips[0]); ActivateItem(male.leg_Right[0]); ActivateItem(male.leg_Left[0]); break; case CharacterSkinData.Gender.Female: ActivateItem(female.arm_Upper_Right[0]); ActivateItem(female.arm_Upper_Left[0]); ActivateItem(female.arm_Lower_Right[0]); ActivateItem(female.arm_Lower_Left[0]); ActivateItem(female.hand_Right[0]); ActivateItem(female.hand_Left[0]); ActivateItem(female.hips[0]); ActivateItem(female.leg_Right[0]); ActivateItem(female.leg_Left[0]); break; } } private void ActivateDefaultMale() { ActivateItem(male.headAllElements[0]); ActivateItem(male.eyebrow[0]); ActivateItem(male.facialHair[0]); ActivateItem(male.torso[0]); ActivateItem(male.arm_Upper_Right[0]); ActivateItem(male.arm_Upper_Left[0]); ActivateItem(male.arm_Lower_Right[0]); ActivateItem(male.arm_Lower_Left[0]); ActivateItem(male.hand_Right[0]); ActivateItem(male.hand_Left[0]); ActivateItem(male.hips[0]); ActivateItem(male.leg_Right[0]); ActivateItem(male.leg_Left[0]); } // character randomization method public void Randomize() { Debug.Log($\"[CharacterRandomizer] Randomizing...\"); // initialize settings CharacterSkinData.Gender gender = CharacterSkinData.Gender.Male; Race race = Race.Human; SkinColor skinColor = SkinColor.White; Elements elements = Elements.Yes; HeadCovering headCovering = HeadCovering.HeadCoverings_Base_Hair; FacialHair facialHair = FacialHair.Yes; // disable any enabled objects before clear if (enabledObjects.Count != 0) { foreach (GameObject g in enabledObjects) { g.SetActive(false); } } // clear enabled objects list (all objects now disabled) enabledObjects.Clear(); // roll for gender if (!GetPercent(50)) gender = CharacterSkinData.Gender.Female; // roll for human (70% chance, 30% chance for elf) if (!GetPercent(70)) race = Race.Elf; // roll for facial elements (beard, eyebrows) if (!GetPercent(50)) elements = Elements.No; // select head covering 33% chance for each int headCoveringRoll = Random.Range(0, 100); // HeadCoverings_Base_Hair if (headCoveringRoll <= 33) headCovering = HeadCovering.HeadCoverings_Base_Hair; // HeadCoverings_No_FacialHair if (headCoveringRoll > 33 && headCoveringRoll < 66) headCovering = HeadCovering.HeadCoverings_No_FacialHair; // HeadCoverings_No_Hair if (headCoveringRoll >= 66) headCovering = HeadCovering.HeadCoverings_No_Hair; // select skin color if human, otherwise set skin color to elf switch (race) { case Race.Human: // select human skin 33% chance for each int colorRoll = Random.Range(0, 100); // select white skin if (colorRoll <= 33) skinColor = SkinColor.White; // select brown skin if (colorRoll > 33 && colorRoll < 66) skinColor = SkinColor.Brown; // select black skin if (colorRoll >= 66) skinColor = SkinColor.Black; break; case Race.Elf: // select elf skin skinColor = SkinColor.Elf; break; } //roll for gender switch (gender) { case CharacterSkinData.Gender.Male: // roll for facial hair if male if (!GetPercent(50)) facialHair = FacialHair.No; // initialize randomization RandomizeByVariable(male, gender, elements, race, facialHair, skinColor, headCovering); break; case CharacterSkinData.Gender.Female: // no facial hair if female facialHair = FacialHair.No; // initialize randomization RandomizeByVariable(female, gender, elements, race, facialHair, skinColor, headCovering); break; } } // randomization method based on previously selected variables void RandomizeByVariable(CharacterObjectGroups cog, CharacterSkinData.Gender gender, Elements elements, Race race, FacialHair facialHair, SkinColor skinColor, HeadCovering headCovering) { // if facial elements are enabled switch (elements) { case Elements.Yes: //select head with all elements if (cog.headAllElements.Count != 0) ActivateItem(cog.headAllElements[Random.Range(0, cog.headAllElements.Count)]); //select eyebrows if (cog.eyebrow.Count != 0) ActivateItem(cog.eyebrow[Random.Range(0, cog.eyebrow.Count)]); //select facial hair (conditional) if (cog.facialHair.Count != 0 && facialHair == FacialHair.Yes && gender == CharacterSkinData.Gender.Male && headCovering != HeadCovering.HeadCoverings_No_FacialHair) ActivateItem(cog.facialHair[Random.Range(0, cog.facialHair.Count)]); // select hair attachment switch (headCovering) { case HeadCovering.HeadCoverings_Base_Hair: // set hair attachment to index 1 if (allGender.all_Hair.Count != 0) ActivateItem(allGender.all_Hair[1]); if (allGender.headCoverings_Base_Hair.Count != 0) ActivateItem(allGender.headCoverings_Base_Hair[Random.Range(0, allGender.headCoverings_Base_Hair.Count)]); break; case HeadCovering.HeadCoverings_No_FacialHair: // no facial hair attachment if (allGender.all_Hair.Count != 0) ActivateItem(allGender.all_Hair[Random.Range(0, allGender.all_Hair.Count)]); if (allGender.headCoverings_No_FacialHair.Count != 0) ActivateItem(allGender.headCoverings_No_FacialHair[Random.Range(0, allGender.headCoverings_No_FacialHair.Count)]); break; case HeadCovering.HeadCoverings_No_Hair: // select hair attachment if (allGender.headCoverings_No_Hair.Count != 0) ActivateItem(allGender.all_Hair[Random.Range(0, allGender.all_Hair.Count)]); // if not human if (race != Race.Human) { // select elf ear attachment if (allGender.elf_Ear.Count != 0) ActivateItem(allGender.elf_Ear[Random.Range(0, allGender.elf_Ear.Count)]); } break; } break; case Elements.No: //select head with no elements if (cog.headNoElements.Count != 0) ActivateItem(cog.headNoElements[Random.Range(0, cog.headNoElements.Count)]); break; } // select torso starting at index 1 if (cog.torso.Count != 0) ActivateItem(cog.torso[Random.Range(1, cog.torso.Count)]); // determine chance for upper arms to be different and activate if (cog.arm_Upper_Right.Count != 0) RandomizeLeftRight(cog.arm_Upper_Right, cog.arm_Upper_Left, 15); // determine chance for lower arms to be different and activate if (cog.arm_Lower_Right.Count != 0) RandomizeLeftRight(cog.arm_Lower_Right, cog.arm_Lower_Left, 15); // determine chance for hands to be different and activate if (cog.hand_Right.Count != 0) RandomizeLeftRight(cog.hand_Right, cog.hand_Left, 15); // select hips starting at index 1 if (cog.hips.Count != 0) ActivateItem(cog.hips[Random.Range(1, cog.hips.Count)]); // determine chance for legs to be different and activate if (cog.leg_Right.Count != 0) RandomizeLeftRight(cog.leg_Right, cog.leg_Left, 15); // select chest attachment if (allGender.chest_Attachment.Count != 0) ActivateItem(allGender.chest_Attachment[Random.Range(0, allGender.chest_Attachment.Count)]); // select back attachment if (allGender.back_Attachment.Count != 0 && _isShowBackAttachment) ActivateItem(allGender.back_Attachment[Random.Range(0, allGender.back_Attachment.Count)]); // determine chance for shoulder attachments to be different and activate if (allGender.shoulder_Attachment_Right.Count != 0) RandomizeLeftRight(allGender.shoulder_Attachment_Right, allGender.shoulder_Attachment_Left, 10); // determine chance for elbow attachments to be different and activate if (allGender.elbow_Attachment_Right.Count != 0) RandomizeLeftRight(allGender.elbow_Attachment_Right, allGender.elbow_Attachment_Left, 10); // select hip attachment if (allGender.hips_Attachment.Count != 0) ActivateItem(allGender.hips_Attachment[Random.Range(0, allGender.hips_Attachment.Count)]); // determine chance for knee attachments to be different and activate if (allGender.knee_Attachement_Right.Count != 0) RandomizeLeftRight(allGender.knee_Attachement_Right, allGender.knee_Attachement_Left, 10); // start randomization of the random characters colors RandomizeColors(skinColor); } // handle randomization of the random characters colors void RandomizeColors(SkinColor skinColor) { // set skin and hair colors based on skin color roll switch (skinColor) { case SkinColor.White: // randomize and set white skin, hair, stubble, and scar color RandomizeAndSetHairSkinColors(\"White\", whiteSkin, whiteHair, whiteStubble, whiteScar); break; case SkinColor.Brown: // randomize and set brown skin, hair, stubble, and scar color RandomizeAndSetHairSkinColors(\"Brown\", brownSkin, brownHair, brownStubble, brownScar); break; case SkinColor.Black: // randomize and black elf skin, hair, stubble, and scar color RandomizeAndSetHairSkinColors(\"Black\", blackSkin, blackHair, blackStubble, blackScar); break; case SkinColor.Elf: // randomize and set elf skin, hair, stubble, and scar color RandomizeAndSetHairSkinColors(\"Elf\", elfSkin, elfHair, elfStubble, elfScar); break; } // randomize and set primary color if (primary.Length != 0) mat.SetColor(\"_Color_Primary\", primary[Random.Range(0, primary.Length)]); else Debug.Log(\"No Primary Colors Specified In The Inspector\"); // randomize and set secondary color if (secondary.Length != 0) mat.SetColor(\"_Color_Secondary\", secondary[Random.Range(0, secondary.Length)]); else Debug.Log(\"No Secondary Colors Specified In The Inspector\"); // randomize and set primary metal color if (metalPrimary.Length != 0) mat.SetColor(\"_Color_Metal_Primary\", metalPrimary[Random.Range(0, metalPrimary.Length)]); else Debug.Log(\"No Primary Metal Colors Specified In The Inspector\"); // randomize and set secondary metal color if (metalSecondary.Length != 0) mat.SetColor(\"_Color_Metal_Secondary\", metalSecondary[Random.Range(0, metalSecondary.Length)]); else Debug.Log(\"No Secondary Metal Colors Specified In The Inspector\"); // randomize and set primary leather color if (leatherPrimary.Length != 0) mat.SetColor(\"_Color_Leather_Primary\", leatherPrimary[Random.Range(0, leatherPrimary.Length)]); else Debug.Log(\"No Primary Leather Colors Specified In The Inspector\"); // randomize and set secondary leather color if (leatherSecondary.Length != 0) mat.SetColor(\"_Color_Leather_Secondary\", leatherSecondary[Random.Range(0, leatherSecondary.Length)]); else Debug.Log(\"No Secondary Leather Colors Specified In The Inspector\"); // randomize and set body art color if (bodyArt.Length != 0) SetBodyArtColor(bodyArt[Random.Range(0, bodyArt.Length)]); else Debug.Log(\"No Body Art Colors Specified In The Inspector\"); // randomize and set body art amount mat.SetFloat(\"_BodyArt_Amount\", Random.Range(0.0f, 1.0f)); } public CharacterSkinData GetSkinData() { if (skinData == null) skinData = new CharacterSkinData(); return skinData; } public void SetSkinData(CharacterSkinData data) { string gameObjectName = gameObject.name; if (transform.parent != null) gameObjectName = transform.parent.name; Debug.Log($\"[CharacterSkinController] {gameObjectName} SetSkinData({data.ToString()})\"); skinData = data; bool isMale = data.genderId == 0; ChangeGender(isMale); SetSkinColor(data.skinColorId); SetHairColor(data.hairColorId); if (isMale) SetBeard(data.beardId); SetBodyArtColor(data.bodyArtId); SetFace(data.faceId); SetHair(data.hairId); } public void SetHairColor(int colorIndex) { Debug.Log($\"[CharacterSkinController] SetHairColor({colorIndex})\"); Color stubbleColor = _hairColors[0].stubColor; int[] len = new int[4]; for (int i = 0; i < 4; i++) { len[i] = _hairColors[i].colors.Length; } int cumulativeLen = 0; for (int i = 0; i < 4; i++) { cumulativeLen += len[i]; if (colorIndex < cumulativeLen) { stubbleColor = _hairColors[i].stubColor; SetHairColor(_hairColors[i].colors[colorIndex - (cumulativeLen - len[i])]); CharacterSkinData skinData = GetSkinData(); skinData.hairColorId = colorIndex; break; } } SetStubbleColor(stubbleColor); } public void SetHairColor(Color color) { mat.SetColor(\"_Color_Hair\", color); } public void SetSkinColor(int id) { Debug.Log($\"[CharacterSkinController] SetSkinColor({id})\"); CharacterSkinData skinData = GetSkinData(); skinData.skinColorId = id; switch (id) { case 0: SetSkinColor(whiteSkin[0]); SetScarColor(whiteScar); break; case 1: SetSkinColor(brownSkin[0]); SetScarColor(brownScar); break; case 2: SetSkinColor(blackSkin[0]); SetScarColor(blackScar); break; case 3: SetSkinColor(elfSkin[0]); SetScarColor(elfScar); break; } } public void SetSkinColor(Color color) { mat.SetColor(\"_Color_Skin\", color); } public void SetScarColor(Color scar) { Debug.Log($\"[CharacterSkinController] SetScarColor({scar})\"); mat.SetColor(\"_Color_Scar\", scar); } public void SetStubbleColor(Color stubble) { mat.SetColor(\"_Color_Stubble\", stubble); } public void SetBodyArtColor(int index) { Debug.Log($\"[CharacterSkinController] SetBodyArtColor({index})\"); SetBodyArtColor(bodyArt[index]); CharacterSkinData skinData = GetSkinData(); skinData.bodyArtId = index; } private void SetBodyArtColor(Color bodyArtColor) { mat.SetColor(\"_Color_BodyArt\", bodyArtColor); } void RandomizeAndSetHairSkinColors(string info, Color[] skin, Color[] hair, Color stubble, Color scar) { // randomize and set elf skin color if (skin.Length != 0) { SetSkinColor(skin[Random.Range(0, skin.Length)]); } else { Debug.Log(\"No \" + info + \" Skin Colors Specified In The Inspector\"); } // randomize and set elf hair color if (hair.Length != 0) { SetHairColor(hair[Random.Range(0, hair.Length)]); } else { Debug.Log(\"No \" + info + \" Hair Colors Specified In The Inspector\"); } // set stubble color SetStubbleColor(stubble); // set scar color SetScarColor(scar); } // method for handling the chance of left/right items to be differnt (such as shoulders, hands, legs, arms) void RandomizeLeftRight(List<GameObject> objectListRight, List<GameObject> objectListLeft, int rndPercent) { // rndPercent = chance for left item to be different // stored right index int index = Random.Range(0, objectListRight.Count); // enable item from list using index ActivateItem(objectListRight[index]); // roll for left item mismatch, if true randomize index based on left item list if (GetPercent(rndPercent)) index = Random.Range(0, objectListLeft.Count); // enable left item from list using index ActivateItem(objectListLeft[index]); } // enable game object and add it to the enabled objects list void ActivateItem(GameObject go) { // enable item go.SetActive(true); // add item to the enabled items list enabledObjects.Add(go); } public void ActivateHeadCovering(byte race, HeadCovering headCovering, byte index) { switch (headCovering) { case HeadCovering.HeadCoverings_Base_Hair: // set hair attachment to index 1 if (allGender.all_Hair.Count != 0) ActivateItem(allGender.all_Hair[1]); if (allGender.headCoverings_Base_Hair.Count != 0) ActivateItem(allGender.headCoverings_Base_Hair[index]); break; case HeadCovering.HeadCoverings_No_FacialHair: // no facial hair attachment if (allGender.all_Hair.Count != 0) ActivateItem(allGender.all_Hair[Random.Range(0, allGender.all_Hair.Count)]); if (allGender.headCoverings_No_FacialHair.Count != 0) ActivateItem(allGender.headCoverings_No_FacialHair[index]); break; case HeadCovering.HeadCoverings_No_Hair: // select hair attachment if (allGender.headCoverings_No_Hair.Count != 0) ActivateItem(allGender.all_Hair[Random.Range(0, allGender.all_Hair.Count)]); // if elf if (race == 1) { // select elf ear attachment if (allGender.elf_Ear.Count != 0) ActivateItem(allGender.elf_Ear[Random.Range(0, allGender.elf_Ear.Count)]); } break; } } Color ConvertColor(int r, int g, int b) { return new Color(r / 255.0f, g / 255.0f, b / 255.0f, 1); } // method for rolling percentages (returns true/false) bool GetPercent(int pct) { bool p = false; int roll = Random.Range(0, 100); if (roll <= pct) { p = true; } return p; } // build all item lists for use in randomization private void StoreAllComponents() { //build out male lists BuildList(male.headAllElements, \"Male_Head_All_Elements\");//face with tattoos BuildList(male.headNoElements, \"Male_Head_No_Elements\");//only helmets BuildList(male.eyebrow, \"Male_01_Eyebrows\"); BuildList(male.facialHair, \"Male_02_FacialHair\"); BuildList(male.torso, \"Male_03_Torso\"); BuildList(male.arm_Upper_Right, \"Male_04_Arm_Upper_Right\"); BuildList(male.arm_Upper_Left, \"Male_05_Arm_Upper_Left\"); BuildList(male.arm_Lower_Right, \"Male_06_Arm_Lower_Right\"); BuildList(male.arm_Lower_Left, \"Male_07_Arm_Lower_Left\"); BuildList(male.hand_Right, \"Male_08_Hand_Right\"); BuildList(male.hand_Left, \"Male_09_Hand_Left\"); BuildList(male.hips, \"Male_10_Hips\"); BuildList(male.leg_Right, \"Male_11_Leg_Right\"); BuildList(male.leg_Left, \"Male_12_Leg_Left\"); //build out female lists BuildList(female.headAllElements, \"Female_Head_All_Elements\");//face with tattoos BuildList(female.headNoElements, \"Female_Head_No_Elements\");//only helmets BuildList(female.eyebrow, \"Female_01_Eyebrows\"); BuildList(female.facialHair, \"Female_02_FacialHair\"); BuildList(female.torso, \"Female_03_Torso\"); BuildList(female.arm_Upper_Right, \"Female_04_Arm_Upper_Right\"); BuildList(female.arm_Upper_Left, \"Female_05_Arm_Upper_Left\"); BuildList(female.arm_Lower_Right, \"Female_06_Arm_Lower_Right\"); BuildList(female.arm_Lower_Left, \"Female_07_Arm_Lower_Left\"); BuildList(female.hand_Right, \"Female_08_Hand_Right\"); BuildList(female.hand_Left, \"Female_09_Hand_Left\"); BuildList(female.hips, \"Female_10_Hips\"); BuildList(female.leg_Right, \"Female_11_Leg_Right\"); BuildList(female.leg_Left, \"Female_12_Leg_Left\"); // build out all gender lists BuildList(allGender.all_Hair, \"All_01_Hair\"); BuildList(allGender.all_Head_Attachment, \"All_02_Head_Attachment\");//tails, cosmetics BuildList(allGender.headCoverings_Base_Hair, \"HeadCoverings_Base_Hair\"); BuildList(allGender.headCoverings_No_FacialHair, \"HeadCoverings_No_FacialHair\"); BuildList(allGender.headCoverings_No_Hair, \"HeadCoverings_No_Hair\"); BuildList(allGender.chest_Attachment, \"All_03_Chest_Attachment\"); BuildList(allGender.back_Attachment, \"All_04_Back_Attachment\"); BuildList(allGender.shoulder_Attachment_Right, \"All_05_Shoulder_Attachment_Right\"); BuildList(allGender.shoulder_Attachment_Left, \"All_06_Shoulder_Attachment_Left\"); BuildList(allGender.elbow_Attachment_Right, \"All_07_Elbow_Attachment_Right\"); BuildList(allGender.elbow_Attachment_Left, \"All_08_Elbow_Attachment_Left\"); BuildList(allGender.hips_Attachment, \"All_09_Hips_Attachment\"); BuildList(allGender.knee_Attachement_Right, \"All_10_Knee_Attachement_Right\"); BuildList(allGender.knee_Attachement_Left, \"All_11_Knee_Attachement_Left\"); BuildList(allGender.elf_Ear, \"Elf_Ear\"); } public int GetOrCreateBodyPartIndex(BodyPart bodyPart) { if (!BodyPartSelectedIndex.ContainsKey(bodyPart)) { _bodyPartSelectedIndex.Add(bodyPart, 0); } return BodyPartSelectedIndex[bodyPart]; } public void SetFace(int index) { Debug.Log($\"[CharacterSkin] SetFace {index}\"); HideAllFaces(); if (_gender == CharacterSkinData.Gender.Male) { male.headAllElements[index].SetActive(true); } else { female.headAllElements[index].SetActive(true); } CharacterSkinData skinData = GetSkinData(); skinData.faceId = index; _bodyPartSelectedIndex[BodyPart.Face] = index; } public void SetBeard(int id) { Debug.Log($\"[CharacterSkin] SetBeard {id}\"); HideAllBeards(); male.facialHair[id].SetActive(true); CharacterSkinData skinData = GetSkinData(); skinData.beardId = id; } private void HideAllBeards() { HideAllElements(male.facialHair); } public void SetHair(int index) { Debug.Log($\"[CharacterSkin] SetHair {index}\"); HideAllHair(); ActivateItem(allGender.all_Hair[index]); var skinData = GetSkinData(); skinData.hairId = index; } public void ChangeGender(bool isMale) { bool isChanged = false; if (isMale) { if (_gender == CharacterSkinData.Gender.Female) { isChanged = true; } } else { if (_gender == CharacterSkinData.Gender.Male) { isChanged = true; } } if (isChanged) { Debug.Log($\"[CharacterSkin] Gender is changed to {isMale}\"); _gender = isMale ? CharacterSkinData.Gender.Male : CharacterSkinData.Gender.Female; ActivateDefaultCharacter(); CharacterSkinData skinData = GetSkinData(); skinData.genderId = (int)_gender; OnGenderChanged?.Invoke((int)_gender); } } private void HideAllHair() { HideAllElements(allGender.all_Hair); } public void HideAllShoulders() { HideAllElements(allGender.shoulder_Attachment_Right); HideAllElements(allGender.shoulder_Attachment_Left); } public void HideAllHelmets() { HideAllElements(allGender.all_Head_Attachment); if (_gender == CharacterSkinData.Gender.Male) { HideAllElements(male.headNoElements); } else { HideAllElements(female.headNoElements); } } public void HideAllFaces() { HideAllElements(male.headAllElements); HideAllElements(female.headAllElements); } private void HideAllElements(List<GameObject> targetList) { foreach (var go in targetList) { if (go.activeSelf) go.SetActive(false); } } public void HideAllChests() { DebugWrite.Log($\"[CharacterSkin] HideAllChests\"); HideAllElements(male.torso); HideAllElements(female.torso); } public void ShowShoulder(int id) { DebugWrite.Log($\"[CharacterSkin] ShowShoulder {id}\"); HideAllShoulders(); if (id < 0) return; allGender.shoulder_Attachment_Right[id].SetActive(true); allGender.shoulder_Attachment_Left[id].SetActive(true); } public void ShowChest(int id) { DebugWrite.Log($\"[CharacterSkin] ShowChest {id}\"); if (id < 0) id = 0; HideAllChests(); switch (_gender) { case CharacterSkinData.Gender.Female: female.torso[id].SetActive(true); break; case CharacterSkinData.Gender.Male: male.torso[id].SetActive(true); break; } } public void ShowHelmet(int id) { DebugWrite.Log($\"[CharacterSkin] ShowHeadHelmet {id}\"); if (id == -1) { LoadFace(); } else { HideAllFaces(); HideAllHelmets(); switch (_gender) { case CharacterSkinData.Gender.Female: female.headNoElements[id].SetActive(true); break; case CharacterSkinData.Gender.Male: male.headNoElements[id].SetActive(true); break; } } } /// <summary> /// allGender.elbow_Attachment_Right /// </summary> /// <param name=\"id\"></param> public void ShowWrist(int id) { DebugWrite.Log($\"[CharacterSkin] ShowWrist {id}\"); HideAllElements(allGender.elbow_Attachment_Right); HideAllElements(allGender.elbow_Attachment_Left); if (id < 0) return; allGender.elbow_Attachment_Right[id].SetActive(true); } public void ShowHands(int id) { DebugWrite.Log($\"[CharacterSkin] ShowHands {id}\"); HideAllElements(male.arm_Lower_Right); HideAllElements(male.arm_Lower_Left); HideAllElements(female.arm_Lower_Right); HideAllElements(female.arm_Lower_Left); if (_gender == CharacterSkinData.Gender.Male) { male.arm_Lower_Right[id].SetActive(true); male.arm_Lower_Left[id].SetActive(true); ShowCorrespondingHand(id); } else { female.arm_Lower_Right[id].SetActive(true); female.arm_Lower_Left[id].SetActive(true); } } public void ShowHips(int id) { } public void ShowAmulet(int id) { } public void ShowBoots(int id) { } private void ShowCorrespondingHand(int id) { HideAllElements(male.hand_Right); HideAllElements(male.hand_Left); HideAllElements(female.hand_Right); HideAllElements(female.hand_Left); if (_gender == CharacterSkinData.Gender.Male) { int handId = _maleArmLowerToHand[id]; male.hand_Right[handId].SetActive(true); male.hand_Left[handId].SetActive(true); } else { int handId = _femaleArmLowerToHand[id]; female.hand_Right[handId].SetActive(true); female.hand_Left[handId].SetActive(true); } } private void LoadFace() { HideAllFaces(); int indexFace = GetOrCreateBodyPartIndex(BodyPart.Face); int indexBeard = GetOrCreateBodyPartIndex(BodyPart.Beard); int indexEyebrow = GetOrCreateBodyPartIndex(BodyPart.Eyebrow); switch (_gender) { case CharacterSkinData.Gender.Male: LoadBeard(indexBeard); indexEyebrow = Math.Min(male.eyebrow.Count, indexEyebrow); ActivateItem(male.eyebrow[indexEyebrow]); ActivateItem(male.headAllElements[indexFace]); break; case CharacterSkinData.Gender.Female: indexEyebrow = Math.Min(female.eyebrow.Count, indexEyebrow); ActivateItem(female.eyebrow[indexEyebrow]); ActivateItem(female.headAllElements[indexFace]); break; } } private void LoadBeard(int index) { ActivateItem(male.facialHair[index]); } // called from the BuildLists method void BuildList(List<GameObject> targetList, string characterPart) { Transform[] rootTransform = gameObject.GetComponentsInChildren<Transform>(); // declare target root transform Transform targetRoot = null; // find character parts parent object in the scene foreach (Transform t in rootTransform) { if (t.gameObject.name == characterPart) { targetRoot = t; break; } } // clears targeted list of all objects targetList.Clear(); // cycle through all child objects of the parent object for (int i = 0; i < targetRoot.childCount; i++) { // get child gameobject index i GameObject go = targetRoot.GetChild(i).gameObject; // disable child object go.SetActive(false); // add object to the targeted object list targetList.Add(go); // collect the material for the random character, only if null in the inspector; if (!mat) { if (go.GetComponent<SkinnedMeshRenderer>()) mat = go.GetComponent<SkinnedMeshRenderer>().material; } } } } public enum Gender { Male, Female } public enum Race { Human, Elf } public enum SkinColor { White, Brown, Black, Elf } public enum Elements { Yes, No } public enum HeadCovering { HeadCoverings_Base_Hair, HeadCoverings_No_FacialHair, HeadCoverings_No_Hair } public enum SkinParts: byte {Race, HeadCoveringBaseHair, HeadCoveringNoFacialHair, HeadCoveringNoHair, AllHair, AllHeadAttachment, ChestAttachment, BackAttachment, ShoulderAttachmentRight, ShoulderAttachmentLeft, ElbowAttachmentRight, ElbowAttachmentLeft, HipsAttachment, KneeAttachmentRight, KneeAttachmentLeft, ElfEar } public enum FacialHair { Yes, No } // classe for keeping the lists organized, allows for simple switching from male/female objects [System.Serializable] public class CharacterObjectGroups { public List<GameObject> headAllElements; public List<GameObject> headNoElements; public List<GameObject> eyebrow; public List<GameObject> facialHair; public List<GameObject> torso; public List<GameObject> arm_Upper_Right; public List<GameObject> arm_Upper_Left; public List<GameObject> arm_Lower_Right; public List<GameObject> arm_Lower_Left; public List<GameObject> hand_Right; public List<GameObject> hand_Left; public List<GameObject> hips; public List<GameObject> leg_Right; public List<GameObject> leg_Left; } // classe for keeping the lists organized, allows for organization of the all gender items [System.Serializable] public class CharacterObjectListsAllGender { public List<GameObject> headCoverings_Base_Hair; public List<GameObject> headCoverings_No_FacialHair; public List<GameObject> headCoverings_No_Hair; public List<GameObject> all_Hair; public List<GameObject> all_Head_Attachment; public List<GameObject> chest_Attachment; public List<GameObject> back_Attachment; public List<GameObject> shoulder_Attachment_Right; public List<GameObject> shoulder_Attachment_Left; public List<GameObject> elbow_Attachment_Right; public List<GameObject> elbow_Attachment_Left; public List<GameObject> hips_Attachment; public List<GameObject> knee_Attachement_Right; public List<GameObject> knee_Attachement_Left; public List<GameObject> all_12_Extra; public List<GameObject> elf_Ear; } /* If one of these values change you * probably don't want to send the * entire container. A custom SyncObject * is perfect for only sending what is changed. */ [Serializable] public struct SkinPartSetting { public SkinParts Part; public byte Index; public SkinPartSetting(byte part, byte index) { Part = (SkinParts)part; Index = index; } } public class HairColors { public CharacterSkin.ColorTypes colorType; public Color[] colors; public Color stubColor; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "using System; using System.Collections.Generic; using DungeonScrollerCore; using UnityEngine; using Random = UnityEngine.Random; namespace Character { public class CharacterSkin : MonoBehaviour { public CharacterSkinData skinData; [Header(\"Demo Settings\")] public bool repeatOnPlay = false; public float shuffleSpeed = 0.7f; [Header(\"Material\")] public Material mat; [Header(\"Gear Colors\")] public Color[] primary = { new Color(0.2862745f, 0.4f, 0.4941177f), new Color(0.4392157f, 0.1960784f, 0.172549f), new Color(0.3529412f, 0.3803922f, 0.2705882f), new Color(0.682353f, 0.4392157f, 0.2196079f), new Color(0.4313726f, 0.2313726f, 0.2705882f), new Color(0.5921569f, 0.4941177f, 0.2588235f), new Color(0.482353f, 0.4156863f, 0.3529412f), new Color(0.2352941f, 0.2352941f, 0.2352941f), new Color(0.2313726f, 0.4313726f, 0.4156863f) }; public Color[] secondary = { new Color(0.7019608f, 0.6235294f, 0.4666667f), new Color(0.7372549f, 0.7372549f, 0.7372549f), new Color(0.1647059f, 0.1647059f, 0.1647059f), new Color(0.2392157f, 0.2509804f, 0.1882353f) }; [Header(\"Metal Colors\")] public Color[] metalPrimary = { new Color(0.6705883f, 0.6705883f, 0.6705883f), new Color(0.5568628f, 0.5960785f, 0.6392157f), new Color(0.5568628f, 0.6235294f, 0.6f), new Color(0.6313726f, 0.6196079f, 0.5568628f), new Color(0.6980392f, 0.6509804f, 0.6196079f) }; public Color[] metalSecondary = { new Color(0.3921569f, 0.4039216f, 0.4117647f), new Color(0.4784314f, 0.5176471f, 0.5450981f), new Color(0.3764706f, 0.3607843f, 0.3372549f), new Color(0.3254902f, 0.3764706f, 0.3372549f), new Color(0.4f, 0.4039216f, 0.3568628f) }; [Header(\"Leather Colors\")] public Color[] leatherPrimary; public Color[] leatherSecondary; [Header(\"Skin Colors\")] public Color[] whiteSkin = { new Color(1f, 0.8000001f, 0.682353f) }; public Color[] brownSkin = { new Color(0.8196079f, 0.6352941f, 0.4588236f) }; public Color[] blackSkin = { new Color(0.5647059f, 0.4078432f, 0.3137255f) }; public Color[] elfSkin = { new Color(0.9607844f, 0.7843138f, 0.7294118f) }; [Header(\"Hair Colors\")] public Color[] whiteHair = { new Color(0.3098039f, 0.254902f, 0.1764706f), new Color(0.2196079f, 0.2196079f, 0.2196079f), new Color(0.8313726f, 0.6235294f, 0.3607843f), new Color(0.8901961f, 0.7803922f, 0.5490196f), new Color(0.8000001f, 0.8196079f, 0.8078432f), new Color(0.6862745f, 0.4f, 0.2352941f), new Color(0.5450981f, 0.427451f, 0.2156863f), new Color(0.8470589f, 0.4666667f, 0.2470588f) }; public Color whiteStubble = new Color(0.8039216f, 0.7019608f, 0.6313726f); public Color[] brownHair = { new Color(0.3098039f, 0.254902f, 0.1764706f), new Color(0.1764706f, 0.1686275f, 0.1686275f), new Color(0.3843138f, 0.2352941f, 0.0509804f), new Color(0.6196079f, 0.6196079f, 0.6196079f), new Color(0.6196079f, 0.6196079f, 0.6196079f) }; public Color brownStubble = new Color(0.6588235f, 0.572549f, 0.4627451f); public Color[] blackHair = { new Color(0.2431373f, 0.2039216f, 0.145098f), new Color(0.1764706f, 0.1686275f, 0.1686275f), new Color(0.1764706f, 0.1686275f, 0.1686275f) }; public Color blackStubble = new Color(0.3882353f, 0.2901961f, 0.2470588f); public Color[] elfHair = { new Color(0.9764706f, 0.9686275f, 0.9568628f), new Color(0.1764706f, 0.1686275f, 0.1686275f), new Color(0.8980393f, 0.7764707f, 0.6196079f) }; public Color elfStubble = new Color(0.8627452f, 0.7294118f, 0.6862745f); [Header(\"Scar Colors\")] public Color whiteScar = new Color(0.9294118f, 0.6862745f, 0.5921569f); public Color brownScar = new Color(0.6980392f, 0.5450981f, 0.4f); public Color blackScar = new Color(0.4235294f, 0.3176471f, 0.282353f); public Color elfScar = new Color(0.8745099f, 0.6588235f, 0.6313726f); [Header(\"Body Art Colors\")] public Color[] bodyArt = { new Color(0.0509804f, 0.6745098f, 0.9843138f), new Color(0.7215686f, 0.2666667f, 0.2666667f), new Color(0.3058824f, 0.7215686f, 0.6862745f), new Color(0.9254903f, 0.882353f, 0.8509805f), new Color(0.3098039f, 0.7058824f, 0.3137255f), new Color(0.5294118f, 0.3098039f, 0.6470588f), new Color(0.8666667f, 0.7764707f, 0.254902f), new Color(0.2392157f, 0.4588236f, 0.8156863f) }; // list of enabed objects on character [HideInInspector] public List<GameObject> enabledObjects = new List<GameObject>(); public bool IsMale => _gender == CharacterSkinData.Gender.Male; private CharacterSkinData.Gender _gender = CharacterSkinData.Gender.Male; [SerializeField] private byte[] _femaleArmLowerToHand; [SerializeField] private byte[] _maleArmLowerToHand; public HairColors[] GHairColors => _hairColors; private HairColors[] _hairColors = new HairColors[4]; public enum ColorTypes {White, Brown, Black, Elf} // character object lists // male list [HideInInspector] public CharacterObjectGroups male; // female list [HideInInspector] public CharacterObjectGroups female; // universal list public CharacterObjectListsAllGender allGender; [SerializeField] private bool _isShowBackAttachment = false; public enum BodyPart {Face, Beard, Hair, Eyebrow } public Dictionary<BodyPart, int> BodyPartSelectedIndex => _bodyPartSelectedIndex; private Dictionary<BodyPart, int> _bodyPartSelectedIndex = new Dictionary<BodyPart, int>(); public Action OnInitialized; public Action<int> OnGenderChanged; // randomize character creating button // void OnGUI() // { // if (GUI.Button(new Rect(10, 10, 150, 50), \"Randomize Character\")) // { // // call randomization method // Randomize(); // } //  ",
          "content_tokens": 2121,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "private void Awake() { StoreAllComponents(); SetupHairColors(); // disable any enabled objects before clear if (enabledObjects.Count != 0) { foreach (GameObject g in enabledObjects) { g.SetActive(false); } } // clear enabled objects list enabledObjects.Clear(); //ActivateDefaultMale(); ActivateDefaultCharacter();  private void Start() { //Randomize(); // if repeat on play is checked in the inspector, repeat the randomize method based on the shuffle speed, also defined in the inspector //if (repeatOnPlay) InvokeRepeating(\"Randomize\", shuffleSpeed, shuffleSpeed); OnInitialized?.Invoke();  ",
          "content_tokens": 144,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "private void SetupHairColors() { int colorCount = System.Enum.GetNames(typeof(ColorTypes)).Length; for (int i = 0; i < colorCount; i++) { HairColors hairColors = new HairColors(); hairColors.colorType = (ColorTypes)i; switch (hairColors.colorType) { case ColorTypes.White: hairColors.colors = whiteHair; hairColors.stubColor = whiteStubble; break; case ColorTypes.Brown: hairColors.colors = brownHair; hairColors.stubColor = brownStubble; break; case ColorTypes.Black: hairColors.colors = blackHair; hairColors.stubColor = blackStubble; break; case ColorTypes.Elf: hairColors.colors = elfHair; hairColors.stubColor = elfStubble; break; } _hairColors[i] = (hairColors); }  ",
          "content_tokens": 224,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "public void ActivateDefaultCharacter() { HideAllBeards(); LoadFace(); ShowChest(0); switch (_gender) { case CharacterSkinData.Gender.Male: ActivateItem(male.arm_Upper_Right[0]); ActivateItem(male.arm_Upper_Left[0]); ActivateItem(male.arm_Lower_Right[0]); ActivateItem(male.arm_Lower_Left[0]); ActivateItem(male.hand_Right[0]); ActivateItem(male.hand_Left[0]); ActivateItem(male.hips[0]); ActivateItem(male.leg_Right[0]); ActivateItem(male.leg_Left[0]); break; case CharacterSkinData.Gender.Female: ActivateItem(female.arm_Upper_Right[0]); ActivateItem(female.arm_Upper_Left[0]); ActivateItem(female.arm_Lower_Right[0]); ActivateItem(female.arm_Lower_Left[0]); ActivateItem(female.hand_Right[0]); ActivateItem(female.hand_Left[0]); ActivateItem(female.hips[0]); ActivateItem(female.leg_Right[0]); ActivateItem(female.leg_Left[0]); break; }  ",
          "content_tokens": 264,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "private void ActivateDefaultMale() { ActivateItem(male.headAllElements[0]); ActivateItem(male.eyebrow[0]); ActivateItem(male.facialHair[0]); ActivateItem(male.torso[0]); ActivateItem(male.arm_Upper_Right[0]); ActivateItem(male.arm_Upper_Left[0]); ActivateItem(male.arm_Lower_Right[0]); ActivateItem(male.arm_Lower_Left[0]); ActivateItem(male.hand_Right[0]); ActivateItem(male.hand_Left[0]); ActivateItem(male.hips[0]); ActivateItem(male.leg_Right[0]); ActivateItem(male.leg_Left[0]); } // character randomization method public void Randomize() { Debug.Log($\"[CharacterRandomizer] Randomizing...\"); // initialize settings CharacterSkinData.Gender gender = CharacterSkinData.Gender.Male; Race race = Race.Human; SkinColor skinColor = SkinColor.White; Elements elements = Elements.Yes; HeadCovering headCovering = HeadCovering.HeadCoverings_Base_Hair; FacialHair facialHair = FacialHair.Yes; // disable any enabled objects before clear if (enabledObjects.Count != 0) { foreach (GameObject g in enabledObjects) { g.SetActive(false); } } // clear enabled objects list (all objects now disabled) enabledObjects.Clear(); // roll for gender if (!GetPercent(50)) gender = CharacterSkinData.Gender.Female; // roll for human (70% chance, 30% chance for elf) if (!GetPercent(70)) race = Race.Elf; // roll for facial elements (beard, eyebrows) if (!GetPercent(50)) elements = Elements.No; // select head covering 33% chance for each int headCoveringRoll = Random.Range(0, 100); // HeadCoverings_Base_Hair if (headCoveringRoll <= 33) headCovering = HeadCovering.HeadCoverings_Base_Hair; // HeadCoverings_No_FacialHair if (headCoveringRoll > 33 && headCoveringRoll < 66) headCovering = HeadCovering.HeadCoverings_No_FacialHair; // HeadCoverings_No_Hair if (headCoveringRoll >= 66) headCovering = HeadCovering.HeadCoverings_No_Hair; // select skin color if human, otherwise set skin color to elf switch (race) { case Race.Human: // select human skin 33% chance for each int colorRoll = Random.Range(0, 100); // select white skin if (colorRoll <= 33) skinColor = SkinColor.White; // select brown skin if (colorRoll > 33 && colorRoll < 66) skinColor = SkinColor.Brown; // select black skin if (colorRoll >= 66) skinColor = SkinColor.Black; break; case Race.Elf: // select elf skin skinColor = SkinColor.Elf; break; } //roll for gender switch (gender) { case CharacterSkinData.Gender.Male: // roll for facial hair if male if (!GetPercent(50)) facialHair = FacialHair.No; // initialize randomization RandomizeByVariable(male, gender, elements, race, facialHair, skinColor, headCovering); break; case CharacterSkinData.Gender.Female: // no facial hair if female facialHair = FacialHair.No; // initialize randomization RandomizeByVariable(female, gender, elements, race, facialHair, skinColor, headCovering); break; } } // randomization method based on previously selected variables void RandomizeByVariable(CharacterObjectGroups cog, CharacterSkinData.Gender gender, Elements elements, Race race, FacialHair facialHair, SkinColor skinColor, HeadCovering headCovering) { // if facial elements are enabled switch (elements) { case Elements.Yes: //select head with all elements if (cog.headAllElements.Count != 0) ActivateItem(cog.headAllElements[Random.Range(0, cog.headAllElements.Count)]); //select eyebrows if (cog.eyebrow.Count != 0) ActivateItem(cog.eyebrow[Random.Range(0, cog.eyebrow.Count)]); //select facial hair (conditional) if (cog.facialHair.Count != 0 && facialHair == FacialHair.Yes && gender == CharacterSkinData.Gender.Male && headCovering != HeadCovering.HeadCoverings_No_FacialHair) ActivateItem(cog.facialHair[Random.Range(0, cog.facialHair.Count)]); // select hair attachment switch (headCovering) { case HeadCovering.HeadCoverings_Base_Hair: // set hair attachment to index 1 if (allGender.all_Hair.Count != 0) ActivateItem(allGender.all_Hair[1]); if (allGender.headCoverings_Base_Hair.Count != 0) ActivateItem(allGender.headCoverings_Base_Hair[Random.Range(0, allGender.headCoverings_Base_Hair.Count)]); break; case HeadCovering.HeadCoverings_No_FacialHair: // no facial hair attachment if (allGender.all_Hair.Count != 0) ActivateItem(allGender.all_Hair[Random.Range(0, allGender.all_Hair.Count)]); if (allGender.headCoverings_No_FacialHair.Count != 0) ActivateItem(allGender.headCoverings_No_FacialHair[Random.Range(0, allGender.headCoverings_No_FacialHair.Count)]); break; case HeadCovering.HeadCoverings_No_Hair: // select hair attachment if (allGender.headCoverings_No_Hair.Count != 0) ActivateItem(allGender.all_Hair[Random.Range(0, allGender.all_Hair.Count)]); // if not human if (race != Race.Human) { // select elf ear attachment if (allGender.elf_Ear.Count != 0) ActivateItem(allGender.elf_Ear[Random.Range(0, allGender.elf_Ear.Count)]); } break; } break; case Elements.No: //select head with no elements if (cog.headNoElements.Count != 0) ActivateItem(cog.headNoElements[Random.Range(0, cog.headNoElements.Count)]); break; } // select torso starting at index 1 if (cog.torso.Count != 0) ActivateItem(cog.torso[Random.Range(1, cog.torso.Count)]); // determine chance for upper arms to be different and activate if (cog.arm_Upper_Right.Count != 0) RandomizeLeftRight(cog.arm_Upper_Right, cog.arm_Upper_Left, 15); // determine chance for lower arms to be different and activate if (cog.arm_Lower_Right.Count != 0) RandomizeLeftRight(cog.arm_Lower_Right, cog.arm_Lower_Left, 15); // determine chance for hands to be different and activate if (cog.hand_Right.Count != 0) RandomizeLeftRight(cog.hand_Right, cog.hand_Left, 15); // select hips starting at index 1 if (cog.hips.Count != 0) ActivateItem(cog.hips[Random.Range(1, cog.hips.Count)]); // determine chance for legs to be different and activate if (cog.leg_Right.Count != 0) RandomizeLeftRight(cog.leg_Right, cog.leg_Left, 15); // select chest attachment if (allGender.chest_Attachment.Count != 0) ActivateItem(allGender.chest_Attachment[Random.Range(0, allGender.chest_Attachment.Count)]); // select back attachment if (allGender.back_Attachment.Count != 0 && _isShowBackAttachment) ActivateItem(allGender.back_Attachment[Random.Range(0, allGender.back_Attachment.Count)]); // determine chance for shoulder attachments to be different and activate if (allGender.shoulder_Attachment_Right.Count != 0) RandomizeLeftRight(allGender.shoulder_Attachment_Right, allGender.shoulder_Attachment_Left, 10); // determine chance for elbow attachments to be different and activate if (allGender.elbow_Attachment_Right.Count != 0) RandomizeLeftRight(allGender.elbow_Attachment_Right, allGender.elbow_Attachment_Left, 10); // select hip attachment if (allGender.hips_Attachment.Count != 0) ActivateItem(allGender.hips_Attachment[Random.Range(0, allGender.hips_Attachment.Count)]); // determine chance for knee attachments to be different and activate if (allGender.knee_Attachement_Right.Count != 0) RandomizeLeftRight(allGender.knee_Attachement_Right, allGender.knee_Attachement_Left, 10); // start randomization of the random characters colors RandomizeColors(skinColor); } // handle randomization of the random characters colors void RandomizeColors(SkinColor skinColor) { // set skin and hair colors based on skin color roll switch (skinColor) { case SkinColor.White: // randomize and set white skin, hair, stubble, and scar color RandomizeAndSetHairSkinColors(\"White\", whiteSkin, whiteHair, whiteStubble, whiteScar); break; case SkinColor.Brown: // randomize and set brown skin, hair, stubble, and scar color RandomizeAndSetHairSkinColors(\"Brown\", brownSkin, brownHair, brownStubble, brownScar); break; case SkinColor.Black: // randomize and black elf skin, hair, stubble, and scar color RandomizeAndSetHairSkinColors(\"Black\", blackSkin, blackHair, blackStubble, blackScar); break; case SkinColor.Elf: // randomize and set elf skin, hair, stubble, and scar color RandomizeAndSetHairSkinColors(\"Elf\", elfSkin, elfHair, elfStubble, elfScar); break; } // randomize and set primary color if (primary.Length != 0) mat.SetColor(\"_Color_Primary\", primary[Random.Range(0, primary.Length)]); else Debug.Log(\"No Primary Colors Specified In The Inspector\"); // randomize and set secondary color if (secondary.Length != 0) mat.SetColor(\"_Color_Secondary\", secondary[Random.Range(0, secondary.Length)]); else Debug.Log(\"No Secondary Colors Specified In The Inspector\"); // randomize and set primary metal color if (metalPrimary.Length != 0) mat.SetColor(\"_Color_Metal_Primary\", metalPrimary[Random.Range(0, metalPrimary.Length)]); else Debug.Log(\"No Primary Metal Colors Specified In The Inspector\"); // randomize and set secondary metal color if (metalSecondary.Length != 0) mat.SetColor(\"_Color_Metal_Secondary\", metalSecondary[Random.Range(0, metalSecondary.Length)]); else Debug.Log(\"No Secondary Metal Colors Specified In The Inspector\"); // randomize and set primary leather color if (leatherPrimary.Length != 0) mat.SetColor(\"_Color_Leather_Primary\", leatherPrimary[Random.Range(0, leatherPrimary.Length)]); else Debug.Log(\"No Primary Leather Colors Specified In The Inspector\"); // randomize and set secondary leather color if (leatherSecondary.Length != 0) mat.SetColor(\"_Color_Leather_Secondary\", leatherSecondary[Random.Range(0, leatherSecondary.Length)]); else Debug.Log(\"No Secondary Leather Colors Specified In The Inspector\"); // randomize and set body art color if (bodyArt.Length != 0) SetBodyArtColor(bodyArt[Random.Range(0, bodyArt.Length)]); else Debug.Log(\"No Body Art Colors Specified In The Inspector\"); // randomize and set body art amount mat.SetFloat(\"_BodyArt_Amount\", Random.Range(0.0f, 1.0f)); } public CharacterSkinData GetSkinData() { if (skinData == null) skinData = new CharacterSkinData(); return skinData;  ",
          "content_tokens": 2777,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "public void SetSkinData(CharacterSkinData data) { string gameObjectName = gameObject.name; if (transform.parent != null) gameObjectName = transform.parent.name; Debug.Log($\"[CharacterSkinController] {gameObjectName}SetSkinData({data.ToString()})\"); skinData = data; bool isMale = data.genderId == 0; ChangeGender(isMale); SetSkinColor(data.skinColorId); SetHairColor(data.hairColorId); if (isMale) SetBeard(data.beardId); SetBodyArtColor(data.bodyArtId); SetFace(data.faceId); SetHair(data.hairId);  ",
          "content_tokens": 152,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "public void SetHairColor(int colorIndex) { Debug.Log($\"[CharacterSkinController] SetHairColor({colorIndex})\"); Color stubbleColor = _hairColors[0].stubColor; int[] len = new int[4]; for (int i = 0; i < 4; i++) { len[i] = _hairColors[i].colors.Length; } int cumulativeLen = 0; for (int i = 0; i < 4; i++) { cumulativeLen += len[i]; if (colorIndex < cumulativeLen) { stubbleColor = _hairColors[i].stubColor; SetHairColor(_hairColors[i].colors[colorIndex - (cumulativeLen - len[i])]); CharacterSkinData skinData = GetSkinData(); skinData.hairColorId = colorIndex; break; }  ",
          "content_tokens": 190,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "SetStubbleColor(stubbleColor);  public void SetHairColor(Color color) { mat.SetColor(\"_Color_Hair\", color);  public void SetSkinColor(int id) { Debug.Log($\"[CharacterSkinController] SetSkinColor({id})\"); CharacterSkinData skinData = GetSkinData(); skinData.skinColorId = id; switch (id) { case 0: SetSkinColor(whiteSkin[0]); SetScarColor(whiteScar); break; case 1: SetSkinColor(brownSkin[0]); SetScarColor(brownScar); break; case 2: SetSkinColor(blackSkin[0]); SetScarColor(blackScar); break; case 3: SetSkinColor(elfSkin[0]); SetScarColor(elfScar); break; }  public void SetSkinColor(Color color) { mat.SetColor(\"_Color_Skin\", color);  ",
          "content_tokens": 197,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "public void SetScarColor(Color scar) { Debug.Log($\"[CharacterSkinController] SetScarColor({scar})\"); mat.SetColor(\"_Color_Scar\", scar);  public void SetStubbleColor(Color stubble) { mat.SetColor(\"_Color_Stubble\", stubble);  public void SetBodyArtColor(int index) { Debug.Log($\"[CharacterSkinController] SetBodyArtColor({index})\"); SetBodyArtColor(bodyArt[index]); CharacterSkinData skinData = GetSkinData(); skinData.bodyArtId = index;  private void SetBodyArtColor(Color bodyArtColor) { mat.SetColor(\"_Color_BodyArt\", bodyArtColor);  ",
          "content_tokens": 156,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "void RandomizeAndSetHairSkinColors(string info, Color[] skin, Color[] hair, Color stubble, Color scar) { // randomize and set elf skin color if (skin.Length != 0) { SetSkinColor(skin[Random.Range(0, skin.Length)]); } else { Debug.Log(\"No \" + info + \" Skin Colors Specified In The Inspector\"); } // randomize and set elf hair color if (hair.Length != 0) { SetHairColor(hair[Random.Range(0, hair.Length)]); } else { Debug.Log(\"No \" + info + \" Hair Colors Specified In The Inspector\"); } // set stubble color SetStubbleColor(stubble); // set scar color SetScarColor(scar); } // method for handling the chance of left/right items to be differnt (such as shoulders, hands, legs, arms) void RandomizeLeftRight(List<GameObject> objectListRight, List<GameObject> objectListLeft, int rndPercent) { // rndPercent = chance for left item to be different // stored right index int index = Random.Range(0, objectListRight.Count); // enable item from list using index ActivateItem(objectListRight[index]); // roll for left item mismatch, if true randomize index based on left item list if (GetPercent(rndPercent)) index = Random.Range(0, objectListLeft.Count); // enable left item from list using index ActivateItem(objectListLeft[index]); } // enable game object and add it to the enabled objects list void ActivateItem(GameObject go) { // enable item go.SetActive(true); // add item to the enabled items list enabledObjects.Add(go);  ",
          "content_tokens": 379,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "public void ActivateHeadCovering(byte race, HeadCovering headCovering, byte index) { switch (headCovering) { case HeadCovering.HeadCoverings_Base_Hair: // set hair attachment to index 1 if (allGender.all_Hair.Count != 0) ActivateItem(allGender.all_Hair[1]); if (allGender.headCoverings_Base_Hair.Count != 0) ActivateItem(allGender.headCoverings_Base_Hair[index]); break; case HeadCovering.HeadCoverings_No_FacialHair: // no facial hair attachment if (allGender.all_Hair.Count != 0) ActivateItem(allGender.all_Hair[Random.Range(0, allGender.all_Hair.Count)]); if (allGender.headCoverings_No_FacialHair.Count != 0) ActivateItem(allGender.headCoverings_No_FacialHair[index]); break; case HeadCovering.HeadCoverings_No_Hair: // select hair attachment if (allGender.headCoverings_No_Hair.Count != 0) ActivateItem(allGender.all_Hair[Random.Range(0, allGender.all_Hair.Count)]); // if elf if (race == 1) { // select elf ear attachment if (allGender.elf_Ear.Count != 0) ActivateItem(allGender.elf_Ear[Random.Range(0, allGender.elf_Ear.Count)]); } break; } } Color ConvertColor(int r, int g, int b) { return new Color(r / 255.0f, g / 255.0f, b / 255.0f, 1); } // method for rolling percentages (returns true/false) bool GetPercent(int pct) { bool p = false; int roll = Random.Range(0, 100); if (roll <= pct) { p = true; } return p; } // build all item lists for use in randomization private void StoreAllComponents() { //build out male lists BuildList(male.headAllElements, \"Male_Head_All_Elements\");//face with tattoos BuildList(male.headNoElements, \"Male_Head_No_Elements\");//only helmets BuildList(male.eyebrow, \"Male_01_Eyebrows\"); BuildList(male.facialHair, \"Male_02_FacialHair\"); BuildList(male.torso, \"Male_03_Torso\"); BuildList(male.arm_Upper_Right, \"Male_04_Arm_Upper_Right\"); BuildList(male.arm_Upper_Left, \"Male_05_Arm_Upper_Left\"); BuildList(male.arm_Lower_Right, \"Male_06_Arm_Lower_Right\"); BuildList(male.arm_Lower_Left, \"Male_07_Arm_Lower_Left\"); BuildList(male.hand_Right, \"Male_08_Hand_Right\"); BuildList(male.hand_Left, \"Male_09_Hand_Left\"); BuildList(male.hips, \"Male_10_Hips\"); BuildList(male.leg_Right, \"Male_11_Leg_Right\"); BuildList(male.leg_Left, \"Male_12_Leg_Left\"); //build out female lists BuildList(female.headAllElements, \"Female_Head_All_Elements\");//face with tattoos BuildList(female.headNoElements, \"Female_Head_No_Elements\");//only helmets BuildList(female.eyebrow, \"Female_01_Eyebrows\"); BuildList(female.facialHair, \"Female_02_FacialHair\"); BuildList(female.torso, \"Female_03_Torso\"); BuildList(female.arm_Upper_Right, \"Female_04_Arm_Upper_Right\"); BuildList(female.arm_Upper_Left, \"Female_05_Arm_Upper_Left\"); BuildList(female.arm_Lower_Right, \"Female_06_Arm_Lower_Right\"); BuildList(female.arm_Lower_Left, \"Female_07_Arm_Lower_Left\"); BuildList(female.hand_Right, \"Female_08_Hand_Right\"); BuildList(female.hand_Left, \"Female_09_Hand_Left\"); BuildList(female.hips, \"Female_10_Hips\"); BuildList(female.leg_Right, \"Female_11_Leg_Right\"); BuildList(female.leg_Left, \"Female_12_Leg_Left\"); // build out all gender lists BuildList(allGender.all_Hair, \"All_01_Hair\"); BuildList(allGender.all_Head_Attachment, \"All_02_Head_Attachment\");//tails, cosmetics BuildList(allGender.headCoverings_Base_Hair, \"HeadCoverings_Base_Hair\"); BuildList(allGender.headCoverings_No_FacialHair, \"HeadCoverings_No_FacialHair\"); BuildList(allGender.headCoverings_No_Hair, \"HeadCoverings_No_Hair\"); BuildList(allGender.chest_Attachment, \"All_03_Chest_Attachment\"); BuildList(allGender.back_Attachment, \"All_04_Back_Attachment\"); BuildList(allGender.shoulder_Attachment_Right, \"All_05_Shoulder_Attachment_Right\"); BuildList(allGender.shoulder_Attachment_Left, \"All_06_Shoulder_Attachment_Left\"); BuildList(allGender.elbow_Attachment_Right, \"All_07_Elbow_Attachment_Right\"); BuildList(allGender.elbow_Attachment_Left, \"All_08_Elbow_Attachment_Left\"); BuildList(allGender.hips_Attachment, \"All_09_Hips_Attachment\"); BuildList(allGender.knee_Attachement_Right, \"All_10_Knee_Attachement_Right\"); BuildList(allGender.knee_Attachement_Left, \"All_11_Knee_Attachement_Left\"); BuildList(allGender.elf_Ear, \"Elf_Ear\");  ",
          "content_tokens": 1402,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "public int GetOrCreateBodyPartIndex(BodyPart bodyPart) { if (!BodyPartSelectedIndex.ContainsKey(bodyPart)) { _bodyPartSelectedIndex.Add(bodyPart, 0); } return BodyPartSelectedIndex[bodyPart];  public void SetFace(int index) { Debug.Log($\"[CharacterSkin] SetFace {index}\"); HideAllFaces(); if (_gender == CharacterSkinData.Gender.Male) { male.headAllElements[index].SetActive(true); } else { female.headAllElements[index].SetActive(true); } CharacterSkinData skinData = GetSkinData(); skinData.faceId = index; _bodyPartSelectedIndex[BodyPart.Face] = index;  ",
          "content_tokens": 165,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "public void SetBeard(int id) { Debug.Log($\"[CharacterSkin] SetBeard {id}\"); HideAllBeards(); male.facialHair[id].SetActive(true); CharacterSkinData skinData = GetSkinData(); skinData.beardId = id;  private void HideAllBeards() { HideAllElements(male.facialHair);  public void SetHair(int index) { Debug.Log($\"[CharacterSkin] SetHair {index}\"); HideAllHair(); ActivateItem(allGender.all_Hair[index]); var skinData = GetSkinData(); skinData.hairId = index;  ",
          "content_tokens": 145,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "public void ChangeGender(bool isMale) { bool isChanged = false; if (isMale) { if (_gender == CharacterSkinData.Gender.Female) { isChanged = true; } } else { if (_gender == CharacterSkinData.Gender.Male) { isChanged = true; }  if (isChanged) { Debug.Log($\"[CharacterSkin] Gender is changed to {isMale}\"); _gender = isMale ? CharacterSkinData.Gender.Male : CharacterSkinData.Gender.Female; ActivateDefaultCharacter(); CharacterSkinData skinData = GetSkinData(); skinData.genderId = (int)_gender; OnGenderChanged?.Invoke((int)_gender); }  private void HideAllHair() { HideAllElements(allGender.all_Hair);  ",
          "content_tokens": 173,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "public void HideAllShoulders() { HideAllElements(allGender.shoulder_Attachment_Right); HideAllElements(allGender.shoulder_Attachment_Left);  public void HideAllHelmets() { HideAllElements(allGender.all_Head_Attachment); if (_gender == CharacterSkinData.Gender.Male) { HideAllElements(male.headNoElements); } else { HideAllElements(female.headNoElements); }  public void HideAllFaces() { HideAllElements(male.headAllElements); HideAllElements(female.headAllElements);  private void HideAllElements(List<GameObject> targetList) { foreach (var go in targetList) { if (go.activeSelf) go.SetActive(false); }  ",
          "content_tokens": 183,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "public void HideAllChests() { DebugWrite.Log($\"[CharacterSkin] HideAllChests\"); HideAllElements(male.torso); HideAllElements(female.torso);  public void ShowShoulder(int id) { DebugWrite.Log($\"[CharacterSkin] ShowShoulder {id}\"); HideAllShoulders(); if (id < 0) return; allGender.shoulder_Attachment_Right[id].SetActive(true); allGender.shoulder_Attachment_Left[id].SetActive(true);  ",
          "content_tokens": 120,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "public void ShowChest(int id) { DebugWrite.Log($\"[CharacterSkin] ShowChest {id}\"); if (id < 0) id = 0; HideAllChests(); switch (_gender) { case CharacterSkinData.Gender.Female: female.torso[id].SetActive(true); break; case CharacterSkinData.Gender.Male: male.torso[id].SetActive(true); break; }  ",
          "content_tokens": 93,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "public void ShowHelmet(int id) { DebugWrite.Log($\"[CharacterSkin] ShowHeadHelmet {id}\"); if (id == -1) { LoadFace(); } else { HideAllFaces(); HideAllHelmets(); switch (_gender) { case CharacterSkinData.Gender.Female: female.headNoElements[id].SetActive(true); break; case CharacterSkinData.Gender.Male: male.headNoElements[id].SetActive(true); break; } } } /// <summary> /// allGender.elbow_Attachment_Right /// </summary> /// <param name=\"id\"></param> public void ShowWrist(int id) { DebugWrite.Log($\"[CharacterSkin] ShowWrist {id}\"); HideAllElements(allGender.elbow_Attachment_Right); HideAllElements(allGender.elbow_Attachment_Left); if (id < 0) return; allGender.elbow_Attachment_Right[id].SetActive(true);  ",
          "content_tokens": 224,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "public void ShowHands(int id) { DebugWrite.Log($\"[CharacterSkin] ShowHands {id}\"); HideAllElements(male.arm_Lower_Right); HideAllElements(male.arm_Lower_Left); HideAllElements(female.arm_Lower_Right); HideAllElements(female.arm_Lower_Left); if (_gender == CharacterSkinData.Gender.Male) { male.arm_Lower_Right[id].SetActive(true); male.arm_Lower_Left[id].SetActive(true); ShowCorrespondingHand(id); } else { female.arm_Lower_Right[id].SetActive(true); female.arm_Lower_Left[id].SetActive(true); }  public void ShowHips(int id) {  public void ShowAmulet(int id) {  public void ShowBoots(int id) {  ",
          "content_tokens": 198,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "private void ShowCorrespondingHand(int id) { HideAllElements(male.hand_Right); HideAllElements(male.hand_Left); HideAllElements(female.hand_Right); HideAllElements(female.hand_Left); if (_gender == CharacterSkinData.Gender.Male) { int handId = _maleArmLowerToHand[id]; male.hand_Right[handId].SetActive(true); male.hand_Left[handId].SetActive(true); } else { int handId = _femaleArmLowerToHand[id]; female.hand_Right[handId].SetActive(true); female.hand_Left[handId].SetActive(true); }  ",
          "content_tokens": 157,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "private void LoadFace() { HideAllFaces(); int indexFace = GetOrCreateBodyPartIndex(BodyPart.Face); int indexBeard = GetOrCreateBodyPartIndex(BodyPart.Beard); int indexEyebrow = GetOrCreateBodyPartIndex(BodyPart.Eyebrow); switch (_gender) { case CharacterSkinData.Gender.Male: LoadBeard(indexBeard); indexEyebrow = Math.Min(male.eyebrow.Count, indexEyebrow); ActivateItem(male.eyebrow[indexEyebrow]); ActivateItem(male.headAllElements[indexFace]); break; case CharacterSkinData.Gender.Female: indexEyebrow = Math.Min(female.eyebrow.Count, indexEyebrow); ActivateItem(female.eyebrow[indexEyebrow]); ActivateItem(female.headAllElements[indexFace]); break; }  ",
          "content_tokens": 201,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkin",
          "content": "private void LoadBeard(int index) { ActivateItem(male.facialHair[index]); } // called from the BuildLists method void BuildList(List<GameObject> targetList, string characterPart) { Transform[] rootTransform = gameObject.GetComponentsInChildren<Transform>(); // declare target root transform Transform targetRoot = null; // find character parts parent object in the scene foreach (Transform t in rootTransform) { if (t.gameObject.name == characterPart) { targetRoot = t; break; } } // clears targeted list of all objects targetList.Clear(); // cycle through all child objects of the parent object for (int i = 0; i < targetRoot.childCount; i++) { // get child gameobject index i GameObject go = targetRoot.GetChild(i).gameObject; // disable child object go.SetActive(false); // add object to the targeted object list targetList.Add(go); // collect the material for the random character, only if null in the inspector; if (!mat) { if (go.GetComponent<SkinnedMeshRenderer>()) mat = go.GetComponent<SkinnedMeshRenderer>().material; } } } } public enum Gender { Male, Female } public enum Race { Human, Elf } public enum SkinColor { White, Brown, Black, Elf } public enum Elements { Yes, No } public enum HeadCovering { HeadCoverings_Base_Hair, HeadCoverings_No_FacialHair, HeadCoverings_No_Hair } public enum SkinParts: byte {Race, HeadCoveringBaseHair, HeadCoveringNoFacialHair, HeadCoveringNoHair, AllHair, AllHeadAttachment, ChestAttachment, BackAttachment, ShoulderAttachmentRight, ShoulderAttachmentLeft, ElbowAttachmentRight, ElbowAttachmentLeft, HipsAttachment, KneeAttachmentRight, KneeAttachmentLeft, ElfEar } public enum FacialHair { Yes, No } // classe for keeping the lists organized, allows for simple switching from male/female objects [System.Serializable] public class CharacterObjectGroups { public List<GameObject> headAllElements; public List<GameObject> headNoElements; public List<GameObject> eyebrow; public List<GameObject> facialHair; public List<GameObject> torso; public List<GameObject> arm_Upper_Right; public List<GameObject> arm_Upper_Left; public List<GameObject> arm_Lower_Right; public List<GameObject> arm_Lower_Left; public List<GameObject> hand_Right; public List<GameObject> hand_Left; public List<GameObject> hips; public List<GameObject> leg_Right; public List<GameObject> leg_Left; } // classe for keeping the lists organized, allows for organization of the all gender items [System.Serializable] public class CharacterObjectListsAllGender { public List<GameObject> headCoverings_Base_Hair; public List<GameObject> headCoverings_No_FacialHair; public List<GameObject> headCoverings_No_Hair; public List<GameObject> all_Hair; public List<GameObject> all_Head_Attachment; public List<GameObject> chest_Attachment; public List<GameObject> back_Attachment; public List<GameObject> shoulder_Attachment_Right; public List<GameObject> shoulder_Attachment_Left; public List<GameObject> elbow_Attachment_Right; public List<GameObject> elbow_Attachment_Left; public List<GameObject> hips_Attachment; public List<GameObject> knee_Attachement_Right; public List<GameObject> knee_Attachement_Left; public List<GameObject> all_12_Extra; public List<GameObject> elf_Ear; } /* If one of these values change you * probably don't want to send the * entire container. A custom SyncObject * is perfect for only sending what is changed. */ [Serializable] public struct SkinPartSetting { public SkinParts Part; public byte Index; public SkinPartSetting(byte part, byte index) { Part = (SkinParts)part; Index = index; } } public class HairColors { public CharacterSkin.ColorTypes colorType; public Color[] colors; public Color stubColor; } }",
          "content_tokens": 962,
          "embedding": []
        }
      ],
      "length": 33979
    },
    {
      "filename": "CharacterSkinSync",
      "content": " using System; using System.Collections.Generic; using Character; using FishNet.Object; using FishNet.Object.Synchronizing; using FishNet.Object.Synchronizing.Internal; using UnityEngine; namespace _ZombieRoyale.Scripts.Clients { public class CharacterSkinSync: NetworkBehaviour { private CharacterSkin _characterSkin; [SyncVar(OnChange=nameof(OnHeadCoverings_Base_Hair))] private byte _headCoverings_Base_Hair; [SyncVar(OnChange=nameof(OnHeadCoverings_No_FacialHair))] private byte _headCoverings_No_FacialHair; [SyncVar(OnChange=nameof(OnHeadCoverings_No_Hair))] private byte _headCoverings_No_Hair; [SyncVar(OnChange=nameof(OnAll_Hair))] private byte _all_Hair; [SyncVar(OnChange=nameof(OnAll_Head_Attachment))] private byte _all_Head_Attachment; [SyncVar(OnChange=nameof(OnChest_Attachment))] private byte _chest_Attachment; [SyncVar(OnChange=nameof(OnBack_Attachment))] private byte _back_Attachment; [SyncVar(OnChange=nameof(OnShoulder_Attachment_Right))] private byte _shoulder_Attachment_Right; [SyncVar(OnChange=nameof(OnShoulder_Attachment_Left))] private byte _shoulder_Attachment_Left; [SyncVar(OnChange=nameof(OnElbow_Attachment_Right))] private byte _elbow_Attachment_Right; [SyncVar(OnChange=nameof(OnElbow_Attachment_Left))] private byte _elbow_Attachment_Left; [SyncVar(OnChange=nameof(OnHips_Attachment))] private byte _hips_Attachment; [SyncVar(OnChange=nameof(OnKnee_Attachement_Right))] private byte _knee_Attachement_Right; [SyncVar(OnChange=nameof(OnKnee_Attachement_Left))] private byte _knee_Attachement_Left; [SyncVar(OnChange=nameof(OnAll_12_Extra))] private byte _all_12_Extra; [SyncVar(OnChange=nameof(OnElf_Ear))] private byte _elf_Ear; [SyncObject] private readonly SyncSkinSetting _race = new SyncSkinSetting(); private void Awake() { _characterSkin = GetComponentInChildren<CharacterSkin>(); //Listen for change events. _race.OnChange += _race_OnChange; } private void _race_OnChange(SyncSkinSetting.CustomOperation op, SkinPartSetting oldItem, SkinPartSetting newItem, bool asServer) { Debug.Log(\"Changed \" + op.ToString() + \", \" + newItem.Index + \", \" + asServer); if (!asServer) { //_characterSkin.SetSkin(newItem.Index); } } private void OnRaceChange(byte prev, byte next, bool asServer) { } private void OnHeadCoverings_Base_Hair(byte prev, byte next, bool asServer) { } private void OnHeadCoverings_No_FacialHair(byte prev, byte next, bool asServer) { } private void OnHeadCoverings_No_Hair(byte prev, byte next, bool asServer) { } private void OnAll_Hair(byte prev, byte next, bool asServer) { } private void OnAll_Head_Attachment(byte prev, byte next, bool asServer) { } private void OnChest_Attachment(byte prev, byte next, bool asServer) { } private void OnBack_Attachment(byte prev, byte next, bool asServer) { } private void OnShoulder_Attachment_Right(byte prev, byte next, bool asServer) { } private void OnShoulder_Attachment_Left(byte prev, byte next, bool asServer) { } private void OnElbow_Attachment_Right(byte prev, byte next, bool asServer) { } private void OnElbow_Attachment_Left(byte prev, byte next, bool asServer) { } private void OnHips_Attachment(byte prev, byte next, bool asServer) { } private void OnKnee_Attachement_Right(byte prev, byte next, bool asServer) { } private void OnKnee_Attachement_Left(byte prev, byte next, bool asServer) { } private void OnAll_12_Extra(byte prev, byte next, bool asServer) { } private void OnElf_Ear(byte prev, byte next, bool asServer) { } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharacterSkinSync",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkinSync",
          "content": " using System; using System.Collections.Generic; using Character; using FishNet.Object; using FishNet.Object.Synchronizing; using FishNet.Object.Synchronizing.Internal; using UnityEngine; namespace _ZombieRoyale.Scripts.Clients { public class CharacterSkinSync: NetworkBehaviour { private CharacterSkin _characterSkin; [SyncVar(OnChange=nameof(OnHeadCoverings_Base_Hair))] private byte _headCoverings_Base_Hair; [SyncVar(OnChange=nameof(OnHeadCoverings_No_FacialHair))] private byte _headCoverings_No_FacialHair; [SyncVar(OnChange=nameof(OnHeadCoverings_No_Hair))] private byte _headCoverings_No_Hair; [SyncVar(OnChange=nameof(OnAll_Hair))] private byte _all_Hair; [SyncVar(OnChange=nameof(OnAll_Head_Attachment))] private byte _all_Head_Attachment; [SyncVar(OnChange=nameof(OnChest_Attachment))] private byte _chest_Attachment; [SyncVar(OnChange=nameof(OnBack_Attachment))] private byte _back_Attachment; [SyncVar(OnChange=nameof(OnShoulder_Attachment_Right))] private byte _shoulder_Attachment_Right; [SyncVar(OnChange=nameof(OnShoulder_Attachment_Left))] private byte _shoulder_Attachment_Left; [SyncVar(OnChange=nameof(OnElbow_Attachment_Right))] private byte _elbow_Attachment_Right; [SyncVar(OnChange=nameof(OnElbow_Attachment_Left))] private byte _elbow_Attachment_Left; [SyncVar(OnChange=nameof(OnHips_Attachment))] private byte _hips_Attachment; [SyncVar(OnChange=nameof(OnKnee_Attachement_Right))] private byte _knee_Attachement_Right; [SyncVar(OnChange=nameof(OnKnee_Attachement_Left))] private byte _knee_Attachement_Left; [SyncVar(OnChange=nameof(OnAll_12_Extra))] private byte _all_12_Extra; [SyncVar(OnChange=nameof(OnElf_Ear))] private byte _elf_Ear; [SyncObject] private readonly SyncSkinSetting _race = new SyncSkinSetting(); private void Awake() { _characterSkin = GetComponentInChildren<CharacterSkin>(); //Listen for change events. _race.OnChange += _race_OnChange;  ",
          "content_tokens": 606,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkinSync",
          "content": "private void _race_OnChange(SyncSkinSetting.CustomOperation op, SkinPartSetting oldItem, SkinPartSetting newItem, bool asServer) { Debug.Log(\"Changed \" + op.ToString() + \", \" + newItem.Index + \", \" + asServer); if (!asServer) { //_characterSkin.SetSkin(newItem.Index); }  private void OnRaceChange(byte prev, byte next, bool asServer) {  private void OnHeadCoverings_Base_Hair(byte prev, byte next, bool asServer) {  private void OnHeadCoverings_No_FacialHair(byte prev, byte next, bool asServer) {  private void OnHeadCoverings_No_Hair(byte prev, byte next, bool asServer) {  private void OnAll_Hair(byte prev, byte next, bool asServer) {  ",
          "content_tokens": 194,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkinSync",
          "content": "private void OnAll_Head_Attachment(byte prev, byte next, bool asServer) {  private void OnChest_Attachment(byte prev, byte next, bool asServer) {  private void OnBack_Attachment(byte prev, byte next, bool asServer) {  private void OnShoulder_Attachment_Right(byte prev, byte next, bool asServer) {  private void OnShoulder_Attachment_Left(byte prev, byte next, bool asServer) {  private void OnElbow_Attachment_Right(byte prev, byte next, bool asServer) {  private void OnElbow_Attachment_Left(byte prev, byte next, bool asServer) {  private void OnHips_Attachment(byte prev, byte next, bool asServer) {  private void OnKnee_Attachement_Right(byte prev, byte next, bool asServer) {  ",
          "content_tokens": 200,
          "embedding": []
        },
        {
          "cs_scriptfile": "CharacterSkinSync",
          "content": "private void OnKnee_Attachement_Left(byte prev, byte next, bool asServer) {  private void OnAll_12_Extra(byte prev, byte next, bool asServer) {  private void OnElf_Ear(byte prev, byte next, bool asServer) { } } }",
          "content_tokens": 66,
          "embedding": []
        }
      ],
      "length": 3442
    },
    {
      "filename": "CharacterStats",
      "content": " namespace _ZombieRoyale.Scripts.Clients { public class CharacterStats { public float str; public float dex; public float con; public float inte; public float wis; public float cha; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharacterStats",
          "content": "namespace _ZombieRoyale.Scripts.Clients { public class CharacterStats { public float str; public float dex; public float con; public float inte; public float wis; public float cha; } }",
          "content_tokens": 47,
          "embedding": []
        }
      ],
      "length": 185
    },
    {
      "filename": "DC_Torch",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; using core.client.mechanics; namespace NGS.AdvancedCullingSystem.Dynamic { public class DC_Torch : DC_Source { private ICullingTarget _cullingTarget; private bool _visible; [SerializeField] private VfxGraphController vfxGraphController; public override void SetCullingTarget(ICullingTarget target) { _cullingTarget = target; _cullingTarget.MakeInvisible(); } public override void RemoveCullingTarget(ICullingTarget target) { enabled = false; Destroy(gameObject); } protected override void OnHitInternal() { if (_visible) return; _cullingTarget.MakeVisible(); _visible = true; } protected override void OnTimeout() { _cullingTarget.MakeInvisible(); _visible = false; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DC_Torch",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; using core.client.mechanics; namespace NGS.AdvancedCullingSystem.Dynamic { public class DC_Torch : DC_Source { private ICullingTarget _cullingTarget; private bool _visible; [SerializeField] private VfxGraphController vfxGraphController; public override void SetCullingTarget(ICullingTarget target) { _cullingTarget = target; _cullingTarget.MakeInvisible(); } public override void RemoveCullingTarget(ICullingTarget target) { enabled = false; Destroy(gameObject); } protected override void OnHitInternal() { if (_visible) return; _cullingTarget.MakeVisible(); _visible = true; } protected override void OnTimeout() { _cullingTarget.MakeInvisible(); _visible = false; } } }",
          "content_tokens": 197,
          "embedding": []
        }
      ],
      "length": 750
    },
    {
      "filename": "DC_VFXSourceSettingsStrategy",
      "content": "using System; using System.Collections; using System.Collections.Generic; using UnityEngine; namespace NGS.AdvancedCullingSystem.Dynamic { [Serializable] public class DC_VFXSourceSettingsStrategy : IDC_SourceSettingsStrategy { [field : SerializeField] public int Layer { get; set; } [field: SerializeField] public bool Baked { get; private set; } [SerializeField] private GameObject _go; [SerializeField] private MeshRenderer _renderer; [SerializeField] private Mesh _mesh; [SerializeField] private MeshCollider _collider; public DC_VFXSourceSettingsStrategy(GameObject go) { _go = go; } public bool TryGetBounds(ref Bounds bounds) { if (_renderer != null) { bounds = _renderer.bounds; return true; } return false; } public ICullingTarget CreateCullingTarget(CullingMethod cullingMethod) { if (cullingMethod == CullingMethod.KeepShadows) return new DC_RendererShadowsTarget(_renderer); return new DC_RendererTarget(_renderer); } public IEnumerable<Collider> GetColliders() { if (_collider == null) yield break; yield return _collider; } public bool CheckCompatibilityAndGetComponents(out string incompatibilityReason) { if (_renderer == null) { if (!_go.TryGetComponent(out _renderer)) { incompatibilityReason = \"MeshRenderer not found\"; return false; } } if (_mesh == null) { MeshFilter filter = _go.GetComponent<MeshFilter>(); if (filter == null) { incompatibilityReason = \"MeshFilter not found\"; return false; } _mesh = filter.sharedMesh; if (_mesh == null) { incompatibilityReason = \"Mesh not found\"; return false; } } incompatibilityReason = \"\"; return true; } public void Bake() { if (Baked) return; GameObject go = new GameObject(\"DC_Collider\"); go.transform.parent = _renderer.transform; go.layer = Layer; go.transform.localPosition = Vector3.zero; go.transform.localEulerAngles = Vector3.zero; go.transform.localScale = Vector3.one; _collider = go.AddComponent<MeshCollider>(); _collider.sharedMesh = _mesh; Rigidbody rb = _renderer.GetComponent<Rigidbody>(); if (rb != null && !rb.isKinematic) _collider.convex = true; Baked = true; } public void ClearBakedData() { if (!Baked) return; if (_collider != null) UnityEngine.Object.DestroyImmediate(_collider.gameObject); _collider = null; Baked = false; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DC_VFXSourceSettingsStrategy",
          "content": "using System; using System.Collections; using System.Collections.Generic; using UnityEngine; namespace NGS.AdvancedCullingSystem.Dynamic { [Serializable] public class DC_VFXSourceSettingsStrategy : IDC_SourceSettingsStrategy { [field : SerializeField] public int Layer { get; set; } [field: SerializeField] public bool Baked { get; private set; } [SerializeField] private GameObject _go; [SerializeField] private MeshRenderer _renderer; [SerializeField] private Mesh _mesh; [SerializeField] private MeshCollider _collider; public DC_VFXSourceSettingsStrategy(GameObject go) { _go = go;  ",
          "content_tokens": 161,
          "embedding": []
        },
        {
          "cs_scriptfile": "DC_VFXSourceSettingsStrategy",
          "content": "public bool TryGetBounds(ref Bounds bounds) { if (_renderer != null) { bounds = _renderer.bounds; return true; } return false; } public ICullingTarget CreateCullingTarget(CullingMethod cullingMethod) { if (cullingMethod == CullingMethod.KeepShadows) return new DC_RendererShadowsTarget(_renderer); return new DC_RendererTarget(_renderer); } public IEnumerable<Collider> GetColliders() { if (_collider == null) yield break; yield return _collider;  public bool CheckCompatibilityAndGetComponents(out string incompatibilityReason) { if (_renderer == null) { if (!_go.TryGetComponent(out _renderer)) { incompatibilityReason = \"MeshRenderer not found\"; return false; }  ",
          "content_tokens": 188,
          "embedding": []
        },
        {
          "cs_scriptfile": "DC_VFXSourceSettingsStrategy",
          "content": "if (_mesh == null) { MeshFilter filter = _go.GetComponent<MeshFilter>(); if (filter == null) { incompatibilityReason = \"MeshFilter not found\"; return false; } _mesh = filter.sharedMesh; if (_mesh == null) { incompatibilityReason = \"Mesh not found\"; return false; } } incompatibilityReason = \"\"; return true;  ",
          "content_tokens": 85,
          "embedding": []
        },
        {
          "cs_scriptfile": "DC_VFXSourceSettingsStrategy",
          "content": "public void Bake() { if (Baked) return; GameObject go = new GameObject(\"DC_Collider\"); go.transform.parent = _renderer.transform; go.layer = Layer; go.transform.localPosition = Vector3.zero; go.transform.localEulerAngles = Vector3.zero; go.transform.localScale = Vector3.one; _collider = go.AddComponent<MeshCollider>(); _collider.sharedMesh = _mesh; Rigidbody rb = _renderer.GetComponent<Rigidbody>(); if (rb != null && !rb.isKinematic) _collider.convex = true; Baked = true;  ",
          "content_tokens": 157,
          "embedding": []
        },
        {
          "cs_scriptfile": "DC_VFXSourceSettingsStrategy",
          "content": "public void ClearBakedData() { if (!Baked) return; if (_collider != null) UnityEngine.Object.DestroyImmediate(_collider.gameObject); _collider = null; Baked = false; } } }",
          "content_tokens": 51,
          "embedding": []
        }
      ],
      "length": 2216
    },
    {
      "filename": "CharacterSkinEditor",
      "content": "using UnityEditor; using UnityEngine; namespace Character { [CustomEditor(typeof(CharacterSkin))] public class CharacterSkinEditor : Editor { private CharacterSkin _decorator; private void OnEnable() { _decorator = (CharacterSkin)target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); if (GUILayout.Button(\"Randomize\")) { _decorator.Randomize(); } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CharacterSkinEditor",
          "content": "using UnityEditor; using UnityEngine; namespace Character { [CustomEditor(typeof(CharacterSkin))] public class CharacterSkinEditor : Editor { private CharacterSkin _decorator; private void OnEnable() { _decorator = (CharacterSkin)target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); if (GUILayout.Button(\"Randomize\")) { _decorator.Randomize(); } } } }",
          "content_tokens": 99,
          "embedding": []
        }
      ],
      "length": 371
    },
    {
      "filename": "ItemVisualsForNHAvatarEditor",
      "content": "using System.Collections.Generic; using NHance.Assets.Scripts; using NHance.Assets.Scripts.Items; using NHance.Assets.Scripts.Enums; using UnityEditor; using UnityEngine; [CustomEditor(typeof(ItemVisualsForNHAvatar))] public class ItemVisualsForNHAvatarEditor : Editor { private SerializedProperty itemGenderPrefabsProperty; private SerializedProperty isShowAvatarWorksProperty; private ItemVisualsForNHAvatar itemVisuals; private void OnEnable() { itemVisuals = (ItemVisualsForNHAvatar)target; itemGenderPrefabsProperty = serializedObject.FindProperty(\"itemGenderTypePrefabs\"); isShowAvatarWorksProperty = serializedObject.FindProperty(\"IsShowAvatarWorks\"); } public override void OnInspectorGUI() { serializedObject.Update(); //Serialize nhAvatarPrefab if (itemVisuals.IsShowAvatarWorks) { EditorGUILayout.PropertyField(serializedObject.FindProperty(\"nhAvatarPrefab\"), true); if (GUILayout.Button(\"Fill NHAvatar Prefabs\")) { FillNHAvatarPrefabs(); } } if (GUILayout.Button(\"Add Missing Items\")) { AddMissingItems(); } EditorGUILayout.PropertyField(itemGenderPrefabsProperty, true); EditorGUILayout.PropertyField(isShowAvatarWorksProperty); serializedObject.ApplyModifiedProperties(); } private void FillNHAvatarPrefabs() { itemVisuals.FillItemGenderPrefabsFromNHAvatar(); EditorUtility.SetDirty(itemVisuals); Debug.Log(\"NHAvatar prefabs filled.\"); } private void AddMissingItems() { string parentFolder = \"Assets/StylizedCharacter/Prefabs/Item/Equipment/\"; string[] folders = System.IO.Directory.GetFiles(parentFolder); for (int i = 0; i < folders.Length; i++) { string folder = folders[i].Substring(0, folders[i].Length - 5); string folderPath = folder; NHItem[] items = LoadItems(folderPath); for (int j = 0; j < items.Length; j++) { NHItem item = items[j]; Gender itemGender = GenderFromName(item.name); if (!itemVisuals.IsPrefabPersistInList(itemGender, item.Type, item.name)) { AddItemToDB(itemGender, item); } } } EditorUtility.SetDirty(itemVisuals); } private void AddItemToDB(Gender itemGender, NHItem item) { ItemTypeEnum itemType = item.Type; for (int i = 0; i < itemVisuals.itemGenderTypePrefabs.Length; i++) { if (itemVisuals.itemGenderTypePrefabs[i].gender != itemGender) continue; foreach (var itemTypePrefabs in itemVisuals.itemGenderTypePrefabs[i].itemTypePrefabs) { if (itemTypePrefabs.itemType != itemType) continue; ItemVisualsForNHAvatar.ItemPrefab[] newPrefabs = new ItemVisualsForNHAvatar.ItemPrefab[itemTypePrefabs.itemPrefabs.Length + 1]; for (int j = 0; j < itemTypePrefabs.itemPrefabs.Length; j++) { newPrefabs[j] = itemTypePrefabs.itemPrefabs[j]; } newPrefabs[newPrefabs.Length - 1] = ItemVisualsForNHAvatar.CreateItemPrefab(item); itemTypePrefabs.itemPrefabs = newPrefabs; return; } } } private Gender GenderFromName(string itemName) { string firstFourChars = itemName.Substring(0, 4); switch (firstFourChars) { case \"Hu_M\": return Gender.HumanMale; case \"Hu_F\": return Gender.HumanFemale; case \"Or_M\": return Gender.OrcMale; case \"Or_F\": return Gender.OrcFemale; default: return Gender.HumanMale; } } private string GetNameBeginning(Gender gend) { switch (gend) { case Gender.HumanMale: return \"Hu_M\"; case Gender.HumanFemale: return \"Hu_F\"; case Gender.OrcMale: return \"Or_M\"; case Gender.OrcFemale: return \"Or_F\"; default: return \"Hu_M\"; } } private NHItem[] LoadItems(string path) { List<NHItem> nhItems = new List<NHItem>(); AssetFlipperEditor.TryGetUnityObjectsOfTypeFromPath<NHItem>(path, nhItems); return nhItems.ToArray(); } private NHItem[] GetPrefabArray(ItemVisualsForNHAvatar.ItemPrefab[] itemPrefabs) { var prefabs = new NHItem[itemPrefabs.Length]; for (int i = 0; i < itemPrefabs.Length; i++) { prefabs[i] = itemPrefabs[i].prefab; } return prefabs; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ItemVisualsForNHAvatarEditor",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemVisualsForNHAvatarEditor",
          "content": "using System.Collections.Generic; using NHance.Assets.Scripts; using NHance.Assets.Scripts.Items; using NHance.Assets.Scripts.Enums; using UnityEditor; using UnityEngine; [CustomEditor(typeof(ItemVisualsForNHAvatar))] public class ItemVisualsForNHAvatarEditor : Editor { private SerializedProperty itemGenderPrefabsProperty; private SerializedProperty isShowAvatarWorksProperty; private ItemVisualsForNHAvatar itemVisuals; private void OnEnable() { itemVisuals = (ItemVisualsForNHAvatar)target; itemGenderPrefabsProperty = serializedObject.FindProperty(\"itemGenderTypePrefabs\"); isShowAvatarWorksProperty = serializedObject.FindProperty(\"IsShowAvatarWorks\"); } public override void OnInspectorGUI() { serializedObject.Update(); //Serialize nhAvatarPrefab if (itemVisuals.IsShowAvatarWorks) { EditorGUILayout.PropertyField(serializedObject.FindProperty(\"nhAvatarPrefab\"), true); if (GUILayout.Button(\"Fill NHAvatar Prefabs\")) { FillNHAvatarPrefabs(); }  ",
          "content_tokens": 264,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemVisualsForNHAvatarEditor",
          "content": "if (GUILayout.Button(\"Add Missing Items\")) { AddMissingItems(); } EditorGUILayout.PropertyField(itemGenderPrefabsProperty, true); EditorGUILayout.PropertyField(isShowAvatarWorksProperty); serializedObject.ApplyModifiedProperties();  private void FillNHAvatarPrefabs() { itemVisuals.FillItemGenderPrefabsFromNHAvatar(); EditorUtility.SetDirty(itemVisuals); Debug.Log(\"NHAvatar prefabs filled.\");  ",
          "content_tokens": 113,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemVisualsForNHAvatarEditor",
          "content": "private void AddMissingItems() { string parentFolder = \"Assets/StylizedCharacter/Prefabs/Item/Equipment/\"; string[] folders = System.IO.Directory.GetFiles(parentFolder); for (int i = 0; i < folders.Length; i++) { string folder = folders[i].Substring(0, folders[i].Length - 5); string folderPath = folder; NHItem[] items = LoadItems(folderPath); for (int j = 0; j < items.Length; j++) { NHItem item = items[j]; Gender itemGender = GenderFromName(item.name); if (!itemVisuals.IsPrefabPersistInList(itemGender, item.Type, item.name)) { AddItemToDB(itemGender, item); } } } EditorUtility.SetDirty(itemVisuals);  ",
          "content_tokens": 187,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemVisualsForNHAvatarEditor",
          "content": "private void AddItemToDB(Gender itemGender, NHItem item) { ItemTypeEnum itemType = item.Type; for (int i = 0; i < itemVisuals.itemGenderTypePrefabs.Length; i++) { if (itemVisuals.itemGenderTypePrefabs[i].gender != itemGender) continue; foreach (var itemTypePrefabs in itemVisuals.itemGenderTypePrefabs[i].itemTypePrefabs) { if (itemTypePrefabs.itemType != itemType) continue; ItemVisualsForNHAvatar.ItemPrefab[] newPrefabs = new ItemVisualsForNHAvatar.ItemPrefab[itemTypePrefabs.itemPrefabs.Length + 1]; for (int j = 0; j < itemTypePrefabs.itemPrefabs.Length; j++) { newPrefabs[j] = itemTypePrefabs.itemPrefabs[j]; } newPrefabs[newPrefabs.Length - 1] = ItemVisualsForNHAvatar.CreateItemPrefab(item); itemTypePrefabs.itemPrefabs = newPrefabs; return; } } } private Gender GenderFromName(string itemName) { string firstFourChars = itemName.Substring(0, 4); switch (firstFourChars) { case \"Hu_M\": return Gender.HumanMale; case \"Hu_F\": return Gender.HumanFemale; case \"Or_M\": return Gender.OrcMale; case \"Or_F\": return Gender.OrcFemale; default: return Gender.HumanMale; }  ",
          "content_tokens": 340,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemVisualsForNHAvatarEditor",
          "content": "private string GetNameBeginning(Gender gend) { switch (gend) { case Gender.HumanMale: return \"Hu_M\"; case Gender.HumanFemale: return \"Hu_F\"; case Gender.OrcMale: return \"Or_M\"; case Gender.OrcFemale: return \"Or_F\"; default: return \"Hu_M\"; } } private NHItem[] LoadItems(string path) { List<NHItem> nhItems = new List<NHItem>(); AssetFlipperEditor.TryGetUnityObjectsOfTypeFromPath<NHItem>(path, nhItems); return nhItems.ToArray(); } private NHItem[] GetPrefabArray(ItemVisualsForNHAvatar.ItemPrefab[] itemPrefabs) { var prefabs = new NHItem[itemPrefabs.Length]; for (int i = 0; i < itemPrefabs.Length; i++) { prefabs[i] = itemPrefabs[i].prefab; } return prefabs; } }",
          "content_tokens": 218,
          "embedding": []
        }
      ],
      "length": 3697
    },
    {
      "filename": "PlayerDataEditor",
      "content": "using _ZombieRoyale.Scripts.Clients; using UnityEditor; using UnityEngine; [CustomEditor(typeof(PlayerData))] public class PlayerDataEditor : Editor { private PlayerData _playerData; private void OnEnable() { _playerData = (PlayerData) target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); if (GUILayout.Button(\"Flush PlayerPrefs\")) { _playerData.FlushPlayerPrefs(); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PlayerDataEditor",
          "content": "using _ZombieRoyale.Scripts.Clients; using UnityEditor; using UnityEngine; [CustomEditor(typeof(PlayerData))] public class PlayerDataEditor : Editor { private PlayerData _playerData; private void OnEnable() { _playerData = (PlayerData) target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); if (GUILayout.Button(\"Flush PlayerPrefs\")) { _playerData.FlushPlayerPrefs(); } } }",
          "content_tokens": 111,
          "embedding": []
        }
      ],
      "length": 392
    },
    {
      "filename": "SpeechPlayTestEditor",
      "content": "using UnityEditor; using UnityEngine; [CustomEditor(typeof(SpeechPlayTest))] public class SpeechPlayTestEditor : Editor { public override void OnInspectorGUI() { DrawDefaultInspector(); // This draws the default inspector SpeechPlayTest script = (SpeechPlayTest)target; if(GUILayout.Button(\"Download and Play Audio\")) { script.DownloadAndPlay(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SpeechPlayTestEditor",
          "content": "using UnityEditor; using UnityEngine; [CustomEditor(typeof(SpeechPlayTest))] public class SpeechPlayTestEditor : Editor { public override void OnInspectorGUI() { DrawDefaultInspector(); // This draws the default inspector SpeechPlayTest script = (SpeechPlayTest)target; if(GUILayout.Button(\"Download and Play Audio\")) { script.DownloadAndPlay(); } } }",
          "content_tokens": 89,
          "embedding": []
        }
      ],
      "length": 351
    },
    {
      "filename": "TeamUIControllerEditor",
      "content": "using System; using System.Collections; using System.Collections.Generic; using FirstGearGames.LobbyAndWorld.Clients; using UnityEditor; using UnityEngine; namespace _ZombieRoyale.Scripts.Clients { [CustomEditor(typeof(TeamUIController))] public class TeamUIControllerEditor : Editor { private TeamUIController _myScript; private void OnEnable() { _myScript = (TeamUIController) target; } public override void OnInspectorGUI() { DrawDefaultInspector(); DrawAllyHPFields(); } private void DrawAllyHPFields() { if (!Application.isPlaying) return; EditorGUILayout.LabelField(\"Ally Hit Points\", EditorStyles.boldLabel); EditorGUILayout.BeginVertical(\"box\"); foreach (var kv in _myScript.AllyHPs) { EditorGUILayout.BeginHorizontal(); if (kv.Value == null) { EditorGUILayout.LabelField($\"Ally: null\", EditorStyles.boldLabel); EditorGUILayout.EndHorizontal(); continue; } EditorGUILayout.BeginVertical(\"box\"); ClientInstance clientInstance = ClientInstance.GetClientInstance(kv.Key); var playerName = clientInstance != null ? clientInstance.PlayerSettings.PlayerName : \"Unknown\"; EditorGUILayout.LabelField($\"{playerName} #{kv.Value.clientId}: \", EditorStyles.label); EditorGUILayout.LabelField($\"{kv.Value.current}/{kv.Value.max}\", EditorStyles.label); EditorGUILayout.EndVertical(); EditorGUILayout.EndHorizontal(); } EditorGUILayout.EndVertical(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "TeamUIControllerEditor",
          "content": "using System; using System.Collections; using System.Collections.Generic; using FirstGearGames.LobbyAndWorld.Clients; using UnityEditor; using UnityEngine; namespace _ZombieRoyale.Scripts.Clients { [CustomEditor(typeof(TeamUIController))] public class TeamUIControllerEditor : Editor { private TeamUIController _myScript; private void OnEnable() { _myScript = (TeamUIController) target; } public override void OnInspectorGUI() { DrawDefaultInspector(); DrawAllyHPFields();  ",
          "content_tokens": 131,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeamUIControllerEditor",
          "content": "private void DrawAllyHPFields() { if (!Application.isPlaying) return; EditorGUILayout.LabelField(\"Ally Hit Points\", EditorStyles.boldLabel); EditorGUILayout.BeginVertical(\"box\"); foreach (var kv in _myScript.AllyHPs) { EditorGUILayout.BeginHorizontal(); if (kv.Value == null) { EditorGUILayout.LabelField($\"Ally: null\", EditorStyles.boldLabel); EditorGUILayout.EndHorizontal(); continue; } EditorGUILayout.BeginVertical(\"box\"); ClientInstance clientInstance = ClientInstance.GetClientInstance(kv.Key); var playerName = clientInstance != null ? clientInstance.PlayerSettings.PlayerName : \"Unknown\"; EditorGUILayout.LabelField($\"{playerName} #{kv.Value.clientId}: \", EditorStyles.label); EditorGUILayout.LabelField($\"{kv.Value.current}/{kv.Value.max}\", EditorStyles.label); EditorGUILayout.EndVertical(); EditorGUILayout.EndHorizontal(); } EditorGUILayout.EndVertical(); } } }",
          "content_tokens": 273,
          "embedding": []
        }
      ],
      "length": 1349
    },
    {
      "filename": "VfxGraphControllerEditor",
      "content": "using core.client.mechanics; using UnityEngine; using UnityEditor; [CustomEditor(typeof(VfxGraphController))] public class VfxGraphControllerEditor : Editor { public override void OnInspectorGUI() { base.OnInspectorGUI(); VfxGraphController controller = (VfxGraphController)target; EditorGUILayout.Space(); if (GUILayout.Button(\"Enable VFX\")) { controller.Enable(); } if (GUILayout.Button(\"Disable VFX\")) { controller.Disable(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "VfxGraphControllerEditor",
          "content": "using core.client.mechanics; using UnityEngine; using UnityEditor; [CustomEditor(typeof(VfxGraphController))] public class VfxGraphControllerEditor : Editor { public override void OnInspectorGUI() { base.OnInspectorGUI(); VfxGraphController controller = (VfxGraphController)target; EditorGUILayout.Space(); if (GUILayout.Button(\"Enable VFX\")) { controller.Enable(); } if (GUILayout.Button(\"Disable VFX\")) { controller.Disable(); } } }",
          "content_tokens": 120,
          "embedding": []
        }
      ],
      "length": 434
    },
    {
      "filename": "EscapeMenu",
      "content": "using System; using DuloGames.UI; using FirstGearGames.LobbyAndWorld.Clients; using FirstGearGames.LobbyAndWorld.Lobbies; using FishnetInvector; using UnityEngine; using UnityEngine.Serialization; public class EscapeMenu : MonoBehaviour { [SerializeField] private FishnetInvectorManager _fim; private SteamMainMenu _steamMainMenu; [HideInInspector] public UIWindow UIWindow; public static EscapeMenu Instance { get; private set; } private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } _steamMainMenu = FindObjectOfType<SteamMainMenu>(); UIWindow = GetComponent<UIWindow>(); UIWindow.Hide(); } private void Update() { if (Input.GetKeyDown(KeyCode.Escape)) { if (!IfInventoryOpened()) { if (IfEscapeMenuOpened()) { UIWindow.Hide(); RoomSystemHandler.ShowCursor(false); RoomSystemHandler.LockCursor(true); if (_steamMainMenu.IsHost) { _steamMainMenu.CloseScreens(); } } else { UIWindow.Show(); RoomSystemHandler.ShowCursor(true); RoomSystemHandler.LockCursor(false); if (_steamMainMenu.IsHost) { _steamMainMenu.ShowScreens(); } } } } } private bool IfEscapeMenuOpened() { return UIWindow.IsVisible; } private bool IfInventoryOpened() { return _fim.Inventory.isOpen; } public void OnClick_Resume() { UIWindow.Hide(); } public void OnClickOpenSettings() { MainSettings.Instance._uiWindow.Toggle(); } public void OnClick_ExitToMainMenu() { ReadyLobbyNetwork.LeaveRoom(); ClientInstance clientInstance = ClientInstance.GetClientInstance(_fim.NetworkObject.Owner); clientInstance.Disconnect(); } public void OnClick_ExitGame() { Application.Quit(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "EscapeMenu",
          "content": "using System; using DuloGames.UI; using FirstGearGames.LobbyAndWorld.Clients; using FirstGearGames.LobbyAndWorld.Lobbies; using FishnetInvector; using UnityEngine; using UnityEngine.Serialization; public class EscapeMenu : MonoBehaviour { [SerializeField] private FishnetInvectorManager _fim; private SteamMainMenu _steamMainMenu; [HideInInspector] public UIWindow UIWindow; public static EscapeMenu Instance { get; private set;  private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } _steamMainMenu = FindObjectOfType<SteamMainMenu>(); UIWindow = GetComponent<UIWindow>(); UIWindow.Hide();  ",
          "content_tokens": 170,
          "embedding": []
        },
        {
          "cs_scriptfile": "EscapeMenu",
          "content": "private void Update() { if (Input.GetKeyDown(KeyCode.Escape)) { if (!IfInventoryOpened()) { if (IfEscapeMenuOpened()) { UIWindow.Hide(); RoomSystemHandler.ShowCursor(false); RoomSystemHandler.LockCursor(true); if (_steamMainMenu.IsHost) { _steamMainMenu.CloseScreens(); } } else { UIWindow.Show(); RoomSystemHandler.ShowCursor(true); RoomSystemHandler.LockCursor(false); if (_steamMainMenu.IsHost) { _steamMainMenu.ShowScreens(); } } } }  private bool IfEscapeMenuOpened() { return UIWindow.IsVisible;  private bool IfInventoryOpened() { return _fim.Inventory.isOpen;  public void OnClick_Resume() { UIWindow.Hide();  ",
          "content_tokens": 192,
          "embedding": []
        },
        {
          "cs_scriptfile": "EscapeMenu",
          "content": "public void OnClickOpenSettings() { MainSettings.Instance._uiWindow.Toggle();  public void OnClick_ExitToMainMenu() { ReadyLobbyNetwork.LeaveRoom(); ClientInstance clientInstance = ClientInstance.GetClientInstance(_fim.NetworkObject.Owner); clientInstance.Disconnect();  public void OnClick_ExitGame() { Application.Quit(); } }",
          "content_tokens": 82,
          "embedding": []
        }
      ],
      "length": 1581
    },
    {
      "filename": "CombatTextController",
      "content": "using FishnetInvector; using Invector; using UnityEngine; public class CombatTextController : MonoBehaviour { [SerializeField] private CanvasGroup canvasGroup; [SerializeField] private UICombatText uiCombatTextPrefab; [SerializeField] private FishnetInvectorHealthController healthController; [SerializeField] private Sprite meleeIcon; private void AssignComponentsIfRequired() { canvasGroup ??= GetComponent<CanvasGroup>(); } private void OnValidate() { AssignComponentsIfRequired(); } private void OnEnable() { healthController.OnTakeDamage += HealthController_OnTakeDamage; healthController.OnHeal += HealthController_OnHeal; } private void OnDisable() { healthController.OnTakeDamage -= HealthController_OnTakeDamage; healthController.OnHeal += HealthController_OnHeal; } private void HealthController_OnHeal(FishnetInvectorHealthController.HealData healData) { Sprite icon = null; if (healData.abilityId > 0) { icon = AbilityManager.Instance.GetAbility(healData.abilityId).AbilityDefinition.Icon; } AllocateHealText(icon, (int)healData.amount); } private void HealthController_OnTakeDamage(vDamage damage) { Sprite icon = meleeIcon; if (damage.abilityId > 0) { Ability ability = AbilityManager.Instance.GetAbility(damage.abilityId); icon = ability.AbilityDefinition.Icon; } AllocateCombatText(icon, damage.damageValue); } private void Awake() { AssignComponentsIfRequired(); } public void AllocateHealText(Sprite icon, int amount, string extra = \"\") { var combatText = Instantiate(uiCombatTextPrefab, transform); string amountString = $\"+{amount}\"; combatText.Init(icon, amountString, combatText.PositiveColor, extra); } public void AllocateCombatText(Sprite icon, int amount, string extra = \"\") { var combatText = Instantiate(uiCombatTextPrefab, transform); string amountString = $\"-{amount}\"; combatText.Init(icon, amountString, combatText.NegativeColor, extra); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CombatTextController",
          "content": "using FishnetInvector; using Invector; using UnityEngine; public class CombatTextController : MonoBehaviour { [SerializeField] private CanvasGroup canvasGroup; [SerializeField] private UICombatText uiCombatTextPrefab; [SerializeField] private FishnetInvectorHealthController healthController; [SerializeField] private Sprite meleeIcon; private void AssignComponentsIfRequired() { canvasGroup ??= GetComponent<CanvasGroup>();  private void OnValidate() { AssignComponentsIfRequired();  private void OnEnable() { healthController.OnTakeDamage += HealthController_OnTakeDamage; healthController.OnHeal += HealthController_OnHeal;  private void OnDisable() { healthController.OnTakeDamage -= HealthController_OnTakeDamage; healthController.OnHeal += HealthController_OnHeal;  ",
          "content_tokens": 187,
          "embedding": []
        },
        {
          "cs_scriptfile": "CombatTextController",
          "content": "private void HealthController_OnHeal(FishnetInvectorHealthController.HealData healData) { Sprite icon = null; if (healData.abilityId > 0) { icon = AbilityManager.Instance.GetAbility(healData.abilityId).AbilityDefinition.Icon;  AllocateHealText(icon, (int)healData.amount);  private void HealthController_OnTakeDamage(vDamage damage) { Sprite icon = meleeIcon; if (damage.abilityId > 0) { Ability ability = AbilityManager.Instance.GetAbility(damage.abilityId); icon = ability.AbilityDefinition.Icon;  AllocateCombatText(icon, damage.damageValue);  private void Awake() { AssignComponentsIfRequired();  ",
          "content_tokens": 165,
          "embedding": []
        },
        {
          "cs_scriptfile": "CombatTextController",
          "content": "public void AllocateHealText(Sprite icon, int amount, string extra = \"\") { var combatText = Instantiate(uiCombatTextPrefab, transform); string amountString = $\"+{amount}\"; combatText.Init(icon, amountString, combatText.PositiveColor, extra);  public void AllocateCombatText(Sprite icon, int amount, string extra = \"\") { var combatText = Instantiate(uiCombatTextPrefab, transform); string amountString = $\"-{amount}\"; combatText.Init(icon, amountString, combatText.NegativeColor, extra); } }",
          "content_tokens": 133,
          "embedding": []
        }
      ],
      "length": 1873
    },
    {
      "filename": "UICombatText",
      "content": "using System.Collections; using UnityEngine; using UnityEngine.UI; public class UICombatText : MonoBehaviour { private readonly float DURATION = 2f; [SerializeField] private CanvasGroup canvasGroup; [SerializeField] private Image imageIcon; [SerializeField] private TMProDecorator textAmount; [SerializeField] private TMProDecorator textExtra; public Color PositiveColor => positiveColor; [SerializeField] private Color positiveColor; public Color NegativeColor => negativeColor; [SerializeField] private Color negativeColor; private void AssignComponentsIfRequired() { canvasGroup ??= GetComponent<CanvasGroup>(); } private void OnValidate() { AssignComponentsIfRequired(); } private void Awake() { AssignComponentsIfRequired(); } public void Init(Sprite icon, string amountString, Color color, string extra) { if (icon == null) { imageIcon.gameObject.SetActive(false); } else { imageIcon.sprite = icon; } textAmount.SetText(amountString); textAmount.SetColor(color); textExtra.SetText(extra); textExtra.SetColor(color); canvasGroup.alpha = 1f; StartCoroutine(FadeOutCoroutine()); } private IEnumerator FadeOutCoroutine() { float elapsedTime = 0; while (elapsedTime < DURATION) { canvasGroup.alpha = 1 - elapsedTime / DURATION; elapsedTime += Time.deltaTime; yield return null; } Destroy(gameObject); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "UICombatText",
          "content": "using System.Collections; using UnityEngine; using UnityEngine.UI; public class UICombatText : MonoBehaviour { private readonly float DURATION = 2f; [SerializeField] private CanvasGroup canvasGroup; [SerializeField] private Image imageIcon; [SerializeField] private TMProDecorator textAmount; [SerializeField] private TMProDecorator textExtra; public Color PositiveColor => positiveColor; [SerializeField] private Color positiveColor; public Color NegativeColor => negativeColor; [SerializeField] private Color negativeColor; private void AssignComponentsIfRequired() { canvasGroup ??= GetComponent<CanvasGroup>();  private void OnValidate() { AssignComponentsIfRequired();  private void Awake() { AssignComponentsIfRequired();  ",
          "content_tokens": 177,
          "embedding": []
        },
        {
          "cs_scriptfile": "UICombatText",
          "content": "public void Init(Sprite icon, string amountString, Color color, string extra) { if (icon == null) { imageIcon.gameObject.SetActive(false); } else { imageIcon.sprite = icon; } textAmount.SetText(amountString); textAmount.SetColor(color); textExtra.SetText(extra); textExtra.SetColor(color); canvasGroup.alpha = 1f; StartCoroutine(FadeOutCoroutine()); } private IEnumerator FadeOutCoroutine() { float elapsedTime = 0; while (elapsedTime < DURATION) { canvasGroup.alpha = 1 - elapsedTime / DURATION; elapsedTime += Time.deltaTime; yield return null;  Destroy(gameObject); } }",
          "content_tokens": 165,
          "embedding": []
        }
      ],
      "length": 1305
    },
    {
      "filename": "GameStateController",
      "content": "using UnityEngine; public class GameStateController : MonoBehaviour { public static GameStateController Instance { get; private set; } public static GameState CurrentState => Instance._currentState; private GameState _currentState = GameState.Default; public enum GameState { Default, ChatOpen, SettingsMenu } private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(gameObject); } DontDestroyOnLoad(this); } /// <summary> /// Change the current state of the game /// </summary> /// <param name=\"state\"></param> public void SetState(GameState state) { _currentState = state; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "GameStateController",
          "content": "using UnityEngine; public class GameStateController : MonoBehaviour { public static GameStateController Instance { get; private set; } public static GameState CurrentState => Instance._currentState; private GameState _currentState = GameState.Default; public enum GameState { Default, ChatOpen, SettingsMenu } private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(gameObject); } DontDestroyOnLoad(this); } /// <summary> /// Change the current state of the game /// </summary> /// <param name=\"state\"></param> public void SetState(GameState state) { _currentState = state; } }",
          "content_tokens": 145,
          "embedding": []
        }
      ],
      "length": 602
    },
    {
      "filename": "GpuInstancingForGameObjects",
      "content": "// scr* https://gist.github.com/andrew-raphael-lukasik/df4a36ff2ad89078258fd653c422a021 using System.Collections.Generic; using UnityEngine; public class GpuInstancingForGameObjects : MonoBehaviour { [SerializeField] Camera _camera = null; [SerializeField] MeshRenderer[] _meshRenderers = new MeshRenderer[0]; /// <summary> /// Prefer \"true\" ☑ as \"false\" ☐ require updates every frame. /// It is a good idea to keep lists of still and moving mesh renderers in a separate components. /// </summary> public bool meshesAreStill = true; Dictionary<(Mesh mesh,Material material),(List<Transform> transforms,Bounds aabb)> _sources = new Dictionary<(Mesh,Material),(List<Transform>,Bounds)>(); Dictionary<(Mesh mesh,Material material),(Matrix4x4[] matrices,Bounds aabb)> _batches = new Dictionary<(Mesh,Material),(Matrix4x4[],Bounds)>(); Dictionary<int,Stack<Matrix4x4[]>> _freeMatrices = new Dictionary<int,Stack<Matrix4x4[]>>(); Plane[] _frustum = new Plane[6]; public void SetMeshRenderers(MeshRenderer[] meshRenderers) { _meshRenderers = meshRenderers; } public void InitStart () { Initialize(); UpdateMatrices(); if( _camera==null ) _camera = GameObject.FindGameObjectWithTag(\"MainCamera\").GetComponent<Camera>(); if( _camera==null ) { Debug.LogError( \"no camera, can't continue\" , this ); enabled = false; } } void Update () { if( _camera==null ) return; if( !meshesAreStill ) UpdateMatrices(); GeometryUtility.CalculateFrustumPlanes( _camera , _frustum ); foreach( var batch in _batches ) { var meshMaterialPair = batch.Key; var matricesAabbPair = batch.Value; var aabb = matricesAabbPair.aabb; if( GeometryUtility.TestPlanesAABB(_frustum,aabb) ) { Graphics.DrawMeshInstanced( mesh: meshMaterialPair.mesh , submeshIndex: 0 , material: meshMaterialPair.material , matrices: matricesAabbPair.matrices ); } } } #if UNITY_EDITOR // void OnDrawGizmosSelected () void OnDrawGizmos () { Initialize(); Gizmos.color = Color.yellow; foreach( var source in _sources ) { var transformsAabbPair = source.Value; var aabb = transformsAabbPair.aabb; Gizmos.DrawWireCube( aabb.center , aabb.size ); if( Application.isPlaying && !GeometryUtility.TestPlanesAABB(_frustum,aabb) ) UnityEditor.Handles.Label( aabb.center , \"(out of camera view)\" ); } } #endif void Initialize () { _sources.Clear(); foreach( var meshRenderer in _meshRenderers ) { if( meshRenderer==null ) continue; var meshFilter = meshRenderer.GetComponent<MeshFilter>(); if( meshFilter==null ) continue; var mesh = meshFilter.sharedMesh; if( mesh==null ) continue; foreach( var material in meshRenderer.sharedMaterials ) { if( !material.enableInstancing && Application.isPlaying ) { Debug.LogWarning($\"\\\"{material.name}\\\" material won't be rendered as it's <b>GPU Instancing</b> is not enabled\",meshRenderer); continue; } if( material==null ) continue; var aabb = meshRenderer.bounds; var meshMaterialPair = ( mesh , material ); if( _sources.ContainsKey( meshMaterialPair ) ) { var transforms = _sources[meshMaterialPair].transforms; transforms.Add( meshRenderer.transform ); var newAabb = _sources[meshMaterialPair].aabb; newAabb.Encapsulate( aabb ); _sources[meshMaterialPair] = ( transforms , newAabb ); } else { _sources.Add( meshMaterialPair , ( new List<Transform>(){ meshRenderer.transform } , aabb ) ); } } if( Application.isPlaying ) meshRenderer.enabled = false; } } void UpdateMatrices () { foreach( var batch in _batches ) { var matricesAabbPair = batch.Value; var matrices = matricesAabbPair.matrices; if( _freeMatrices.ContainsKey( matrices.Length ) ) { _freeMatrices[matrices.Length].Push( matrices ); } else { var stack = new Stack<Matrix4x4[]>(); stack.Push( matrices ); _freeMatrices.Add( matrices.Length , stack ); } } _batches.Clear(); foreach( var source in _sources ) { var meshMaterialPair = source.Key; var transformsAabbPair = source.Value; var transforms = transformsAabbPair.transforms; int numTransforms = transforms.Count; Matrix4x4[] matrices = null; if( _freeMatrices.ContainsKey(numTransforms) && _freeMatrices[numTransforms].Count!=0 ) { matrices = _freeMatrices[numTransforms].Pop(); } else matrices = new Matrix4x4[ numTransforms ]; for( int i=0 ; i<numTransforms ; i++ ) matrices[i] = transforms[i].localToWorldMatrix; _batches.Add( meshMaterialPair , ( matrices , transformsAabbPair.aabb ) ); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "GpuInstancingForGameObjects",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "GpuInstancingForGameObjects",
          "content": "// scr* https://gist.github.com/andrew-raphael-lukasik/df4a36ff2ad89078258fd653c422a021 using System.Collections.Generic; using UnityEngine; public class GpuInstancingForGameObjects : MonoBehaviour { [SerializeField] Camera _camera = null; [SerializeField] MeshRenderer[] _meshRenderers = new MeshRenderer[0]; /// <summary> /// Prefer \"true\" ☑ as \"false\" ☐ require updates every frame. /// It is a good idea to keep lists of still and moving mesh renderers in a separate components. /// </summary> public bool meshesAreStill = true; Dictionary<(Mesh mesh,Material material),(List<Transform> transforms,Bounds aabb)> _sources = new Dictionary<(Mesh,Material),(List<Transform>,Bounds)>(); Dictionary<(Mesh mesh,Material material),(Matrix4x4[] matrices,Bounds aabb)> _batches = new Dictionary<(Mesh,Material),(Matrix4x4[],Bounds)>(); Dictionary<int,Stack<Matrix4x4[]>> _freeMatrices = new Dictionary<int,Stack<Matrix4x4[]>>(); Plane[] _frustum = new Plane[6]; public void SetMeshRenderers(MeshRenderer[] meshRenderers) { _meshRenderers = meshRenderers;  ",
          "content_tokens": 326,
          "embedding": []
        },
        {
          "cs_scriptfile": "GpuInstancingForGameObjects",
          "content": "public void InitStart () { Initialize(); UpdateMatrices(); if( _camera==null ) _camera = GameObject.FindGameObjectWithTag(\"MainCamera\").GetComponent<Camera>(); if( _camera==null ) { Debug.LogError( \"no camera, can't continue\" , this ); enabled = false; }  ",
          "content_tokens": 72,
          "embedding": []
        },
        {
          "cs_scriptfile": "GpuInstancingForGameObjects",
          "content": "void Update () { if( _camera==null ) return; if( !meshesAreStill ) UpdateMatrices(); GeometryUtility.CalculateFrustumPlanes( _camera , _frustum ); foreach( var batch in _batches ) { var meshMaterialPair = batch.Key; var matricesAabbPair = batch.Value; var aabb = matricesAabbPair.aabb; if( GeometryUtility.TestPlanesAABB(_frustum,aabb) ) { Graphics.DrawMeshInstanced( mesh: meshMaterialPair.mesh , submeshIndex: 0 , material: meshMaterialPair.material , matrices: matricesAabbPair.matrices ); } } } #if UNITY_EDITOR // void OnDrawGizmosSelected () void OnDrawGizmos () { Initialize(); Gizmos.color = Color.yellow; foreach( var source in _sources ) { var transformsAabbPair = source.Value; var aabb = transformsAabbPair.aabb; Gizmos.DrawWireCube( aabb.center , aabb.size ); if( Application.isPlaying && !GeometryUtility.TestPlanesAABB(_frustum,aabb) ) UnityEditor.Handles.Label( aabb.center , \"(out of camera view)\" ); } } #endif void Initialize () { _sources.Clear(); foreach( var meshRenderer in _meshRenderers ) { if( meshRenderer==null ) continue; var meshFilter = meshRenderer.GetComponent<MeshFilter>(); if( meshFilter==null ) continue; var mesh = meshFilter.sharedMesh; if( mesh==null ) continue; foreach( var material in meshRenderer.sharedMaterials ) { if( !material.enableInstancing && Application.isPlaying ) { Debug.LogWarning($\"\\\"{material.name}\\\" material won't be rendered as it's <b>GPU Instancing</b> is not enabled\",meshRenderer); continue;  ",
          "content_tokens": 462,
          "embedding": []
        },
        {
          "cs_scriptfile": "GpuInstancingForGameObjects",
          "content": "if( material==null ) continue; var aabb = meshRenderer.bounds; var meshMaterialPair = ( mesh , material ); if( _sources.ContainsKey( meshMaterialPair ) ) { var transforms = _sources[meshMaterialPair].transforms; transforms.Add( meshRenderer.transform ); var newAabb = _sources[meshMaterialPair].aabb; newAabb.Encapsulate( aabb ); _sources[meshMaterialPair] = ( transforms , newAabb ); } else { _sources.Add( meshMaterialPair , ( new List<Transform>(){ meshRenderer.transform } , aabb ) ); }  if( Application.isPlaying ) meshRenderer.enabled = false; }  ",
          "content_tokens": 176,
          "embedding": []
        },
        {
          "cs_scriptfile": "GpuInstancingForGameObjects",
          "content": "void UpdateMatrices () { foreach( var batch in _batches ) { var matricesAabbPair = batch.Value; var matrices = matricesAabbPair.matrices; if( _freeMatrices.ContainsKey( matrices.Length ) ) { _freeMatrices[matrices.Length].Push( matrices ); } else { var stack = new Stack<Matrix4x4[]>(); stack.Push( matrices ); _freeMatrices.Add( matrices.Length , stack ); } } _batches.Clear(); foreach( var source in _sources ) { var meshMaterialPair = source.Key; var transformsAabbPair = source.Value; var transforms = transformsAabbPair.transforms; int numTransforms = transforms.Count; Matrix4x4[] matrices = null; if( _freeMatrices.ContainsKey(numTransforms) && _freeMatrices[numTransforms].Count!=0 ) { matrices = _freeMatrices[numTransforms].Pop(); } else matrices = new Matrix4x4[ numTransforms ]; for( int i=0 ; i<numTransforms ; i++ ) matrices[i] = transforms[i].localToWorldMatrix; _batches.Add( meshMaterialPair , ( matrices , transformsAabbPair.aabb ) ); } } }",
          "content_tokens": 303,
          "embedding": []
        }
      ],
      "length": 4282
    },
    {
      "filename": "HeadEffectorMovement",
      "content": "using System.Collections; using DG.Tweening; using RootMotion.FinalIK; using UnityEngine; public class HeadEffectorMovement : MonoBehaviour { [SerializeField] private FBBIKHeadEffector headEffector; private MeshRenderer _meshRenderer; private Vector3 _prevHeadPos; private bool _isPlayingHitEffect; private void Awake() { _meshRenderer = headEffector.GetComponent<MeshRenderer>(); SetPositionWeight(0f); } private void OnValidate(){ headEffector ??= GetComponent<FBBIKHeadEffector>(); } public void DoHitEffect(Vector3 dirNormalized, float force) { if (_isPlayingHitEffect) return; var targetTrans = headEffector.transform; _prevHeadPos = headEffector.ik.references.head.position; float duration = .5f; _isPlayingHitEffect = true; SetPositionWeight(.1f); StartCoroutine(ReturnHeadBack(duration)); // Project hit direction onto XZ plane to get horizontal rotation Vector3 horizontalDir = new Vector3(dirNormalized.x, 0f, dirNormalized.z).normalized; // Calculate the rotation based on the hit direction Quaternion targetRotation = Quaternion.LookRotation(horizontalDir, Vector3.up); // Calculate rotation angle based on the force float rotationAngle = Mathf.Clamp(force * 10f, -45f, 45f); // Adjust the multiplier as needed // Apply rotation angle to target rotation targetRotation *= Quaternion.Euler(0f, rotationAngle, 0f); // Add rotation animation using DOTween targetTrans.DORotateQuaternion(targetRotation, duration) .SetEase(Ease.InOutQuad); // You can adjust easing function as needed // //Rotate in a movie style manner like receiving sword attack // // Calculate the rotation based on the hit direction // Quaternion targetRotation = Quaternion.LookRotation(dirNormalized, Vector3.up); // // // Add rotation animation using DOTween // targetTrans.DORotateQuaternion(targetRotation, duration) // .SetEase(Ease.InOutQuad); // You can adjust easing function as needed // Just move head //targetTrans.DOMove(targetTrans.position + dirNormalized * force, duration).SetEase(Ease.OutQuad); } private IEnumerator ReturnHeadBack(float timeout) { yield return new WaitForSeconds(timeout); float headReturnTime = .3f; headEffector.transform.DOMove(_prevHeadPos, headReturnTime).SetEase(Ease.InQuad); yield return new WaitForSeconds(headReturnTime); _isPlayingHitEffect = false; SetPositionWeight(0f); } private void SetPositionWeight(float value) { headEffector.positionWeight = value; Debug.Log($\"[HeadEffector] Position weight set to {value}\"); if (Mathf.Approximately(value, float.Epsilon)) { _meshRenderer.enabled = false; transform.position = headEffector.ik.references.head.position; } else { _meshRenderer.enabled = true; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "HeadEffectorMovement",
          "content": "using System.Collections; using DG.Tweening; using RootMotion.FinalIK; using UnityEngine; public class HeadEffectorMovement : MonoBehaviour { [SerializeField] private FBBIKHeadEffector headEffector; private MeshRenderer _meshRenderer; private Vector3 _prevHeadPos; private bool _isPlayingHitEffect; private void Awake() { _meshRenderer = headEffector.GetComponent<MeshRenderer>(); SetPositionWeight(0f);  private void OnValidate(){ headEffector ??= GetComponent<FBBIKHeadEffector>();  ",
          "content_tokens": 138,
          "embedding": []
        },
        {
          "cs_scriptfile": "HeadEffectorMovement",
          "content": "public void DoHitEffect(Vector3 dirNormalized, float force) { if (_isPlayingHitEffect) return; var targetTrans = headEffector.transform; _prevHeadPos = headEffector.ik.references.head.position; float duration = .5f; _isPlayingHitEffect = true; SetPositionWeight(.1f); StartCoroutine(ReturnHeadBack(duration)); // Project hit direction onto XZ plane to get horizontal rotation Vector3 horizontalDir = new Vector3(dirNormalized.x, 0f, dirNormalized.z).normalized; // Calculate the rotation based on the hit direction Quaternion targetRotation = Quaternion.LookRotation(horizontalDir, Vector3.up); // Calculate rotation angle based on the force float rotationAngle = Mathf.Clamp(force * 10f, -45f, 45f); // Adjust the multiplier as needed // Apply rotation angle to target rotation targetRotation *= Quaternion.Euler(0f, rotationAngle, 0f); // Add rotation animation using DOTween targetTrans.DORotateQuaternion(targetRotation, duration) .SetEase(Ease.InOutQuad); // You can adjust easing function as needed // //Rotate in a movie style manner like receiving sword attack // // Calculate the rotation based on the hit direction // Quaternion targetRotation = Quaternion.LookRotation(dirNormalized, Vector3.up); // // // Add rotation animation using DOTween // targetTrans.DORotateQuaternion(targetRotation, duration) // .SetEase(Ease.InOutQuad); // You can adjust easing function as needed // Just move head //targetTrans.DOMove(targetTrans.position + dirNormalized * force, duration).SetEase(Ease.OutQuad); } private IEnumerator ReturnHeadBack(float timeout) { yield return new WaitForSeconds(timeout); float headReturnTime = .3f; headEffector.transform.DOMove(_prevHeadPos, headReturnTime).SetEase(Ease.InQuad); yield return new WaitForSeconds(headReturnTime); _isPlayingHitEffect = false; SetPositionWeight(0f);  ",
          "content_tokens": 494,
          "embedding": []
        },
        {
          "cs_scriptfile": "HeadEffectorMovement",
          "content": "private void SetPositionWeight(float value) { headEffector.positionWeight = value; Debug.Log($\"[HeadEffector] Position weight set to {value}\"); if (Mathf.Approximately(value, float.Epsilon)) { _meshRenderer.enabled = false; transform.position = headEffector.ik.references.head.position; } else { _meshRenderer.enabled = true; } } }",
          "content_tokens": 98,
          "embedding": []
        }
      ],
      "length": 2632
    },
    {
      "filename": "HidePlayerOverheadRenderer",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class HidePlayerOverheadRenderer : MonoBehaviour { }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "HidePlayerOverheadRenderer",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class HidePlayerOverheadRenderer : MonoBehaviour { }",
          "content_tokens": 33,
          "embedding": []
        }
      ],
      "length": 138
    },
    {
      "filename": "HoldBar",
      "content": "using UnityEngine; using DuloGames.UI; public class HoldBar : MonoBehaviour { public GameObject HoldBtn; public static HoldBar Instance { get; private set; } private UIWindow _UIWindow; private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } } private void Start() { _UIWindow = GetComponent<UIWindow>(); } public void ToggleHoldBar() { //HoldBtn.SetActive(!HoldBtn.activeSelf); _UIWindow.ToggleNoSound(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "HoldBar",
          "content": "using UnityEngine; using DuloGames.UI; public class HoldBar : MonoBehaviour { public GameObject HoldBtn; public static HoldBar Instance { get; private set; } private UIWindow _UIWindow; private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } } private void Start() { _UIWindow = GetComponent<UIWindow>(); } public void ToggleHoldBar() { //HoldBtn.SetActive(!HoldBtn.activeSelf); _UIWindow.ToggleNoSound(); } }",
          "content_tokens": 125,
          "embedding": []
        }
      ],
      "length": 444
    },
    {
      "filename": "ItemVisualsForNHAvatar",
      "content": "using System; using System.Collections.Generic; using NHance.Assets.Scripts; using UnityEngine; using NHance.Assets.Scripts.Enums; using NHance.Assets.Scripts.Items; using UnityEngine.Serialization; [CreateAssetMenu(fileName = \"ItemVisualsForNHAvatar\", menuName = \"ScriptableObjects/ItemVisualsForNHAvatar\", order = 0)] public class ItemVisualsForNHAvatar : ScriptableObject { public ItemGenderTypePrefabs[] itemGenderTypePrefabs; public bool IsShowAvatarWorks = false; public NHAvatar[] nhAvatarPrefab; public void FillItemGenderPrefabsFromNHAvatar() { itemGenderTypePrefabs = new ItemGenderTypePrefabs[nhAvatarPrefab.Length]; //ItemGenderPrefabs[] //---Element 0 //------Gender //------Item Type //------Item Prefabs[] //------------Element 0 //---------------SetName //---------------Prefab for (int i = 0; i < nhAvatarPrefab.Length; i++) { var nhAvatar = nhAvatarPrefab[i]; itemGenderTypePrefabs[i] = new ItemGenderTypePrefabs(); itemGenderTypePrefabs[i].gender = nhAvatar.Gender; } } public NHItem GetPrefab(Gender gender, ItemTypeEnum itemType, int id) { for (int i = 0; i < itemGenderTypePrefabs.Length; i++) { var itemGenderPrefab = itemGenderTypePrefabs[i]; if (itemGenderPrefab == null) continue; if (itemGenderPrefab.gender != gender) continue; if (itemGenderPrefab.itemTypePrefabs == null) continue; for (int j = 0; j < itemGenderPrefab.itemTypePrefabs.Count; j++) { var itemTypePrefabsForSelectedGender = itemGenderPrefab.itemTypePrefabs[j]; if (itemTypePrefabsForSelectedGender.itemType != itemType) continue; if (id < 0 || id >= itemTypePrefabsForSelectedGender.itemPrefabs.Length) continue; return itemTypePrefabsForSelectedGender.itemPrefabs[id].prefab; } } Debug.LogError($\"[ItemVisualsForNHAvatar] No prefab found for {gender} itemType: {itemType} id: {id}\"); return null; } public bool IsPrefabPersistInList(Gender gender, ItemTypeEnum itemType, string targetName) { ItemPrefab[] possiblePrefabs = GetItemPrefabs(gender, itemType); if (possiblePrefabs == null) return false; for (int i = 0; i < possiblePrefabs.Length; i++) { if (possiblePrefabs[i].prefab.name == targetName) { return true; } } return false; } public int GetPrefabId(Gender gender, ItemTypeEnum itemType, NHItem prefab) { ItemPrefab[] possiblePrefabs = GetItemPrefabs(gender, itemType); if (possiblePrefabs == null) return -1; for (int i = 0; i < possiblePrefabs.Length; i++) { if (possiblePrefabs[i].prefab == prefab) { return i; } } return -1; } public ItemPrefab[] GetItemPrefabs(Gender gender, ItemTypeEnum itemType) { for (int i = 0; i < itemGenderTypePrefabs.Length; i++) { var itemGenderPrefab = itemGenderTypePrefabs[i]; if (itemGenderPrefab == null) continue; if (itemGenderPrefab.gender != gender) continue; foreach (var itemTypePrefabs in itemGenderTypePrefabs[i].itemTypePrefabs) { if (itemTypePrefabs.itemType == itemType) return itemTypePrefabs.itemPrefabs; } } return null; } [Serializable] public class ItemGenderTypePrefabs { public Gender gender; public List<ItemTypePrefabs> itemTypePrefabs = new (); } [Serializable] public class ItemTypePrefabs { public string m_Name; public ItemTypeEnum itemType; public ItemPrefab[] itemPrefabs; } [Serializable] public class ItemPrefab { public string m_Name; public NHItem prefab; } private void AddTargetType(int i, NHItem[] target) { if (target == null || target.Length == 0) return; //ItemGenderPrefabs //---Element 0 //------Gender //------Item Type //---------Item Prefabs //------------Element 0 //---------------SetName //---------------Prefab ItemGenderTypePrefabs targetPrefabs = itemGenderTypePrefabs[i]; var newItemTypePrefabs = new ItemTypePrefabs(); targetPrefabs.itemTypePrefabs.Add(newItemTypePrefabs); newItemTypePrefabs.itemType = target[i].Type; newItemTypePrefabs.m_Name = newItemTypePrefabs.itemType.ToString(); List<ItemPrefab> itemPrefabs = new List<ItemPrefab>(); for (int j = 0; j < target.Length; j++) { var itemPrefab = CreateItemPrefab(target[j]); itemPrefabs.Add(itemPrefab); } newItemTypePrefabs.itemPrefabs = itemPrefabs.ToArray(); } public static ItemPrefab CreateItemPrefab(NHItem target) { var itemPrefab = new ItemPrefab(); itemPrefab.prefab = target; string[] nameParts = target.name.Split(\"_\"); string name = String.Empty; for (int k = 3; k < nameParts.Length; k++) { name += nameParts[k]; if (k < nameParts.Length - 1) name += \"_\"; } itemPrefab.m_Name = name; return itemPrefab; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ItemVisualsForNHAvatar",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemVisualsForNHAvatar",
          "content": "using System; using System.Collections.Generic; using NHance.Assets.Scripts; using UnityEngine; using NHance.Assets.Scripts.Enums; using NHance.Assets.Scripts.Items; using UnityEngine.Serialization; [CreateAssetMenu(fileName = \"ItemVisualsForNHAvatar\", menuName = \"ScriptableObjects/ItemVisualsForNHAvatar\", order = 0)] public class ItemVisualsForNHAvatar : ScriptableObject { public ItemGenderTypePrefabs[] itemGenderTypePrefabs; public bool IsShowAvatarWorks = false; public NHAvatar[] nhAvatarPrefab; public void FillItemGenderPrefabsFromNHAvatar() { itemGenderTypePrefabs = new ItemGenderTypePrefabs[nhAvatarPrefab.Length]; //ItemGenderPrefabs[] //---Element 0 //------Gender //------Item Type //------Item Prefabs[] //------------Element 0 //---------------SetName //---------------Prefab for (int i = 0; i < nhAvatarPrefab.Length; i++) { var nhAvatar = nhAvatarPrefab[i]; itemGenderTypePrefabs[i] = new ItemGenderTypePrefabs(); itemGenderTypePrefabs[i].gender = nhAvatar.Gender; } } public NHItem GetPrefab(Gender gender, ItemTypeEnum itemType, int id) { for (int i = 0; i < itemGenderTypePrefabs.Length; i++) { var itemGenderPrefab = itemGenderTypePrefabs[i]; if (itemGenderPrefab == null) continue; if (itemGenderPrefab.gender != gender) continue; if (itemGenderPrefab.itemTypePrefabs == null) continue; for (int j = 0; j < itemGenderPrefab.itemTypePrefabs.Count; j++) { var itemTypePrefabsForSelectedGender = itemGenderPrefab.itemTypePrefabs[j]; if (itemTypePrefabsForSelectedGender.itemType != itemType) continue; if (id < 0 || id >= itemTypePrefabsForSelectedGender.itemPrefabs.Length) continue; return itemTypePrefabsForSelectedGender.itemPrefabs[id].prefab; } } Debug.LogError($\"[ItemVisualsForNHAvatar] No prefab found for {gender} itemType: {itemType} id: {id}\"); return null;  ",
          "content_tokens": 531,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemVisualsForNHAvatar",
          "content": "public bool IsPrefabPersistInList(Gender gender, ItemTypeEnum itemType, string targetName) { ItemPrefab[] possiblePrefabs = GetItemPrefabs(gender, itemType); if (possiblePrefabs == null) return false; for (int i = 0; i < possiblePrefabs.Length; i++) { if (possiblePrefabs[i].prefab.name == targetName) { return true; } } return false;  ",
          "content_tokens": 101,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemVisualsForNHAvatar",
          "content": "public int GetPrefabId(Gender gender, ItemTypeEnum itemType, NHItem prefab) { ItemPrefab[] possiblePrefabs = GetItemPrefabs(gender, itemType); if (possiblePrefabs == null) return -1; for (int i = 0; i < possiblePrefabs.Length; i++) { if (possiblePrefabs[i].prefab == prefab) { return i; } } return -1; } public ItemPrefab[] GetItemPrefabs(Gender gender, ItemTypeEnum itemType) { for (int i = 0; i < itemGenderTypePrefabs.Length; i++) { var itemGenderPrefab = itemGenderTypePrefabs[i]; if (itemGenderPrefab == null) continue; if (itemGenderPrefab.gender != gender) continue; foreach (var itemTypePrefabs in itemGenderTypePrefabs[i].itemTypePrefabs) { if (itemTypePrefabs.itemType == itemType) return itemTypePrefabs.itemPrefabs; } } return null; } [Serializable] public class ItemGenderTypePrefabs { public Gender gender; public List<ItemTypePrefabs> itemTypePrefabs = new (); } [Serializable] public class ItemTypePrefabs { public string m_Name; public ItemTypeEnum itemType; public ItemPrefab[] itemPrefabs; } [Serializable] public class ItemPrefab { public string m_Name; public NHItem prefab;  ",
          "content_tokens": 320,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemVisualsForNHAvatar",
          "content": "private void AddTargetType(int i, NHItem[] target) { if (target == null || target.Length == 0) return; //ItemGenderPrefabs //---Element 0 //------Gender //------Item Type //---------Item Prefabs //------------Element 0 //---------------SetName //---------------Prefab ItemGenderTypePrefabs targetPrefabs = itemGenderTypePrefabs[i]; var newItemTypePrefabs = new ItemTypePrefabs(); targetPrefabs.itemTypePrefabs.Add(newItemTypePrefabs); newItemTypePrefabs.itemType = target[i].Type; newItemTypePrefabs.m_Name = newItemTypePrefabs.itemType.ToString(); List<ItemPrefab> itemPrefabs = new List<ItemPrefab>(); for (int j = 0; j < target.Length; j++) { var itemPrefab = CreateItemPrefab(target[j]); itemPrefabs.Add(itemPrefab); } newItemTypePrefabs.itemPrefabs = itemPrefabs.ToArray(); } public static ItemPrefab CreateItemPrefab(NHItem target) { var itemPrefab = new ItemPrefab(); itemPrefab.prefab = target; string[] nameParts = target.name.Split(\"_\"); string name = String.Empty; for (int k = 3; k < nameParts.Length; k++) { name += nameParts[k]; if (k < nameParts.Length - 1) name += \"_\"; } itemPrefab.m_Name = name; return itemPrefab; } }",
          "content_tokens": 334,
          "embedding": []
        }
      ],
      "length": 4365
    },
    {
      "filename": "LightFlickerEffect",
      "content": "using UnityEngine; using System.Collections.Generic; using LlamaSoftware.Utilities; // Written by Steve Streeting 2017 // License: CC0 Public Domain http://creativecommons.org/publicdomain/zero/1.0/ /// <summary> /// Component which will flicker a linked light while active by changing its /// intensity between the min and max values given. The flickering can be /// sharp or smoothed depending on the value of the smoothing parameter. /// /// Just activate / deactivate this component as usual to pause / resume flicker /// </summary> public class LightFlickerEffect : MonoBehaviour { [Tooltip(\"External light to flicker; you can leave this null if you attach script to a light\")] public new Light light; [Tooltip(\"Minimum random light intensity\")] public float minIntensity = 0f; [Tooltip(\"Maximum random light intensity\")] public float maxIntensity = 1f; [Tooltip(\"How much to smooth out the randomness; lower values = sparks, higher = lantern\")] [Range(1, 50)] public int smoothing = 5; [SerializeField] private bool isAutoStart = false; private bool _isStarted = false; // Continuous average calculation via FIFO queue // Saves us iterating every time we update, we just change by the delta Queue<float> smoothQueue; float lastSum = 0; private LightLOD _lightLod; private System.Random _random; private void Awake() { _lightLod = GetComponent<LightLOD>(); _lightLod.OnLightLODChanged += LightLod_OnLightLODChanged; _random = new System.Random(); smoothQueue = new Queue<float>(smoothing); // External or internal light? if (light == null) { light = GetComponent<Light>(); } } /// <summary> /// Reset the randomness and start again. You usually don't need to call /// this, deactivating/reactivating is usually fine but if you want a strict /// restart you can do. /// </summary> public void Reset() { smoothQueue.Clear(); lastSum = 0; } void Start() { if (isAutoStart) { _isStarted = true; } } private void LightLod_OnLightLODChanged(int lod) { if (lod < 2) { _isStarted = true; } } public void Stop() { _isStarted = false; } void Update() { if (!_isStarted) return; if (light == null) return; // pop off an item if too big while (smoothQueue.Count >= smoothing) { lastSum -= smoothQueue.Dequeue(); } // Generate random new item, calculate new average float newVal = _random.NextFloat() * (maxIntensity - minIntensity) + minIntensity; smoothQueue.Enqueue(newVal); lastSum += newVal; // Calculate new smoothed average light.intensity = lastSum / (float)smoothQueue.Count; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LightFlickerEffect",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "LightFlickerEffect",
          "content": "using UnityEngine; using System.Collections.Generic; using LlamaSoftware.Utilities; // Written by Steve Streeting 2017 // License: CC0 Public Domain http://creativecommons.org/publicdomain/zero/1.0/ /// <summary> /// Component which will flicker a linked light while active by changing its /// intensity between the min and max values given. The flickering can be /// sharp or smoothed depending on the value of the smoothing parameter. /// /// Just activate / deactivate this component as usual to pause / resume flicker /// </summary> public class LightFlickerEffect : MonoBehaviour { [Tooltip(\"External light to flicker; you can leave this null if you attach script to a light\")] public new Light light; [Tooltip(\"Minimum random light intensity\")] public float minIntensity = 0f; [Tooltip(\"Maximum random light intensity\")] public float maxIntensity = 1f; [Tooltip(\"How much to smooth out the randomness; lower values = sparks, higher = lantern\")] [Range(1, 50)] public int smoothing = 5; [SerializeField] private bool isAutoStart = false; private bool _isStarted = false; // Continuous average calculation via FIFO queue // Saves us iterating every time we update, we just change by the delta Queue<float> smoothQueue; float lastSum = 0; private LightLOD _lightLod; private System.Random _random; private void Awake() { _lightLod = GetComponent<LightLOD>(); _lightLod.OnLightLODChanged += LightLod_OnLightLODChanged; _random = new System.Random(); smoothQueue = new Queue<float>(smoothing); // External or internal light? if (light == null) { light = GetComponent<Light>(); } } /// <summary> /// Reset the randomness and start again. You usually don't need to call /// this, deactivating/reactivating is usually fine but if you want a strict /// restart you can do. /// </summary> public void Reset() { smoothQueue.Clear(); lastSum = 0;  ",
          "content_tokens": 459,
          "embedding": []
        },
        {
          "cs_scriptfile": "LightFlickerEffect",
          "content": "void Start() { if (isAutoStart) { _isStarted = true; }  private void LightLod_OnLightLODChanged(int lod) { if (lod < 2) { _isStarted = true; }  public void Stop() { _isStarted = false;  void Update() { if (!_isStarted) return; if (light == null) return; // pop off an item if too big while (smoothQueue.Count >= smoothing) { lastSum -= smoothQueue.Dequeue(); } // Generate random new item, calculate new average float newVal = _random.NextFloat() * (maxIntensity - minIntensity) + minIntensity; smoothQueue.Enqueue(newVal); lastSum += newVal; // Calculate new smoothed average light.intensity = lastSum / (float)smoothQueue.Count; } }",
          "content_tokens": 191,
          "embedding": []
        }
      ],
      "length": 2480
    },
    {
      "filename": "FreeCamera",
      "content": " using UnityEngine; namespace LlamaSoftware.Utilities { [RequireComponent(typeof(Camera))] public class FreeCamera : MonoBehaviour { [SerializeField] private bool EnableInputCapture = true; [SerializeField] private bool HoldRightMouseCapture = false; [SerializeField] private float lookSpeed = 3f; [SerializeField] private float moveSpeed = 3f; [SerializeField] private float FastMoveSpeed = 10f; private bool InputCaptured; private float Yaw; private float Pitch; private float RotationX; private float RotationY; private float Speed; private float Forward; private float Right; private float Up; private new Camera camera; private void Awake() { camera = GetComponent<Camera>(); } void Start() { enabled = EnableInputCapture; } private void CaptureInput() { Cursor.lockState = CursorLockMode.Locked; Cursor.visible = false; InputCaptured = true; Yaw = transform.eulerAngles.y; Pitch = transform.eulerAngles.x; } private void ReleaseInput() { Cursor.lockState = CursorLockMode.None; Cursor.visible = true; InputCaptured = false; } void Update() { if (camera.enabled) { if (!InputCaptured) { if (!HoldRightMouseCapture && Input.GetMouseButtonDown(0)) { CaptureInput(); } else if (HoldRightMouseCapture && Input.GetMouseButtonDown(1)) { CaptureInput(); } } if (!InputCaptured) { return; } if (InputCaptured) { if (!HoldRightMouseCapture && Input.GetKeyDown(KeyCode.Escape)) { ReleaseInput(); } else if (HoldRightMouseCapture && Input.GetMouseButtonUp(1)) { ReleaseInput(); } } RotationX = Input.GetAxis(\"Mouse X\"); RotationY = Input.GetAxis(\"Mouse Y\"); Yaw = (Yaw + lookSpeed * RotationX) % 360f; Pitch = (Pitch - lookSpeed * RotationY) % 360f; transform.rotation = Quaternion.AngleAxis(Yaw, Vector3.up) * Quaternion.AngleAxis(Pitch, Vector3.right); Speed = Time.deltaTime * (Input.GetKey(KeyCode.LeftShift) ? FastMoveSpeed : moveSpeed); Forward = Speed * Input.GetAxis(\"Vertical\"); Right = Speed * Input.GetAxis(\"Horizontal\"); Up = Speed * ((Input.GetKey(KeyCode.E) ? 1f : 0f) - (Input.GetKey(KeyCode.Q) ? 1f : 0f)); transform.position += (transform.forward * Forward) + (transform.right * Right) + (Vector3.up * Up); } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "FreeCamera",
          "content": " using UnityEngine; namespace LlamaSoftware.Utilities { [RequireComponent(typeof(Camera))] public class FreeCamera : MonoBehaviour { [SerializeField] private bool EnableInputCapture = true; [SerializeField] private bool HoldRightMouseCapture = false; [SerializeField] private float lookSpeed = 3f; [SerializeField] private float moveSpeed = 3f; [SerializeField] private float FastMoveSpeed = 10f; private bool InputCaptured; private float Yaw; private float Pitch; private float RotationX; private float RotationY; private float Speed; private float Forward; private float Right; private float Up; private new Camera camera; private void Awake() { camera = GetComponent<Camera>();  void Start() { enabled = EnableInputCapture;  ",
          "content_tokens": 174,
          "embedding": []
        },
        {
          "cs_scriptfile": "FreeCamera",
          "content": "private void CaptureInput() { Cursor.lockState = CursorLockMode.Locked; Cursor.visible = false; InputCaptured = true; Yaw = transform.eulerAngles.y; Pitch = transform.eulerAngles.x;  private void ReleaseInput() { Cursor.lockState = CursorLockMode.None; Cursor.visible = true; InputCaptured = false;  void Update() { if (camera.enabled) { if (!InputCaptured) { if (!HoldRightMouseCapture && Input.GetMouseButtonDown(0)) { CaptureInput(); } else if (HoldRightMouseCapture && Input.GetMouseButtonDown(1)) { CaptureInput(); }  if (!InputCaptured) { return;  ",
          "content_tokens": 163,
          "embedding": []
        },
        {
          "cs_scriptfile": "FreeCamera",
          "content": "if (InputCaptured) { if (!HoldRightMouseCapture && Input.GetKeyDown(KeyCode.Escape)) { ReleaseInput(); } else if (HoldRightMouseCapture && Input.GetMouseButtonUp(1)) { ReleaseInput(); } } RotationX = Input.GetAxis(\"Mouse X\"); RotationY = Input.GetAxis(\"Mouse Y\"); Yaw = (Yaw + lookSpeed * RotationX) % 360f; Pitch = (Pitch - lookSpeed * RotationY) % 360f; transform.rotation = Quaternion.AngleAxis(Yaw, Vector3.up) * Quaternion.AngleAxis(Pitch, Vector3.right); Speed = Time.deltaTime * (Input.GetKey(KeyCode.LeftShift) ? FastMoveSpeed : moveSpeed); Forward = Speed * Input.GetAxis(\"Vertical\"); Right = Speed * Input.GetAxis(\"Horizontal\"); Up = Speed * ((Input.GetKey(KeyCode.E) ? 1f : 0f) - (Input.GetKey(KeyCode.Q) ? 1f : 0f)); transform.position += (transform.forward * Forward) + (transform.right * Right) + (Vector3.up * Up); } } } }",
          "content_tokens": 282,
          "embedding": []
        }
      ],
      "length": 2125
    },
    {
      "filename": "LightLOD",
      "content": " using System; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.Events; using UnityEngine.Rendering; using UnityEngine.Serialization; namespace LlamaSoftware.Utilities { [RequireComponent(typeof(Light))] public class LightLOD : MonoBehaviour { private new Light light; [SerializeField] [Tooltip(\"For static (uncontrolled by script) lights, this should be true. If you have interactable lights, you should also adjust this with light.enabed\")] public bool LightShouldBeOn = true; [SerializeField] [Tooltip(\"The lower you set this, the faster the light will respond to player locations, and the higher the CPU usage\")] [Range(0, 1f)] private float UpdateDelay = 0.1f; //Replace this with your \"Player\" object private List<LightLODCamera> LODCameras = new (); [SerializeField] public List<LODAdjustment> ShadowQualityLods; [Header(\"Debug info\")] [SerializeField] [Tooltip(\"For Debugging - If you check this, the light color will be changed to the debug color defined on each LOD quality\")] private bool ShowLightColorAsDebugColor; [SerializeField] [Tooltip(\"For Debugging - displays how far player is from the light source\")] private float DistanceFromPlayer; [SerializeField] [Tooltip(\"For Debugging - displays if the Light's Shadow Resolution is clamped to Quality Settings\")] private bool IsClamped; [FormerlySerializedAs(\"LOD\")] [SerializeField] private int _lod; private Color CurrentDebugColor; private LightShadows DesiredLightShadowQuality; private LightShadowResolution InspectorShadowResolution; private bool InitiallyOn; private LightLODCamera FirstActiveCamera; private int index; private string WarningMessage = \"Shadow Resolution is clamped to: {0}, but no Light LOD step matches this quality!\"; private bool _isNeedCalculation = true; public Action<int> OnLightLODChanged; public UnityEvent OnLightLod0Activated; public UnityEvent OnLightLod1Activated; public UnityEvent OnLightLod2Activated; public UnityEvent OnLightLod3Activated; public UnityEvent OnLightLod4Activated; private void Awake() { light = GetComponent<Light>(); DesiredLightShadowQuality = light.shadows; InspectorShadowResolution = light.shadowResolution; InitiallyOn = light.enabled; StartCoroutine(CameraCatcher()); } private IEnumerator CameraCatcher() { while (LODCameras.Count == 0) { LODCameras = new List<LightLODCamera>(GameObject.FindObjectsOfType<LightLODCamera>()); yield return new WaitForSeconds(0.1f); } foreach (var lodCamera in LODCameras) { lodCamera.OnCameraMoved += LightLODCamera_OnCameraMoved; } } private void LightLODCamera_OnCameraMoved() { _isNeedCalculation = true; } private void OnEnable() { StartCoroutine(AdjustLODQuality()); } #if UNITY_EDITOR private void Update() { if (LODCameras.Count == 0) return; FirstActiveCamera = FindFirstActiveCamera(); if (FirstActiveCamera != null) { CurrentDebugColor = ShadowQualityLods[_lod].DebugColor; Debug.DrawLine(transform.position, LODCameras[index].transform.position, CurrentDebugColor); } } #endif IEnumerator AdjustLODQuality() { float delay = UpdateDelay + UpdateDelay == 0 ? UpdateDelay : UnityEngine.Random.value / 20f; //this randomization is to prevent all lights updating at the same time causing frame spikes int i = 0; int DesiredQuality; LODAdjustment ClampedLOD; WaitForSeconds Wait = new WaitForSeconds(delay); while (true) { FirstActiveCamera = FindFirstActiveCamera(); if (!_isNeedCalculation) { yield return Wait; continue; } if (FirstActiveCamera != null) // If first active camera is null, no cameras with LightLODCamera are active, so we will default to on, unless it should be on { if (LightShouldBeOn) { //DistanceFromPlayer = Vector3.Distance(transform.position, FirstActiveCamera.transform.position); DistanceFromPlayer = Vector3.SqrMagnitude(FirstActiveCamera.transform.position - transform.position); _isNeedCalculation = false; //Debug.Log($\"[LightLOD] DistanceFromPlayer: {DistanceFromPlayer}\", gameObject); for (i = 0; i < ShadowQualityLods.Count; i++) { if ((DistanceFromPlayer > ShadowQualityLods[i].DistanceRange.x && DistanceFromPlayer <= ShadowQualityLods[i].DistanceRange.y) || i == ShadowQualityLods.Count - 1) { UpdateLodValue(i); if (ShadowQualityLods[i].CastNoShadows) { light.shadows = LightShadows.None; if (ShowLightColorAsDebugColor) { light.color = ShadowQualityLods[i].DebugColor; } } else { light.shadows = ShadowQualityLods[i].LightShadows; light.enabled = true; //respect quality settings, do not go higher than what they have defined. if (QualitySettings.shadowResolution <= ShadowQualityLods[i].ShadowResolution) { IsClamped = true; DesiredQuality = (int)QualitySettings.shadowResolution; light.shadowResolution = (LightShadowResolution)DesiredQuality; if (ShowLightColorAsDebugColor) { ClampedLOD = FindMatchingShadowQualityIndex(QualitySettings.shadowResolution); if (ClampedLOD == null) { Debug.LogWarning(string.Format(WarningMessage, QualitySettings.shadowResolution.ToString())); } else { light.color = ClampedLOD.DebugColor; } } } else { IsClamped = false; light.shadowResolution = (LightShadowResolution)ShadowQualityLods[i].ShadowResolution; if (ShowLightColorAsDebugColor) { light.color = ShadowQualityLods[i].DebugColor; } } } break; } } } else { light.enabled = false; UpdateLodValue(0); } } else if (InitiallyOn) { light.enabled = true; light.shadows = DesiredLightShadowQuality; light.shadowResolution = InspectorShadowResolution; UpdateLodValue(0); } yield return Wait; } } private LightLODCamera FindFirstActiveCamera() { for (index = 0; index < LODCameras.Count; index++) { if (LODCameras[index] == null) { LODCameras = new List<LightLODCamera>(GameObject.FindObjectsOfType<LightLODCamera>()); }else{ if (LODCameras[index].Camera.enabled && LODCameras[index].gameObject.activeInHierarchy) { return LODCameras[index]; } } } return null; } private void UpdateLodValue(int value) { if (value != _lod) { _lod = value; OnLightLODChanged?.Invoke(value); switch (value) { case 0: OnLightLod0Activated?.Invoke(); break; case 1: OnLightLod1Activated?.Invoke(); break; case 2: OnLightLod2Activated?.Invoke(); break; case 3: OnLightLod3Activated?.Invoke(); break; case 4: OnLightLod4Activated?.Invoke(); break; default: break; } } } private LODAdjustment FindMatchingShadowQualityIndex(ShadowResolution Quality) { for (index = 0; index < ShadowQualityLods.Count; index++) { if (ShadowQualityLods[index].ShadowResolution.Equals(Quality)) { return ShadowQualityLods[index]; } } return null; } [Serializable] public class LODAdjustment { public Vector2 DistanceRange; public ShadowResolution ShadowResolution; public LightShadows LightShadows; public bool CastNoShadows; public Color DebugColor; public bool IsFlickerLight; } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LightLOD",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "LightLOD",
          "content": " using System; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.Events; using UnityEngine.Rendering; using UnityEngine.Serialization; namespace LlamaSoftware.Utilities { [RequireComponent(typeof(Light))] public class LightLOD : MonoBehaviour { private new Light light; [SerializeField] [Tooltip(\"For static (uncontrolled by script) lights, this should be true. If you have interactable lights, you should also adjust this with light.enabed\")] public bool LightShouldBeOn = true; [SerializeField] [Tooltip(\"The lower you set this, the faster the light will respond to player locations, and the higher the CPU usage\")] [Range(0, 1f)] private float UpdateDelay = 0.1f; //Replace this with your \"Player\" object private List<LightLODCamera> LODCameras = new (); [SerializeField] public List<LODAdjustment> ShadowQualityLods; [Header(\"Debug info\")] [SerializeField] [Tooltip(\"For Debugging - If you check this, the light color will be changed to the debug color defined on each LOD quality\")] private bool ShowLightColorAsDebugColor; [SerializeField] [Tooltip(\"For Debugging - displays how far player is from the light source\")] private float DistanceFromPlayer; [SerializeField] [Tooltip(\"For Debugging - displays if the Light's Shadow Resolution is clamped to Quality Settings\")] private bool IsClamped; [FormerlySerializedAs(\"LOD\")] [SerializeField] private int _lod; private Color CurrentDebugColor; private LightShadows DesiredLightShadowQuality; private LightShadowResolution InspectorShadowResolution; private bool InitiallyOn; private LightLODCamera FirstActiveCamera; private int index; private string WarningMessage = \"Shadow Resolution is clamped to: {0}, but no Light LOD step matches this quality!\"; private bool _isNeedCalculation = true; public Action<int> OnLightLODChanged; public UnityEvent OnLightLod0Activated; public UnityEvent OnLightLod1Activated; public UnityEvent OnLightLod2Activated; public UnityEvent OnLightLod3Activated; public UnityEvent OnLightLod4Activated; private void Awake() { light = GetComponent<Light>(); DesiredLightShadowQuality = light.shadows; InspectorShadowResolution = light.shadowResolution; InitiallyOn = light.enabled; StartCoroutine(CameraCatcher()); } private IEnumerator CameraCatcher() { while (LODCameras.Count == 0) { LODCameras = new List<LightLODCamera>(GameObject.FindObjectsOfType<LightLODCamera>()); yield return new WaitForSeconds(0.1f);  ",
          "content_tokens": 620,
          "embedding": []
        },
        {
          "cs_scriptfile": "LightLOD",
          "content": "foreach (var lodCamera in LODCameras) { lodCamera.OnCameraMoved += LightLODCamera_OnCameraMoved; }  private void LightLODCamera_OnCameraMoved() { _isNeedCalculation = true;  ",
          "content_tokens": 55,
          "embedding": []
        },
        {
          "cs_scriptfile": "LightLOD",
          "content": "private void OnEnable() { StartCoroutine(AdjustLODQuality()); } #if UNITY_EDITOR private void Update() { if (LODCameras.Count == 0) return; FirstActiveCamera = FindFirstActiveCamera(); if (FirstActiveCamera != null) { CurrentDebugColor = ShadowQualityLods[_lod].DebugColor; Debug.DrawLine(transform.position, LODCameras[index].transform.position, CurrentDebugColor); } } #endif IEnumerator AdjustLODQuality() { float delay = UpdateDelay + UpdateDelay == 0 ? UpdateDelay : UnityEngine.Random.value / 20f; //this randomization is to prevent all lights updating at the same time causing frame spikes int i = 0; int DesiredQuality; LODAdjustment ClampedLOD; WaitForSeconds Wait = new WaitForSeconds(delay); while (true) { FirstActiveCamera = FindFirstActiveCamera(); if (!_isNeedCalculation) { yield return Wait; continue;  ",
          "content_tokens": 218,
          "embedding": []
        },
        {
          "cs_scriptfile": "LightLOD",
          "content": "if (FirstActiveCamera != null) // If first active camera is null, no cameras with LightLODCamera are active, so we will default to on, unless it should be on { if (LightShouldBeOn) { //DistanceFromPlayer = Vector3.Distance(transform.position, FirstActiveCamera.transform.position); DistanceFromPlayer = Vector3.SqrMagnitude(FirstActiveCamera.transform.position - transform.position); _isNeedCalculation = false; //Debug.Log($\"[LightLOD] DistanceFromPlayer: {DistanceFromPlayer}\", gameObject); for (i = 0; i < ShadowQualityLods.Count; i++) { if ((DistanceFromPlayer > ShadowQualityLods[i].DistanceRange.x && DistanceFromPlayer <= ShadowQualityLods[i].DistanceRange.y) || i == ShadowQualityLods.Count - 1) { UpdateLodValue(i); if (ShadowQualityLods[i].CastNoShadows) { light.shadows = LightShadows.None; if (ShowLightColorAsDebugColor) { light.color = ShadowQualityLods[i].DebugColor; } } else { light.shadows = ShadowQualityLods[i].LightShadows; light.enabled = true; //respect quality settings, do not go higher than what they have defined. if (QualitySettings.shadowResolution <= ShadowQualityLods[i].ShadowResolution) { IsClamped = true; DesiredQuality = (int)QualitySettings.shadowResolution; light.shadowResolution = (LightShadowResolution)DesiredQuality; if (ShowLightColorAsDebugColor) { ClampedLOD = FindMatchingShadowQualityIndex(QualitySettings.shadowResolution); if (ClampedLOD == null) { Debug.LogWarning(string.Format(WarningMessage, QualitySettings.shadowResolution.ToString())); } else { light.color = ClampedLOD.DebugColor; } } } else { IsClamped = false; light.shadowResolution = (LightShadowResolution)ShadowQualityLods[i].ShadowResolution; if (ShowLightColorAsDebugColor) { light.color = ShadowQualityLods[i].DebugColor; } } } break; } } } else { light.enabled = false; UpdateLodValue(0); } } else if (InitiallyOn) { light.enabled = true; light.shadows = DesiredLightShadowQuality; light.shadowResolution = InspectorShadowResolution; UpdateLodValue(0); } yield return Wait; } } private LightLODCamera FindFirstActiveCamera() { for (index = 0; index < LODCameras.Count; index++) { if (LODCameras[index] == null) { LODCameras = new List<LightLODCamera>(GameObject.FindObjectsOfType<LightLODCamera>()); }else{ if (LODCameras[index].Camera.enabled && LODCameras[index].gameObject.activeInHierarchy) { return LODCameras[index]; } } } return null;  ",
          "content_tokens": 669,
          "embedding": []
        },
        {
          "cs_scriptfile": "LightLOD",
          "content": "private void UpdateLodValue(int value) { if (value != _lod) { _lod = value; OnLightLODChanged?.Invoke(value); switch (value) { case 0: OnLightLod0Activated?.Invoke(); break; case 1: OnLightLod1Activated?.Invoke(); break; case 2: OnLightLod2Activated?.Invoke(); break; case 3: OnLightLod3Activated?.Invoke(); break; case 4: OnLightLod4Activated?.Invoke(); break; default: break; } } } private LODAdjustment FindMatchingShadowQualityIndex(ShadowResolution Quality) { for (index = 0; index < ShadowQualityLods.Count; index++) { if (ShadowQualityLods[index].ShadowResolution.Equals(Quality)) { return ShadowQualityLods[index]; } } return null; } [Serializable] public class LODAdjustment { public Vector2 DistanceRange; public ShadowResolution ShadowResolution; public LightShadows LightShadows; public bool CastNoShadows; public Color DebugColor; public bool IsFlickerLight; } } }",
          "content_tokens": 258,
          "embedding": []
        }
      ],
      "length": 6681
    },
    {
      "filename": "LightLODCamera",
      "content": " using System; using System.Collections; using UnityEngine; namespace LlamaSoftware.Utilities { [RequireComponent(typeof(Camera))] public class LightLODCamera : MonoBehaviour { [HideInInspector] public Camera Camera; public Action OnCameraMoved; private Vector3 previousCameraPosition; private void Awake() { Camera = GetComponent<Camera>(); previousCameraPosition = transform.position; StartCoroutine(TimedUpdate()); } private IEnumerator TimedUpdate() { WaitForSeconds wait = new WaitForSeconds(0.1f); while (true) { // Check if the camera's position has changed approximately if (!Mathf.Approximately(Camera.transform.position.x, previousCameraPosition.x) || !Mathf.Approximately(Camera.transform.position.y, previousCameraPosition.y) || !Mathf.Approximately(Camera.transform.position.z, previousCameraPosition.z)) { // Invoke the OnCameraMoved action OnCameraMoved?.Invoke(); // Update the previous camera position previousCameraPosition = Camera.transform.position; } yield return wait; } } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LightLODCamera",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "LightLODCamera",
          "content": "using System; using System.Collections; using UnityEngine; namespace LlamaSoftware.Utilities { [RequireComponent(typeof(Camera))] public class LightLODCamera : MonoBehaviour { [HideInInspector] public Camera Camera; public Action OnCameraMoved; private Vector3 previousCameraPosition; private void Awake() { Camera = GetComponent<Camera>(); previousCameraPosition = transform.position; StartCoroutine(TimedUpdate()); } private IEnumerator TimedUpdate() { WaitForSeconds wait = new WaitForSeconds(0.1f); while (true) { // Check if the camera's position has changed approximately if (!Mathf.Approximately(Camera.transform.position.x, previousCameraPosition.x) || !Mathf.Approximately(Camera.transform.position.y, previousCameraPosition.y) || !Mathf.Approximately(Camera.transform.position.z, previousCameraPosition.z)) { // Invoke the OnCameraMoved action OnCameraMoved?.Invoke(); // Update the previous camera position previousCameraPosition = Camera.transform.position; } yield return wait; } } } }",
          "content_tokens": 250,
          "embedding": []
        }
      ],
      "length": 1000
    },
    {
      "filename": "LoadingBarLogic",
      "content": "using System.Collections; using UnityEngine; using UnityEngine.UI; using TMPro; public class LoadingBarLogic : MonoBehaviour { [SerializeField] private Image _sliderImage; [SerializeField] private TextMeshProUGUI _sliderText; private UICanvasGroupDecorator _canvasGroupDecorator; private Coroutine _coroutine; public static LoadingBarLogic Instance => _instance; private static LoadingBarLogic _instance; private void Awake() { if (_instance == null) { _instance = this; DontDestroyOnLoad(gameObject); } else Destroy(gameObject); _canvasGroupDecorator = GetComponent<UICanvasGroupDecorator>(); } public void StartLoading(float time) { _coroutine = StartCoroutine(CorStartLoading(time)); } public void CancelLoading() { if (_coroutine != null) { _canvasGroupDecorator.Hide(); StopCoroutine(_coroutine); _coroutine = null; } } private IEnumerator CorStartLoading(float time) { _sliderImage.fillAmount = .0f; _canvasGroupDecorator.Show(); float fillAmount = 0.0f; var waitTime = new WaitForEndOfFrame(); while (fillAmount < 1f) { fillAmount += Time.deltaTime / time; _sliderText.text = (time - fillAmount * time).ToString()[..3].Replace(',','.'); _sliderImage.fillAmount = fillAmount; yield return waitTime; } _canvasGroupDecorator.Hide(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LoadingBarLogic",
          "content": "using System.Collections; using UnityEngine; using UnityEngine.UI; using TMPro; public class LoadingBarLogic : MonoBehaviour { [SerializeField] private Image _sliderImage; [SerializeField] private TextMeshProUGUI _sliderText; private UICanvasGroupDecorator _canvasGroupDecorator; private Coroutine _coroutine; public static LoadingBarLogic Instance => _instance; private static LoadingBarLogic _instance; private void Awake() { if (_instance == null) { _instance = this; DontDestroyOnLoad(gameObject); } else Destroy(gameObject); _canvasGroupDecorator = GetComponent<UICanvasGroupDecorator>();  public void StartLoading(float time) { _coroutine = StartCoroutine(CorStartLoading(time));  ",
          "content_tokens": 185,
          "embedding": []
        },
        {
          "cs_scriptfile": "LoadingBarLogic",
          "content": "public void CancelLoading() { if (_coroutine != null) { _canvasGroupDecorator.Hide(); StopCoroutine(_coroutine); _coroutine = null; } } private IEnumerator CorStartLoading(float time) { _sliderImage.fillAmount = .0f; _canvasGroupDecorator.Show(); float fillAmount = 0.0f; var waitTime = new WaitForEndOfFrame(); while (fillAmount < 1f) { fillAmount += Time.deltaTime / time; _sliderText.text = (time - fillAmount * time).ToString()[..3].Replace(',','.'); _sliderImage.fillAmount = fillAmount; yield return waitTime; } _canvasGroupDecorator.Hide(); } }",
          "content_tokens": 172,
          "embedding": []
        }
      ],
      "length": 1241
    },
    {
      "filename": "LoadingScreenController",
      "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FirstGearGames.LobbyAndWorld.Lobbies; using FishnetInvector; using UnityEngine; using DDCore; public class LoadingScreenController : MonoBehaviour { [SerializeField] private GameObjectDispatcher _loadingScreen; private void Awake() { NetworkHudCanvases.OnDisconnectedFromServer += DeactivateLoadingScreen; GameplayManager.OnLocalClientInitStarted += ActivateLoadingScreen; FishnetInvectorManager.OnLocalPlayerInitialized += DeactivateLoadingScreen; } private void OnDisable() { ReadyLobbyNetwork.OnGameStarting -= ActivateLoadingScreen; FishnetInvectorManager.OnLocalPlayerInitialized -= DeactivateLoadingScreen; NetworkHudCanvases.OnDisconnectedFromServer -= DeactivateLoadingScreen; } private void ActivateLoadingScreen() { _loadingScreen.Activate(); } private void DeactivateLoadingScreen() { _loadingScreen.Deactivate(); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LoadingScreenController",
          "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FirstGearGames.LobbyAndWorld.Lobbies; using FishnetInvector; using UnityEngine; using DDCore; public class LoadingScreenController : MonoBehaviour { [SerializeField] private GameObjectDispatcher _loadingScreen; private void Awake() { NetworkHudCanvases.OnDisconnectedFromServer += DeactivateLoadingScreen; GameplayManager.OnLocalClientInitStarted += ActivateLoadingScreen; FishnetInvectorManager.OnLocalPlayerInitialized += DeactivateLoadingScreen;  private void OnDisable() { ReadyLobbyNetwork.OnGameStarting -= ActivateLoadingScreen; FishnetInvectorManager.OnLocalPlayerInitialized -= DeactivateLoadingScreen; NetworkHudCanvases.OnDisconnectedFromServer -= DeactivateLoadingScreen;  ",
          "content_tokens": 194,
          "embedding": []
        },
        {
          "cs_scriptfile": "LoadingScreenController",
          "content": "private void ActivateLoadingScreen() { _loadingScreen.Activate();  private void DeactivateLoadingScreen() { _loadingScreen.Deactivate(); } }",
          "content_tokens": 32,
          "embedding": []
        }
      ],
      "length": 924
    },
    {
      "filename": "MainMenuBankController",
      "content": "using System.Collections.Generic; using System.Linq; using _ZombieRoyale.Scripts.Clients; using DuloGames.UI; using Invector.vItemManager; using SingletonsExtension; using TMPro; using UnityEngine; public class MainMenuBankController : MonoBehaviour { [SerializeField] private TextMeshProUGUI _goldText; [SerializeField] private UIItemSlot[] _slots; private void Start() { RegistrationController.Instance.OnCharacterLoaded += OnCharacterLoaded; } private List<UIItemSlot> GetNFreeSlot(int howMany) { List<UIItemSlot> freeSlots = new List<UIItemSlot>(); for (int i = 0; i < _slots.Length; i++) { if (_slots[i].IsAssigned()) continue; freeSlots.Add(_slots[i]); if (freeSlots.Count == howMany) break; } Debug.Log($\"[MainMenuBankController] GetNFreeSlot({howMany}) => {freeSlots.Count} available free slots\"); return freeSlots; } private void OnCharacterLoaded(CharacterData charData) { Debug.Log($\"[MainMenuBankController] OnCharacterLoaded\"); UpdateSlotItems(charData); UpdateGoldAmount(charData); } private void UpdateGoldAmount(CharacterData charData) { Debug.Log($\"[MainMenuBankController] UpdateGoldAmount() => {charData.gold}\"); } private void UpdateSlotItems(CharacterData charData) { if (charData.bank_items == null) { Debug.Log($\"[MainMenuEquipmentController] OnCharacterLoaded() => charData.bank_items is null\"); return; } List<UIItemSlot> freeSlots = GetNFreeSlot(charData.bank_items.Length); foreach (var slotItem in charData.bank_items) { int itemId = slotItem.itemId; vItem vItem = MasterManager.Instance.ItemListData.GetItem(itemId); UIItemInfo item = vItem.ToUIItemInfo(); UIItemSlot slot = slotItem.slotId == -1 ? freeSlots.First() : _slots[slotItem.slotId]; slot.Assign(item); Debug.Log($\"[MainMenuBankController] OnCharacterLoaded() => Assigned {item.Name} to slot #{slot.ID}\"); freeSlots.Remove(slot); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MainMenuBankController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainMenuBankController",
          "content": "using System.Collections.Generic; using System.Linq; using _ZombieRoyale.Scripts.Clients; using DuloGames.UI; using Invector.vItemManager; using SingletonsExtension; using TMPro; using UnityEngine; public class MainMenuBankController : MonoBehaviour { [SerializeField] private TextMeshProUGUI _goldText; [SerializeField] private UIItemSlot[] _slots; private void Start() { RegistrationController.Instance.OnCharacterLoaded += OnCharacterLoaded; } private List<UIItemSlot> GetNFreeSlot(int howMany) { List<UIItemSlot> freeSlots = new List<UIItemSlot>(); for (int i = 0; i < _slots.Length; i++) { if (_slots[i].IsAssigned()) continue; freeSlots.Add(_slots[i]); if (freeSlots.Count == howMany) break; } Debug.Log($\"[MainMenuBankController] GetNFreeSlot({howMany}) => {freeSlots.Count} available free slots\"); return freeSlots;  ",
          "content_tokens": 246,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainMenuBankController",
          "content": "private void OnCharacterLoaded(CharacterData charData) { Debug.Log($\"[MainMenuBankController] OnCharacterLoaded\"); UpdateSlotItems(charData); UpdateGoldAmount(charData);  private void UpdateGoldAmount(CharacterData charData) { Debug.Log($\"[MainMenuBankController] UpdateGoldAmount() => {charData.gold}\");  ",
          "content_tokens": 79,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainMenuBankController",
          "content": "private void UpdateSlotItems(CharacterData charData) { if (charData.bank_items == null) { Debug.Log($\"[MainMenuEquipmentController] OnCharacterLoaded() => charData.bank_items is null\"); return; } List<UIItemSlot> freeSlots = GetNFreeSlot(charData.bank_items.Length); foreach (var slotItem in charData.bank_items) { int itemId = slotItem.itemId; vItem vItem = MasterManager.Instance.ItemListData.GetItem(itemId); UIItemInfo item = vItem.ToUIItemInfo(); UIItemSlot slot = slotItem.slotId == -1 ? freeSlots.First() : _slots[slotItem.slotId]; slot.Assign(item); Debug.Log($\"[MainMenuBankController] OnCharacterLoaded() => Assigned {item.Name} to slot #{slot.ID}\"); freeSlots.Remove(slot); } } }",
          "content_tokens": 216,
          "embedding": []
        }
      ],
      "length": 1825
    },
    {
      "filename": "MainMenuEquipmentController",
      "content": "using System.Collections.Generic; using System.Linq; using _ZombieRoyale.Scripts.Clients; using DuloGames.UI; using Invector.vItemManager; using SingletonsExtension; using UnityEngine; public class MainMenuEquipmentController : MonoBehaviour { [SerializeField] private UIItemSlot[] _slots; private void Start() { RegistrationController.Instance.OnCharacterLoaded += OnCharacterLoaded; } private List<UIItemSlot> GetNFreeSlot(int howMany) { List<UIItemSlot> freeSlots = new List<UIItemSlot>(); for (int i = 0; i < _slots.Length; i++) { if (_slots[i].IsAssigned()) continue; freeSlots.Add(_slots[i]); if (freeSlots.Count == howMany) break; } Debug.Log($\"[MainMenuEquipmentController] GetNFreeSlot({howMany}) => {freeSlots.Count} available free slots\"); return freeSlots; } private void OnCharacterLoaded(CharacterData charData) { if (charData.bank_items == null) { Debug.Log($\"[MainMenuEquipmentController] OnCharacterLoaded() => charData.bank_items is null\"); return; } List<UIItemSlot> freeSlots = GetNFreeSlot(charData.bank_items.Length); foreach (var slotItem in charData.bank_items) { int itemId = slotItem.itemId; vItem vItem = MasterManager.Instance.ItemListData.GetItem(itemId); UIItemInfo item = vItem.ToUIItemInfo(); UIItemSlot slot = slotItem.slotId == -1 ? freeSlots.First() : _slots[slotItem.slotId]; slot.Assign(item); Debug.Log($\"[MainMenuEquipmentController] OnCharacterLoaded() => Assigned {item.Name} to slot #{slot.ID}\"); freeSlots.Remove(slot); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MainMenuEquipmentController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainMenuEquipmentController",
          "content": "using System.Collections.Generic; using System.Linq; using _ZombieRoyale.Scripts.Clients; using DuloGames.UI; using Invector.vItemManager; using SingletonsExtension; using UnityEngine; public class MainMenuEquipmentController : MonoBehaviour { [SerializeField] private UIItemSlot[] _slots; private void Start() { RegistrationController.Instance.OnCharacterLoaded += OnCharacterLoaded; } private List<UIItemSlot> GetNFreeSlot(int howMany) { List<UIItemSlot> freeSlots = new List<UIItemSlot>(); for (int i = 0; i < _slots.Length; i++) { if (_slots[i].IsAssigned()) continue; freeSlots.Add(_slots[i]); if (freeSlots.Count == howMany) break; } Debug.Log($\"[MainMenuEquipmentController] GetNFreeSlot({howMany}) => {freeSlots.Count} available free slots\"); return freeSlots;  ",
          "content_tokens": 229,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainMenuEquipmentController",
          "content": "private void OnCharacterLoaded(CharacterData charData) { if (charData.bank_items == null) { Debug.Log($\"[MainMenuEquipmentController] OnCharacterLoaded() => charData.bank_items is null\"); return; } List<UIItemSlot> freeSlots = GetNFreeSlot(charData.bank_items.Length); foreach (var slotItem in charData.bank_items) { int itemId = slotItem.itemId; vItem vItem = MasterManager.Instance.ItemListData.GetItem(itemId); UIItemInfo item = vItem.ToUIItemInfo(); UIItemSlot slot = slotItem.slotId == -1 ? freeSlots.First() : _slots[slotItem.slotId]; slot.Assign(item); Debug.Log($\"[MainMenuEquipmentController] OnCharacterLoaded() => Assigned {item.Name} to slot #{slot.ID}\"); freeSlots.Remove(slot); } } }",
          "content_tokens": 218,
          "embedding": []
        }
      ],
      "length": 1468
    },
    {
      "filename": "MicrophoneWhisper",
      "content": "using System.Diagnostics; using UnityEngine; using UnityEngine.UI; using Whisper; using Whisper.Utils; using System; public class MicrophoneWhisper : MonoBehaviour { [SerializeField] private WhisperManager _whisper; [SerializeField] private MicrophoneRecord _microphoneRecord; public KeyCode HoldMicrophoneKey => _holdMicrophoneKey; [SerializeField] private KeyCode _holdMicrophoneKey; public static MicrophoneWhisper Instance { get; private set; } public Action<string> OnTextReceived; private Text _outputText; private SpeechPlayTest _speechPlayTest; private void Awake() { _speechPlayTest = GetComponent<SpeechPlayTest>(); _microphoneRecord.OnRecordStop += OnRecordStop; if (Instance == null) { Instance = this; } else { Destroy(this); } DontDestroyOnLoad(gameObject); //OnTextReceived += _speechPlayTest.DoDialog; } private void Update() { if (Input.GetKeyDown(_holdMicrophoneKey)) _microphoneRecord.StartRecord(); if (Input.GetKeyUp(_holdMicrophoneKey)) _microphoneRecord.StopRecord(); } private async void OnRecordStop(AudioChunk recordedAudio) { var sw = new Stopwatch(); sw.Start(); var res = await _whisper.GetTextAsync(recordedAudio.Data, recordedAudio.Frequency, recordedAudio.Channels); if (res == null) return; var text = res.Result; if (text.Contains(\"[\")) return; if (text == null) return; if (text.Length <= 1) return; OnTextReceived?.Invoke(text); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MicrophoneWhisper",
          "content": "using System.Diagnostics; using UnityEngine; using UnityEngine.UI; using Whisper; using Whisper.Utils; using System; public class MicrophoneWhisper : MonoBehaviour { [SerializeField] private WhisperManager _whisper; [SerializeField] private MicrophoneRecord _microphoneRecord; public KeyCode HoldMicrophoneKey => _holdMicrophoneKey; [SerializeField] private KeyCode _holdMicrophoneKey; public static MicrophoneWhisper Instance { get; private set; } public Action<string> OnTextReceived; private Text _outputText; private SpeechPlayTest _speechPlayTest; private void Awake() { _speechPlayTest = GetComponent<SpeechPlayTest>(); _microphoneRecord.OnRecordStop += OnRecordStop; if (Instance == null) { Instance = this; } else { Destroy(this);  ",
          "content_tokens": 194,
          "embedding": []
        },
        {
          "cs_scriptfile": "MicrophoneWhisper",
          "content": "DontDestroyOnLoad(gameObject); //OnTextReceived += _speechPlayTest.DoDialog;  private void Update() { if (Input.GetKeyDown(_holdMicrophoneKey)) _microphoneRecord.StartRecord(); if (Input.GetKeyUp(_holdMicrophoneKey)) _microphoneRecord.StopRecord(); } private async void OnRecordStop(AudioChunk recordedAudio) { var sw = new Stopwatch(); sw.Start(); var res = await _whisper.GetTextAsync(recordedAudio.Data, recordedAudio.Frequency, recordedAudio.Channels); if (res == null) return; var text = res.Result; if (text.Contains(\"[\")) return; if (text == null) return; if (text.Length <= 1) return; OnTextReceived?.Invoke(text); } }",
          "content_tokens": 184,
          "embedding": []
        }
      ],
      "length": 1369
    },
    {
      "filename": "PlayerData",
      "content": "using System; using System.Collections; using System.Collections.Generic; using DungeonScrollerCore; using HeathenEngineering.SteamworksIntegration; using UnityEngine; using Newtonsoft.Json; using SingletonsExtension; using TMPro; using UnityEngine.Serialization; using UnityEngine.UI; namespace _ZombieRoyale.Scripts.Clients{ public class PlayerData : MonoBehaviour { private static string PLAYER_PREFS_PLAYER_ID_KEY = \"username\"; private static string PLAYER_PREFS_PLAYER_PASSWORD = \"password\"; private static string PLAYER_PREFS_EMAIL = \"email\"; private static string PLAYER_PREFS_TOKEN = \"access_token\"; [field:SerializeField] public bool IsUsingBackend { get; private set; } public Action OnPlayerLoggedIn; private Action OnPlayerIdAndPasswordLoaded; public Action<CharacterData> OnCharacterLoaded; [SerializeField] private TextMeshProUGUI backendResponseStatusText; [SerializeField] private Button savePlayerDataBtn; [SerializeField] private TMP_InputField usernameInputField; [SerializeField] private TMP_InputField _passwordInputField; [SerializeField] private TMP_InputField _emailInputField; [SerializeField] private TextMeshProUGUI _playerNameText; [SerializeField] private TextMeshProUGUI _playerEmailText; [SerializeField] private TextMeshProUGUI _playerPasswordText; public PlayerRegisterData MyPlayerRegisterData => _playerRegisterData; private PlayerRegisterData _playerRegisterData = new PlayerRegisterData(); [field:SerializeField] public string Username { get; private set; } [field:SerializeField] public string SteamUsername { get; private set; } public enum FieldType { Username, Email, Password } public static PlayerData Instance { get; private set; } public BackendReadWrites.Player Player => _player; private BackendReadWrites.Player _player = new BackendReadWrites.Player(); public string Token => _token; private string _token; private string _nickName; private bool _isDebug; private bool _isSteamInitialized; public void OnSteamInitialized() { _isSteamInitialized = true; SteamUsername = UserData.Me.Name; } public string GetPlayerName() { if (_isSteamInitialized) { return SteamUsername; } else { return Username; } } public void StoreUsername(string username) { if (_player.username == username) return; _player.username = username; UpdateVisualField(FieldType.Username, username); PlayerPrefs.SetString(PLAYER_PREFS_PLAYER_ID_KEY, username); } public void StorePassword(string password) { if (_player.password == password) return; _player.password = password; _playerRegisterData.password = password; UpdateVisualField(FieldType.Password, _playerRegisterData.password); PlayerPrefs.SetString(PLAYER_PREFS_PLAYER_PASSWORD, password); } public void StoreEmail(string email) { if (_player.email == email) return; _player.email = email; _playerRegisterData.email = email; UpdateVisualField(FieldType.Email, _playerRegisterData.email); PlayerPrefs.SetString(PLAYER_PREFS_EMAIL, email); } public void StoreToken(string token) { _token = token; PlayerPrefs.SetString(PLAYER_PREFS_TOKEN, token); MasterManager.Instance.SetToken(token); } private void UpdateVisualField(FieldType fieldType, string value) { switch (fieldType) { case FieldType.Username: _playerNameText.text = value; break; case FieldType.Email: _playerEmailText.text = value; break; case FieldType.Password: _playerPasswordText.text = value; break; } } public void LoadPlayerDataFromPlayerPrefs() { _playerRegisterData.email = PlayerPrefs.GetString(PLAYER_PREFS_EMAIL); _playerRegisterData.password = PlayerPrefs.GetString(PLAYER_PREFS_PLAYER_PASSWORD); Username = PlayerPrefs.GetString(PLAYER_PREFS_PLAYER_ID_KEY); UpdateVisualField(FieldType.Username, Username); UpdateVisualField(FieldType.Email, _playerRegisterData.email); UpdateVisualField(FieldType.Password, _playerRegisterData.password); Debug.Log($\"Loaded player data from player prefs: {MyPlayerRegisterData.email}\"); } public bool IsPlayerPersistInPlayerPrefs() { return PlayerPrefs.HasKey(PLAYER_PREFS_EMAIL) && PlayerPrefs.HasKey(PLAYER_PREFS_PLAYER_PASSWORD); } public void UpdateToken() { BackendReadWrites.Player player = new BackendReadWrites.Player(); player.email = MyPlayerRegisterData.email; player.password = MyPlayerRegisterData.password; LoginPlayer(player); } private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); } else { Destroy(gameObject); } } public void RegisterPlayer(BackendReadWrites.Player player) { Debug.Log($\"_username: {player.username}; _password: {player.password}; _email: {player.email}\"); if (IsUsingBackend) { BackendReadWrites.RegisterUser(player, (exception, response, body) => { bool isSuccessful = true; if (exception != null) { Debug.Log(exception.Message); return; } Debug.Log($\"[RegisterPlayer] response: {response}, body: {body}\"); if (isSuccessful) { BackendReadWrites.Token token = JsonConvert.DeserializeObject<BackendReadWrites.Token>(body); StoreUsername(player.username); StorePassword(player.password); StoreEmail(player.email); StoreToken(token.access_token); OnPlayerLoggedIn?.Invoke(); Debug.Log($\"token: {token}\"); } }); } else { //generate unique id PlayerRegisterData playerRegisterData = new PlayerRegisterData(); playerRegisterData.email = Guid.NewGuid().ToString(); playerRegisterData.password = Guid.NewGuid().ToString(); //callback(playerRegisterData.ToString()); OnPlayerLoggedIn?.Invoke(); } } public void LoginPlayer(BackendReadWrites.Player player) { Debug.Log($\"[PlayerData.LoginPlayer] _password: {player.password}; _email: {player.email}\"); if (IsUsingBackend) { BackendReadWrites.Login(player, (exception, response, body) => { bool isSuccessful = true; if (exception != null) { Debug.Log($\"[LoginPlayer] {exception.Message}\"); if (exception.Message.Contains(\"HTTP/1.1 400 Bad Request\")) { FlushPlayerPrefs(); GetOrCreatePlayerIdAndPassword(); } return; } Debug.Log($\"[LoginPlayer] response: {response}, body: {body}\"); if (isSuccessful) { BackendReadWrites.Token token = JsonConvert.DeserializeObject<BackendReadWrites.Token>(body); StoreUsername(token.username); StorePassword(player.password); StoreEmail(player.email); StoreToken(token.access_token); OnPlayerLoggedIn?.Invoke(); Debug.Log($\"token raw: {token}\"); } }); } } private void GetOrCreatePlayerIdAndPassword() { Action<string> callback = (data) => { Debug.Log($\"data raw: {data}\"); PlayerRegisterData json = JsonConvert.DeserializeObject<PlayerRegisterData>(data); _playerRegisterData.email = json.email; _playerRegisterData.password = json.password; PlayerPrefs.SetString(PLAYER_PREFS_PLAYER_ID_KEY, MyPlayerRegisterData.email); PlayerPrefs.SetString(PLAYER_PREFS_PLAYER_PASSWORD, MyPlayerRegisterData.password); OnPlayerIdAndPasswordLoaded?.Invoke(); }; if (!PlayerPrefs.HasKey(PLAYER_PREFS_PLAYER_ID_KEY)) { if (IsUsingBackend) { BackendReadWrites.Player _player = new BackendReadWrites.Player(); _player.username = MyPlayerRegisterData.email; _player.password = MyPlayerRegisterData.password; _player.email = MyPlayerRegisterData.email; BackendReadWrites.RegisterUser(_player, (exception, response, body) => { if (exception != null) { DebugWrite.LogError(\"Error registering user: \" + exception.Message, gameObject, _isDebug); return; } DebugWrite.Log(\"User registered: \" + body, gameObject, _isDebug); callback(body); }); } else { //generate unique id PlayerRegisterData playerRegisterData = new PlayerRegisterData(); playerRegisterData.email = Guid.NewGuid().ToString(); playerRegisterData.password = Guid.NewGuid().ToString(); callback(playerRegisterData.ToString()); } } else { _playerRegisterData.email = PlayerPrefs.GetString(PLAYER_PREFS_PLAYER_ID_KEY); _playerRegisterData.password = PlayerPrefs.GetString(PLAYER_PREFS_PLAYER_PASSWORD); } } /// <summary> /// Called from inspector button /// </summary> /// <param name=\"nickname\"></param> public void OnClickSavePlayerData() { string newUsername = usernameInputField.text == \"\" ? _playerNameText.text : usernameInputField.text; string newEmail = _emailInputField.text == \"\" ? _playerEmailText.text : _emailInputField.text; string newPassword = _passwordInputField.text == \"\" ? _playerPasswordText.text : _passwordInputField.text; backendResponseStatusText.text = $\"saving...\"; BackendReadWrites.ChangePlayerData(_token, newUsername, newEmail, newPassword, (exception, response, body) => { if (exception != null) { Debug.LogError($\"[OnClickSavePlayerData] {exception.Message}\"); return; } else { BackendReadWrites.Token token = JsonConvert.DeserializeObject<BackendReadWrites.Token>(body); StoreUsername(newUsername); StorePassword(newPassword); StoreEmail(newEmail); StoreToken(token.access_token); SwitchSaveBtn(false); StartCoroutine(ShowStatus(\"saved!\")); Debug.Log($\"[OnClickSavePlayerData] response: {response}, body: {body}\"); } }); } private IEnumerator ShowStatus(string saved) { backendResponseStatusText.text = $\"{saved}\"; yield return new WaitForSeconds(2f); backendResponseStatusText.text = String.Empty; } public void UnlockSaveButtonIfRequired() { bool isOn = usernameInputField.text != Username || _emailInputField.text != _playerRegisterData.email || _passwordInputField.text != _playerRegisterData.password; SwitchSaveBtn(isOn); } private void SwitchSaveBtn(bool isOn) { savePlayerDataBtn.interactable = isOn; } [Serializable] public class PlayerRegisterData { public string email; public string password; } public void FlushPlayerPrefs() { PlayerPrefs.DeleteAll(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PlayerData",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "PlayerData",
          "content": "using System; using System.Collections; using System.Collections.Generic; using DungeonScrollerCore; using HeathenEngineering.SteamworksIntegration; using UnityEngine; using Newtonsoft.Json; using SingletonsExtension; using TMPro; using UnityEngine.Serialization; using UnityEngine.UI; namespace _ZombieRoyale.Scripts.Clients{ public class PlayerData : MonoBehaviour { private static string PLAYER_PREFS_PLAYER_ID_KEY = \"username\"; private static string PLAYER_PREFS_PLAYER_PASSWORD = \"password\"; private static string PLAYER_PREFS_EMAIL = \"email\"; private static string PLAYER_PREFS_TOKEN = \"access_token\"; [field:SerializeField] public bool IsUsingBackend { get; private set; } public Action OnPlayerLoggedIn; private Action OnPlayerIdAndPasswordLoaded; public Action<CharacterData> OnCharacterLoaded; [SerializeField] private TextMeshProUGUI backendResponseStatusText; [SerializeField] private Button savePlayerDataBtn; [SerializeField] private TMP_InputField usernameInputField; [SerializeField] private TMP_InputField _passwordInputField; [SerializeField] private TMP_InputField _emailInputField; [SerializeField] private TextMeshProUGUI _playerNameText; [SerializeField] private TextMeshProUGUI _playerEmailText; [SerializeField] private TextMeshProUGUI _playerPasswordText; public PlayerRegisterData MyPlayerRegisterData => _playerRegisterData; private PlayerRegisterData _playerRegisterData = new PlayerRegisterData(); [field:SerializeField] public string Username { get; private set; } [field:SerializeField] public string SteamUsername { get; private set; } public enum FieldType { Username, Email, Password } public static PlayerData Instance { get; private set; } public BackendReadWrites.Player Player => _player; private BackendReadWrites.Player _player = new BackendReadWrites.Player(); public string Token => _token; private string _token; private string _nickName; private bool _isDebug; private bool _isSteamInitialized; public void OnSteamInitialized() { _isSteamInitialized = true; SteamUsername = UserData.Me.Name;  ",
          "content_tokens": 513,
          "embedding": []
        },
        {
          "cs_scriptfile": "PlayerData",
          "content": "public string GetPlayerName() { if (_isSteamInitialized) { return SteamUsername; } else { return Username; }  public void StoreUsername(string username) { if (_player.username == username) return; _player.username = username; UpdateVisualField(FieldType.Username, username); PlayerPrefs.SetString(PLAYER_PREFS_PLAYER_ID_KEY, username);  public void StorePassword(string password) { if (_player.password == password) return; _player.password = password; _playerRegisterData.password = password; UpdateVisualField(FieldType.Password, _playerRegisterData.password); PlayerPrefs.SetString(PLAYER_PREFS_PLAYER_PASSWORD, password);  ",
          "content_tokens": 164,
          "embedding": []
        },
        {
          "cs_scriptfile": "PlayerData",
          "content": "public void StoreEmail(string email) { if (_player.email == email) return; _player.email = email; _playerRegisterData.email = email; UpdateVisualField(FieldType.Email, _playerRegisterData.email); PlayerPrefs.SetString(PLAYER_PREFS_EMAIL, email);  public void StoreToken(string token) { _token = token; PlayerPrefs.SetString(PLAYER_PREFS_TOKEN, token); MasterManager.Instance.SetToken(token);  private void UpdateVisualField(FieldType fieldType, string value) { switch (fieldType) { case FieldType.Username: _playerNameText.text = value; break; case FieldType.Email: _playerEmailText.text = value; break; case FieldType.Password: _playerPasswordText.text = value; break; }  ",
          "content_tokens": 189,
          "embedding": []
        },
        {
          "cs_scriptfile": "PlayerData",
          "content": "public void LoadPlayerDataFromPlayerPrefs() { _playerRegisterData.email = PlayerPrefs.GetString(PLAYER_PREFS_EMAIL); _playerRegisterData.password = PlayerPrefs.GetString(PLAYER_PREFS_PLAYER_PASSWORD); Username = PlayerPrefs.GetString(PLAYER_PREFS_PLAYER_ID_KEY); UpdateVisualField(FieldType.Username, Username); UpdateVisualField(FieldType.Email, _playerRegisterData.email); UpdateVisualField(FieldType.Password, _playerRegisterData.password); Debug.Log($\"Loaded player data from player prefs: {MyPlayerRegisterData.email}\");  ",
          "content_tokens": 152,
          "embedding": []
        },
        {
          "cs_scriptfile": "PlayerData",
          "content": "public bool IsPlayerPersistInPlayerPrefs() { return PlayerPrefs.HasKey(PLAYER_PREFS_EMAIL) && PlayerPrefs.HasKey(PLAYER_PREFS_PLAYER_PASSWORD);  public void UpdateToken() { BackendReadWrites.Player player = new BackendReadWrites.Player(); player.email = MyPlayerRegisterData.email; player.password = MyPlayerRegisterData.password; LoginPlayer(player);  private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); } else { Destroy(gameObject); }  ",
          "content_tokens": 141,
          "embedding": []
        },
        {
          "cs_scriptfile": "PlayerData",
          "content": "public void RegisterPlayer(BackendReadWrites.Player player) { Debug.Log($\"_username: {player.username}; _password: {player.password}; _email: {player.email}\"); if (IsUsingBackend) { BackendReadWrites.RegisterUser(player, (exception, response, body) => { bool isSuccessful = true; if (exception != null) { Debug.Log(exception.Message); return; } Debug.Log($\"[RegisterPlayer] response: {response}, body: {body}\"); if (isSuccessful) { BackendReadWrites.Token token = JsonConvert.DeserializeObject<BackendReadWrites.Token>(body); StoreUsername(player.username); StorePassword(player.password); StoreEmail(player.email); StoreToken(token.access_token); OnPlayerLoggedIn?.Invoke(); Debug.Log($\"token: {token}\"); } }); } else { //generate unique id PlayerRegisterData playerRegisterData = new PlayerRegisterData(); playerRegisterData.email = Guid.NewGuid().ToString(); playerRegisterData.password = Guid.NewGuid().ToString(); //callback(playerRegisterData.ToString()); OnPlayerLoggedIn?.Invoke(); }  ",
          "content_tokens": 283,
          "embedding": []
        },
        {
          "cs_scriptfile": "PlayerData",
          "content": "public void LoginPlayer(BackendReadWrites.Player player) { Debug.Log($\"[PlayerData.LoginPlayer] _password: {player.password}; _email: {player.email}\"); if (IsUsingBackend) { BackendReadWrites.Login(player, (exception, response, body) => { bool isSuccessful = true; if (exception != null) { Debug.Log($\"[LoginPlayer] {exception.Message}\"); if (exception.Message.Contains(\"HTTP/1.1 400 Bad Request\")) { FlushPlayerPrefs(); GetOrCreatePlayerIdAndPassword(); } return; } Debug.Log($\"[LoginPlayer] response: {response}, body: {body}\"); if (isSuccessful) { BackendReadWrites.Token token = JsonConvert.DeserializeObject<BackendReadWrites.Token>(body); StoreUsername(token.username); StorePassword(player.password); StoreEmail(player.email); StoreToken(token.access_token); OnPlayerLoggedIn?.Invoke(); Debug.Log($\"token raw: {token}\"); } }); }  ",
          "content_tokens": 252,
          "embedding": []
        },
        {
          "cs_scriptfile": "PlayerData",
          "content": "private void GetOrCreatePlayerIdAndPassword() { Action<string> callback = (data) => { Debug.Log($\"data raw: {data}\"); PlayerRegisterData json = JsonConvert.DeserializeObject<PlayerRegisterData>(data); _playerRegisterData.email = json.email; _playerRegisterData.password = json.password; PlayerPrefs.SetString(PLAYER_PREFS_PLAYER_ID_KEY, MyPlayerRegisterData.email); PlayerPrefs.SetString(PLAYER_PREFS_PLAYER_PASSWORD, MyPlayerRegisterData.password); OnPlayerIdAndPasswordLoaded?.Invoke(); }; if (!PlayerPrefs.HasKey(PLAYER_PREFS_PLAYER_ID_KEY)) { if (IsUsingBackend) { BackendReadWrites.Player _player = new BackendReadWrites.Player(); _player.username = MyPlayerRegisterData.email; _player.password = MyPlayerRegisterData.password; _player.email = MyPlayerRegisterData.email; BackendReadWrites.RegisterUser(_player, (exception, response, body) => { if (exception != null) { DebugWrite.LogError(\"Error registering user: \" + exception.Message, gameObject, _isDebug); return; } DebugWrite.Log(\"User registered: \" + body, gameObject, _isDebug); callback(body); }); } else { //generate unique id PlayerRegisterData playerRegisterData = new PlayerRegisterData(); playerRegisterData.email = Guid.NewGuid().ToString(); playerRegisterData.password = Guid.NewGuid().ToString(); callback(playerRegisterData.ToString()); } } else { _playerRegisterData.email = PlayerPrefs.GetString(PLAYER_PREFS_PLAYER_ID_KEY); _playerRegisterData.password = PlayerPrefs.GetString(PLAYER_PREFS_PLAYER_PASSWORD); } } /// <summary> /// Called from inspector button /// </summary> /// <param name=\"nickname\"></param> public void OnClickSavePlayerData() { string newUsername = usernameInputField.text == \"\" ? _playerNameText.text : usernameInputField.text; string newEmail = _emailInputField.text == \"\" ? _playerEmailText.text : _emailInputField.text; string newPassword = _passwordInputField.text == \"\" ? _playerPasswordText.text : _passwordInputField.text; backendResponseStatusText.text = $\"saving...\"; BackendReadWrites.ChangePlayerData(_token, newUsername, newEmail, newPassword, (exception, response, body) => { if (exception != null) { Debug.LogError($\"[OnClickSavePlayerData] {exception.Message}\"); return; } else { BackendReadWrites.Token token = JsonConvert.DeserializeObject<BackendReadWrites.Token>(body); StoreUsername(newUsername); StorePassword(newPassword); StoreEmail(newEmail); StoreToken(token.access_token); SwitchSaveBtn(false); StartCoroutine(ShowStatus(\"saved!\")); Debug.Log($\"[OnClickSavePlayerData] response: {response}, body: {body}\"); } }); } private IEnumerator ShowStatus(string saved) { backendResponseStatusText.text = $\"{saved}\"; yield return new WaitForSeconds(2f); backendResponseStatusText.text = String.Empty;  ",
          "content_tokens": 767,
          "embedding": []
        },
        {
          "cs_scriptfile": "PlayerData",
          "content": "public void UnlockSaveButtonIfRequired() { bool isOn = usernameInputField.text != Username || _emailInputField.text != _playerRegisterData.email || _passwordInputField.text != _playerRegisterData.password; SwitchSaveBtn(isOn);  private void SwitchSaveBtn(bool isOn) { savePlayerDataBtn.interactable = isOn; } [Serializable] public class PlayerRegisterData { public string email; public string password;  public void FlushPlayerPrefs() { PlayerPrefs.DeleteAll(); } } }",
          "content_tokens": 122,
          "embedding": []
        }
      ],
      "length": 9373
    },
    {
      "filename": "RenderersCatcher",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; [RequireComponent(typeof(GpuInstancingForGameObjects))] public class RenderersCatcher : MonoBehaviour { [SerializeField] private GpuInstancingForGameObjects gpuInstancingForGameObjects; List<MeshRenderer> _renderers = new List<MeshRenderer>(); private void OnValidate() { gpuInstancingForGameObjects ??= GetComponent<GpuInstancingForGameObjects>(); } private void Awake() { gpuInstancingForGameObjects ??= GetComponent<GpuInstancingForGameObjects>(); } private IEnumerator Start() { yield return new WaitForSeconds(10f); StoreRendererInfo(transform); gpuInstancingForGameObjects.SetMeshRenderers(_renderers.ToArray()); gpuInstancingForGameObjects.InitStart(); } void StoreRendererInfo(Transform target) { // Iterate through all child objects of the transform foreach (Transform child in target) { // Check if the child has a Renderer component MeshRenderer renderer = child.GetComponent<MeshRenderer>(); // If a renderer is found, create a RendererInfo struct and add it to the list if (renderer != null) { _renderers.Add(renderer); } // Recursively check for children of this child StoreRendererInfo(child); } Debug.Log($\"[RenderersCatcher] Found {_renderers.Count} renderers\"); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RenderersCatcher",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; [RequireComponent(typeof(GpuInstancingForGameObjects))] public class RenderersCatcher : MonoBehaviour { [SerializeField] private GpuInstancingForGameObjects gpuInstancingForGameObjects; List<MeshRenderer> _renderers = new List<MeshRenderer>(); private void OnValidate() { gpuInstancingForGameObjects ??= GetComponent<GpuInstancingForGameObjects>();  ",
          "content_tokens": 122,
          "embedding": []
        },
        {
          "cs_scriptfile": "RenderersCatcher",
          "content": "private void Awake() { gpuInstancingForGameObjects ??= GetComponent<GpuInstancingForGameObjects>(); } private IEnumerator Start() { yield return new WaitForSeconds(10f); StoreRendererInfo(transform); gpuInstancingForGameObjects.SetMeshRenderers(_renderers.ToArray()); gpuInstancingForGameObjects.InitStart();  ",
          "content_tokens": 92,
          "embedding": []
        },
        {
          "cs_scriptfile": "RenderersCatcher",
          "content": "void StoreRendererInfo(Transform target) { // Iterate through all child objects of the transform foreach (Transform child in target) { // Check if the child has a Renderer component MeshRenderer renderer = child.GetComponent<MeshRenderer>(); // If a renderer is found, create a RendererInfo struct and add it to the list if (renderer != null) { _renderers.Add(renderer); } // Recursively check for children of this child StoreRendererInfo(child); } Debug.Log($\"[RenderersCatcher] Found {_renderers.Count} renderers\"); } }",
          "content_tokens": 139,
          "embedding": []
        }
      ],
      "length": 1262
    },
    {
      "filename": "RoomLODController",
      "content": "using System; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using UnityEngine; public class RoomLODController : NetworkBehaviour { public static RoomLODController Instance { get; private set; } private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } } public void InitForClient() { var rooms = GameplayManager.Instance.DungeonHolder.RoomDatas; for (int i = 0; i < rooms.Count; i++) { var roomLODHolder = new GameObject($\"RoomLODHolder {i}\"); roomLODHolder.transform.parent = rooms[i].transform; roomLODHolder.transform.localPosition = Vector3.zero; RoomLODDetector roomLodDetector = roomLODHolder.AddComponent<RoomLODDetector>(); roomLodDetector.Init(rooms[i]); RoomLODDetector.AddTotalActiveRooms(); roomLODHolder.transform.parent = transform; roomLODHolder.transform.rotation = rooms[i].transform.rotation; bool isLogicOn = true; if (GameplayManager.Instance.NetworkObject.IsHost) { if (GameplayManager.Instance.RoomDetails.MemberIds.Count == 1) { isLogicOn = true; } else { isLogicOn = false; } } else { isLogicOn = true; } if (isLogicOn) { roomLodDetector.SetDetectingRoomActive(false); } } Debug.Log($\"[RoomLODController] Created {rooms.Count} RoomLODHolders\"); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RoomLODController",
          "content": "using System; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using UnityEngine; public class RoomLODController : NetworkBehaviour { public static RoomLODController Instance { get; private set;  private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); }  ",
          "content_tokens": 95,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomLODController",
          "content": "public void InitForClient() { var rooms = GameplayManager.Instance.DungeonHolder.RoomDatas; for (int i = 0; i < rooms.Count; i++) { var roomLODHolder = new GameObject($\"RoomLODHolder {i}\"); roomLODHolder.transform.parent = rooms[i].transform; roomLODHolder.transform.localPosition = Vector3.zero; RoomLODDetector roomLodDetector = roomLODHolder.AddComponent<RoomLODDetector>(); roomLodDetector.Init(rooms[i]); RoomLODDetector.AddTotalActiveRooms(); roomLODHolder.transform.parent = transform; roomLODHolder.transform.rotation = rooms[i].transform.rotation; bool isLogicOn = true; if (GameplayManager.Instance.NetworkObject.IsHost) { if (GameplayManager.Instance.RoomDetails.MemberIds.Count == 1) { isLogicOn = true; } else { isLogicOn = false; } } else { isLogicOn = true;  ",
          "content_tokens": 238,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomLODController",
          "content": "if (isLogicOn) { roomLodDetector.SetDetectingRoomActive(false); } } Debug.Log($\"[RoomLODController] Created {rooms.Count} RoomLODHolders\"); } }",
          "content_tokens": 46,
          "embedding": []
        }
      ],
      "length": 1270
    },
    {
      "filename": "RoomLODDetector",
      "content": "using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using InRoomSystems; using UnityEngine; using System; using _ZombieRoyale.Scripts.Core; using DungeonArchitect; public class RoomLODDetector : MonoBehaviour { private static readonly float ENLARGE_RADIUS = 48f; [SerializeField] private GameObject _detectingRoom; private bool isFirstEnter = true; public static Action OnLocalPlayerDetected; public static int TotalActiveRooms { get; private set; } private static readonly bool IsShowLog = true; public void Init(DungeonSceneProviderData roomGo) { gameObject.layer = LayerMask.NameToLayer(\"Triggers\"); _detectingRoom = roomGo.gameObject; BoxCollider boxCollider = roomGo.GetComponent<BoxCollider>(); CreateDetectingCollider(boxCollider); } private void CreateDetectingCollider(BoxCollider boxCollider) { BoxCollider detectingCollider = gameObject.AddComponent<BoxCollider>(); Vector3 center = boxCollider.center; Vector3 size = new Vector3(boxCollider.size.x + ENLARGE_RADIUS, boxCollider.size.y, boxCollider.size.z + ENLARGE_RADIUS); detectingCollider.center = center; detectingCollider.size = size; detectingCollider.isTrigger = true; } public static void AddTotalActiveRooms() { TotalActiveRooms++; } public void SetDetectingRoomActive(bool value) { if (_detectingRoom.activeSelf == value) return; _detectingRoom.SetActive(value); if (value) { TotalActiveRooms++; } else { TotalActiveRooms--; } if (IsShowLog) { Debug.Log($\"[RoomLODDetector] Total active rooms: {TotalActiveRooms}. {_detectingRoom.name} IsActive({value})\", _detectingRoom); } } #if !(UNITY_SERVER || UNITY_STANDALONE_LINUX) private void OnTriggerEnter(Collider other) { if (other.CompareTag(\"Player\")) { if (GameplayManager.LocalPlayer != null) { if (GameplayManager.LocalPlayer.GetHealthController(other) != null) if (!GameplayManager.LocalPlayer.GetHealthController(other).IsOwner) return; if (isFirstEnter) { //ObjectsRoomManager.Instance.RemoveNonNetworkedObjectsClient(); } isFirstEnter = false; Debug.Log($\"[RoomLODDetector] Local player detected for {gameObject.name}\", gameObject); OnLocalPlayerDetected?.Invoke(); } SetDetectingRoomActive(true); } } private void OnTriggerExit(Collider other) { if (other.CompareTag(\"Player\")) { if (!GameplayManager.LocalPlayer.GetHealthController(other).IsOwner) return; SetDetectingRoomActive(false); } } #endif } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RoomLODDetector",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomLODDetector",
          "content": "using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using InRoomSystems; using UnityEngine; using System; using _ZombieRoyale.Scripts.Core; using DungeonArchitect; public class RoomLODDetector : MonoBehaviour { private static readonly float ENLARGE_RADIUS = 48f; [SerializeField] private GameObject _detectingRoom; private bool isFirstEnter = true; public static Action OnLocalPlayerDetected; public static int TotalActiveRooms { get; private set; } private static readonly bool IsShowLog = true; public void Init(DungeonSceneProviderData roomGo) { gameObject.layer = LayerMask.NameToLayer(\"Triggers\"); _detectingRoom = roomGo.gameObject; BoxCollider boxCollider = roomGo.GetComponent<BoxCollider>(); CreateDetectingCollider(boxCollider);  ",
          "content_tokens": 204,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomLODDetector",
          "content": "private void CreateDetectingCollider(BoxCollider boxCollider) { BoxCollider detectingCollider = gameObject.AddComponent<BoxCollider>(); Vector3 center = boxCollider.center; Vector3 size = new Vector3(boxCollider.size.x + ENLARGE_RADIUS, boxCollider.size.y, boxCollider.size.z + ENLARGE_RADIUS); detectingCollider.center = center; detectingCollider.size = size; detectingCollider.isTrigger = true; } public static void AddTotalActiveRooms() { TotalActiveRooms++;  public void SetDetectingRoomActive(bool value) { if (_detectingRoom.activeSelf == value) return; _detectingRoom.SetActive(value); if (value) { TotalActiveRooms++; } else { TotalActiveRooms--;  ",
          "content_tokens": 196,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomLODDetector",
          "content": "if (IsShowLog) { Debug.Log($\"[RoomLODDetector] Total active rooms: {TotalActiveRooms}. {_detectingRoom.name}",
          "content_tokens": 36,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomLODDetector",
          "content": "IsActive({value})\", _detectingRoom); } } #if !(UNITY_SERVER || UNITY_STANDALONE_LINUX) private void OnTriggerEnter(Collider other) { if (other.CompareTag(\"Player\")) { if (GameplayManager.LocalPlayer != null) { if (GameplayManager.LocalPlayer.GetHealthController(other) != null) if (!GameplayManager.LocalPlayer.GetHealthController(other).IsOwner) return; if (isFirstEnter) { //ObjectsRoomManager.Instance.RemoveNonNetworkedObjectsClient(); } isFirstEnter = false; Debug.Log($\"[RoomLODDetector] Local player detected for {gameObject.name}\", gameObject); OnLocalPlayerDetected?.Invoke();  SetDetectingRoomActive(true); }  ",
          "content_tokens": 179,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomLODDetector",
          "content": "private void OnTriggerExit(Collider other) { if (other.CompareTag(\"Player\")) { if (!GameplayManager.LocalPlayer.GetHealthController(other).IsOwner) return; SetDetectingRoomActive(false); } } #endif }",
          "content_tokens": 53,
          "embedding": []
        }
      ],
      "length": 2334
    },
    {
      "filename": "RpgUIInventory",
      "content": "using DarkTonic.MasterAudio; using DuloGames.UI; using FishnetInvector; using Invector.vItemManager; using SingletonsExtension; using UnityEngine; public class RpgUIInventory : MonoBehaviour { public UIEquipSlot[] EquipSlots => equipSlots; [SerializeField] private UIEquipSlot[] equipSlots; [SerializeField] private UIItemSlot[] itemSlots; [SerializeField] private FNvItemManager itemManager; public string ClassName => _className ??= $\"{StringToHexColor.GetColoredClassName(GetType())}\"; private string _className; private void Awake() { itemManager.OnInit += InitOwner; } private void InitOwner() { itemManager.SetUIInventory(this); itemManager.onChangeItemAmount.AddListener(UpdateItemAmount); itemManager.onAddItem.AddListener(AddItem); itemManager.onDropItem.AddListener(DropItem); itemManager.onDestroyItem.AddListener(DestroyItemInInventory); itemManager.onEquipItem.AddListener(MoveItemFromInventoryToEquipSlot); itemManager.FishnetInvectorItemManager.ArmorSlotsController.OnArmorSuccessfullyEquipped += MoveArmorItemFromInventoryToEquipSlot; for (int i = 0; i < equipSlots.Length; i++) { equipSlots[i].OnUnequipItemId += UnequipItemId; //equipSlots[i].OnEquipItemId += EquipItemId; //equipSlots[i].onUnassign.AddListener(UnassignItem); equipSlots[i].onRightClick.AddListener(UnequipItem); equipSlots[i].onAssign.AddListener(EquipItemByDragAndDrop);//duplicates onAssign event } for (int i = 0; i < itemSlots.Length; i++) { itemSlots[i].onRightClick.AddListener(RightClickOnItemSlot); itemSlots[i].onAssignWithSource.AddListener(AssignFromSource); } } private void MoveArmorItemFromInventoryToEquipSlot(int itemId) { vItem item = MasterManager.GetVItem(itemId); item.amount = 1; Debug.Log($\"{ClassName} MoveArmorItemFromInventoryToEquipSlot: {item.name}\"); UIEquipmentType itemEquipmentType = item.GetEquipmentType(); for (int i = 0; i < equipSlots.Length; i++) { if (equipSlots[i].equipType != itemEquipmentType) continue; UIItemInfo info = item.ToUIItemInfo(); DestroyItemInInventory(item, item.amount); equipSlots[i].AssignWithoutEvent(info, null); Debug.Log($\"{ClassName} MoveArmorItemFromInventoryToEquipSlot({equipSlots[i].IsAssigned()}): {item.name} assigned to {equipSlots[i].name}\"); return; } } private void EquipItemId(int itemId) { Debug.Log($\"{ClassName} EquipItemId: {itemId}\"); vItem item = itemManager.GetItem(itemId); if (item == null) return; if (item.equipArea != null) { int indexArea = item.ToItemReference().indexArea; vEquipArea equipArea = itemManager.inventory.equipAreas[indexArea]; itemManager.inventory.OnEquipItem(equipArea, item); } } private void UnequipItemId(int id) { Debug.Log($\"{ClassName} UnequipItemId: {id}\"); vItem itemDb = MasterManager.GetVItem(id); if (itemDb.isArmorItem) { UIEquipmentType equipmentType = itemDb.GetEquipmentType(); itemManager.FishnetInvectorItemManager.ArmorSlotsController.CmdUnequipArmor((ushort)equipmentType); } else { vItem itemInInventory = itemManager.GetItem(id); if (itemInInventory == null) return; itemManager.UnequipItem(itemInInventory); } //TODO: play unequip sound: //MasterAudio.PlaySound(\"1-Dark Fantasy Studio- The ocean takes it all\"); } private void EquipItemByDragAndDrop(UIEquipSlot equipSlot) { Debug.Log($\"{ClassName} EquipItemByDragAndDrop: {equipSlot.name}\"); if (equipSlot.IsAssigned()) { UIItemInfo info = equipSlot.GetItemInfo(); vItem item = itemManager.GetItem(info.ID); if (item.equipArea == vItem.EquipAreaNames.mainHand || item.equipArea == vItem.EquipAreaNames.offHand) { ItemReference itemReference = item.ToItemReference(); int indexArea = itemReference.indexArea; vEquipArea equipArea = itemManager.inventory.equipAreas[indexArea]; itemManager.inventory.OnEquipItem(equipArea, item); }else if (item.isArmorItem) { itemManager.FishnetInvectorItemManager.ArmorSlotsController.CmdEquipArmor(item.id); } } } private void RightClickOnItemSlot(UIItemSlot itemSlot) { Debug.Log($\"{ClassName} RightClickOnItemSlot: {itemSlot.name}\"); if (!itemSlot.IsAssigned()) return; UIItemInfo info = itemSlot.GetItemInfo(); vItem item = itemManager.GetItem(info.ID); if (item == null) return; if (item.type == vItemType.Consumable) { //TODO: extract to different class bool isItemHealthPotion = item.id == 2; bool isItemBookExp= item.id == 753; if (isItemHealthPotion) { int healingPotionAbilityId = 12; int myId = itemManager.FishnetInvectorItemManager.NetworkObject.ObjectId; AbilityManager.Instance.InitAbility(myId, healingPotionAbilityId); DestroyItemInInventory(item, 1); }else if (isItemBookExp) { int bookExpAbilityId = 16; int myId = itemManager.FishnetInvectorItemManager.NetworkObject.ObjectId; AbilityManager.Instance.InitAbility(myId, bookExpAbilityId); DestroyItemInInventory(item, 1); } }else if (item.equipArea != null) { int indexArea = item.ToItemReference().indexArea; if (item.isArmorItem) { itemManager.FishnetInvectorItemManager.ArmorSlotsController.CmdEquipArmor(item.id); } else { vEquipArea equipArea = itemManager.inventory.equipAreas[indexArea]; itemManager.inventory.OnEquipItem(equipArea, item); } } } private void UnequipItem(UIEquipSlot equipSlot) { Debug.Log($\"{ClassName} UnequipItem: {equipSlot.name}\"); if (!equipSlot.IsAssigned()) return; UIItemInfo info = equipSlot.GetItemInfo(); vItem item = MasterManager.GetVItem(info.ID); if (item == null) return; if (IsInventoryHaveEmptySlot(out UIItemSlot emptySlot)) { equipSlot.Unassign(); if (item.isArmorItem) { UIEquipmentType equipmentType = item.GetEquipmentType(); itemManager.FishnetInvectorItemManager.ArmorSlotsController.CmdUnequipArmor((ushort)equipmentType); } else { itemManager.UnequipItem(item); emptySlot.Assign(info); } } else { MasterAudio.PlaySound(\"1-Dark Fantasy Studio- The ocean takes it all\"); } } private void UnassignItem(UIEquipSlot slot) { Debug.Log($\"{ClassName} UnassignItem from {slot.name}\"); UnequipItem(slot); } /// <summary> /// Use only for direct equipping, skipping inventory /// </summary> /// <param name=\"arg0\"></param> /// <param name=\"item\"></param> public void EquipItem(vEquipArea arg0, vItem item) { Debug.Log($\"{ClassName} EquipItem: {item.name}\"); UIEquipmentType equipmentType = item.GetEquipmentType(); for (int i = 0; i < equipSlots.Length; i++) { if (equipSlots[i].equipType != equipmentType) continue; UIItemInfo info = item.ToUIItemInfo(); equipSlots[i].Assign(info); DestroyItemInInventory(item, item.amount); return; } } private void MoveItemFromInventoryToEquipSlot(vEquipArea equipArea, vItem item) { Debug.Log($\"{ClassName} MoveItemFromInventoryToEquipSlot: {item.name}\"); UIEquipmentType equipmentType = item.GetEquipmentType(); for (int i = 0; i < equipSlots.Length; i++) { if (equipSlots[i].equipType != equipmentType) continue; UIItemInfo info = item.ToUIItemInfo(); DestroyItemInInventory(item, item.amount); equipSlots[i].AssignWithoutEvent(info, null); Debug.Log($\"{ClassName} MoveItemFromInventoryToEquipSlot({equipSlots[i].IsAssigned()}): {item.name} assigned to {equipSlots[i].name}\"); return; } } public void DestroyItemInInventory(vItem item, int amount) { Debug.Log($\"{ClassName} DestroyItem: {item.name}, amount: {amount}\"); foreach (var itemSlot in itemSlots) { if (!itemSlot.IsAssigned()) continue; if (itemSlot.ItemInfo.ID != item.id) continue; var itemInfo = itemSlot.GetItemInfo(); if (itemInfo.Amount > amount) { itemInfo.Amount -= amount; }else { itemSlot.Unassign(); } } } private void DropItem(vItem item, int amount) { Debug.Log($\"{ClassName} DropItem: {item.name}, amount: {amount}\"); foreach (var itemSlot in itemSlots) { if (!itemSlot.IsAssigned()) continue; if (itemSlot.ID != item.id) continue; itemSlot.Unassign(); } } private void AddItem(vItem item) { Debug.Log($\"{ClassName} AddItem: {item.name}, amount: {item.amount}\"); foreach (var itemSlot in itemSlots) { if (itemSlot.IsAssigned()) continue; UIItemInfo info = item.ToUIItemInfo(); itemSlot.Assign(info); break; } } public void UpdateItemAmount(vItem item) { Debug.Log($\"{ClassName} UpdateItemAmount: {item.name}, amount: {item.amount}\"); foreach (var itemSlot in itemSlots) { if (!itemSlot.IsAssigned()) continue; if (itemSlot.ItemInfo.ID != item.id) continue; itemSlot.UpdateAmount(item.amount); } } private bool IsInventoryHaveEmptySlot(out UIItemSlot emptySlot) { emptySlot = null; for (int i = 0; i < itemSlots.Length; i++) { if (!itemSlots[i].IsAssigned()) { emptySlot = itemSlots[i]; return true; } } return false; } private int _lastDropSlot; /// <summary> /// removes duplicative item from inventory /// </summary> /// <param name=\"slot\"></param> /// <param name=\"source\"></param> private void AssignFromSource(UIItemSlot slot, Object source) { string logText = $\"{ClassName} AssignFromSource: {slot.name}\"; UIEquipSlot equipSlot = source as UIEquipSlot; if (equipSlot == null) return; if (equipSlot.equipType == UIEquipmentType.Weapon_MainHand) return; if (equipSlot.equipType == UIEquipmentType.Weapon_OffHand) return; logText += $\" from {equipSlot.name}\"; for (int i = 0; i < itemSlots.Length; i++) { if (itemSlots[i] == slot) { _lastDropSlot = i; logText += $\" slot index: {i}\"; break; } } slot.UnassignNoEvent(); Debug.Log(logText); } public void StartCooldownIfRequired(int abilityId, float time) { for (int i = 0; i < itemSlots.Length; i++) { if (!itemSlots[i].IsAssigned()) continue; vItem item = MasterManager.GetVItem(itemSlots[i].ItemInfo.ID); if (item.IsItemHaveAbility(abilityId)) { itemSlots[i].cooldownComponent.StartCooldown(abilityId, time); } break; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "using DarkTonic.MasterAudio; using DuloGames.UI; using FishnetInvector; using Invector.vItemManager; using SingletonsExtension; using UnityEngine; public class RpgUIInventory : MonoBehaviour { public UIEquipSlot[] EquipSlots => equipSlots; [SerializeField] private UIEquipSlot[] equipSlots; [SerializeField] private UIItemSlot[] itemSlots; [SerializeField] private FNvItemManager itemManager; public string ClassName => _className ??= $\"{StringToHexColor.GetColoredClassName(GetType())}\"; private string _className; private void Awake() { itemManager.OnInit += InitOwner;  ",
          "content_tokens": 163,
          "embedding": []
        },
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "private void InitOwner() { itemManager.SetUIInventory(this); itemManager.onChangeItemAmount.AddListener(UpdateItemAmount); itemManager.onAddItem.AddListener(AddItem); itemManager.onDropItem.AddListener(DropItem); itemManager.onDestroyItem.AddListener(DestroyItemInInventory); itemManager.onEquipItem.AddListener(MoveItemFromInventoryToEquipSlot); itemManager.FishnetInvectorItemManager.ArmorSlotsController.OnArmorSuccessfullyEquipped += MoveArmorItemFromInventoryToEquipSlot; for (int i = 0; i < equipSlots.Length; i++) { equipSlots[i].OnUnequipItemId += UnequipItemId; //equipSlots[i].OnEquipItemId += EquipItemId; //equipSlots[i].onUnassign.AddListener(UnassignItem); equipSlots[i].onRightClick.AddListener(UnequipItem); equipSlots[i].onAssign.AddListener(EquipItemByDragAndDrop);//duplicates onAssign event  ",
          "content_tokens": 255,
          "embedding": []
        },
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "for (int i = 0; i < itemSlots.Length; i++) { itemSlots[i].onRightClick.AddListener(RightClickOnItemSlot); itemSlots[i].onAssignWithSource.AddListener(AssignFromSource); }  ",
          "content_tokens": 60,
          "embedding": []
        },
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "private void MoveArmorItemFromInventoryToEquipSlot(int itemId) { vItem item = MasterManager.GetVItem(itemId); item.amount = 1; Debug.Log($\"{ClassName} MoveArmorItemFromInventoryToEquipSlot: {item.name}\"); UIEquipmentType itemEquipmentType = item.GetEquipmentType(); for (int i = 0; i < equipSlots.Length; i++) { if (equipSlots[i].equipType != itemEquipmentType) continue; UIItemInfo info = item.ToUIItemInfo(); DestroyItemInInventory(item, item.amount); equipSlots[i].AssignWithoutEvent(info, null); Debug.Log($\"{ClassName}",
          "content_tokens": 167,
          "embedding": []
        },
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "MoveArmorItemFromInventoryToEquipSlot({equipSlots[i].IsAssigned()}): {item.name} assigned to {equipSlots[i].name}\"); return; }  private void EquipItemId(int itemId) { Debug.Log($\"{ClassName} EquipItemId: {itemId}\"); vItem item = itemManager.GetItem(itemId); if (item == null) return; if (item.equipArea != null) { int indexArea = item.ToItemReference().indexArea; vEquipArea equipArea = itemManager.inventory.equipAreas[indexArea]; itemManager.inventory.OnEquipItem(equipArea, item); }  ",
          "content_tokens": 159,
          "embedding": []
        },
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "private void UnequipItemId(int id) { Debug.Log($\"{ClassName} UnequipItemId: {id}\"); vItem itemDb = MasterManager.GetVItem(id); if (itemDb.isArmorItem) { UIEquipmentType equipmentType = itemDb.GetEquipmentType(); itemManager.FishnetInvectorItemManager.ArmorSlotsController.CmdUnequipArmor((ushort)equipmentType); } else { vItem itemInInventory = itemManager.GetItem(id); if (itemInInventory == null) return; itemManager.UnequipItem(itemInInventory); } //TODO: play unequip sound: //MasterAudio.PlaySound(\"1-Dark Fantasy Studio- The ocean takes it all\");  ",
          "content_tokens": 177,
          "embedding": []
        },
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "private void EquipItemByDragAndDrop(UIEquipSlot equipSlot) { Debug.Log($\"{ClassName} EquipItemByDragAndDrop: {equipSlot.name}\"); if (equipSlot.IsAssigned()) { UIItemInfo info = equipSlot.GetItemInfo(); vItem item = itemManager.GetItem(info.ID); if (item.equipArea == vItem.EquipAreaNames.mainHand || item.equipArea == vItem.EquipAreaNames.offHand) { ItemReference itemReference = item.ToItemReference(); int indexArea = itemReference.indexArea; vEquipArea equipArea = itemManager.inventory.equipAreas[indexArea]; itemManager.inventory.OnEquipItem(equipArea, item); }else if (item.isArmorItem) { itemManager.FishnetInvectorItemManager.ArmorSlotsController.CmdEquipArmor(item.id); } }  ",
          "content_tokens": 212,
          "embedding": []
        },
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "private void RightClickOnItemSlot(UIItemSlot itemSlot) { Debug.Log($\"{ClassName} RightClickOnItemSlot: {itemSlot.name}\"); if (!itemSlot.IsAssigned()) return; UIItemInfo info = itemSlot.GetItemInfo(); vItem item = itemManager.GetItem(info.ID); if (item == null) return; if (item.type == vItemType.Consumable) { //TODO: extract to different class bool isItemHealthPotion = item.id == 2; bool isItemBookExp= item.id == 753; if (isItemHealthPotion) { int healingPotionAbilityId = 12; int myId = itemManager.FishnetInvectorItemManager.NetworkObject.ObjectId; AbilityManager.Instance.InitAbility(myId, healingPotionAbilityId); DestroyItemInInventory(item, 1); }else if (isItemBookExp) { int bookExpAbilityId = 16; int myId = itemManager.FishnetInvectorItemManager.NetworkObject.ObjectId; AbilityManager.Instance.InitAbility(myId, bookExpAbilityId); DestroyItemInInventory(item, 1); } }else if (item.equipArea != null) { int indexArea = item.ToItemReference().indexArea; if (item.isArmorItem) { itemManager.FishnetInvectorItemManager.ArmorSlotsController.CmdEquipArmor(item.id); } else { vEquipArea equipArea = itemManager.inventory.equipAreas[indexArea]; itemManager.inventory.OnEquipItem(equipArea, item); } }  ",
          "content_tokens": 364,
          "embedding": []
        },
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "private void UnequipItem(UIEquipSlot equipSlot) { Debug.Log($\"{ClassName} UnequipItem: {equipSlot.name}\"); if (!equipSlot.IsAssigned()) return; UIItemInfo info = equipSlot.GetItemInfo(); vItem item = MasterManager.GetVItem(info.ID); if (item == null) return; if (IsInventoryHaveEmptySlot(out UIItemSlot emptySlot)) { equipSlot.Unassign(); if (item.isArmorItem) { UIEquipmentType equipmentType = item.GetEquipmentType(); itemManager.FishnetInvectorItemManager.ArmorSlotsController.CmdUnequipArmor((ushort)equipmentType); } else { itemManager.UnequipItem(item); emptySlot.Assign(info); } } else { MasterAudio.PlaySound(\"1-Dark Fantasy Studio- The ocean takes it all\"); }  ",
          "content_tokens": 211,
          "embedding": []
        },
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "private void UnassignItem(UIEquipSlot slot) { Debug.Log($\"{ClassName} UnassignItem from {slot.name}\"); UnequipItem(slot); } /// <summary> /// Use only for direct equipping, skipping inventory /// </summary> /// <param name=\"arg0\"></param> /// <param name=\"item\"></param> public void EquipItem(vEquipArea arg0, vItem item) { Debug.Log($\"{ClassName} EquipItem: {item.name}\"); UIEquipmentType equipmentType = item.GetEquipmentType(); for (int i = 0; i < equipSlots.Length; i++) { if (equipSlots[i].equipType != equipmentType) continue; UIItemInfo info = item.ToUIItemInfo(); equipSlots[i].Assign(info); DestroyItemInInventory(item, item.amount); return; }  ",
          "content_tokens": 207,
          "embedding": []
        },
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "private void MoveItemFromInventoryToEquipSlot(vEquipArea equipArea, vItem item) { Debug.Log($\"{ClassName} MoveItemFromInventoryToEquipSlot: {item.name}\"); UIEquipmentType equipmentType = item.GetEquipmentType(); for (int i = 0; i < equipSlots.Length; i++) { if (equipSlots[i].equipType != equipmentType) continue; UIItemInfo info = item.ToUIItemInfo(); DestroyItemInInventory(item, item.amount); equipSlots[i].AssignWithoutEvent(info, null); Debug.Log($\"{ClassName}MoveItemFromInventoryToEquipSlot({equipSlots[i].IsAssigned()}): {item.name} assigned to {equipSlots[i].name}\"); return; }  ",
          "content_tokens": 194,
          "embedding": []
        },
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "public void DestroyItemInInventory(vItem item, int amount) { Debug.Log($\"{ClassName} DestroyItem: {item.name}, amount: {amount}\"); foreach (var itemSlot in itemSlots) { if (!itemSlot.IsAssigned()) continue; if (itemSlot.ItemInfo.ID != item.id) continue; var itemInfo = itemSlot.GetItemInfo(); if (itemInfo.Amount > amount) { itemInfo.Amount -= amount; }else { itemSlot.Unassign(); } }  ",
          "content_tokens": 120,
          "embedding": []
        },
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "private void DropItem(vItem item, int amount) { Debug.Log($\"{ClassName} DropItem: {item.name}, amount: {amount}\"); foreach (var itemSlot in itemSlots) { if (!itemSlot.IsAssigned()) continue; if (itemSlot.ID != item.id) continue; itemSlot.Unassign(); }  private void AddItem(vItem item) { Debug.Log($\"{ClassName} AddItem: {item.name}, amount: {item.amount}\"); foreach (var itemSlot in itemSlots) { if (itemSlot.IsAssigned()) continue; UIItemInfo info = item.ToUIItemInfo(); itemSlot.Assign(info); break; }  ",
          "content_tokens": 164,
          "embedding": []
        },
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "public void UpdateItemAmount(vItem item) { Debug.Log($\"{ClassName} UpdateItemAmount: {item.name}, amount: {item.amount}\"); foreach (var itemSlot in itemSlots) { if (!itemSlot.IsAssigned()) continue; if (itemSlot.ItemInfo.ID != item.id) continue; itemSlot.UpdateAmount(item.amount); }  ",
          "content_tokens": 89,
          "embedding": []
        },
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "private bool IsInventoryHaveEmptySlot(out UIItemSlot emptySlot) { emptySlot = null; for (int i = 0; i < itemSlots.Length; i++) { if (!itemSlots[i].IsAssigned()) { emptySlot = itemSlots[i]; return true; } } return false; } private int _lastDropSlot; /// <summary> /// removes duplicative item from inventory /// </summary> /// <param name=\"slot\"></param> /// <param name=\"source\"></param> private void AssignFromSource(UIItemSlot slot, Object source) { string logText = $\"{ClassName} AssignFromSource: {slot.name}\"; UIEquipSlot equipSlot = source as UIEquipSlot; if (equipSlot == null) return; if (equipSlot.equipType == UIEquipmentType.Weapon_MainHand) return; if (equipSlot.equipType == UIEquipmentType.Weapon_OffHand) return; logText += $\" from {equipSlot.name}\"; for (int i = 0; i < itemSlots.Length; i++) { if (itemSlots[i] == slot) { _lastDropSlot = i; logText += $\" slot index: {i}\"; break; } } slot.UnassignNoEvent(); Debug.Log(logText);  ",
          "content_tokens": 304,
          "embedding": []
        },
        {
          "cs_scriptfile": "RpgUIInventory",
          "content": "public void StartCooldownIfRequired(int abilityId, float time) { for (int i = 0; i < itemSlots.Length; i++) { if (!itemSlots[i].IsAssigned()) continue; vItem item = MasterManager.GetVItem(itemSlots[i].ItemInfo.ID); if (item.IsItemHaveAbility(abilityId)) { itemSlots[i].cooldownComponent.StartCooldown(abilityId, time); } break; } } }",
          "content_tokens": 106,
          "embedding": []
        }
      ],
      "length": 9397
    },
    {
      "filename": "SlashEffectController",
      "content": "using System.Collections; using DungeonScrollerCore; using UnityEngine; public class SlashEffectController : MonoBehaviour { [SerializeField] private ParticleSystem[] _particles; public void PlayAll() { for (int i = 0; i < _particles.Length; i++) { _particles[i].Play(); } } public void StopAll() { for (int i = 0; i < _particles.Length; i++) { _particles[i].Stop(); } DebugWrite.Log($\"[SlashEffectController] StopAll: _particles.Length={_particles.Length}\", gameObject, true); } public void PlayTimed(float duration) { StartCoroutine(CorPlayTimed(duration)); } private IEnumerator CorPlayTimed(float duration) { PlayAll(); yield return new WaitForSeconds(duration); StopAll(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SlashEffectController",
          "content": "using System.Collections; using DungeonScrollerCore; using UnityEngine; public class SlashEffectController : MonoBehaviour { [SerializeField] private ParticleSystem[] _particles; public void PlayAll() { for (int i = 0; i < _particles.Length; i++) { _particles[i].Play(); } } public void StopAll() { for (int i = 0; i < _particles.Length; i++) { _particles[i].Stop(); } DebugWrite.Log($\"[SlashEffectController] StopAll: _particles.Length={_particles.Length}\", gameObject, true); } public void PlayTimed(float duration) { StartCoroutine(CorPlayTimed(duration)); } private IEnumerator CorPlayTimed(float duration) { PlayAll(); yield return new WaitForSeconds(duration); StopAll(); } }",
          "content_tokens": 194,
          "embedding": []
        }
      ],
      "length": 682
    },
    {
      "filename": "SpeechPlayTest",
      "content": "using System; using System.Collections; using Proyecto26; using UnityEngine; public class SpeechPlayTest : MonoBehaviour { [SerializeField] AudioSource audioSource; // Assign this in the inspector or create it via script //[SerializeField] private string audioFileName; [SerializeField] private Animator aiAnimator; private void OnValidate() { audioSource ??= GetComponent<AudioSource>(); } public void PlayAudio(AudioClip clip) { SetTalkingAnimation(true); audioSource.clip = clip; audioSource.Play(); StartCoroutine(StopTalkingAfter(clip.length)); } private IEnumerator StopTalkingAfter(float seconds) { yield return new WaitForSeconds(seconds); SetTalkingAnimation(false); } private void SetTalkingAnimation(bool isTalking) { aiAnimator.SetBool(\"IsTalking\", isTalking); } public void DoDialog(string question) { Action<RequestException, ResponseHelper, string> callback = (error, response, body) => { if (error != null) { Debug.LogError($\"[SpeechPlayTest] Error: {error}\"); return; } Debug.Log($\"[SpeechPlayTest] Response: {response}\"); Debug.Log($\"[SpeechPlayTest] Body: {body}\"); DownloadAndPlay(body); }; BackendReadWrites.AiDoDialog(question, 17, 20, callback); } // Example usage public void DownloadAndPlay(string audioFileName = \"1\") { var startTime = DateTime.Now; BackendReadWrites.GetAudioFile(\"dialogues\", audioFileName, PlayAudio, error => Debug.LogError(\"Error: \" + error)); Debug.Log($\"[SpeechPlayTest] DownloadAndPlay took {(DateTime.Now - startTime).TotalMilliseconds} ms\"); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SpeechPlayTest",
          "content": "using System; using System.Collections; using Proyecto26; using UnityEngine; public class SpeechPlayTest : MonoBehaviour { [SerializeField] AudioSource audioSource; // Assign this in the inspector or create it via script //[SerializeField] private string audioFileName; [SerializeField] private Animator aiAnimator; private void OnValidate() { audioSource ??= GetComponent<AudioSource>();  public void PlayAudio(AudioClip clip) { SetTalkingAnimation(true); audioSource.clip = clip; audioSource.Play(); StartCoroutine(StopTalkingAfter(clip.length)); } private IEnumerator StopTalkingAfter(float seconds) { yield return new WaitForSeconds(seconds); SetTalkingAnimation(false);  private void SetTalkingAnimation(bool isTalking) { aiAnimator.SetBool(\"IsTalking\", isTalking);  ",
          "content_tokens": 195,
          "embedding": []
        },
        {
          "cs_scriptfile": "SpeechPlayTest",
          "content": "public void DoDialog(string question) { Action<RequestException, ResponseHelper, string> callback = (error, response, body) => { if (error != null) { Debug.LogError($\"[SpeechPlayTest] Error: {error}\"); return; } Debug.Log($\"[SpeechPlayTest] Response: {response}\"); Debug.Log($\"[SpeechPlayTest] Body: {body}\"); DownloadAndPlay(body); }; BackendReadWrites.AiDoDialog(question, 17, 20, callback); } // Example usage public void DownloadAndPlay(string audioFileName = \"1\") { var startTime = DateTime.Now; BackendReadWrites.GetAudioFile(\"dialogues\", audioFileName, PlayAudio, error => Debug.LogError(\"Error: \" + error)); Debug.Log($\"[SpeechPlayTest] DownloadAndPlay took {(DateTime.Now - startTime).TotalMilliseconds} ms\"); } }",
          "content_tokens": 210,
          "embedding": []
        }
      ],
      "length": 1498
    },
    {
      "filename": "StatInfo",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class StatInfo : MonoBehaviour { [SerializeField] private TMProDecorator _statName; [SerializeField] private TMProDecorator _statValueText; private Stat.STAT_TYPE _statType; private float _statValue; public void Init(Stat.STAT_TYPE statType, float baseValue, float bonusValue) { _statType = statType; _statName.SetText(TMProDecorator.ToUpperCase(statType.ToString())); UpdateAmount(baseValue, bonusValue); } public void UpdateAmount(float baseValue, float bonusValue) { float totalValue = baseValue + bonusValue; _statValue = totalValue; string valueText = $\"{totalValue.ToString(\"F2\")}</color=green>(+{bonusValue.ToString(\"F2\")})\"; _statValueText.SetText(valueText); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "StatInfo",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class StatInfo : MonoBehaviour { [SerializeField] private TMProDecorator _statName; [SerializeField] private TMProDecorator _statValueText; private Stat.STAT_TYPE _statType; private float _statValue; public void Init(Stat.STAT_TYPE statType, float baseValue, float bonusValue) { _statType = statType; _statName.SetText(TMProDecorator.ToUpperCase(statType.ToString())); UpdateAmount(baseValue, bonusValue);  ",
          "content_tokens": 138,
          "embedding": []
        },
        {
          "cs_scriptfile": "StatInfo",
          "content": "public void UpdateAmount(float baseValue, float bonusValue) { float totalValue = baseValue + bonusValue; _statValue = totalValue; string valueText = $\"{totalValue.ToString(\"F2\")}</color=green>(+{bonusValue.ToString(\"F2\")})\"; _statValueText.SetText(valueText); } }",
          "content_tokens": 80,
          "embedding": []
        }
      ],
      "length": 758
    },
    {
      "filename": "StatsWindowController",
      "content": "using System; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishnetInvector; using UnityEngine; public class StatsWindowController : MonoBehaviour { [SerializeField] private StatInfo _statInfoPrefab; [SerializeField] private GameObject _statsContainer; [SerializeField] private FishnetInvectorManager _fishnetInvectorManager; private Stat.STAT_TYPE[] statTypesToDraw = new Stat.STAT_TYPE[] { Stat.STAT_TYPE.ARMOR, Stat.STAT_TYPE.XP, Stat.STAT_TYPE.STRENGTH, Stat.STAT_TYPE.AGILITY, Stat.STAT_TYPE.INTELLECT, Stat.STAT_TYPE.Constitution, Stat.STAT_TYPE.Wisdom, Stat.STAT_TYPE.Charisma }; [SerializeField] private StatValueContainer[] _statValueContainers; public Dictionary<Stat.STAT_TYPE, StatInfo> StatInfos => _statInfos; private Dictionary<Stat.STAT_TYPE, StatInfo> _statInfos = new Dictionary<Stat.STAT_TYPE, StatInfo>(); public UnitComponents UnitComponents { get { if (_unitComponents == null) { if (_fishnetInvectorManager.IsServer) { _unitComponents = GameplayManager.Instance.GetUnitComponents(_fishnetInvectorManager.NetworkObject); } else { _unitComponents = GameplayManager.Instance.GetUnitComponents(_fishnetInvectorManager .NetworkObject); } } return _unitComponents; } } private UnitComponents _unitComponents; private bool _isWindowOpened; public void Init() { DebugWrite.Log($\"[StatsWindowController] Init\"); UnitComponents unitComponents = UnitComponents; unitComponents.StatsController.OnStatChanged += FNStatsController_OnStatsUpdated; } public void UpdateStats() { for (int i = 0; i < _statValueContainers.Length; i++) { UpdateStatsInfo(i); } } private void FNStatsController_OnStatsUpdated(byte statId, float newValue) { DebugWrite.Log($\"[StatsWindowController] FNStatsController_OnStatsUpdated statType: {(Stat.STAT_TYPE) statId} newValue: {newValue}\"); for (int i = 0; i < _statValueContainers.Length; i++) { StatValueContainer statValueContainer = _statValueContainers[i]; if (statValueContainer.statType == (Stat.STAT_TYPE) statId) { UpdateStatsInfo(i); return; } } } private void UpdateStatsInfo(int index) { Debug.Log($\"[StatsWindowController] UpdateStatsInfo index: {index}\"); Stat.STAT_TYPE statType = _statValueContainers[index].statType; var baseValue = UnitComponents.StatsController.GetBaseValue(statType); var bonusValue = UnitComponents.StatsController.GetAllBonusValue(statType); DebugWrite.Log($\"[StatsWindowController] UpdateStatsInfo statType: {(int)statType}{statType} baseValue: {baseValue} bonusValue: {bonusValue}\"); UpdateAmount(_statValueContainers[index].statValueText, baseValue, bonusValue); } private void UpdateAmount(TMProDecorator text, float baseValue, float bonusValue) { float totalValue = baseValue + bonusValue; string valueText = $\"{totalValue.ToString(\"F2\")})\"; text.SetText(valueText); } [Serializable] public class StatValueContainer { public Stat.STAT_TYPE statType; public TMProDecorator statValueText; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "StatsWindowController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "StatsWindowController",
          "content": "using System; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishnetInvector; using UnityEngine; public class StatsWindowController : MonoBehaviour { [SerializeField] private StatInfo _statInfoPrefab; [SerializeField] private GameObject _statsContainer; [SerializeField] private FishnetInvectorManager _fishnetInvectorManager; private Stat.STAT_TYPE[] statTypesToDraw = new Stat.STAT_TYPE[] { Stat.STAT_TYPE.ARMOR, Stat.STAT_TYPE.XP, Stat.STAT_TYPE.STRENGTH, Stat.STAT_TYPE.AGILITY, Stat.STAT_TYPE.INTELLECT, Stat.STAT_TYPE.Constitution, Stat.STAT_TYPE.Wisdom, Stat.STAT_TYPE.Charisma }; [SerializeField] private StatValueContainer[] _statValueContainers; public Dictionary<Stat.STAT_TYPE, StatInfo> StatInfos => _statInfos; private Dictionary<Stat.STAT_TYPE, StatInfo> _statInfos = new Dictionary<Stat.STAT_TYPE, StatInfo>(); public UnitComponents UnitComponents { get { if (_unitComponents == null) { if (_fishnetInvectorManager.IsServer) { _unitComponents = GameplayManager.Instance.GetUnitComponents(_fishnetInvectorManager.NetworkObject); } else { _unitComponents = GameplayManager.Instance.GetUnitComponents(_fishnetInvectorManager .NetworkObject); } } return _unitComponents; } } private UnitComponents _unitComponents; private bool _isWindowOpened; public void Init() { DebugWrite.Log($\"[StatsWindowController] Init\"); UnitComponents unitComponents = UnitComponents; unitComponents.StatsController.OnStatChanged += FNStatsController_OnStatsUpdated;  ",
          "content_tokens": 431,
          "embedding": []
        },
        {
          "cs_scriptfile": "StatsWindowController",
          "content": "public void UpdateStats() { for (int i = 0; i < _statValueContainers.Length; i++) { UpdateStatsInfo(i); }  private void FNStatsController_OnStatsUpdated(byte statId, float newValue) { DebugWrite.Log($\"[StatsWindowController] FNStatsController_OnStatsUpdated statType: {(Stat.STAT_TYPE) statId} newValue: {newValue}\"); for (int i = 0; i < _statValueContainers.Length; i++) { StatValueContainer statValueContainer = _statValueContainers[i]; if (statValueContainer.statType == (Stat.STAT_TYPE) statId) { UpdateStatsInfo(i); return; } }  ",
          "content_tokens": 159,
          "embedding": []
        },
        {
          "cs_scriptfile": "StatsWindowController",
          "content": "private void UpdateStatsInfo(int index) { Debug.Log($\"[StatsWindowController] UpdateStatsInfo index: {index}\"); Stat.STAT_TYPE statType = _statValueContainers[index].statType; var baseValue = UnitComponents.StatsController.GetBaseValue(statType); var bonusValue = UnitComponents.StatsController.GetAllBonusValue(statType); DebugWrite.Log($\"[StatsWindowController] UpdateStatsInfo statType: {(int)statType}{statType} baseValue: {baseValue} bonusValue: {bonusValue}\"); UpdateAmount(_statValueContainers[index].statValueText, baseValue, bonusValue);  ",
          "content_tokens": 148,
          "embedding": []
        },
        {
          "cs_scriptfile": "StatsWindowController",
          "content": "private void UpdateAmount(TMProDecorator text, float baseValue, float bonusValue) { float totalValue = baseValue + bonusValue; string valueText = $\"{totalValue.ToString(\"F2\")})\"; text.SetText(valueText); } [Serializable] public class StatValueContainer { public Stat.STAT_TYPE statType; public TMProDecorator statValueText; } }",
          "content_tokens": 89,
          "embedding": []
        }
      ],
      "length": 2981
    },
    {
      "filename": "ConnectedHostIDSetter",
      "content": "using TMPro; using UnityEngine; public class ConnectedHostIDSetter : MonoBehaviour { [SerializeField] private TextMeshProUGUI _text; private void Start() { if (SteamConnectionManager.Instance.IsSteamHostStarted) { _text.text = $\"Steam Host ID: {SteamConnectionManager.GetHostHex()}\"; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ConnectedHostIDSetter",
          "content": "using TMPro; using UnityEngine; public class ConnectedHostIDSetter : MonoBehaviour { [SerializeField] private TextMeshProUGUI _text; private void Start() { if (SteamConnectionManager.Instance.IsSteamHostStarted) { _text.text = $\"Steam Host ID: {SteamConnectionManager.GetHostHex()}\"; } } }",
          "content_tokens": 81,
          "embedding": []
        }
      ],
      "length": 289
    },
    {
      "filename": "SteamConnectionManager",
      "content": "using System; using DDCore; using FishNet; using FishNet.Connection; using FishNet.Transporting.Tugboat; using HeathenEngineering.SteamworksIntegration; using TMPro; using UnityEngine; using FishNet.Managing; using FishNet.Transporting; using LiteNetLib; using Steamworks; public class SteamConnectionManager : MonoBehaviour { private string _hostHex; [SerializeField] private FishySteamworks.FishySteamworks fishySteamworks; [SerializeField] private TMP_InputField connectionInput; [SerializeField] private NetworkManager networkManager; [SerializeField] private Tugboat tugboat; [SerializeField] private LobbyManager lobbyManager; public static SteamConnectionManager Instance { get; private set; } public static string GetHostHex() => Instance._hostHex; public bool IsSteamHostStarted { get; private set; } private void OnValidate() { AssignComponents(); } private void AssignComponents() { if (networkManager == null) networkManager = FindObjectOfType<NetworkManager>(); if (tugboat == null) tugboat = FindObjectOfType<Tugboat>(); if (lobbyManager == null) lobbyManager = FindObjectOfType<LobbyManager>(); } private void Awake() { if (Instance != null) { Destroy(gameObject); return; } Instance = this; AssignComponents(); DontDestroyOnLoad(this); } public void StartHost() { ReplaceTugboatToFishySteamworks(); networkManager.ServerManager.OnServerConnectionState += CustomServerManager.Instance.OnServerConnectionState; lobbyManager.Create(\"\", ELobbyType.k_ELobbyTypePublic, 3); fishySteamworks.StartConnection(true); if (fishySteamworks.StartConnection(false)) IsSteamHostStarted = true; var user = UserData.Get(); if (user == null) { Debug.LogError(\"User data is null\"); return; } _hostHex = user.ToString(); } private void OnRemoteConnectionState(NetworkConnection arg1, RemoteConnectionStateArgs arg2) { switch (arg2.ConnectionState) { case RemoteConnectionState.Started: Debug.Log(\"Connected\"); //networkManager.ClientManager.StartConnection(); break; case RemoteConnectionState.Stopped: Debug.Log(\"Disconnected\"); break; } } private void ReplaceTugboatToFishySteamworks() { DestroyImmediate(tugboat); fishySteamworks = networkManager.gameObject.AddComponent<FishySteamworks.FishySteamworks>(); fishySteamworks.SetPeerToPeer(true); networkManager.Init(); } public void StartConnection() { ReplaceTugboatToFishySteamworks(); _hostHex = connectionInput.text; var hostUser = UserData.Get(_hostHex); //if (!hostUser.IsValidHost()) //{ // Debug.LogError(\"Invalid host user\"); // return; //} fishySteamworks.SetClientAddress(_hostHex);//hostUser.id.ToString()); fishySteamworks.StartConnection(false); } public void StartConnection(string hostHex) { ReplaceTugboatToFishySteamworks(); _hostHex = hostHex; UserData hostUser = UserData.Get(_hostHex); if (!hostUser.IsValid) { Debug.LogError(\"Invalid host user\"); return; } fishySteamworks.SetClientAddress(hostUser.SteamId.ToString()); fishySteamworks.StartConnection(false); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SteamConnectionManager",
          "content": "using System; using DDCore; using FishNet; using FishNet.Connection; using FishNet.Transporting.Tugboat; using HeathenEngineering.SteamworksIntegration; using TMPro; using UnityEngine; using FishNet.Managing; using FishNet.Transporting; using LiteNetLib; using Steamworks; public class SteamConnectionManager : MonoBehaviour { private string _hostHex; [SerializeField] private FishySteamworks.FishySteamworks fishySteamworks; [SerializeField] private TMP_InputField connectionInput; [SerializeField] private NetworkManager networkManager; [SerializeField] private Tugboat tugboat; [SerializeField] private LobbyManager lobbyManager; public static SteamConnectionManager Instance { get; private set; } public static string GetHostHex() => Instance._hostHex; public bool IsSteamHostStarted { get; private set;  ",
          "content_tokens": 201,
          "embedding": []
        },
        {
          "cs_scriptfile": "SteamConnectionManager",
          "content": "private void OnValidate() { AssignComponents();  private void AssignComponents() { if (networkManager == null) networkManager = FindObjectOfType<NetworkManager>(); if (tugboat == null) tugboat = FindObjectOfType<Tugboat>(); if (lobbyManager == null) lobbyManager = FindObjectOfType<LobbyManager>();  private void Awake() { if (Instance != null) { Destroy(gameObject); return; } Instance = this; AssignComponents(); DontDestroyOnLoad(this);  ",
          "content_tokens": 124,
          "embedding": []
        },
        {
          "cs_scriptfile": "SteamConnectionManager",
          "content": "public void StartHost() { ReplaceTugboatToFishySteamworks(); networkManager.ServerManager.OnServerConnectionState += CustomServerManager.Instance.OnServerConnectionState; lobbyManager.Create(\"\", ELobbyType.k_ELobbyTypePublic, 3); fishySteamworks.StartConnection(true); if (fishySteamworks.StartConnection(false)) IsSteamHostStarted = true; var user = UserData.Get(); if (user == null) { Debug.LogError(\"User data is null\"); return; } _hostHex = user.ToString();  ",
          "content_tokens": 127,
          "embedding": []
        },
        {
          "cs_scriptfile": "SteamConnectionManager",
          "content": "private void OnRemoteConnectionState(NetworkConnection arg1, RemoteConnectionStateArgs arg2) { switch (arg2.ConnectionState) { case RemoteConnectionState.Started: Debug.Log(\"Connected\"); //networkManager.ClientManager.StartConnection(); break; case RemoteConnectionState.Stopped: Debug.Log(\"Disconnected\"); break; }  private void ReplaceTugboatToFishySteamworks() { DestroyImmediate(tugboat); fishySteamworks = networkManager.gameObject.AddComponent<FishySteamworks.FishySteamworks>(); fishySteamworks.SetPeerToPeer(true); networkManager.Init();  ",
          "content_tokens": 142,
          "embedding": []
        },
        {
          "cs_scriptfile": "SteamConnectionManager",
          "content": "public void StartConnection() { ReplaceTugboatToFishySteamworks(); _hostHex = connectionInput.text; var hostUser = UserData.Get(_hostHex); //if (!hostUser.IsValidHost()) //{ // Debug.LogError(\"Invalid host user\"); // return; //} fishySteamworks.SetClientAddress(_hostHex);//hostUser.id.ToString()); fishySteamworks.StartConnection(false);  public void StartConnection(string hostHex) { ReplaceTugboatToFishySteamworks(); _hostHex = hostHex; UserData hostUser = UserData.Get(_hostHex); if (!hostUser.IsValid) { Debug.LogError(\"Invalid host user\"); return; } fishySteamworks.SetClientAddress(hostUser.SteamId.ToString()); fishySteamworks.StartConnection(false); } }",
          "content_tokens": 194,
          "embedding": []
        }
      ],
      "length": 2932
    },
    {
      "filename": "SteamLobbyManagerDecorator",
      "content": "using HeathenEngineering.SteamworksIntegration; using UnityEngine; public class SteamLobbyManagerDecorator : MonoBehaviour { private LobbyManager _steamLobbyManager; void Awake() { AddSteamLobbyManagerIfExist(); Debug.Log(\"SteamLobbyManagerDecorator.Awake\"); } private void AddSteamLobbyManagerIfExist() { if (_steamLobbyManager == null) { _steamLobbyManager = FindObjectOfType<LobbyManager>(); } if (_steamLobbyManager.Lobby != null) { Debug.Log($\"[SteamLobbyManagerDecorator] Lobby is ok!\"); } } public void InviteFriend(UserData user) { Debug.Log($\"[SteamLobbyManagerDecorator] InviteFriend: {user.Name} #{user.SteamId}; Lobby: {_steamLobbyManager.Lobby.Name}\"); _steamLobbyManager.Invite(user); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SteamLobbyManagerDecorator",
          "content": "using HeathenEngineering.SteamworksIntegration; using UnityEngine; public class SteamLobbyManagerDecorator : MonoBehaviour { private LobbyManager _steamLobbyManager; void Awake() { AddSteamLobbyManagerIfExist(); Debug.Log(\"SteamLobbyManagerDecorator.Awake\");  private void AddSteamLobbyManagerIfExist() { if (_steamLobbyManager == null) { _steamLobbyManager = FindObjectOfType<LobbyManager>();  if (_steamLobbyManager.Lobby != null) { Debug.Log($\"[SteamLobbyManagerDecorator] Lobby is ok!\"); }  ",
          "content_tokens": 141,
          "embedding": []
        },
        {
          "cs_scriptfile": "SteamLobbyManagerDecorator",
          "content": "public void InviteFriend(UserData user) { Debug.Log($\"[SteamLobbyManagerDecorator] InviteFriend: {user.Name} #{user.SteamId}; Lobby: {_steamLobbyManager.Lobby.Name}\"); _steamLobbyManager.Invite(user); } }",
          "content_tokens": 68,
          "embedding": []
        }
      ],
      "length": 702
    },
    {
      "filename": "SteamMenuManager",
      "content": "using HeathenEngineering.SteamworksIntegration; using UnityEngine; public class SteamMainMenu : MonoBehaviour { [SerializeField] private GameObjectDispatcher[] mainMenuObjects; [SerializeField] private GameObject lobbyObject; [SerializeField] private LobbyManager lobbyManager; [SerializeField] private SteamworksBehaviour steamworksBehaviour; [SerializeField] private TMProDecorator lobbyTitle; public bool IsHost { get; private set; } private void OnValidate() { AssignComponentsIfRequired(); } private void Awake() { AssignComponentsIfRequired(); HeathenEngineering.SteamworksIntegration.API.Overlay.Client.EventGameLobbyJoinRequested.AddListener(OverlayJoinButton); lobbyManager.evtEnterSuccess.AddListener(OpenLobby); lobbyManager.evtCreated.AddListener(OpenLobby); lobbyManager.evtLeave.AddListener(OpenMainMenu); } public void OnLobbyCreated(LobbyData lobbyData) { lobbyData.Name = UserData.Me.Name + \"'s Lobby\"; lobbyTitle.SetText(lobbyData.Name); OpenLobby(lobbyData); } public void OnLobbyJoined(LobbyData lobbyData) { lobbyTitle.SetText(lobbyData.Name); OpenLobby(lobbyData); } private void OverlayJoinButton(LobbyData lobbyData, UserData userData) { lobbyManager.Join(lobbyData); } private void AssignComponentsIfRequired() { lobbyManager ??= FindObjectOfType<LobbyManager>(); steamworksBehaviour ??= FindObjectOfType<SteamworksBehaviour>(); } public void OpenMainMenu() { Debug.Log(\"OpenMainMenu\"); CloseScreens(); for (int i = 0; i < mainMenuObjects.Length; i++) { mainMenuObjects[i].Activate(); } } public void ShowLobbyMenu() { lobbyObject.SetActive(true); } public void OpenLobby(LobbyData lobbyData) { Debug.Log(\"OpenLobby\"); CloseScreens(); ShowLobbyMenu(); var host = lobbyData.Owner.user; if (UserData.Me != host) { SteamConnectionManager.Instance.StartConnection(host.ToString()); IsHost = false; } else { IsHost = true; } } public void ShowScreens() { for (int i = 0; i < mainMenuObjects.Length; i++) { mainMenuObjects[i].Activate(); } lobbyObject.SetActive(true); } public void CloseScreens() { for (int i = 0; i < mainMenuObjects.Length; i++) { mainMenuObjects[i].Deactivate(); } lobbyObject.SetActive(false); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SteamMenuManager",
          "content": "using HeathenEngineering.SteamworksIntegration; using UnityEngine; public class SteamMainMenu : MonoBehaviour { [SerializeField] private GameObjectDispatcher[] mainMenuObjects; [SerializeField] private GameObject lobbyObject; [SerializeField] private LobbyManager lobbyManager; [SerializeField] private SteamworksBehaviour steamworksBehaviour; [SerializeField] private TMProDecorator lobbyTitle; public bool IsHost { get; private set;  private void OnValidate() { AssignComponentsIfRequired();  ",
          "content_tokens": 120,
          "embedding": []
        },
        {
          "cs_scriptfile": "SteamMenuManager",
          "content": "private void Awake() { AssignComponentsIfRequired(); HeathenEngineering.SteamworksIntegration.API.Overlay.Client.EventGameLobbyJoinRequested.AddListener(OverlayJoinButton); lobbyManager.evtEnterSuccess.AddListener(OpenLobby); lobbyManager.evtCreated.AddListener(OpenLobby); lobbyManager.evtLeave.AddListener(OpenMainMenu);  public void OnLobbyCreated(LobbyData lobbyData) { lobbyData.Name = UserData.Me.Name + \"'s Lobby\"; lobbyTitle.SetText(lobbyData.Name); OpenLobby(lobbyData);  public void OnLobbyJoined(LobbyData lobbyData) { lobbyTitle.SetText(lobbyData.Name); OpenLobby(lobbyData);  ",
          "content_tokens": 177,
          "embedding": []
        },
        {
          "cs_scriptfile": "SteamMenuManager",
          "content": "private void OverlayJoinButton(LobbyData lobbyData, UserData userData) { lobbyManager.Join(lobbyData);  private void AssignComponentsIfRequired() { lobbyManager ??= FindObjectOfType<LobbyManager>(); steamworksBehaviour ??= FindObjectOfType<SteamworksBehaviour>();  public void OpenMainMenu() { Debug.Log(\"OpenMainMenu\"); CloseScreens(); for (int i = 0; i < mainMenuObjects.Length; i++) { mainMenuObjects[i].Activate(); }  public void ShowLobbyMenu() { lobbyObject.SetActive(true);  ",
          "content_tokens": 139,
          "embedding": []
        },
        {
          "cs_scriptfile": "SteamMenuManager",
          "content": "public void OpenLobby(LobbyData lobbyData) { Debug.Log(\"OpenLobby\"); CloseScreens(); ShowLobbyMenu(); var host = lobbyData.Owner.user; if (UserData.Me != host) { SteamConnectionManager.Instance.StartConnection(host.ToString()); IsHost = false; } else { IsHost = true; }  public void ShowScreens() { for (int i = 0; i < mainMenuObjects.Length; i++) { mainMenuObjects[i].Activate(); } lobbyObject.SetActive(true);  public void CloseScreens() { for (int i = 0; i < mainMenuObjects.Length; i++) { mainMenuObjects[i].Deactivate(); } lobbyObject.SetActive(false); } }",
          "content_tokens": 172,
          "embedding": []
        }
      ],
      "length": 2139
    },
    {
      "filename": "SyncSkinSetting",
      "content": " using System.Collections.Generic; using Character; using FishNet.Object.Synchronizing; using FishNet.Object.Synchronizing.Internal; using FishNet.Serializing; public class SyncSkinSetting : SyncBase, ICustomSync { #region Types. /// <summary> /// Information about how the struct has changed. /// You could send the entire struct on every change /// but this is an example of how you might send individual changed /// fields. /// </summary> private struct ChangeData { internal CustomOperation Operation; internal SkinPartSetting Data; public ChangeData(CustomOperation operation, SkinPartSetting data) { Operation = operation; Data = data; } } /// <summary> /// Types of changes. This is related to ChangedData /// where you can specify what has changed. /// </summary> public enum CustomOperation : byte { Full = 0, Part = 1, Index = 2 } #endregion #region Public. /// <summary> /// Delegate signature for when Structy changes. /// </summary> /// <param name=\"op\"></param> /// <param name=\"oldItem\"></param> /// <param name=\"newItem\"></param> public delegate void CustomChanged(CustomOperation op, SkinPartSetting oldItem, SkinPartSetting newItem, bool asServer); /// <summary> /// Called when the Structy changes. /// </summary> public event CustomChanged OnChange; #endregion #region Private. /// <summary> /// Initial value when initialized. /// </summary> private SkinPartSetting _initialValue; /// <summary> /// Value this SyncType is for, which is SkinPartSetting. /// </summary> private SkinPartSetting _value = new SkinPartSetting(); /// <summary> /// Copy of value on client portion when acting as a host. /// This is not mandatory but this setup separates server values /// from client, creating a more reliable test environment when running as host. /// </summary> private SkinPartSetting _clientValue = new SkinPartSetting(); /// <summary> /// Changed data which will be sent next tick. /// </summary> private readonly List<ChangeData> _changed = new List<ChangeData>(); /// <summary> /// True if values have changed since initialization. /// The only reasonable way to reset this during a Reset call is by duplicating the original list and setting all values to it on reset. /// </summary> private bool _valuesChanged; #endregion protected override void Registered() { base.Registered(); _initialValue = _value; } // <summary> /// Adds an operation and invokes locally. /// </summary> /// <param name=\"operation\"></param> /// <param name=\"index\"></param> /// <param name=\"prev\"></param> /// <param name=\"next\"></param> private void AddOperation(CustomOperation operation, SkinPartSetting prev, SkinPartSetting next) { if (!base.IsRegistered) return; if (base.NetworkManager != null && base.Settings.WritePermission == WritePermission.ServerOnly && !base.NetworkBehaviour.IsServer) { NetworkManager.LogWarning($\"Cannot complete operation as server when server is not active.\"); return; } /* Set as changed even if cannot dirty. * Dirty is only set when there are observers, * but even if there are not observers * values must be marked as changed so when * there are observers, new values are sent. */ _valuesChanged = true; base.Dirty(); //Data can currently only be set from server, so this is always asServer. bool asServer = true; //Add to changed. ChangeData cd = new ChangeData(operation, next); _changed.Add(cd); OnChange?.Invoke(operation, prev, next, asServer); } /// <summary> /// Writes all changed values. /// </summary> /// <param name=\"writer\"></param> ///<param name=\"resetSyncTick\">True to set the next time data may sync.</param> public override void WriteDelta(PooledWriter writer, bool resetSyncTick = true) { base.WriteDelta(writer, resetSyncTick); writer.WriteInt32(_changed.Count); for (int i = 0; i < _changed.Count; i++) { ChangeData change = _changed[i]; writer.WriteByte((byte)change.Operation); //Clear does not need to write anymore data so it is not included in checks. if (change.Operation == CustomOperation.Part) { writer.WriteByte((byte)change.Data.Part); } else if (change.Operation == CustomOperation.Index) { writer.WriteByte(change.Data.Index); } } _changed.Clear(); } /// <summary> /// Writes all values if not initial values. /// </summary> /// <param name=\"writer\"></param> public override void WriteFull(PooledWriter writer) { if (!_valuesChanged) return; base.WriteHeader(writer, false); //Write one change. writer.WriteInt32(1); //Write if changed is from the server, so always use the server _value. writer.WriteByte((byte)CustomOperation.Full); //Write value. writer.Write(_value); } /// <summary> /// Sets current values. /// </summary> /// <param name=\"reader\"></param> public override void Read(PooledReader reader) { //Read is always on client side. bool asServer = false; /* When !asServer don't make changes if server is running. * This is because changes would have already been made on * the server side and doing so again would result in duplicates * and potentially overwrite data not yet sent. */ bool asClientAndHost = (!asServer && base.NetworkManager.IsServer); int changes = reader.ReadInt32(); for (int i = 0; i < changes; i++) { CustomOperation operation = (CustomOperation)reader.ReadByte(); SkinPartSetting prev = GetValue(asServer); SkinPartSetting next = default(SkinPartSetting); //Full. if (operation == CustomOperation.Full) { next = reader.Read<SkinPartSetting>(); } //Name. else if (operation == CustomOperation.Part) { next = prev; next.Part = (SkinParts)reader.ReadByte(); } //Age else if (operation == CustomOperation.Index) { next = prev; next.Index = reader.ReadByte(); } OnChange?.Invoke(operation, prev, next, asServer); } } /// <summary> /// Resets to initialized values. /// </summary> public override void Reset() { base.Reset(); _changed.Clear(); _value = _initialValue; _clientValue = _initialValue; _valuesChanged = false; } /// <summary> /// Sets name value. /// </summary> public void SetPart(SkinParts part) { SetPart(part, true, true); } private void SetPart(SkinParts part, bool asServer, bool force) { SkinPartSetting data = GetValue(asServer); bool sameValue = (!force && (part == data.Part)); if (!sameValue) { SkinPartSetting prev = data; SkinPartSetting next = data; next.Part = part; SetValue(asServer, next); if (asServer) { if (base.NetworkManager == null) _clientValue = next; AddOperation(CustomOperation.Part, prev, next); } } } /// <summary> /// Sets age value. /// </summary> public void SetIndex(byte index) { SetIndex(index, true, true); } private void SetIndex(byte index, bool asServer, bool force) { SkinPartSetting data = GetValue(asServer); bool sameValue = (!force && (index == data.Index)); if (!sameValue) { SkinPartSetting prev = data; SkinPartSetting next = data; next.Index = index; SetValue(asServer, next); if (asServer) { if (base.NetworkManager == null) _clientValue = next; AddOperation(CustomOperation.Index, prev, next); } } } /// <summary> /// Gets value depending if being called asServer or not. /// </summary> /// <param name=\"asServer\"></param> /// <returns></returns> public SkinPartSetting GetValue(bool asServer) { return (asServer) ? _value : _clientValue; } /// <summary> /// Sets value depending if being called asServer or not. /// </summary> /// <param name=\"asServer\"></param> /// <returns></returns> private void SetValue(bool asServer, SkinPartSetting data) { if (asServer) _value = data; else _clientValue = data; } /* If you intend to serialize your type * as a whole at any point in your custom * SyncObject and would like the automatic * serializers to include it then use * GetSerializedType() to return the type. * In this case, the type is MyContainer. * If you do not need a serializer generated * you may return null. */ public object GetSerializedType() => typeof(SkinPartSetting); }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SyncSkinSetting",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "SyncSkinSetting",
          "content": " using System.Collections.Generic; using Character; using FishNet.Object.Synchronizing; using FishNet.Object.Synchronizing.Internal; using FishNet.Serializing; public class SyncSkinSetting : SyncBase, ICustomSync { #region Types. /// <summary> /// Information about how the struct has changed. /// You could send the entire struct on every change /// but this is an example of how you might send individual changed /// fields. /// </summary> private struct ChangeData { internal CustomOperation Operation; internal SkinPartSetting Data; public ChangeData(CustomOperation operation, SkinPartSetting data) { Operation = operation; Data = data; } } /// <summary> /// Types of changes. This is related to ChangedData /// where you can specify what has changed. /// </summary> public enum CustomOperation : byte { Full = 0, Part = 1, Index = 2 } #endregion #region Public. /// <summary> /// Delegate signature for when Structy changes. /// </summary> /// <param name=\"op\"></param> /// <param name=\"oldItem\"></param> /// <param name=\"newItem\"></param> public delegate void CustomChanged(CustomOperation op, SkinPartSetting oldItem, SkinPartSetting newItem, bool asServer); /// <summary> /// Called when the Structy changes. /// </summary> public event CustomChanged OnChange; #endregion #region Private. /// <summary> /// Initial value when initialized. /// </summary> private SkinPartSetting _initialValue; /// <summary> /// Value this SyncType is for, which is SkinPartSetting. /// </summary> private SkinPartSetting _value = new SkinPartSetting(); /// <summary> /// Copy of value on client portion when acting as a host. /// This is not mandatory but this setup separates server values /// from client, creating a more reliable test environment when running as host. /// </summary> private SkinPartSetting _clientValue = new SkinPartSetting(); /// <summary> /// Changed data which will be sent next tick. /// </summary> private readonly List<ChangeData> _changed = new List<ChangeData>(); /// <summary> /// True if values have changed since initialization. /// The only reasonable way to reset this during a Reset call is by duplicating the original list and setting all values to it on reset. /// </summary> private bool _valuesChanged; #endregion protected override void Registered() { base.Registered(); _initialValue = _value; } // <summary> /// Adds an operation and invokes locally. /// </summary> /// <param name=\"operation\"></param> /// <param name=\"index\"></param> /// <param name=\"prev\"></param> /// <param name=\"next\"></param> private void AddOperation(CustomOperation operation, SkinPartSetting prev, SkinPartSetting next) { if (!base.IsRegistered) return; if (base.NetworkManager != null && base.Settings.WritePermission == WritePermission.ServerOnly && !base.NetworkBehaviour.IsServer) { NetworkManager.LogWarning($\"Cannot complete operation as server when server is not active.\"); return; } /* Set as changed even if cannot dirty. * Dirty is only set when there are observers, * but even if there are not observers * values must be marked as changed so when * there are observers, new values are sent. */ _valuesChanged = true; base.Dirty(); //Data can currently only be set from server, so this is always asServer. bool asServer = true; //Add to changed. ChangeData cd = new ChangeData(operation, next); _changed.Add(cd); OnChange?.Invoke(operation, prev, next, asServer); } /// <summary> /// Writes all changed values. /// </summary> /// <param name=\"writer\"></param> ///<param name=\"resetSyncTick\">True to set the next time data may sync.</param> public override void WriteDelta(PooledWriter writer, bool resetSyncTick = true) { base.WriteDelta(writer, resetSyncTick); writer.WriteInt32(_changed.Count); for (int i = 0; i < _changed.Count; i++) { ChangeData change = _changed[i]; writer.WriteByte((byte)change.Operation); //Clear does not need to write anymore data so it is not included in checks. if (change.Operation == CustomOperation.Part) { writer.WriteByte((byte)change.Data.Part); } else if (change.Operation == CustomOperation.Index) { writer.WriteByte(change.Data.Index); } } _changed.Clear(); } /// <summary> /// Writes all values if not initial values. /// </summary> /// <param name=\"writer\"></param> public override void WriteFull(PooledWriter writer) { if (!_valuesChanged) return; base.WriteHeader(writer, false); //Write one change. writer.WriteInt32(1); //Write if changed is from the server, so always use the server _value. writer.WriteByte((byte)CustomOperation.Full); //Write value. writer.Write(_value); } /// <summary> /// Sets current values. /// </summary> /// <param name=\"reader\"></param> public override void Read(PooledReader reader) { //Read is always on client side. bool asServer = false; /* When !asServer don't make changes if server is running. * This is because changes would have already been made on * the server side and doing so again would result in duplicates * and potentially overwrite data not yet sent. */ bool asClientAndHost = (!asServer && base.NetworkManager.IsServer); int changes = reader.ReadInt32(); for (int i = 0; i < changes; i++) { CustomOperation operation = (CustomOperation)reader.ReadByte(); SkinPartSetting prev = GetValue(asServer); SkinPartSetting next = default(SkinPartSetting); //Full. if (operation == CustomOperation.Full) { next = reader.Read<SkinPartSetting>(); } //Name. else if (operation == CustomOperation.Part) { next = prev; next.Part = (SkinParts)reader.ReadByte(); } //Age else if (operation == CustomOperation.Index) { next = prev; next.Index = reader.ReadByte(); } OnChange?.Invoke(operation, prev, next, asServer); } } /// <summary> /// Resets to initialized values. /// </summary> public override void Reset() { base.Reset(); _changed.Clear(); _value = _initialValue; _clientValue = _initialValue; _valuesChanged = false; } /// <summary> /// Sets name value. /// </summary> public void SetPart(SkinParts part) { SetPart(part, true, true);  ",
          "content_tokens": 1452,
          "embedding": []
        },
        {
          "cs_scriptfile": "SyncSkinSetting",
          "content": "private void SetPart(SkinParts part, bool asServer, bool force) { SkinPartSetting data = GetValue(asServer); bool sameValue = (!force && (part == data.Part)); if (!sameValue) { SkinPartSetting prev = data; SkinPartSetting next = data; next.Part = part; SetValue(asServer, next); if (asServer) { if (base.NetworkManager == null) _clientValue = next; AddOperation(CustomOperation.Part, prev, next); } } } /// <summary> /// Sets age value. /// </summary> public void SetIndex(byte index) { SetIndex(index, true, true);  ",
          "content_tokens": 145,
          "embedding": []
        },
        {
          "cs_scriptfile": "SyncSkinSetting",
          "content": "private void SetIndex(byte index, bool asServer, bool force) { SkinPartSetting data = GetValue(asServer); bool sameValue = (!force && (index == data.Index)); if (!sameValue) { SkinPartSetting prev = data; SkinPartSetting next = data; next.Index = index; SetValue(asServer, next); if (asServer) { if (base.NetworkManager == null) _clientValue = next; AddOperation(CustomOperation.Index, prev, next); } } } /// <summary> /// Gets value depending if being called asServer or not. /// </summary> /// <param name=\"asServer\"></param> /// <returns></returns> public SkinPartSetting GetValue(bool asServer) { return (asServer) ? _value : _clientValue; } /// <summary> /// Sets value depending if being called asServer or not. /// </summary> /// <param name=\"asServer\"></param> /// <returns></returns> private void SetValue(bool asServer, SkinPartSetting data) { if (asServer) _value = data; else _clientValue = data; } /* If you intend to serialize your type * as a whole at any point in your custom * SyncObject and would like the automatic * serializers to include it then use * GetSerializedType() to return the type. * In this case, the type is MyContainer. * If you do not need a serializer generated * you may return null. */ public object GetSerializedType() => typeof(SkinPartSetting); }",
          "content_tokens": 336,
          "embedding": []
        }
      ],
      "length": 7746
    },
    {
      "filename": "TeamUIController",
      "content": " using System; using System.Collections; using System.Collections.Generic; using System.Linq; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Clients; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using FishnetInvector; using TMPro; using UnityEngine; namespace _ZombieRoyale.Scripts.Clients { public class TeamUIController: NetworkBehaviour { [SerializeField] private AllyBar _prefab; [SerializeField] private FishnetInvectorManager _player; [SerializeField] private Transform _allyBarsParent; [SerializeField] private GameObject playerNameCanvas; [SerializeField] private TextMeshProUGUI playerNameText; public static TeamUIController LocalPlayer { get; private set; } private Dictionary<int, AllyBar> _allyBars = new (); public SyncDictionary<NetworkConnection, HPData> AllyHPs => _allyHPs; [SyncObject(ReadPermissions = ReadPermission.OwnerOnly)] private readonly SyncDictionary<NetworkConnection, HPData> _allyHPs = new (); [Serializable] public class HPData { public int clientId; public float current; public float max; public HPData() { } public HPData(int m_clientId, float m_current, float m_max) { clientId = m_clientId; current = m_current; max = m_max; } } private bool _isDebug = true; private bool _isFirstAllocation = true; protected override void OnValidate() { base.OnValidate(); _player ??= GetComponent<FishnetInvectorManager>(); } private void Awake() { _allyHPs.OnChange += _allyHPs_OnChange; } public override void OnStartNetwork() { base.OnStartNetwork(); if (Owner.IsLocalClient) { LocalPlayer = this; } } public override void OnStartServer() { base.OnStartServer(); if (!GameplayManager.Instance.RoomDetails.IsTeamsMode) return; GameplayManager.Instance.RoomDetails.OnRoomDetailsUpdated += RoomDetailsUpdated; List<NetworkConnection> otherMembers = GameplayManager.Instance.RoomDetails.GetActiveClientsFromSameTeamExcludingMe(ClientInstance.ClientInstances[Owner].NetworkObject); // List<NetworkConnection> allTeamMembers = GameplayManager.Instance.RoomDetails.GetActiveClientsFromSameTeam(ClientInstance.ClientInstances[Owner].NetworkObject); // foreach (NetworkConnection conn in allTeamMembers) // { // // if (conn == NetworkObject.Owner) // // continue; // // ClientInstance clientInstance = ClientInstance.GetClientInstance(conn); // StartCoroutine(DelayedUpdateAllyBar(clientInstance)); // } if (otherMembers.Count > 0) { UpdateAllyBars(otherMembers); } } public override void OnStartClient() { base.OnStartClient(); if (!IsOwner) { StartCoroutine(DelayedCheckNameI()); } } private IEnumerator DelayedCheckNameI() { yield return new WaitForSeconds(5f); if (IsLocalPlayersAllyToOwnerOfThisUnit()) { ShowThisNameUI(); } } public void HideThisNameUI() { playerNameCanvas.SetActive(false); } private void ShowThisNameUI() { playerNameCanvas.SetActive(true); ClientInstance clientInstance = ClientInstance.GetClientInstance(Owner); PlayerSettings playerSettings = clientInstance.PlayerSettings; //allyBar.Init(conn.ClientId, playerSettings.PlayerName); playerNameText.text = playerSettings.PlayerName; // int characterId = clientInstance.PlayerSettings.CharacterSkinData.Id; // try // { // BackendReadWrites.GetPlayerNameBasedOnCharacterId(characterId, playerName => // { // playerNameText.text = playerName; // }); // }catch(Exception e) // { // Debug.LogError($\"[TeamUIController] ShowThisNameUI for client #{Owner.ClientId} {e.Message}\", gameObject); // } } private bool IsLocalPlayersAllyToOwnerOfThisUnit() { var roomDetails = GameplayManager.Instance.RoomDetails; var localPlayerOtherAllies = roomDetails.GetActiveClientsFromSameTeamExcludingMe(ClientInstance.LocalPlayer.NetworkObject); return localPlayerOtherAllies.Contains(ClientInstance.ClientInstances[Owner].Owner); } private void RoomDetailsUpdated(RoomDetails.WhichField obj) { if (obj == RoomDetails.WhichField.ETeams) { List<NetworkConnection> newAlliesToAdd; if (MyTeamInformationWasUpdated(out newAlliesToAdd)) { foreach (var newAlly in newAlliesToAdd) { if (IsPlayerHeroAlreadyInAllyHPs(newAlly)) { continue; } ClientInstance clientInstance = ClientInstance.GetClientInstance(newAlly); StartCoroutine(DelayedUpdateAllyBar(clientInstance)); } } } } /// <summary> /// this method checks if the local player's team information has been updated. /// This function should return true if the player's team has changed, or new members were added, etc. /// </summary> /// <returns></returns> private bool MyTeamInformationWasUpdated(out List<NetworkConnection> newAlliesToAdd) { var roomDetails = GameplayManager.Instance.RoomDetails; var otherAllies = roomDetails.GetActiveClientsFromSameTeamExcludingMe(ClientInstance.ClientInstances[Owner].NetworkObject); newAlliesToAdd = new List<NetworkConnection>(); foreach (var allyConn in otherAllies) { if (IsPlayerHeroAlreadyInAllyHPs(allyConn)) { continue; } newAlliesToAdd.Add(allyConn); } if (newAlliesToAdd.Count == 0) { return false; } return true; } private bool IsPlayerHeroAlreadyInAllyHPs(NetworkConnection conn) { return _allyHPs.ContainsKey(conn); } private void OnDisable() { _allyHPs.OnChange -= _allyHPs_OnChange; } private void _allyHPs_OnChange(SyncDictionaryOperation op, NetworkConnection conn, HPData hpData, bool asServer) { bool IsObserver = !(IsOwner || asServer); if (asServer || IsObserver) { return; } StringBuilder sb = new StringBuilder($\"[TeamUIController] _allyHPs_OnChange {op} on {gameObject.name}; target id: #{conn} \"); switch (op) { case SyncDictionaryOperation.Add: sb.Append(\"Add \"); OwnerUpdateOrAllocateAllyBar(conn, hpData.current, hpData.max); break; case SyncDictionaryOperation.Remove: sb.Append(\"Remove \"); OwnerDeallocateAllyBar(conn.ClientId); break; case SyncDictionaryOperation.Set: sb.Append(\"Set \"); OwnerUpdateOrAllocateAllyBar(conn, hpData.current, hpData.max); break; case SyncDictionaryOperation.Clear: sb.Append(\"Clear dictionary!\"); break; //Like SyncList, indicates all operations are complete. case SyncDictionaryOperation.Complete: return; } sb.Append($\"[{ hpData.current }/{hpData.max}]\"); Debug.Log(sb.ToString()); } [Client] private void OwnerUpdateOrAllocateAllyBar(NetworkConnection conn, float currentHP, float maxHP) { Debug.Log($\"[TeamUIController] OwnerUpdateOrAllocateAllyBar for #{conn}\", gameObject); int clientID = conn.ClientId; if (_allyBars.ContainsKey(clientID)) { AllyBar allyBar = _allyBars[clientID]; allyBar.UpdateHP(FishnetInvectorHealthController.HealthType.Current, currentHP); allyBar.UpdateHP(FishnetInvectorHealthController.HealthType.Max, maxHP); } else { OwnerAllocateAllyBar(conn, currentHP, maxHP); } } [Client] private void OwnerAllocateAllyBar(NetworkConnection conn, float currentHP, float maxHP) { Debug.Log($\"[TeamUIController] AllocateNewAlly for #{conn.ClientId}\", gameObject); AllyBar allyBar = Instantiate(_prefab, _allyBarsParent); _allyBars.Add(conn.ClientId, allyBar); ClientInstance clientInstance = ClientInstance.GetClientInstance(conn); PlayerSettings playerSettings = clientInstance.PlayerSettings; allyBar.Init(conn.ClientId, playerSettings.PlayerName); // int characterId = clientInstance.PlayerSettings.CharacterSkinData.Id; // try // { // BackendReadWrites.GetPlayerNameBasedOnCharacterId(characterId, playerName => // { // allyBar.Init(conn.ClientId, playerName); // }); // }catch(Exception e) // { // Debug.LogError($\"[TeamUIController] AllocateNewAlly for client #{conn.ClientId} {e.Message}\", gameObject); // } allyBar.UpdateHP( FishnetInvectorHealthController.HealthType.Max, maxHP); allyBar.UpdateHP( FishnetInvectorHealthController.HealthType.Current, currentHP); } [Client] private void OwnerDeallocateAllyBar(int clientId) { DebugWrite.Log($\"[TeamUIController] DeallocateAllyBar for #{clientId}\", gameObject, _isDebug); if (_allyBars.ContainsKey(clientId)) { AllyBar allyBar = _allyBars[clientId]; _allyBars.Remove(clientId); Destroy(allyBar.gameObject); } else { DebugWrite.LogError($\"[TeamUIController] DeallocateAllyBar for {clientId} not found\", gameObject, _isDebug); } } /// <summary> /// Called only when players Spawned and is adding to teams and works only when dict dont have that ally hero id /// </summary> /// <param name=\"allCurrentAllies\">Owners of ally heroes</param> [Server] public void UpdateAllyBars(List<NetworkConnection> allCurrentAllies) { Debug.Log($\"[TeamUIController] UpdateAllyBars {allCurrentAllies.Count}\", gameObject); List<NetworkConnection> missingAllies = new List<NetworkConnection>(allCurrentAllies); ClearExcessData(allCurrentAllies, missingAllies); AddAllyHpToListening(missingAllies); } [Server] private void ClearExcessData(List<NetworkConnection> allCurrentAllies, List<NetworkConnection> missingAllies) { foreach (var kv in _allyBars) { bool isFound = false; int currentAllyObjectId = kv.Key; foreach (var allyConn in allCurrentAllies) { var allyUnit = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(allyConn); NetworkObject allyNob = allyUnit.HealthController.NetworkObject; if (currentAllyObjectId == allyNob.ObjectId) { missingAllies.Remove(allyConn); isFound = true; } } if (!isFound) { _allyBars.Remove(currentAllyObjectId); UnitComponents leftPlayerHero = GameplayManager.Instance.GetUnitComponentsServerAndClient(currentAllyObjectId); if (leftPlayerHero != null) { leftPlayerHero.HealthController.OnHealthChanged -= AllyHealthController_OnHealthChanged; } } } } [Server] private void AddAllyHpToListening(List<NetworkConnection> missingAllies) { foreach (var ally in missingAllies) { ClientInstance clientInstance = ClientInstance.GetClientInstance(ally); StartCoroutine(DelayedUpdateAllyBar(clientInstance)); } } private IEnumerator DelayedUpdateAllyBar(ClientInstance clientInstance) { var time = new WaitForSeconds(1f); while (clientInstance.PlayerHero == null) { yield return time; } var allyHealthController = clientInstance.PlayerHero.HealthController; HPData hpData = new HPData(clientInstance.Owner.ClientId, allyHealthController.CurrentHealth, allyHealthController.MaxHealth); _allyHPs[clientInstance.Owner] = hpData; Debug.Log($\"[TeamUIController] AddAllyHpToWatch objectId #{clientInstance.Owner.ClientId} {allyHealthController.CurrentHealth}/{allyHealthController.MaxHealth}\", gameObject); allyHealthController.OnHealthChanged += AllyHealthController_OnHealthChanged; } [Server] private void AllyHealthController_OnHealthChanged(FishnetInvectorHealthController unitHealth, FishnetInvectorHealthController.HealthType type, float newAmount) { //Get callback calling class if(unitHealth.IsDead) unitHealth.gameObject.GetComponent<TeamUIController>().HideThisNameUI(); Debug.Log($\"[TeamUIController] AllyHealthController_OnHealthChanged {unitHealth.gameObject.name} {type} {newAmount}\", gameObject); var ownerConn = unitHealth.NetworkObject.Owner; HPData oldData = _allyHPs[ownerConn]; if (type == FishnetInvectorHealthController.HealthType.Current) { oldData.current = newAmount; } if (type == FishnetInvectorHealthController.HealthType.Max) { oldData.max = newAmount; } _allyHPs[ownerConn] = oldData; _allyHPs.Dirty(ownerConn); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "TeamUIController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeamUIController",
          "content": " using System; using System.Collections; using System.Collections.Generic; using System.Linq; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Clients; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using FishnetInvector; using TMPro; using UnityEngine; namespace _ZombieRoyale.Scripts.Clients { public class TeamUIController: NetworkBehaviour { [SerializeField] private AllyBar _prefab; [SerializeField] private FishnetInvectorManager _player; [SerializeField] private Transform _allyBarsParent; [SerializeField] private GameObject playerNameCanvas; [SerializeField] private TextMeshProUGUI playerNameText; public static TeamUIController LocalPlayer { get; private set; } private Dictionary<int, AllyBar> _allyBars = new (); public SyncDictionary<NetworkConnection, HPData> AllyHPs => _allyHPs; [SyncObject(ReadPermissions = ReadPermission.OwnerOnly)] private readonly SyncDictionary<NetworkConnection, HPData> _allyHPs = new (); [Serializable] public class HPData { public int clientId; public float current; public float max; public HPData() {  ",
          "content_tokens": 344,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeamUIController",
          "content": "public HPData(int m_clientId, float m_current, float m_max) { clientId = m_clientId; current = m_current; max = m_max; } } private bool _isDebug = true; private bool _isFirstAllocation = true; protected override void OnValidate() { base.OnValidate(); _player ??= GetComponent<FishnetInvectorManager>();  ",
          "content_tokens": 92,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeamUIController",
          "content": "private void Awake() { _allyHPs.OnChange += _allyHPs_OnChange; } public override void OnStartNetwork() { base.OnStartNetwork(); if (Owner.IsLocalClient) { LocalPlayer = this; } } public override void OnStartServer() { base.OnStartServer(); if (!GameplayManager.Instance.RoomDetails.IsTeamsMode) return; GameplayManager.Instance.RoomDetails.OnRoomDetailsUpdated += RoomDetailsUpdated; List<NetworkConnection> otherMembers = GameplayManager.Instance.RoomDetails.GetActiveClientsFromSameTeamExcludingMe(ClientInstance.ClientInstances[Owner].NetworkObject); // List<NetworkConnection> allTeamMembers = GameplayManager.Instance.RoomDetails.GetActiveClientsFromSameTeam(ClientInstance.ClientInstances[Owner].NetworkObject); // foreach (NetworkConnection conn in allTeamMembers) // { // // if (conn == NetworkObject.Owner) // // continue; // // ClientInstance clientInstance = ClientInstance.GetClientInstance(conn); // StartCoroutine(DelayedUpdateAllyBar(clientInstance)); //  ",
          "content_tokens": 244,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeamUIController",
          "content": "if (otherMembers.Count > 0) { UpdateAllyBars(otherMembers); } } public override void OnStartClient() { base.OnStartClient(); if (!IsOwner) { StartCoroutine(DelayedCheckNameI()); } } private IEnumerator DelayedCheckNameI() { yield return new WaitForSeconds(5f); if (IsLocalPlayersAllyToOwnerOfThisUnit()) { ShowThisNameUI(); }  public void HideThisNameUI() { playerNameCanvas.SetActive(false);  ",
          "content_tokens": 117,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeamUIController",
          "content": "private void ShowThisNameUI() { playerNameCanvas.SetActive(true); ClientInstance clientInstance = ClientInstance.GetClientInstance(Owner); PlayerSettings playerSettings = clientInstance.PlayerSettings; //allyBar.Init(conn.ClientId, playerSettings.PlayerName); playerNameText.text = playerSettings.PlayerName; // int characterId = clientInstance.PlayerSettings.CharacterSkinData.Id; // try // { // BackendReadWrites.GetPlayerNameBasedOnCharacterId(characterId, playerName => // { // playerNameText.text = playerName; // }); //  catch(Exception e) // { // Debug.LogError($\"[TeamUIController] ShowThisNameUI for client #{Owner.ClientId} {e.Message}\", gameObject); // }  ",
          "content_tokens": 176,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeamUIController",
          "content": "private bool IsLocalPlayersAllyToOwnerOfThisUnit() { var roomDetails = GameplayManager.Instance.RoomDetails; var localPlayerOtherAllies = roomDetails.GetActiveClientsFromSameTeamExcludingMe(ClientInstance.LocalPlayer.NetworkObject); return localPlayerOtherAllies.Contains(ClientInstance.ClientInstances[Owner].Owner);  ",
          "content_tokens": 80,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeamUIController",
          "content": "private void RoomDetailsUpdated(RoomDetails.WhichField obj) { if (obj == RoomDetails.WhichField.ETeams) { List<NetworkConnection> newAlliesToAdd; if (MyTeamInformationWasUpdated(out newAlliesToAdd)) { foreach (var newAlly in newAlliesToAdd) { if (IsPlayerHeroAlreadyInAllyHPs(newAlly)) { continue; } ClientInstance clientInstance = ClientInstance.GetClientInstance(newAlly); StartCoroutine(DelayedUpdateAllyBar(clientInstance)); } } } } /// <summary> /// this method checks if the local player's team information has been updated. /// This function should return true if the player's team has changed, or new members were added, etc. /// </summary> /// <returns></returns> private bool MyTeamInformationWasUpdated(out List<NetworkConnection> newAlliesToAdd) { var roomDetails = GameplayManager.Instance.RoomDetails; var otherAllies = roomDetails.GetActiveClientsFromSameTeamExcludingMe(ClientInstance.ClientInstances[Owner].NetworkObject); newAlliesToAdd = new List<NetworkConnection>(); foreach (var allyConn in otherAllies) { if (IsPlayerHeroAlreadyInAllyHPs(allyConn)) { continue; } newAlliesToAdd.Add(allyConn);  ",
          "content_tokens": 300,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeamUIController",
          "content": "if (newAlliesToAdd.Count == 0) { return false; } return true;  private bool IsPlayerHeroAlreadyInAllyHPs(NetworkConnection conn) { return _allyHPs.ContainsKey(conn);  private void OnDisable() { _allyHPs.OnChange -= _allyHPs_OnChange;  ",
          "content_tokens": 75,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeamUIController",
          "content": "private void _allyHPs_OnChange(SyncDictionaryOperation op, NetworkConnection conn, HPData hpData, bool asServer) { bool IsObserver = !(IsOwner || asServer); if (asServer || IsObserver) { return; } StringBuilder sb = new StringBuilder($\"[TeamUIController] _allyHPs_OnChange {op} on {gameObject.name}; target id: #{conn} \"); switch (op) { case SyncDictionaryOperation.Add: sb.Append(\"Add \"); OwnerUpdateOrAllocateAllyBar(conn, hpData.current, hpData.max); break; case SyncDictionaryOperation.Remove: sb.Append(\"Remove \"); OwnerDeallocateAllyBar(conn.ClientId); break; case SyncDictionaryOperation.Set: sb.Append(\"Set \"); OwnerUpdateOrAllocateAllyBar(conn, hpData.current, hpData.max); break; case SyncDictionaryOperation.Clear: sb.Append(\"Clear dictionary!\"); break; //Like SyncList, indicates all operations are complete. case SyncDictionaryOperation.Complete: return; } sb.Append($\"[{ hpData.current }/{hpData.max}]\"); Debug.Log(sb.ToString()); } [Client] private void OwnerUpdateOrAllocateAllyBar(NetworkConnection conn, float currentHP, float maxHP) { Debug.Log($\"[TeamUIController] OwnerUpdateOrAllocateAllyBar for #{conn}\", gameObject); int clientID = conn.ClientId; if (_allyBars.ContainsKey(clientID)) { AllyBar allyBar = _allyBars[clientID]; allyBar.UpdateHP(FishnetInvectorHealthController.HealthType.Current, currentHP); allyBar.UpdateHP(FishnetInvectorHealthController.HealthType.Max, maxHP); } else { OwnerAllocateAllyBar(conn, currentHP, maxHP); } } [Client] private void OwnerAllocateAllyBar(NetworkConnection conn, float currentHP, float maxHP) { Debug.Log($\"[TeamUIController] AllocateNewAlly for #{conn.ClientId}\", gameObject); AllyBar allyBar = Instantiate(_prefab, _allyBarsParent); _allyBars.Add(conn.ClientId, allyBar); ClientInstance clientInstance = ClientInstance.GetClientInstance(conn); PlayerSettings playerSettings = clientInstance.PlayerSettings; allyBar.Init(conn.ClientId, playerSettings.PlayerName); // int characterId = clientInstance.PlayerSettings.CharacterSkinData.Id; // try // { // BackendReadWrites.GetPlayerNameBasedOnCharacterId(characterId, playerName => // { // allyBar.Init(conn.ClientId, playerName); // }); //  ",
          "content_tokens": 632,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeamUIController",
          "content": "catch(Exception e) // { // Debug.LogError($\"[TeamUIController] AllocateNewAlly for client #{conn.ClientId} {e.Message}\", gameObject); // } allyBar.UpdateHP( FishnetInvectorHealthController.HealthType.Max, maxHP); allyBar.UpdateHP( FishnetInvectorHealthController.HealthType.Current, currentHP); } [Client] private void OwnerDeallocateAllyBar(int clientId) { DebugWrite.Log($\"[TeamUIController] DeallocateAllyBar for #{clientId}\", gameObject, _isDebug); if (_allyBars.ContainsKey(clientId)) { AllyBar allyBar = _allyBars[clientId]; _allyBars.Remove(clientId); Destroy(allyBar.gameObject); } else { DebugWrite.LogError($\"[TeamUIController] DeallocateAllyBar for {clientId} not found\", gameObject, _isDebug); } } /// <summary> /// Called only when players Spawned and is adding to teams and works only when dict dont have that ally hero id /// </summary> /// <param name=\"allCurrentAllies\">Owners of ally heroes</param> [Server] public void UpdateAllyBars(List<NetworkConnection> allCurrentAllies) { Debug.Log($\"[TeamUIController] UpdateAllyBars {allCurrentAllies.Count}\", gameObject); List<NetworkConnection> missingAllies = new List<NetworkConnection>(allCurrentAllies); ClearExcessData(allCurrentAllies, missingAllies); AddAllyHpToListening(missingAllies); } [Server] private void ClearExcessData(List<NetworkConnection> allCurrentAllies, List<NetworkConnection> missingAllies) { foreach (var kv in _allyBars) { bool isFound = false; int currentAllyObjectId = kv.Key; foreach (var allyConn in allCurrentAllies) { var allyUnit = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(allyConn); NetworkObject allyNob = allyUnit.HealthController.NetworkObject; if (currentAllyObjectId == allyNob.ObjectId) { missingAllies.Remove(allyConn); isFound = true; }  ",
          "content_tokens": 511,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeamUIController",
          "content": "if (!isFound) { _allyBars.Remove(currentAllyObjectId); UnitComponents leftPlayerHero = GameplayManager.Instance.GetUnitComponentsServerAndClient(currentAllyObjectId); if (leftPlayerHero != null) { leftPlayerHero.HealthController.OnHealthChanged -= AllyHealthController_OnHealthChanged; } } } } [Server] private void AddAllyHpToListening(List<NetworkConnection> missingAllies) { foreach (var ally in missingAllies) { ClientInstance clientInstance = ClientInstance.GetClientInstance(ally); StartCoroutine(DelayedUpdateAllyBar(clientInstance)); } } private IEnumerator DelayedUpdateAllyBar(ClientInstance clientInstance) { var time = new WaitForSeconds(1f); while (clientInstance.PlayerHero == null) { yield return time; } var allyHealthController = clientInstance.PlayerHero.HealthController; HPData hpData = new HPData(clientInstance.Owner.ClientId, allyHealthController.CurrentHealth, allyHealthController.MaxHealth); _allyHPs[clientInstance.Owner] = hpData; Debug.Log($\"[TeamUIController] AddAllyHpToWatch objectId #{clientInstance.Owner.ClientId} {allyHealthController.CurrentHealth}/{allyHealthController.MaxHealth}\", gameObject); allyHealthController.OnHealthChanged += AllyHealthController_OnHealthChanged; } [Server] private void AllyHealthController_OnHealthChanged(FishnetInvectorHealthController unitHealth, FishnetInvectorHealthController.HealthType type, float newAmount) { //Get callback calling class if(unitHealth.IsDead) unitHealth.gameObject.GetComponent<TeamUIController>().HideThisNameUI(); Debug.Log($\"[TeamUIController] AllyHealthController_OnHealthChanged {unitHealth.gameObject.name} {type} {newAmount}\", gameObject); var ownerConn = unitHealth.NetworkObject.Owner; HPData oldData = _allyHPs[ownerConn]; if (type == FishnetInvectorHealthController.HealthType.Current) { oldData.current = newAmount;  ",
          "content_tokens": 481,
          "embedding": []
        },
        {
          "cs_scriptfile": "TeamUIController",
          "content": "if (type == FishnetInvectorHealthController.HealthType.Max) { oldData.max = newAmount; } _allyHPs[ownerConn] = oldData; _allyHPs.Dirty(ownerConn); } } }",
          "content_tokens": 52,
          "embedding": []
        }
      ],
      "length": 11190
    },
    {
      "filename": "TipsMenu",
      "content": "using DungeonScrollerCore; using FishNet.Object; using FishnetInvector; using Invector.vCharacterController; using UnityEngine; public class TipsMenu : MonoBehaviour { [SerializeField] private GenericInput _showHideTips = new GenericInput(\"U\", \"B\", \"U\"); [SerializeField] private FishnetInvectorManager _fishnetInvectorManager; [SerializeField] private GameObject[] tipLines; private UICanvasGroupDecorator _tipsCanvasGroupDecorator; private FNvThirdPersonInput _thirdPersonInput; private bool _isDebug = true; private void Awake() { _tipsCanvasGroupDecorator = GetComponent<UICanvasGroupDecorator>(); _thirdPersonInput = _fishnetInvectorManager.GetComponent<FNvThirdPersonInput>(); _fishnetInvectorManager.OnObservingPlayerInitialized += FishnetInvectorManager_onObservingPlayerInitialized; FishnetInvectorManager.OnLocalPlayerInitialized += FishnetInvectorManager_onLocalPlayerInitialized; } private void OnDisable() { _fishnetInvectorManager.OnObservingPlayerInitialized -= FishnetInvectorManager_onObservingPlayerInitialized; FishnetInvectorManager.OnLocalPlayerInitialized -= FishnetInvectorManager_onLocalPlayerInitialized; } private void Update() { if (_fishnetInvectorManager.IsOwner) { ShowHideTipsMenuListener(); } } [Client] private void ShowHideTipsMenuListener() { if (_showHideTips.GetButtonUp() && (GameStateController.CurrentState == GameStateController.GameState.Default)) { SwitchMenu(); } } private void FishnetInvectorManager_onLocalPlayerInitialized() { DebugWrite.Log($\"[TipsMenu] FishnetInvectorManager_onLocalPlayerInitialized: {_fishnetInvectorManager}\", gameObject, _isDebug); _tipsCanvasGroupDecorator.Show(true); } private void FishnetInvectorManager_onObservingPlayerInitialized() { DebugWrite.Log($\"[TipsMenu] FishnetInvectorManager_onObservingPlayerInitialized: {_fishnetInvectorManager}\", gameObject, _isDebug); gameObject.SetActive(false); } public void SwitchMenu() { DebugWrite.Log($\"[TipsMenu][SwitchMenu] {_fishnetInvectorManager}\", gameObject, _isDebug); bool isActive = tipLines[0].activeSelf; for (int i = 0; i < tipLines.Length; i++) { tipLines[i].SetActive(!isActive); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "TipsMenu",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "TipsMenu",
          "content": "using DungeonScrollerCore; using FishNet.Object; using FishnetInvector; using Invector.vCharacterController; using UnityEngine; public class TipsMenu : MonoBehaviour { [SerializeField] private GenericInput _showHideTips = new GenericInput(\"U\", \"B\", \"U\"); [SerializeField] private FishnetInvectorManager _fishnetInvectorManager; [SerializeField] private GameObject[] tipLines; private UICanvasGroupDecorator _tipsCanvasGroupDecorator; private FNvThirdPersonInput _thirdPersonInput; private bool _isDebug = true; private void Awake() { _tipsCanvasGroupDecorator = GetComponent<UICanvasGroupDecorator>(); _thirdPersonInput = _fishnetInvectorManager.GetComponent<FNvThirdPersonInput>(); _fishnetInvectorManager.OnObservingPlayerInitialized += FishnetInvectorManager_onObservingPlayerInitialized; FishnetInvectorManager.OnLocalPlayerInitialized += FishnetInvectorManager_onLocalPlayerInitialized;  ",
          "content_tokens": 231,
          "embedding": []
        },
        {
          "cs_scriptfile": "TipsMenu",
          "content": "private void OnDisable() { _fishnetInvectorManager.OnObservingPlayerInitialized -= FishnetInvectorManager_onObservingPlayerInitialized; FishnetInvectorManager.OnLocalPlayerInitialized -= FishnetInvectorManager_onLocalPlayerInitialized;  private void Update() { if (_fishnetInvectorManager.IsOwner) { ShowHideTipsMenuListener(); } } [Client] private void ShowHideTipsMenuListener() { if (_showHideTips.GetButtonUp() && (GameStateController.CurrentState == GameStateController.GameState.Default)) { SwitchMenu(); }  private void FishnetInvectorManager_onLocalPlayerInitialized() { DebugWrite.Log($\"[TipsMenu] FishnetInvectorManager_onLocalPlayerInitialized: {_fishnetInvectorManager}\", gameObject, _isDebug); _tipsCanvasGroupDecorator.Show(true);  ",
          "content_tokens": 190,
          "embedding": []
        },
        {
          "cs_scriptfile": "TipsMenu",
          "content": "private void FishnetInvectorManager_onObservingPlayerInitialized() { DebugWrite.Log($\"[TipsMenu] FishnetInvectorManager_onObservingPlayerInitialized: {_fishnetInvectorManager}\", gameObject, _isDebug); gameObject.SetActive(false);  public void SwitchMenu() { DebugWrite.Log($\"[TipsMenu][SwitchMenu] {_fishnetInvectorManager}\", gameObject, _isDebug); bool isActive = tipLines[0].activeSelf; for (int i = 0; i < tipLines.Length; i++) { tipLines[i].SetActive(!isActive); } } }",
          "content_tokens": 142,
          "embedding": []
        }
      ],
      "length": 2116
    },
    {
      "filename": "UIGameTimer",
      "content": "using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; public class UIGameTimer : MonoBehaviour { [SerializeField] private TMProDecorator timerText; private void OnValidate() { timerText ??= GetComponent<TMProDecorator>(); } private void Start() { GameplayManagerBossBattle.GetInstance.SurvivalGameTimer.OnTimeChanged += UpdateTimer; } private void UpdateTimer(float obj) { if (obj < float.Epsilon) { timerText.Hide(); } else { timerText.Show(); } timerText.SetText(obj.ToString(\"F2\")); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "UIGameTimer",
          "content": "using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; public class UIGameTimer : MonoBehaviour { [SerializeField] private TMProDecorator timerText; private void OnValidate() { timerText ??= GetComponent<TMProDecorator>(); } private void Start() { GameplayManagerBossBattle.GetInstance.SurvivalGameTimer.OnTimeChanged += UpdateTimer; } private void UpdateTimer(float obj) { if (obj < float.Epsilon) { timerText.Hide(); } else { timerText.Show(); } timerText.SetText(obj.ToString(\"F2\")); } }",
          "content_tokens": 147,
          "embedding": []
        }
      ],
      "length": 511
    },
    {
      "filename": "UIRoomCollapsingTimer",
      "content": "using System; using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using UnityEngine; public class UIRoomCollapsingTimer : MonoBehaviour { [SerializeField] private TMProDecorator _timerText; [SerializeField] private GameObject[] timerObjects; private Dictionary<RoomCollapsingTimer, Coroutine> _timers = new(); private Color _defaultColor; [SerializeField] private Color endingSoonColor = Color.red; private void Awake() { _defaultColor = _timerText.GetFontColor(); HideTimer(); } private void OnEnable() { RoomCollapsingTimer.OnCollapsingTimerRoomEnter += AddTimer; RoomCollapsingTimer.OnCollapsingTimerRoomExit += DestroyTimer; } private void OnDisable() { RoomCollapsingTimer.OnCollapsingTimerRoomEnter -= AddTimer; RoomCollapsingTimer.OnCollapsingTimerRoomExit -= DestroyTimer; } private void DestroyTimer(RoomCollapsingTimer leavingRoom) { Debug.Log($\"[UIRoomCollapsingTimer] DestroyTimer on {leavingRoom.gameObject.name}\"); StopAllTimers(); RemoveLeavingRoomFromDictionary(leavingRoom); ShowTimerForRoomWithLowestTimeInDictionary(); } private void ShowTimerForRoomWithLowestTimeInDictionary() { if (_timers.Count == 0) { HideTimer(); return; } float lowestTime = float.MaxValue; RoomCollapsingTimer roomWithLowestTime = null; foreach (var timer in _timers) { if (timer.Key.CollapsingTime < lowestTime) { lowestTime = timer.Key.CollapsingTime; roomWithLowestTime = timer.Key; } } float time = lowestTime - GameplayManager.GetCurrentServerTime(); StartEnteringRoomTimer(roomWithLowestTime, time); } private void RemoveLeavingRoomFromDictionary(RoomCollapsingTimer leavingRoom) { if (_timers.ContainsKey(leavingRoom)) { _timers.Remove(leavingRoom); } } public void AddTimer(RoomCollapsingTimer enteringRoom, float time) { Debug.Log($\"[UIRoomCollapsingTimer] AddTimer: {time} on {enteringRoom.gameObject.name}\"); ShowTimerUI(); StopAllTimers(); StartEnteringRoomTimer(enteringRoom, time); } private void StartEnteringRoomTimer(RoomCollapsingTimer enteringRoom, float time) { if (_timers.ContainsKey(enteringRoom)) { if (_timers[enteringRoom] != null) StopCoroutine(_timers[enteringRoom]); } _timers[enteringRoom] = StartCoroutine(StartTimer(time)); Debug.Log($\"[UIRoomCollapsingTimer] StartEnteringRoomTimer on {enteringRoom.gameObject.name}. Add timer _timers.Count: {_timers.Count}\"); } private void StopAllTimers() { foreach (var timer in _timers) { if (timer.Value == null) continue; StopCoroutine(timer.Value); } } private void ShowTimerUI() { for (int i = 0; i < timerObjects.Length; i++) { timerObjects[i].SetActive(true); } } public void HideTimer() { Debug.Log(\"[UIRoomCollapsingTimer] HideTimer\"); for (int i = 0; i < timerObjects.Length; i++) { timerObjects[i].SetActive(false); } } private IEnumerator StartTimer(float time) { float currentTime = time; while (currentTime > 0) { currentTime -= Time.deltaTime; _timerText.SetText(ConvertFloatToTimeFormat(currentTime)); ChangeColorToRedIfTimeIsEndingSoon(currentTime); yield return null; } } private void ChangeColorToRedIfTimeIsEndingSoon(float currentTime) { if (currentTime < 10f) { _timerText.SetColor(endingSoonColor); } else { _timerText.SetColor(_defaultColor); } } private string ConvertFloatToTimeFormat(float time) { if (time < 0) { return \"00\"; }else if (time < 61) { return $\"{Mathf.FloorToInt(time)}\"; } else { int minutes = Mathf.FloorToInt(time / 60); int seconds = Mathf.FloorToInt(time % 60); return $\"{minutes:00}:{seconds:00}\"; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "UIRoomCollapsingTimer",
          "content": "using System; using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using UnityEngine; public class UIRoomCollapsingTimer : MonoBehaviour { [SerializeField] private TMProDecorator _timerText; [SerializeField] private GameObject[] timerObjects; private Dictionary<RoomCollapsingTimer, Coroutine> _timers = new(); private Color _defaultColor; [SerializeField] private Color endingSoonColor = Color.red; private void Awake() { _defaultColor = _timerText.GetFontColor(); HideTimer();  private void OnEnable() { RoomCollapsingTimer.OnCollapsingTimerRoomEnter += AddTimer; RoomCollapsingTimer.OnCollapsingTimerRoomExit += DestroyTimer;  ",
          "content_tokens": 200,
          "embedding": []
        },
        {
          "cs_scriptfile": "UIRoomCollapsingTimer",
          "content": "private void OnDisable() { RoomCollapsingTimer.OnCollapsingTimerRoomEnter -= AddTimer; RoomCollapsingTimer.OnCollapsingTimerRoomExit -= DestroyTimer;  private void DestroyTimer(RoomCollapsingTimer leavingRoom) { Debug.Log($\"[UIRoomCollapsingTimer] DestroyTimer on {leavingRoom.gameObject.name}\"); StopAllTimers(); RemoveLeavingRoomFromDictionary(leavingRoom); ShowTimerForRoomWithLowestTimeInDictionary();  ",
          "content_tokens": 113,
          "embedding": []
        },
        {
          "cs_scriptfile": "UIRoomCollapsingTimer",
          "content": "private void ShowTimerForRoomWithLowestTimeInDictionary() { if (_timers.Count == 0) { HideTimer(); return; } float lowestTime = float.MaxValue; RoomCollapsingTimer roomWithLowestTime = null; foreach (var timer in _timers) { if (timer.Key.CollapsingTime < lowestTime) { lowestTime = timer.Key.CollapsingTime; roomWithLowestTime = timer.Key; } } float time = lowestTime - GameplayManager.GetCurrentServerTime(); StartEnteringRoomTimer(roomWithLowestTime, time);  private void RemoveLeavingRoomFromDictionary(RoomCollapsingTimer leavingRoom) { if (_timers.ContainsKey(leavingRoom)) { _timers.Remove(leavingRoom); }  ",
          "content_tokens": 179,
          "embedding": []
        },
        {
          "cs_scriptfile": "UIRoomCollapsingTimer",
          "content": "public void AddTimer(RoomCollapsingTimer enteringRoom, float time) { Debug.Log($\"[UIRoomCollapsingTimer] AddTimer: {time} on {enteringRoom.gameObject.name}\"); ShowTimerUI(); StopAllTimers(); StartEnteringRoomTimer(enteringRoom, time);  private void StartEnteringRoomTimer(RoomCollapsingTimer enteringRoom, float time) { if (_timers.ContainsKey(enteringRoom)) { if (_timers[enteringRoom] != null) StopCoroutine(_timers[enteringRoom]); } _timers[enteringRoom] = StartCoroutine(StartTimer(time)); Debug.Log($\"[UIRoomCollapsingTimer] StartEnteringRoomTimer on {enteringRoom.gameObject.name}. Add timer _timers.Count: {_timers.Count}\");  ",
          "content_tokens": 193,
          "embedding": []
        },
        {
          "cs_scriptfile": "UIRoomCollapsingTimer",
          "content": "private void StopAllTimers() { foreach (var timer in _timers) { if (timer.Value == null) continue; StopCoroutine(timer.Value); }  private void ShowTimerUI() { for (int i = 0; i < timerObjects.Length; i++) { timerObjects[i].SetActive(true); }  ",
          "content_tokens": 78,
          "embedding": []
        },
        {
          "cs_scriptfile": "UIRoomCollapsingTimer",
          "content": "public void HideTimer() { Debug.Log(\"[UIRoomCollapsingTimer] HideTimer\"); for (int i = 0; i < timerObjects.Length; i++) { timerObjects[i].SetActive(false); } } private IEnumerator StartTimer(float time) { float currentTime = time; while (currentTime > 0) { currentTime -= Time.deltaTime; _timerText.SetText(ConvertFloatToTimeFormat(currentTime)); ChangeColorToRedIfTimeIsEndingSoon(currentTime); yield return null; }  private void ChangeColorToRedIfTimeIsEndingSoon(float currentTime) { if (currentTime < 10f) { _timerText.SetColor(endingSoonColor); } else { _timerText.SetColor(_defaultColor); }  ",
          "content_tokens": 179,
          "embedding": []
        },
        {
          "cs_scriptfile": "UIRoomCollapsingTimer",
          "content": "private string ConvertFloatToTimeFormat(float time) { if (time < 0) { return \"00\"; }else if (time < 61) { return $\"{Mathf.FloorToInt(time)}\"; } else { int minutes = Mathf.FloorToInt(time / 60); int seconds = Mathf.FloorToInt(time % 60); return $\"{minutes:00}:{seconds:00}\"; } } }",
          "content_tokens": 98,
          "embedding": []
        }
      ],
      "length": 3527
    },
    {
      "filename": "UsernameGenerator",
      "content": "using UnityEngine; public class UsernameGenerator { private static string[] adjectives = new[] { \"Attractive\", \"Beautiful\", \"Charming\", \"Dazzling\", \"Elegant\", \"Fashionable\", \"Glamorous\", \"Handsome\", \"Intriguing\", \"Lovely\", \"Magnificent\", \"Opulent\", \"Polished\", \"Radiant\", \"Stylish\", \"Trendy\", \"Alluring\", \"Classy\", \"Dapper\", \"Exquisite\", \"Graceful\", \"Impeccable\", \"Jaunty\", \"Luminous\", \"Majestic\", \"Noble\", \"Ornate\", \"Pristine\", \"Quaint\", \"Regal\", \"Sophisticated\", \"Timeless\", \"Unique\", \"Vibrant\", \"Winsome\", \"Youthful\", \"Zesty\", \"Chic\", \"Dashing\", \"Fancy\", \"Gleaming\", \"Harmonious\", \"Iridescent\", \"Jubilant\", \"Kinetic\", \"Lively\", \"Mesmerizing\", \"Natty\", \"Omnipotent\", \"Picturesque\", \"Quixotic\", \"Ravishing\", \"Statuesque\", \"Transcendent\", \"Unassuming\", \"Vivid\", \"Whimsical\", \"Xanadu\", \"Yearning\", \"Zealous\", \"Beguiling\", \"Crisp\", \"Dainty\", \"Enchanting\", \"Fascinating\", \"Grandiose\", \"Hypnotic\", \"Intricate\", \"Jovial\", \"Kaleidoscopic\", \"Lustrous\", \"Mellow\", \"Nurturing\", \"Ostentatious\", \"Pearly\", \"Quizzical\", \"Resplendent\", \"Serene\", \"Timeless\", \"Uplifting\", \"Velvety\", \"Whispering\", \"Xquisite\", \"Yielding\", \"Zephyrous\", \"Adventurous\", \"Blissful\", \"Captivating\", \"Dreamy\", \"Ephemeral\", \"Festive\", \"Glowing\", \"Harmonious\", \"Idyllic\", \"Jubilant\" }; private static string[] nouns = new[] {\"Apple\", \"Banana\", \"Carpet\", \"Dolphin\", \"Elephant\", \"Forest\", \"Giraffe\", \"Happiness\", \"Island\", \"Journey\", \"Kangaroo\", \"Lighthouse\", \"Mountain\", \"Notebook\", \"Octopus\", \"Paradise\", \"Quilt\", \"Rainbow\", \"Sunflower\", \"Telescope\", \"Umbrella\", \"Violin\", \"Waterfall\", \"Xylophone\", \"Yearning\", \"Zoo\", \"Breeze\", \"Castle\", \"Diamond\", \"Explorer\", \"Firefly\", \"Galaxy\", \"Harmony\", \"Infinity\", \"Jungle\", \"Kaleidoscope\", \"Lagoon\", \"Meadow\", \"Nectar\", \"Oasis\", \"Pebble\", \"Quasar\", \"Rivulet\", \"Starlight\", \"Tranquility\", \"Universe\", \"Voyage\", \"Whisper\", \"Xanadu\", \"Yacht\", \"Zephyr\", \"Alchemy\", \"Blossom\", \"Canyon\", \"Dream\", \"Eclipse\", \"Fountain\", \"Gondola\", \"Horizon\", \"Ivory\", \"Jasmine\", \"Kite\", \"Lullaby\", \"Majesty\", \"Nebula\", \"Orchid\", \"Pendulum\", \"Quill\", \"Radiance\", \"Silhouette\", \"Talisman\", \"Utopia\", \"Vortex\", \"Wanderlust\", \"Xenon\", \"Yonder\", \"Zenith\", \"Aurora\", \"Bamboo\", \"Cerulean\", \"Dewdrop\", \"Ethereal\", \"Fjord\", \"Gossamer\", \"Halcyon\", \"Iridescent\", \"Jubilee\", \"Kale\", \"Labyrinth\", \"Mystique\", \"Nirvana\", \"Obsidian\", \"Pinnacle\", \"Quintessence\", \"Rhapsody\", \"Serenity\", \"Tryst\", \"Umbra\", \"Velvet\", \"Wisp\" }; public static string GenerateUsername() { return adjectives[Random.Range(0, adjectives.Length)] + nouns[Random.Range(0, nouns.Length)]; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "UsernameGenerator",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "UsernameGenerator",
          "content": "using UnityEngine; public class UsernameGenerator { private static string[] adjectives = new[] { \"Attractive\", \"Beautiful\", \"Charming\", \"Dazzling\", \"Elegant\", \"Fashionable\", \"Glamorous\", \"Handsome\", \"Intriguing\", \"Lovely\", \"Magnificent\", \"Opulent\", \"Polished\", \"Radiant\", \"Stylish\", \"Trendy\", \"Alluring\", \"Classy\", \"Dapper\", \"Exquisite\", \"Graceful\", \"Impeccable\", \"Jaunty\", \"Luminous\", \"Majestic\", \"Noble\", \"Ornate\", \"Pristine\", \"Quaint\", \"Regal\", \"Sophisticated\", \"Timeless\", \"Unique\", \"Vibrant\", \"Winsome\", \"Youthful\", \"Zesty\", \"Chic\", \"Dashing\", \"Fancy\", \"Gleaming\", \"Harmonious\", \"Iridescent\", \"Jubilant\", \"Kinetic\", \"Lively\", \"Mesmerizing\", \"Natty\", \"Omnipotent\", \"Picturesque\", \"Quixotic\", \"Ravishing\", \"Statuesque\", \"Transcendent\", \"Unassuming\", \"Vivid\", \"Whimsical\", \"Xanadu\", \"Yearning\", \"Zealous\", \"Beguiling\", \"Crisp\", \"Dainty\", \"Enchanting\", \"Fascinating\", \"Grandiose\", \"Hypnotic\", \"Intricate\", \"Jovial\", \"Kaleidoscopic\", \"Lustrous\", \"Mellow\", \"Nurturing\", \"Ostentatious\", \"Pearly\", \"Quizzical\", \"Resplendent\", \"Serene\", \"Timeless\", \"Uplifting\", \"Velvety\", \"Whispering\", \"Xquisite\", \"Yielding\", \"Zephyrous\", \"Adventurous\", \"Blissful\", \"Captivating\", \"Dreamy\", \"Ephemeral\", \"Festive\", \"Glowing\", \"Harmonious\", \"Idyllic\", \"Jubilant\" }; private static string[] nouns = new[] {\"Apple\", \"Banana\", \"Carpet\", \"Dolphin\", \"Elephant\", \"Forest\", \"Giraffe\", \"Happiness\", \"Island\", \"Journey\", \"Kangaroo\", \"Lighthouse\", \"Mountain\", \"Notebook\", \"Octopus\", \"Paradise\", \"Quilt\", \"Rainbow\", \"Sunflower\", \"Telescope\", \"Umbrella\", \"Violin\", \"Waterfall\", \"Xylophone\", \"Yearning\", \"Zoo\", \"Breeze\", \"Castle\", \"Diamond\", \"Explorer\", \"Firefly\", \"Galaxy\", \"Harmony\", \"Infinity\", \"Jungle\", \"Kaleidoscope\", \"Lagoon\", \"Meadow\", \"Nectar\", \"Oasis\", \"Pebble\", \"Quasar\", \"Rivulet\", \"Starlight\", \"Tranquility\", \"Universe\", \"Voyage\", \"Whisper\", \"Xanadu\", \"Yacht\", \"Zephyr\", \"Alchemy\", \"Blossom\", \"Canyon\", \"Dream\", \"Eclipse\", \"Fountain\", \"Gondola\", \"Horizon\", \"Ivory\", \"Jasmine\", \"Kite\", \"Lullaby\", \"Majesty\", \"Nebula\", \"Orchid\", \"Pendulum\", \"Quill\", \"Radiance\", \"Silhouette\", \"Talisman\", \"Utopia\", \"Vortex\", \"Wanderlust\", \"Xenon\", \"Yonder\", \"Zenith\", \"Aurora\", \"Bamboo\", \"Cerulean\", \"Dewdrop\", \"Ethereal\", \"Fjord\", \"Gossamer\", \"Halcyon\", \"Iridescent\", \"Jubilee\", \"Kale\", \"Labyrinth\", \"Mystique\", \"Nirvana\", \"Obsidian\", \"Pinnacle\", \"Quintessence\", \"Rhapsody\", \"Serenity\", \"Tryst\", \"Umbra\", \"Velvet\", \"Wisp\" }; public static string GenerateUsername() { return adjectives[Random.Range(0, adjectives.Length)] + nouns[Random.Range(0, nouns.Length)]; } }",
          "content_tokens": 965,
          "embedding": []
        }
      ],
      "length": 2527
    },
    {
      "filename": "VfxGraphController",
      "content": "using UnityEngine; using UnityEngine.VFX; namespace core.client.mechanics { public class VfxGraphController : MonoBehaviour { //vfx graph [SerializeField] private VisualEffect _vfx; private void OnValidate() => AssignVfxGraph(); private void Awake() => AssignVfxGraph(); private void AssignVfxGraph() => _vfx ??= GetComponent<VisualEffect>(); public void Enable() { _vfx.SetBool(\"IsOn\", true); } public void Disable() { _vfx.SetBool(\"IsOn\", false); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "VfxGraphController",
          "content": "using UnityEngine; using UnityEngine.VFX; namespace core.client.mechanics { public class VfxGraphController : MonoBehaviour { //vfx graph [SerializeField] private VisualEffect _vfx; private void OnValidate() => AssignVfxGraph(); private void Awake() => AssignVfxGraph(); private void AssignVfxGraph() => _vfx ??= GetComponent<VisualEffect>(); public void Enable() { _vfx.SetBool(\"IsOn\", true); } public void Disable() { _vfx.SetBool(\"IsOn\", false); } } }",
          "content_tokens": 133,
          "embedding": []
        }
      ],
      "length": 454
    },
    {
      "filename": "WeaponSlashEffect",
      "content": "using System.Collections; using System.Collections.Generic; using DungeonScrollerCore; using UnityEngine; public class WeaponSlashEffect : MonoBehaviour { [SerializeField] private SlashEffectController _slashEffectPrefab; private bool _isDebug = true; private Queue<Slash> _unusedObjectsPool = new Queue<Slash>(); private List<Slash> _usedObjectsPool = new List<Slash>(); public void PlaySlashEffect(float newHeight, Vector3 rotation, float duration) { DebugWrite.Log($\"[WeaponSlashEffect] PlaySlashEffect: newHeight={newHeight}, rotation={rotation}, duration={duration}\"); StartCoroutine(CorPlaySlashEffect(newHeight, rotation, duration)); } private IEnumerator CorPlaySlashEffect(float newHeight, Vector3 rotation, float duration) { Quaternion rotationQ = Quaternion.Euler(rotation); Slash slash = Allocate(); slash.SetHeightRotation(newHeight, rotationQ); slash.SlashEffect.PlayAll(); yield return new WaitForSeconds(duration); DebugWrite.Log($\"[WeaponSlashEffect] CorPlaySlashEffect: slash={slash}\", gameObject, _isDebug); slash.SlashEffect.StopAll(); Deallocate(slash); } private Slash Allocate() { if (_unusedObjectsPool.Count == 0) { ResizePool(_usedObjectsPool.Count + 1); } Slash obj = _unusedObjectsPool.Dequeue(); _usedObjectsPool.Add(obj); obj.SlashEffect.gameObject.SetActive(true); return obj; } public void Deallocate(Slash obj) { DebugWrite.Log($\"[WeaponSlashEffect] Deallocate: obj={obj}\", gameObject, _isDebug); if (_usedObjectsPool.Contains(obj)) { _usedObjectsPool.Remove(obj); _unusedObjectsPool.Enqueue(obj); obj.SlashEffect.gameObject.SetActive(false); DebugWrite.Log($\"[WeaponSlashEffect] Deallocate: obj.SlashEffect={obj.SlashEffect}\", gameObject, _isDebug); } else { Debug.LogError(\"Trying to deallocate an object that is not in the used pool.\"); } } private void ResizePool(int newSize) { if (newSize < _usedObjectsPool.Count) { Debug.LogError(\"Cannot resize the pool to a smaller size than the current used objects.\"); return; } for (int i = _unusedObjectsPool.Count + _usedObjectsPool.Count; i < newSize; i++) { SlashEffectController obj = Instantiate(_slashEffectPrefab, transform.position, Quaternion.identity, transform); DebugWrite.Log($\"[WeaponSlashEffect] ResizePool: pos={obj.transform.position}, local pos={obj.transform.localPosition}\", gameObject, _isDebug); Slash slash = new Slash(obj); obj.gameObject.SetActive(false); _unusedObjectsPool.Enqueue(slash); } } public class Slash { public SlashEffectController SlashEffect; public bool IsUsed; public Slash(SlashEffectController slashEffect) { SlashEffect = slashEffect; IsUsed = false; } public void SetHeightRotation(float height, Quaternion rotation) { DebugWrite.Log($\"[Slash] MoveTo before: position={SlashEffect.transform.position}, rotation={rotation}\", SlashEffect.gameObject, true); Vector3 newPos = new Vector3(SlashEffect.transform.localPosition.x, height, SlashEffect.transform.localPosition.z); SlashEffect.transform.localPosition = newPos; SlashEffect.transform.rotation = rotation; DebugWrite.Log($\"[Slash] MoveTo after: position={newPos}, rotation={rotation}\", SlashEffect.gameObject, true); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "WeaponSlashEffect",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "WeaponSlashEffect",
          "content": "using System.Collections; using System.Collections.Generic; using DungeonScrollerCore; using UnityEngine; public class WeaponSlashEffect : MonoBehaviour { [SerializeField] private SlashEffectController _slashEffectPrefab; private bool _isDebug = true; private Queue<Slash> _unusedObjectsPool = new Queue<Slash>(); private List<Slash> _usedObjectsPool = new List<Slash>(); public void PlaySlashEffect(float newHeight, Vector3 rotation, float duration) { DebugWrite.Log($\"[WeaponSlashEffect] PlaySlashEffect: newHeight={newHeight}, rotation={rotation}, duration={duration}\"); StartCoroutine(CorPlaySlashEffect(newHeight, rotation, duration)); } private IEnumerator CorPlaySlashEffect(float newHeight, Vector3 rotation, float duration) { Quaternion rotationQ = Quaternion.Euler(rotation); Slash slash = Allocate(); slash.SetHeightRotation(newHeight, rotationQ); slash.SlashEffect.PlayAll(); yield return new WaitForSeconds(duration); DebugWrite.Log($\"[WeaponSlashEffect] CorPlaySlashEffect: slash={slash}\", gameObject, _isDebug); slash.SlashEffect.StopAll(); Deallocate(slash); } private Slash Allocate() { if (_unusedObjectsPool.Count == 0) { ResizePool(_usedObjectsPool.Count + 1); } Slash obj = _unusedObjectsPool.Dequeue(); _usedObjectsPool.Add(obj); obj.SlashEffect.gameObject.SetActive(true); return obj;  ",
          "content_tokens": 368,
          "embedding": []
        },
        {
          "cs_scriptfile": "WeaponSlashEffect",
          "content": "public void Deallocate(Slash obj) { DebugWrite.Log($\"[WeaponSlashEffect] Deallocate: obj={obj}\", gameObject, _isDebug); if (_usedObjectsPool.Contains(obj)) { _usedObjectsPool.Remove(obj); _unusedObjectsPool.Enqueue(obj); obj.SlashEffect.gameObject.SetActive(false); DebugWrite.Log($\"[WeaponSlashEffect] Deallocate: obj.SlashEffect={obj.SlashEffect}\", gameObject, _isDebug); } else { Debug.LogError(\"Trying to deallocate an object that is not in the used pool.\"); }  private void ResizePool(int newSize) { if (newSize < _usedObjectsPool.Count) { Debug.LogError(\"Cannot resize the pool to a smaller size than the current used objects.\"); return;  ",
          "content_tokens": 199,
          "embedding": []
        },
        {
          "cs_scriptfile": "WeaponSlashEffect",
          "content": "for (int i = _unusedObjectsPool.Count + _usedObjectsPool.Count; i < newSize; i++) { SlashEffectController obj = Instantiate(_slashEffectPrefab, transform.position, Quaternion.identity, transform); DebugWrite.Log($\"[WeaponSlashEffect] ResizePool: pos={obj.transform.position}, local pos={obj.transform.localPosition}\", gameObject, _isDebug); Slash slash = new Slash(obj); obj.gameObject.SetActive(false); _unusedObjectsPool.Enqueue(slash); } } public class Slash { public SlashEffectController SlashEffect; public bool IsUsed; public Slash(SlashEffectController slashEffect) { SlashEffect = slashEffect; IsUsed = false;  ",
          "content_tokens": 171,
          "embedding": []
        },
        {
          "cs_scriptfile": "WeaponSlashEffect",
          "content": "public void SetHeightRotation(float height, Quaternion rotation) { DebugWrite.Log($\"[Slash] MoveTo before: position={SlashEffect.transform.position}, rotation={rotation}\", SlashEffect.gameObject, true); Vector3 newPos = new Vector3(SlashEffect.transform.localPosition.x, height, SlashEffect.transform.localPosition.z); SlashEffect.transform.localPosition = newPos; SlashEffect.transform.rotation = rotation; DebugWrite.Log($\"[Slash] MoveTo after: position={newPos}, rotation={rotation}\", SlashEffect.gameObject, true); } } }",
          "content_tokens": 141,
          "embedding": []
        }
      ],
      "length": 3103
    },
    {
      "filename": "WeaponSlashEffectGlobal",
      "content": "using System.Collections; using System.Collections.Generic; using DungeonScrollerCore; using UnityEngine; public class WeaponSlashEffectGlobal : MonoBehaviour { [SerializeField] private SlashEffectController _slashEffectPrefab; private bool _isDebug; private Queue<Slash> _unusedObjectsPool = new Queue<Slash>(); private List<Slash> _usedObjectsPool = new List<Slash>(); public static WeaponSlashEffectGlobal Instance { get; private set; } private static WeaponSlashEffectGlobal _instance; private void Awake() { if (_instance == null) { _instance = this; } else { Destroy(this); } } public static void PlaySlashEffect(Vector3 position, float newHeight, Quaternion rotation, float duration) { DebugWrite.Log($\"[WeaponSlashEffect] PlaySlashEffect: position={position} newHeight={newHeight}, rotation={rotation}, duration={duration}\", _instance.gameObject, _instance._isDebug); _instance.StartCoroutine(_instance.CorPlaySlashEffect(position, newHeight, rotation, duration)); } private IEnumerator CorPlaySlashEffect(Vector3 position, float newHeight, Quaternion rotation, float duration) { Slash slash = Allocate(); slash.SlashEffect.transform.position = new Vector3(position.x, position.y + newHeight, position.z); slash.SlashEffect.transform.rotation = rotation; slash.SlashEffect.PlayAll(); yield return new WaitForSeconds(duration); DebugWrite.Log($\"[WeaponSlashEffect] CorPlaySlashEffect: slash={slash}\", gameObject, _isDebug); slash.SlashEffect.StopAll(); Deallocate(slash); } private Slash Allocate() { if (_unusedObjectsPool.Count == 0) { ResizePool(_usedObjectsPool.Count + 1); } Slash obj = _unusedObjectsPool.Dequeue(); _usedObjectsPool.Add(obj); obj.SlashEffect.gameObject.SetActive(true); return obj; } public void Deallocate(Slash obj) { DebugWrite.Log($\"[WeaponSlashEffect] Deallocate: obj={obj}\", gameObject, _isDebug); if (_usedObjectsPool.Contains(obj)) { _usedObjectsPool.Remove(obj); _unusedObjectsPool.Enqueue(obj); obj.SlashEffect.gameObject.SetActive(false); DebugWrite.Log($\"[WeaponSlashEffect] Deallocate: obj.SlashEffect={obj.SlashEffect}\", gameObject, _isDebug); } else { Debug.LogError(\"Trying to deallocate an object that is not in the used pool.\"); } } private void ResizePool(int newSize) { if (newSize < _usedObjectsPool.Count) { Debug.LogError(\"Cannot resize the pool to a smaller size than the current used objects.\"); return; } for (int i = _unusedObjectsPool.Count + _usedObjectsPool.Count; i < newSize; i++) { SlashEffectController obj = Instantiate(_slashEffectPrefab, transform.position, Quaternion.identity, transform); DebugWrite.Log($\"[WeaponSlashEffect] ResizePool: pos={obj.transform.position}, local pos={obj.transform.localPosition}\", gameObject, _isDebug); Slash slash = new Slash(obj); obj.gameObject.SetActive(false); _unusedObjectsPool.Enqueue(slash); } } public class Slash { public SlashEffectController SlashEffect; public bool IsUsed; public Slash(SlashEffectController slashEffect) { SlashEffect = slashEffect; IsUsed = false; } public void SetHeightRotation(float height, Quaternion rotation) { DebugWrite.Log($\"[Slash] MoveTo before: position={SlashEffect.transform.position}, rotation={rotation}\", SlashEffect.gameObject, true); Vector3 newPos = new Vector3(SlashEffect.transform.localPosition.x, height, SlashEffect.transform.localPosition.z); SlashEffect.transform.localPosition = newPos; SlashEffect.transform.rotation = rotation; DebugWrite.Log($\"[Slash] MoveTo after: position={newPos}, rotation={rotation}\", SlashEffect.gameObject, true); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "WeaponSlashEffectGlobal",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "WeaponSlashEffectGlobal",
          "content": "using System.Collections; using System.Collections.Generic; using DungeonScrollerCore; using UnityEngine; public class WeaponSlashEffectGlobal : MonoBehaviour { [SerializeField] private SlashEffectController _slashEffectPrefab; private bool _isDebug; private Queue<Slash> _unusedObjectsPool = new Queue<Slash>(); private List<Slash> _usedObjectsPool = new List<Slash>(); public static WeaponSlashEffectGlobal Instance { get; private set; } private static WeaponSlashEffectGlobal _instance; private void Awake() { if (_instance == null) { _instance = this; } else { Destroy(this); } } public static void PlaySlashEffect(Vector3 position, float newHeight, Quaternion rotation, float duration) { DebugWrite.Log($\"[WeaponSlashEffect] PlaySlashEffect: position={position} newHeight={newHeight}, rotation={rotation}, duration={duration}\", _instance.gameObject, _instance._isDebug); _instance.StartCoroutine(_instance.CorPlaySlashEffect(position, newHeight, rotation, duration)); } private IEnumerator CorPlaySlashEffect(Vector3 position, float newHeight, Quaternion rotation, float duration) { Slash slash = Allocate(); slash.SlashEffect.transform.position = new Vector3(position.x, position.y + newHeight, position.z); slash.SlashEffect.transform.rotation = rotation; slash.SlashEffect.PlayAll(); yield return new WaitForSeconds(duration); DebugWrite.Log($\"[WeaponSlashEffect] CorPlaySlashEffect: slash={slash}\", gameObject, _isDebug); slash.SlashEffect.StopAll(); Deallocate(slash); } private Slash Allocate() { if (_unusedObjectsPool.Count == 0) { ResizePool(_usedObjectsPool.Count + 1); } Slash obj = _unusedObjectsPool.Dequeue(); _usedObjectsPool.Add(obj); obj.SlashEffect.gameObject.SetActive(true); return obj;  ",
          "content_tokens": 467,
          "embedding": []
        },
        {
          "cs_scriptfile": "WeaponSlashEffectGlobal",
          "content": "public void Deallocate(Slash obj) { DebugWrite.Log($\"[WeaponSlashEffect] Deallocate: obj={obj}\", gameObject, _isDebug); if (_usedObjectsPool.Contains(obj)) { _usedObjectsPool.Remove(obj); _unusedObjectsPool.Enqueue(obj); obj.SlashEffect.gameObject.SetActive(false); DebugWrite.Log($\"[WeaponSlashEffect] Deallocate: obj.SlashEffect={obj.SlashEffect}\", gameObject, _isDebug); } else { Debug.LogError(\"Trying to deallocate an object that is not in the used pool.\"); }  private void ResizePool(int newSize) { if (newSize < _usedObjectsPool.Count) { Debug.LogError(\"Cannot resize the pool to a smaller size than the current used objects.\"); return;  ",
          "content_tokens": 199,
          "embedding": []
        },
        {
          "cs_scriptfile": "WeaponSlashEffectGlobal",
          "content": "for (int i = _unusedObjectsPool.Count + _usedObjectsPool.Count; i < newSize; i++) { SlashEffectController obj = Instantiate(_slashEffectPrefab, transform.position, Quaternion.identity, transform); DebugWrite.Log($\"[WeaponSlashEffect] ResizePool: pos={obj.transform.position}, local pos={obj.transform.localPosition}\", gameObject, _isDebug); Slash slash = new Slash(obj); obj.gameObject.SetActive(false); _unusedObjectsPool.Enqueue(slash); } } public class Slash { public SlashEffectController SlashEffect; public bool IsUsed; public Slash(SlashEffectController slashEffect) { SlashEffect = slashEffect; IsUsed = false;  ",
          "content_tokens": 171,
          "embedding": []
        },
        {
          "cs_scriptfile": "WeaponSlashEffectGlobal",
          "content": "public void SetHeightRotation(float height, Quaternion rotation) { DebugWrite.Log($\"[Slash] MoveTo before: position={SlashEffect.transform.position}, rotation={rotation}\", SlashEffect.gameObject, true); Vector3 newPos = new Vector3(SlashEffect.transform.localPosition.x, height, SlashEffect.transform.localPosition.z); SlashEffect.transform.localPosition = newPos; SlashEffect.transform.rotation = rotation; DebugWrite.Log($\"[Slash] MoveTo after: position={newPos}, rotation={rotation}\", SlashEffect.gameObject, true); } } }",
          "content_tokens": 141,
          "embedding": []
        }
      ],
      "length": 3507
    },
    {
      "filename": "GameplayManager",
      "content": " #if UNITY_EDITOR #endif using System; using System.Collections; using System.Collections.Generic; using System.Linq; using System.Text; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Clients; using FirstGearGames.LobbyAndWorld.Lobbies; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using FishNet; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using FishNet.Transporting; using FishnetInvector; using InRoomSystems; using Invector; using Invector.vItemManager; using Invector.vMelee; using JetBrains.Annotations; using My; using ParrelSync; using Pathfinding.RVO; using UnityEngine; using UnityEngine.AddressableAssets; using UnityEngine.ResourceManagement.AsyncOperations; using Zomb; using Zomb.Creatures.Module; using UnitySceneManager = UnityEngine.SceneManagement.SceneManager; using Random = UnityEngine.Random; namespace _ZombieRoyale.Scripts.Core { public class GameplayManager : NetworkBehaviour { // Serialized [Header(\"Spawning\")] /// <summary> /// Region players may spawn. /// </summary> [Tooltip(\"Region players may spawn.\")] [SerializeField] protected Vector3 _spawnRegion = Vector3.one; public List<Vector3> SpawnPointsForPlayers => _spawnPointsForPlayers; protected List<Vector3> _spawnPointsForPlayers = new List<Vector3>(); /// <summary> /// Prefab to spawn. /// </summary> [Tooltip(\"Prefab to spawn.\")] public NetworkObject PlayerPrefab => _playerPrefab; [SerializeField] protected NetworkObject _playerPrefab = null; public NetworkObject MalePrefab => _malePrefab; [SerializeField] protected NetworkObject _malePrefab; public NetworkObject FemalePrefab => _femalePrefab; [SerializeField] protected NetworkObject _femalePrefab; [SerializeField] protected bool isTeamsMode = false; public CreaturesFactory CreaturesFactory => _creaturesFactory; [SerializeField] protected CreaturesFactory _creaturesFactory; [SerializeField] protected EscapeCitySource _escapeCitySourcePrefab; [SerializeField] protected UICanvasGroupDecorator _winCanvasGroup; [SerializeField] protected UICanvasGroupDecorator _looseCanvasGroup; [SerializeField] protected List<Vector3> _escapePoints = new List<Vector3>(); [SerializeField] protected RVOSimulator _rvoSimulator; [SerializeField] protected EscapePortalController _escapePortalPrefab; [SerializeField] protected HealthSphereController _healthSpherePrefab; [SerializeField] protected BookExpController _BookExpPrefab; [SerializeField] protected RewardAbilityManager _rewardAbilityManager; [SerializeField] protected LootDropSystem _lootDropSystem; [SerializeField] protected ServerPlayerManager _serverPlayerManager; [SerializeField] protected DungeonNetworkManager _dungeonNetworkManager; [SerializeField] protected ObjectsRoomManager _objectsManager; [SerializeField] protected MyDungeonListener _dungeonListener; [SerializeField] protected OptimizeServerFromComponents _optimizeServerFromComponents; /// <summary> /// DeathDummy to spawn. /// </summary> [Tooltip(\"DeathDummy to spawn.\")] [SerializeField] protected GameObject _deathDummy = null; /// <summary> /// RoomDetails for this game. Only available on the server. /// </summary> public RoomDetails RoomDetails => _roomDetails.FirstOrDefault(); [SyncObject] protected readonly SyncHashSet<RoomDetails> _roomDetails = new (); [SyncObject] protected readonly SyncDictionary<int, RoomDetails.Team> _teams = new (); protected List<RoomDetails.Team> _lastTeams = new (); /// <summary> /// LobbyNetwork. /// </summary> protected LobbyNetwork _lobbyNetwork = null; /// <summary> /// Becomes true once someone has won. /// </summary> protected bool _winner = false; /// <summary> /// Currently spawned player objects. Synchronized between server and client. /// </summary> public SyncList<int> UnitCharacters => _spawnedUnitObjects; public SyncList<int> SpawnedUnitObjects => _spawnedUnitObjects; [SyncObject] protected readonly SyncList<int> _spawnedUnitObjects = new SyncList<int>(); public List<NetworkObject> SpawnedPlayerHeroes { get; protected set;} = new (); public Action<int> OnSpawnedUnitObjectsChanged; public Dictionary<int,Vector3> PlayerPositions => _playerPositions; protected Dictionary<int,Vector3> _playerPositions = new Dictionary<int, Vector3>(); public static Action<string, List<NetworkObject>> OnRoomDetailsUpdated; public static Action<NetworkObject> OnPlayerJoinedRoom; public Action<int> OnPlayerHeroSpawned; public static Action OnAllPlayersSpawned; protected RoomDataManagement _clientRoomDataManagement; protected static Dictionary<int, UnitComponents> UnitComponentsDict = new Dictionary<int, UnitComponents>(); protected static float SPAWN_POINT_GENERATION_TIME = 30f; protected string ClassAndRoomName => $\"[GPM][<color=#FFFF00>{RoomDetails.Name}</color>]\"; protected static string COLOR_INITIALIZATION = $\"<color=#00dd00>\"; public static string TAG_PLAYER = \"Player\"; public static string[] SERVER_AI_CONTROLLED_TAGS = new string[] { \"Enemy\" }; public static int MONSTER_TAG_ID = 0; public static int MONSTER_TEAM_ID = -2; protected const float THROW_TO_MAIN_MENU_TIMER = 5f; public string RoomName => RoomDetails.Name; public RewardAbilityManager RewardAbilityManager => _rewardAbilityManager; public LootDropSystem LootDropSystem => _lootDropSystem; /// <summary> /// for clients to find GPM in current room /// </summary> public static GameplayManager LocalPlayer => AllGameplayManagers.FirstOrDefault(); /// <summary> /// Mostly used by server, but can be used by clients too /// </summary> public static List<GameplayManager> AllGameplayManagers { get; protected set; } = new List<GameplayManager>(); protected static int NUMBER_OF_PLAYERS_BEFORE_SPAWN = 1; public List<NetworkConnection> ConnectionsToSpawn => _connectionsToSpawn; protected List<NetworkConnection> _connectionsToSpawn = new List<NetworkConnection>(); public AstarPath AstarPath => _astarPath; [SerializeField] protected AstarPath _astarPath; [field: SerializeField] public bool IsDungeonBuilt { get; protected set; } public Action OnDungeonBuilt; public Action OnServerOptimizationFinished; protected Dictionary<Collider, FishnetInvectorHealthController> _collidersToHealthControllers = new Dictionary<Collider,FishnetInvectorHealthController>(); public PhysicsSimulator PhysicsSimulator => _physicsSimulator; [SerializeField] protected PhysicsSimulator _physicsSimulator; protected bool _isDebug = false; public bool IsAllPlayersSpawned => _isAllPlayersSpawned; protected bool _isAllPlayersSpawned; protected System.Random _random = null; public float RoomStartTime { get; protected set; } protected RespawnManager _respawnManager; public static Action OnRoomReady; public static Action OnClientLoadedGameplayManager; public static Action OnLocalClientInitStarted; protected AbilityManager _abilityManager; protected BossLocationNotifier _bossLocationNotifier; [field:SerializeField] public bool IsLoadDungeonFromSave { get; protected set; } public static GameplayManager Instance { get; protected set; } public static Action<NetworkConnection, NetworkObject, UnitComponents> OnUnitComponentsCreated; public DungeonHolder DungeonHolder => _dungeonHolder; private DungeonHolder _dungeonHolder; private Dictionary<int,int> unitToTeamId = new Dictionary<int, int>(); protected PlayerSpawnManager _playerSpawnManager; /// <summary> /// [ServerRpc(RunLocally = true)] - метод выполнится на вызвавшем клиенте, не выполнится на сервере /// [ObserversRpc(RunLocally = true)] - метод выполнится на сервере и на вызвавшем клиенте /// </summary> protected override void OnValidate() { base.OnValidate(); _creaturesFactory ??= FindObjectOfType<CreaturesFactory>(); _rvoSimulator ??= FindObjectOfType<RVOSimulator>(); _rewardAbilityManager ??= FindObjectOfType<RewardAbilityManager>(); _lootDropSystem ??= FindObjectOfType<LootDropSystem>(); _serverPlayerManager ??= FindObjectOfType<ServerPlayerManager>(); _dungeonNetworkManager ??= FindObjectOfType<DungeonNetworkManager>(); _dungeonListener ??= FindObjectOfType<MyDungeonListener>(); _objectsManager ??= FindObjectOfType<ObjectsRoomManager>(); _optimizeServerFromComponents ??= GetComponent<OptimizeServerFromComponents>(); _astarPath ??= FindObjectOfType<AstarPath>(); } [Client] public void ReportDungeonBuilt() { IsDungeonBuilt = true; OnDungeonBuilt?.Invoke(); } /// Initialization and Deinitialization. protected void OnDestroy() { if (_lobbyNetwork != null) { _lobbyNetwork.OnClientJoinedRoom -= LobbyNetwork_OnClientStarted; _lobbyNetwork.OnClientLeftRoom -= LobbyNetwork_OnClientLeftRoom; RoomDetails.OnRoomDetailsUpdated -= RoomDetails_OnRoomDetailsUpdated; RemoveFromUnitComponents(); } } protected virtual void Update() { } /// <summary> /// Initializes this script for use. /// </summary> public void FirstInitialize(RoomDetails roomDetails, LobbyNetwork lobbyNetwork) { //_roomDetails = roomDetails; _lobbyNetwork = lobbyNetwork; _lobbyNetwork.OnClientStarted += LobbyNetwork_OnClientStarted; } protected void Awake() { _astarPath = GameObject.FindObjectOfType<AstarPath>(); _rewardAbilityManager = FindObjectOfType<RewardAbilityManager>(); _abilityManager = FindObjectOfType<AbilityManager>(); _bossLocationNotifier = FindObjectOfType<BossLocationNotifier>(); _serverPlayerManager = FindObjectOfType<ServerPlayerManager>(); _creaturesFactory = FindObjectOfType<CreaturesFactory>(); _dungeonNetworkManager = FindObjectOfType<DungeonNetworkManager>(); _dungeonListener = FindObjectOfType<MyDungeonListener>(); _rvoSimulator = FindObjectOfType<RVOSimulator>(); _lootDropSystem = FindObjectOfType<LootDropSystem>(); _objectsManager = FindObjectOfType<ObjectsRoomManager>(); AllGameplayManagers.Add(this); _spawnedUnitObjects.OnChange += SpawnedUnitObjectsOnChange; _teams.OnChange += _teams_TeamsOnChange; _respawnManager = CreaturesFactory.GetComponent<RespawnManager>(); _optimizeServerFromComponents = GetComponent<OptimizeServerFromComponents>(); if (Instance != null) { Debug.LogError($\"[GameplayManager] Instance already exists!\"); Destroy(Instance); } else { Instance = this; } } public override void OnStopNetwork() { base.OnStopNetwork(); AllGameplayManagers.Remove(this); _spawnedUnitObjects.OnChange -= SpawnedUnitObjectsOnChange; } public override void OnStartNetwork() { base.OnStartNetwork(); try { if (IsServer) { RoomDetails rd = new RoomDetails(); _roomDetails.Add(rd); }else if (base.IsClientOnly) { Destroy(_physicsSimulator); } }catch(Exception e) { Debug.LogError(e); } } public override void OnStartServer() { base.OnStartServer(); if (isTeamsMode) RoomDetails.SetIsTeamsMode(true); StartCoroutine(InitServer()); InstanceFinder.ServerManager.OnRemoteConnectionState += UpdateRoomInfoIfPlayerLeft; RoomDetails.OnRoomDetailsUpdated += RoomDetails_OnRoomDetailsUpdated; //StartCoroutine(GenerateEscapePoint()); } protected void UpdateRoomInfoIfPlayerLeft(NetworkConnection conn, RemoteConnectionStateArgs connState) { if (connState.ConnectionState == RemoteConnectionState.Stopped) { LobbyNetwork_OnClientLeftRoom(RoomDetails, conn.FirstObject); Debug.Log($\"[GameplayManager] Player #{conn.ClientId} {connState.ConnectionState}\"); } } protected virtual IEnumerator InitServer() { var startTime = Time.time; string color = String.Empty; string endColor = String.Empty; #if UNITY_EDITOR color = COLOR_INITIALIZATION; endColor = \"</color>\"; #endif //TODO: Create Scriptable Objects, dungeons generator saver uint seed = 1;//903244736; _playerSpawnManager = new PlayerSpawnManager(this, MalePrefab, FemalePrefab); var time = new WaitForSeconds(1f); //Because ParrelSync can't load addressables #if UNITY_EDITOR if (IsLoadDungeonFromSave && !ClonesManager.IsClone()) { #else if (IsLoadDungeonFromSave) { #endif _dungeonNetworkManager.SetSeed(seed); Debug.Log($\"{color}===========[{RoomDetails.Name}]...New seed: {seed}. Waiting until IsDungeonSpawned...==========={endColor}\", _dungeonNetworkManager); yield return new WaitUntil(()=> _dungeonNetworkManager.IsDungeonSpawned); } else { CreateSeedAndStartBuildingDungeon(seed); yield return new WaitUntil(()=> _dungeonListener.IsDungeonBuilt); yield return time; yield return time; } _dungeonHolder = FindObjectOfType<DungeonHolder>(); _dungeonHolder.SetupCollapsingTimes(); Debug.Log($\"{color}===========[{RoomDetails.Name}]...IsDungeonSpawned -> Storing Spawn Points...==========={endColor}\"); InitPlayerSpawnPoints(); Debug.Log($\"{color}===========[{RoomDetails.Name}]...!Storing Spawn Points finished!...==========={endColor}\"); Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting Spawning Networked objects...==========={endColor}\"); _objectsManager.SpawnObjects(); yield return new WaitUntil(()=>_objectsManager.IsObjectsSpawned); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Spawnning Networked objects finished!==========={endColor}\"); if (!IsHost) { Debug.Log($\"{color}===========...[{RoomDetails.Name}] Starting removing lights...==========={endColor}\"); _optimizeServerFromComponents.RemoveGameObjectsNotNeededForServer(); _optimizeServerFromComponents.OptimizeLights(); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Removing lights finished!==========={endColor}\"); } Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting NavMesh build...==========={endColor}\"); #if UNITY_EDITOR if (IsLoadDungeonFromSave && !ClonesManager.IsClone()) { #else if (IsLoadDungeonFromSave) { #endif LoadPathFroAStarFromAddressables(seed); } else { AstarPath.Scan(); new WaitUntil(()=>!AstarPath.isScanning); } Debug.Log($\"{color}===========[{RoomDetails.Name}]!NavMesh builded!==========={endColor}\"); //yield return time; Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting populating spawn points with monsters...==========={endColor}\"); _respawnManager.MonsterSpawnPointsPopulate(); _respawnManager.PopulatePortalPoints(); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Populating spawn points finished!==========={endColor}\"); Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting Abilities Initialization...==========={endColor}\"); _abilityManager.Init(true); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Abilities initialization finished!==========={endColor}\"); //yield return time; Debug.Log($\"{color}===========[{RoomDetails.Name}]...Order clients to remove monster spawn points...==========={endColor}\"); //SpawnPlayersThatLoadedDungeon(); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Spawnning Players finished!==========={endColor}\"); //NotifyAllPlayersRoomStartTime(); _respawnManager.InitIfAllRequirementsMet(); OnRoomReady?.Invoke(); _serverPlayerManager.InitServer(); var elapsedTime = Time.time - startTime; StartCoroutine(SpawnPlayersThatLoadedDungeon()); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Room initialization finished! Elapsed time: {elapsedTime}==========={endColor}\"); StartCoroutine(DelayedSpawnEscapePortalsAfterTime(15 * 60)); } protected virtual IEnumerator InitClient() { OnLocalClientInitStarted?.Invoke(); string color = String.Empty; string endColor = String.Empty; #if UNITY_EDITOR color = COLOR_INITIALIZATION; endColor = \"</color>\"; #endif UnitySceneManager.SetActiveScene(UnitySceneManager.GetSceneByName(ClientSceneHandler.ROOM_SCENE_NAME)); //MoveClientInstanceToActiveScene(); var time = new WaitForSeconds(.5f); RegistrationController.Instance.SwitchMainMenuElements(false); if (!IsHost) { Destroy(_rvoSimulator); } #if UNITY_EDITOR if (IsLoadDungeonFromSave && !ClonesManager.IsClone()) { #else if (IsLoadDungeonFromSave) { #endif yield return new WaitUntil(() => _dungeonNetworkManager.IsDungeonSpawned); } else { yield return new WaitUntil(() => _dungeonListener.IsDungeonBuilt); } _dungeonHolder = FindObjectOfType<DungeonHolder>(); _dungeonHolder.SetupCollapsingTimes(); yield return new WaitUntil(()=>_objectsManager.IsObjectsSpawned); Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting removing non network GOs...==========={endColor}\"); _objectsManager.RemoveNonNetworkedObjectsClient(); yield return new WaitUntil(()=> _objectsManager.IsNonNetworkedObjectsRemoved); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Removing non network GOs finished!==========={endColor}\"); if (IsHost) { yield return new WaitUntil(() => _objectsManager.IsObjectsSpawned); } if (!IsHost){ Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting Abilities Initialization...==========={endColor}\"); _abilityManager.Init(false); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Abilities initialization finished!==========={endColor}\"); } OnClientLoadedGameplayManager?.Invoke(); if (!IsHost) { yield return new WaitForSeconds(3f); Debug.Log( $\"{color}===========[{RoomDetails.Name}]...Removing monster spawn points...==========={endColor}\"); _respawnManager.RemoveMonsterSpawnPoints(); _respawnManager.RemovePortalSpawnPoints(); } Debug.Log($\"{color}===========[{RoomDetails.Name}]...Waiting for RoomLODController...==========={endColor}\"); yield return new WaitUntil(()=> RoomLODController.Instance != null); RoomLODController.Instance.InitForClient(); MusicController.PlayDungeonMusic(); CmdClientFinishedLoadingGPM(); yield return time; } private void MoveClientInstanceToActiveScene() { ClientInstance clientInstance = ClientInstance.LocalPlayer; if (clientInstance.gameObject.scene.name != ClientSceneHandler.ROOM_SCENE_NAME) { UnitySceneManager.MoveGameObjectToScene(gameObject, UnitySceneManager.GetSceneByName(ClientSceneHandler.ROOM_SCENE_NAME)); } } private void LoadPathFroAStarFromAddressables(uint seed) { string addressableDungeonAStar = $\"{DungeonNetworkManager.DUNGEON_ADDRESSABLES_PATH}/{seed}/graph-{seed}.bytes\"; Addressables.LoadAssetAsync<TextAsset>(addressableDungeonAStar).Completed += OnAstarPathLoaded; } protected void OnAstarPathLoaded(AsyncOperationHandle<TextAsset> handle) { if (handle.Status == AsyncOperationStatus.Succeeded) { TextAsset data = handle.Result; AstarPath.data.file_cachedStartup = data; AstarPath.data.LoadFromCache(); } else { Debug.LogError(\"Failed to load the Addressable prefab.\"); } } [Server] protected void CreateSeedAndStartBuildingDungeon(uint newSeed = 0) { if (newSeed == 0) { newSeed = (uint)Random.Range(0, int.MaxValue); } _dungeonNetworkManager.SetSeed(newSeed); Debug.Log(\"Generated seed: \" + newSeed); } [Server] public void InitPlayerSpawnPoints() { List<Vector3> spawnPositions = FindSpawnPoints(); PopulateSpawnPoints(spawnPositions); } [Server] protected List<Vector3> FindSpawnPoints() { var spawnPoints = GameObject.FindGameObjectsWithTag(\"Respawn\"); if (spawnPoints.Length == 0) { Debug.LogError(\"No player spawn points found!\"); return null; } else { Debug.Log($\"[GameplayManager] Found {spawnPoints.Length} spawn points\"); } List<Vector3> spawnPointsList = new List<Vector3>(); foreach (var spawnPoint in spawnPoints) { spawnPointsList.Add(spawnPoint.transform.position); } foreach (var go in spawnPoints) { Destroy(go); } return spawnPointsList; } public override void OnStartClient() { base.OnStartClient(); StartCoroutine(InitClient()); } #region Room Details Updater public SyncList<NetworkObject> SyncRoomDetailsPlayerCharacters => _syncRoomDetailsPlayerCharacters; [SyncObject] readonly SyncList<NetworkObject> _syncRoomDetailsPlayerCharacters = new (); [Server] protected void RoomDetails_OnRoomDetailsUpdated(RoomDetails.WhichField whichField) { StringBuilder sb = new StringBuilder($\"{ClassAndRoomName} RoomDetails_OnRoomDetailsUpdated \"); switch (whichField) { case RoomDetails.WhichField.EName: sb.Append($\"Name: {RoomDetails.Name}\"); ObserversRoomDetailsNameUpdated(RoomDetails.Name); break; case RoomDetails.WhichField.EMemberIds: sb.Append($\"MemberIds: {RoomDetails.MemberIds.Count}\"); ObserversRoomDetailsMemberIdsUpdated(RoomDetails.MemberIds); break; case RoomDetails.WhichField.EStartedMembers: sb.Append($\"StartedMembers: {RoomDetails.StartedMembers.Count}\"); ObserversRoomDetailsStartedMembersUpdated(RoomDetails.StartedMembers); break; case RoomDetails.WhichField.EIsTeamsMode: sb.Append($\"IsTeamsMode: {RoomDetails.IsTeamsMode}\"); ObserversRoomDetailsIsTeamsModeUpdated(RoomDetails.IsTeamsMode); break; case RoomDetails.WhichField.ETeams: sb.Append($\"Teams: {RoomDetails.Teams.Count}\"); RoomDetails.Team team = new RoomDetails.Team(); for (int i = 0; i < RoomDetails.Teams.Count; i++) { team = RoomDetails.Teams[i]; _teams[i] = team; _teams.Dirty(i); } ObserversRoomDetailsTeamsUpdated(RoomDetails.Teams); break; case RoomDetails.WhichField.EKickedIds: sb.Append($\"KickedIds: {RoomDetails.KickedIds.Count}\"); ObserversRoomDetailsKickedIdsUpdated(RoomDetails.KickedIds); break; case RoomDetails.WhichField.EPlayerCharacters: sb.Append($\"PlayerCharacters: {RoomDetails.PlayerCharacters.Count}\"); _syncRoomDetailsPlayerCharacters.Clear(); foreach (var nob in RoomDetails.PlayerCharacters) { _syncRoomDetailsPlayerCharacters.Add(nob); } ObserversRoomDetailsPlayerCharactersUpdated(RoomDetails.PlayerCharacters.ToList()); break; } Debug.Log(sb.ToString()); } [ObserversRpc(BufferLast = true, ExcludeServer = true)] protected void ObserversRoomDetailsMemberIdsUpdated(List<NetworkObject> roomDetailsMemberIds) { Debug.Log($\"{ClassAndRoomName} ObserversRoomDetailsMemberIdsUpdated {roomDetailsMemberIds.Count}\"); RoomDetails.SetMemberIds(roomDetailsMemberIds); } [ObserversRpc(BufferLast = true, ExcludeServer = true)] protected void ObserversRoomDetailsNameUpdated(string roomName) { Debug.Log($\"{ClassAndRoomName} ObserversRoomDetailsNameUpdated {roomName}\"); RoomDetails.SetName(roomName); } [ObserversRpc(BufferLast = true, ExcludeServer = true)] protected void ObserversRoomDetailsStartedMembersUpdated(List<NetworkObject> startedMembers) { Debug.Log($\"{ClassAndRoomName} ObserversRoomDetailsStartedMembersUpdated {startedMembers.Count}\"); RoomDetails.SetStartedMembers(startedMembers); } [ObserversRpc(BufferLast = true, ExcludeServer = true)] protected void ObserversRoomDetailsIsTeamsModeUpdated(bool isTeamsMode) { Debug.Log($\"{ClassAndRoomName} ObserversRoomDetailsIsTeamsModeUpdated {isTeamsMode}\"); RoomDetails.SetIsTeamsMode(isTeamsMode); } [ObserversRpc(BufferLast = true, ExcludeServer = true)] protected void ObserversRoomDetailsTeamsUpdated(List<RoomDetails.Team> teams) { Debug.Log($\"{ClassAndRoomName} ObserversRoomDetailsTeamsUpdated {teams.Count}\"); RoomDetails.SetTeams(teams); } [ObserversRpc(BufferLast = true, ExcludeServer = true)] protected void ObserversRoomDetailsKickedIdsUpdated(List<NetworkObject> kickedIds) { Debug.Log($\"{ClassAndRoomName} ObserversRoomDetailsKickedIdsUpdated {kickedIds.Count}\"); RoomDetails.SetKickedIds(kickedIds); } [ObserversRpc(BufferLast = true, ExcludeServer = true)] protected void ObserversRoomDetailsPlayerCharactersUpdated(List<NetworkObject> playerCharacters) { Debug.Log($\"{ClassAndRoomName} ObserversRoomDetailsPlayerCharactersUpdated {playerCharacters.Count}\"); RoomDetails.SetPlayerCharacters(playerCharacters); } #endregion [ServerRpc(RequireOwnership = false)] protected void IsServerHaveThatObject(int objectId, NetworkConnection conn = null) { NetworkObject nob = GetNetworkObject(objectId); if (nob != null) { IsServerHaveThatObjectResult(conn, true, nob, objectId); } IsServerHaveThatObjectResult(conn, false, null, objectId); } [TargetRpc] protected void IsServerHaveThatObjectResult(NetworkConnection conn, bool isOk, NetworkObject nob, int objectId) { if (isOk) { DebugWrite.Log($\"{ClassAndRoomName} network object with id {nob.ObjectId} is persist on server\", gameObject, _isDebug); } else { DebugWrite.LogError($\"{ClassAndRoomName} Server could not find network object with id {objectId}.\", gameObject, _isDebug); } } [ItemCanBeNull] protected NetworkObject GetNetworkObject(int objectId, bool isShowError = true) { NetworkObject networkObject = null; if (base.IsServer) { if (InstanceFinder.ServerManager.Objects.Spawned.ContainsKey(objectId)) { networkObject = InstanceFinder.ServerManager.Objects.Spawned[objectId]; } else { if (isShowError) DebugWrite.LogError($\"{ClassAndRoomName} Could not find network object with id {objectId}.\", gameObject, _isDebug); } } else { if (InstanceFinder.ClientManager.Objects.Spawned.ContainsKey(objectId)) { networkObject = InstanceFinder.ClientManager.Objects.Spawned[objectId]; } else { if (isShowError) DebugWrite.LogError($\"{ClassAndRoomName} Could not find network object with id {objectId}.\", gameObject, _isDebug); //IsServerHaveThatObject(objectId); } } if (networkObject != null) { return networkObject; } else { return null; if (isShowError) DebugWrite.LogError($\"{ClassAndRoomName} Could not find network object with id {objectId}.\"); } return null; } /// <summary> /// Called when a client leaves the room. /// </summary> /// <param name=\"arg1\"></param> /// <param name=\"arg2\"></param> protected void LobbyNetwork_OnClientLeftRoom(RoomDetails arg1, NetworkObject arg2) { //Destroy all of clients objects, except their client instance. for (int i = 0; i < UnitCharacters.Count; i++) { NetworkObject entry = GetNetworkObject(UnitCharacters[i]); //Entry is null. Remove and iterate next. if (entry == null) { _spawnedUnitObjects.RemoveAt(i); i--; continue; } //If same connection to client (owner) as client instance of leaving player. if (entry.Owner == arg2.Owner) { //Destroy entry then remove from collection. Debug.Log($\"{ClassAndRoomName} Destroying client object {entry.name} #{entry.ObjectId}.\"); entry.Despawn(); _spawnedUnitObjects.RemoveAt(i); i--; } } } /// <summary> /// Called when a client starts a game. /// </summary> /// <param name=\"roomDetails\"></param> /// <param name=\"client\"></param> protected void LobbyNetwork_OnClientStarted(RoomDetails roomDetails, NetworkObject client) { //Not for this room. if (roomDetails != RoomDetails) return; //NetIdent is null or not a player. if (client == null || client.Owner == null) return; Debug.Log($\"{ClassAndRoomName} Order Client #{client.ObjectId} to load his local game scene\"); client.GetComponent<ClientSceneHandler>().RpcClientLoadRoomScene(client.Owner); } /// <summary> /// Called when player finishes loading his own local game scene. Is not calling in Dungeon mode. /// </summary> /// <param name=\"conn\"></param> [ServerRpc(RequireOwnership = false)] public void CmdClientLoadedGameSceneNotifier(NetworkConnection conn = null) { Debug.Log($\"{ClassAndRoomName} Client #{conn.ClientId} loaded game scene.\"); if (IsClientAlreadySpawned(conn)) return; /* POSSIBLY USEFUL INFORMATION!!!!! * POSSIBLY USEFUL INFORMATION!!!!! * If you want to wait until all players are in the scene * before spaning then check if roomDetails.StartedMembers.Count * is the same as roomDetails.MemberIds.Count. A member is considered * started AFTER they have loaded all of the scenes. */ if (IsHost) _playerSpawnManager.SpawnPlayer(conn); } protected bool IsClientAlreadySpawned(NetworkConnection conn) { foreach (var heroNob in SpawnedPlayerHeroes) { if (heroNob.Owner == conn) { //Debug.Log($\"{ClassAndRoomName} Client #{conn.ClientId} is already spawned.\"); return true; } } return false; } #region Death. /// <summary> /// Called when object exits trigger. Used to respawn players. /// </summary> /// <param name=\"other\"></param> protected void OnTriggerExit(Collider other) { if (!base.IsServer) return; NetworkObject netIdent = other.gameObject.GetComponent<NetworkObject>(); //If doesn't have a netIdent or no owning client exit. if (netIdent == null || netIdent.Owner == null) return; //If there is an owning client then destroy the object and respawn. StartCoroutine((__DelayRespawn(netIdent))); } /// <summary> /// Destroys netIdent and respawns player after delay. /// </summary> /// <param name=\"netIdent\"></param> /// <returns></returns> protected IEnumerator __DelayRespawn(NetworkObject netIdent) { //Send Rpc to spawn death dummy then destroy original. RpcSpawnDeathDummy(netIdent.transform.position); NetworkConnection conn = netIdent.Owner; InstanceFinder.ServerManager.Despawn(netIdent.gameObject); //Wait a little to respawn player. yield return new WaitForSeconds(3f); //Don't respawn if someone won. if (_winner) yield break; /* Check for rage quit conditions (left room). */ if (conn == null) yield break; ClientInstance ci = ClientInstance.GetClientInstance(conn); if (ci == null || !RoomDetails.StartedMembers.Contains(ci.NetworkObject)) yield break; //SpawnPlayer(conn); } /// <summary> /// Spawns a dummy player to show death. /// </summary> /// <param name=\"player\"></param> [ObserversRpc] protected void RpcSpawnDeathDummy(Vector3 position) { GameObject go = Instantiate(_deathDummy, position, Quaternion.identity); UnitySceneManager.MoveGameObjectToScene(go, gameObject.scene); Destroy(go, 1f); } #endregion #region Spawns [Server] public void SpawnHealSphere(Vector3 position) { HealthSphereController sphere = Instantiate(_healthSpherePrefab, position, Quaternion.identity); Spawn(sphere.gameObject); sphere.InitServer(this, \"HealSphere\", position, Vector3.zero); } [Server] public void SpawnBookExp(Vector3 position) { BookExpController book = Instantiate(_BookExpPrefab, position, Quaternion.identity); Spawn(book.gameObject); book.InitServer(this, \"Book Exp\", position, Vector3.zero); } #endregion #region Winning. [Server] protected IEnumerator DelayedSpawnEscapePortalsAfterTime(float time) { yield return new WaitForSeconds(time); foreach (var point in _respawnManager.PortalPoints) { SpawnEscapePortal(point); yield return new WaitForSeconds(5f * 60f); } } [Server] public void SpawnEscapePortal(Vector3 position) { EscapePortalController portal = Instantiate(_escapePortalPrefab, position, Quaternion.identity); Spawn(portal.gameObject); portal.InitServer(this, \"EscapePortal\", position, Vector3.zero); } #endregion protected UnitComponents SaveUnitComponents(NetworkObject nob) { if (UnitComponentsDict.ContainsKey(nob.ObjectId)) return UnitComponentsDict[nob.ObjectId]; UnitComponents unitComps = new UnitComponents(nob); UnitComponentsDict.Add(nob.ObjectId, unitComps); AddToSpawnedUnits(nob); return unitComps; } private void AddToSpawnedUnits(NetworkObject nob) { if (!_spawnedUnitObjects.Contains(nob.ObjectId)) { Debug.Log($\"{ClassAndRoomName} {nob.name} added to _spawnednitObjects\", nob); _spawnedUnitObjects.Add(nob.ObjectId); } } public UnitComponents GetUnitComponents(NetworkObject nob) { if (UnitComponentsDict.ContainsKey(nob.ObjectId)) return UnitComponentsDict[nob.ObjectId]; UnitComponents unitComps = new UnitComponents(nob); UnitComponentsDict.Add(nob.ObjectId, unitComps); AddToSpawnedUnits(nob); return unitComps; } [Server] public UnitComponents SavePlayerToRoom(NetworkObject playerNob) { NetworkConnection conn = playerNob.Owner; ClientInstance ci = ClientInstance.GetClientInstance(conn); AddToSpawnedUnits(playerNob); SpawnedPlayerHeroes.Add(playerNob); RoomDetails.AddPlayerCharacter(playerNob); var unitComps = SaveUnitComponents(playerNob); ci.StoreHero(unitComps); GetUnitTeamId(playerNob.ObjectId); unitComps.InvectorManager.SetupGameplayManager(this); unitComps.HealthController.GameplayManager = this; unitComps.InvectorManager.OnPlayerPositionChanged += FishnetInvectorManager_OnPlayerPositionChanged; RegisterDamageReceivers(unitComps.HealthController.DamageReceivers, unitComps.HealthController); Debug.Log($\"{ClassAndRoomName} Player #{playerNob.Owner.ClientId} {playerNob.name} saved to room.\"); OnPlayerJoinedRoom?.Invoke(playerNob); return unitComps; } [Server] public void SaveNpcToRoom(NetworkObject npcNob) { AddToSpawnedUnits(npcNob); var unitComps = SaveUnitComponents(npcNob); GetUnitTeamId(npcNob.ObjectId); unitComps.HealthController.GameplayManager = this; Collider[] damageReceivers = unitComps.HealthController.DamageReceivers; FishnetInvectorHealthController healthController = unitComps.HealthController; RegisterDamageReceivers(damageReceivers, healthController); } public void RegisterDamageReceivers(Collider[] damageReceivers, FishnetInvectorHealthController healthController) { for (int i = 0; i < damageReceivers.Length; i++) { RegisterCollider(damageReceivers[i], healthController); } } #region Spawning. [Server] public void InitIfAllPlayersSpawned() { if (RoomDetails.PlayerCharacters.Count == RoomDetails.MemberIds.Count) { _isAllPlayersSpawned = true; OnAllPlayersSpawned?.Invoke(); } } public virtual Vector3 GetAvailableSpawnPosition(NetworkConnection conn) { if (RoomDetails.IsTeamsMode) { int teamId; foreach (RoomDetails.Team team in RoomDetails.Teams) { for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] == null) continue; if (team.Slots[i].Owner != conn) continue; teamId = RoomDetails.Teams.IndexOf(team); DebugWrite.Log($\"{ClassAndRoomName} Found in team #{teamId} for client #{conn.ClientId}\", gameObject, _isDebug); if (SpawnPointsForPlayers[teamId] != null) return SpawnPointsForPlayers[teamId] + Vector3.left + Vector3.right * i; else { DebugWrite.LogError($\"{ClassAndRoomName} Could not find spawn point for team #{teamId} for client #{conn.ClientId}\", gameObject, _isDebug); return SpawnPointsForPlayers[0]; } } } if (!IsHost) DebugWrite.LogError($\"{ClassAndRoomName} Could not find team for client #{conn.ClientId}\", gameObject, _isDebug); } Vector3 spawnPosition = Vector3.zero; if (SpawnPointsForPlayers.Count == 0) { Debug.LogError($\"{ClassAndRoomName} CRITICAL ERROR!!! No spawn points for players.\", gameObject); } else { spawnPosition = SpawnPointsForPlayers.FirstOrDefault(); _spawnPointsForPlayers.Remove(spawnPosition); Debug.Log($\"{ClassAndRoomName} Removed spawn point {spawnPosition} from spawn points list. {SpawnPointsForPlayers.Count} left.\"); } return spawnPosition; } /// <summary> /// Draw spawn region. /// </summary> protected void OnDrawGizmosSelected() { Gizmos.DrawWireCube(transform.position, _spawnRegion); } #endregion public void GetPlayerHeroComponentsServerAndClient(NetworkConnection conn, Action<UnitComponents> callback) { Debug.Log($\"{ClassAndRoomName} GetPlayerHeroComponentsServerAndClient\"); foreach (var hero in UnitCharacters) { if (GetNetworkObject(hero).Owner == conn) callback(GetUnitComponentsServerAndClient(GetNetworkObject(hero).ObjectId)); } StartCoroutine(CheckGetUnitComponentsServerAndClient(conn)); OnSpawnedUnitObjectsChanged += (spawnedUnitId) => { var nob = GetNetworkObject(spawnedUnitId); if (nob == null) { return; } if (nob.Owner == conn) { callback(GetUnitComponentsServerAndClient(spawnedUnitId)); Debug.Log($\"{ClassAndRoomName} PlayerComponents found for client #{conn.ClientId}. Callback called = #{spawnedUnitId}.\"); } }; } public UnitComponents GetPlayerHeroComponentsServerAndClient(NetworkConnection conn, bool isShowError = true) { foreach (var hero in UnitCharacters) { var possibleHero = GetNetworkObject(hero); if (possibleHero != null && possibleHero.Owner == conn) return GetUnitComponentsServerAndClient(GetNetworkObject(hero).ObjectId); } if (isShowError) Debug.LogError($\"{ClassAndRoomName} PlayerComponents not found for client #{conn.ClientId}\"); return null; } protected IEnumerator CheckGetUnitComponentsServerAndClient(NetworkConnection conn = null, int objectId = -1) { StringBuilder sb = new StringBuilder($\"{ClassAndRoomName} CheckGetUnitComponentsServerAndClient \"); float timePassed = 0f; bool isFound = false; bool asClient = conn != null; if (asClient) sb.Append($\"asClient \"); else sb.Append($\"asServer \"); while (timePassed < 20f && isFound == false) { foreach (var hero in UnitCharacters) { var nob = GetNetworkObject(hero, false); if (nob == null) continue; if (objectId > 0) { sb.Append($\"Checking for PlayerComponents for client #{objectId}. Timeout {timePassed} secs.\"); isFound = nob.ObjectId == objectId; if (isFound) sb.Append($\"found for object id #{objectId}. Timeout {timePassed} secs.\"); } else { sb.Append($\"Checking for PlayerComponents for client conn #{conn.ClientId}. Timeout {timePassed} secs.\"); isFound = nob.Owner == conn; if (isFound) sb.Append($\"found for object id #{objectId}. Timeout {timePassed} secs.\"); } } Debug.Log(sb.ToString()); yield return new WaitForSeconds(1f); timePassed += 1f; } Debug.LogError($\"{ClassAndRoomName} PlayerComponents not found for client #{conn.ClientId}. Timeout {timePassed} secs.\"); } public void GetUnitComponentsServerAndClient(int objectId, Action<UnitComponents> callback) { Debug.Log($\"{ClassAndRoomName} GetUnitComponentsServerAndClient\"); foreach (var hero in UnitCharacters) { var nob = GetNetworkObject(hero, false); if (nob != null && nob.ObjectId == objectId) callback(GetUnitComponentsServerAndClient(GetNetworkObject(hero).ObjectId)); } StartCoroutine(CheckGetUnitComponentsServerAndClient(null, objectId)); OnSpawnedUnitObjectsChanged += (spawnedUnitId) => { var nob = GetNetworkObject(spawnedUnitId); if (nob == null) { return; } if (nob.ObjectId == objectId) { callback(GetUnitComponentsServerAndClient(spawnedUnitId)); Debug.Log($\"{ClassAndRoomName} PlayerComponents found for object #{objectId}. Callback called = #{spawnedUnitId}.\"); } }; } public static UnitComponents GenerateUnitCompsForMe(NetworkObject obj) { if (!UnitComponentsDict.ContainsKey(obj.ObjectId)) { var pc = new UnitComponents(obj); UnitComponentsDict.Add(obj.ObjectId, pc); OnUnitComponentsCreated?.Invoke(obj.Owner, obj, pc); Debug.Log($\"[GameplayManager] UnitComponents created for object #{obj.ObjectId}\"); return pc; } else { return UnitComponentsDict[obj.ObjectId]; } } public UnitComponents GetUnitComponentsServerAndClient(int targetId) { if (targetId == -1) return null; if (!UnitComponentsDict.ContainsKey(targetId)) { Dictionary<int, NetworkObject> allObjects = null; if (base.IsClient) allObjects = InstanceFinder.ClientManager.Objects.Spawned; else allObjects = InstanceFinder.ServerManager.Objects.Spawned; if (allObjects.ContainsKey(targetId)) { NetworkObject netObj = allObjects[targetId]; var pc = new UnitComponents(netObj); UnitComponentsDict.Add(targetId, pc); Debug.Log($\"[GameplayManager] UnitComponents created for object #{targetId}\"); } else { Debug.LogError($\"{ClassAndRoomName} targetId:{targetId} not found in spawned objects\"); return null; } } return UnitComponentsDict[targetId]; } public NetworkObject GetUnitNob(int objectId) { int objectIdFromUnits = UnitCharacters.Find(x => x == objectId); DebugWrite.Log($\"{ClassAndRoomName} Found unit #{objectIdFromUnits} in UnitCharacters\", gameObject, _isDebug); NetworkObject netObj = GetNetworkObject(objectIdFromUnits); if (netObj != null) DebugWrite.Log($\"{ClassAndRoomName} Found netObj #{netObj.name} from ClientManager.Objects.Spawned[{objectIdFromUnits}];\", gameObject, _isDebug); return netObj; } public List<NetworkObject> GetAllPlayersHeroes() { List<NetworkObject> playersHeroes = new List<NetworkObject>(); foreach (var unitId in UnitCharacters) { var unitNob = GetUnitNob(unitId); if (unitNob == null) continue; if (!unitNob.CompareTag(\"Player\")) continue; DebugWrite.Log($\"{ClassAndRoomName} Found PlayerNob for client #{unitNob.OwnerId}\", gameObject, _isDebug); playersHeroes.Add(unitNob); } return playersHeroes; } [Server] public NetworkObject GetPlayerNob(NetworkConnection conn) { foreach (var connObject in conn.Objects) { foreach (var unitId in UnitCharacters) { if (connObject.ObjectId == unitId) { if (connObject.CompareTag(\"Player\")) { DebugWrite.Log($\"{ClassAndRoomName} Found PlayerNob for client #{conn.ClientId}\", gameObject, _isDebug); return connObject; } } } } DebugWrite.LogError($\"{ClassAndRoomName} PlayerNob not found for client #{conn.ClientId}\", gameObject, _isDebug); return null; } [ItemCanBeNull] public List<NetworkObject> GetAliveAIControlledNobs() { List<NetworkObject> aiControlledNobs = new List<NetworkObject>(); foreach (var unit in UnitCharacters) { NetworkObject unitNob = GetNetworkObject(unit, false); if (unitNob == null) continue; for (int i = 0; i < SERVER_AI_CONTROLLED_TAGS.Length; i++) { if (!unitNob.gameObject.CompareTag(SERVER_AI_CONTROLLED_TAGS[i])) continue; var unitComps = SaveUnitComponents(unitNob); if (unitComps.HealthController.IsDead) continue; aiControlledNobs.Add(unitNob); } } if (aiControlledNobs.Count > 0) return aiControlledNobs; else { //Debug.Log($\"{ClassAndRoomName} No AI controlled nobs found.\"); return null; } } [ItemCanBeNull] public List<NetworkObject> GetAIControlledNobs() { List<NetworkObject> aiControlledNobs = new List<NetworkObject>(); foreach (var unit in UnitCharacters) { NetworkObject unitNob = GetNetworkObject(unit, false); if (unitNob == null) continue; for (int i = 0; i < SERVER_AI_CONTROLLED_TAGS.Length; i++) { if (unitNob.gameObject.CompareTag(SERVER_AI_CONTROLLED_TAGS[i])) aiControlledNobs.Add(unitNob); } } if (aiControlledNobs.Count > 0) return aiControlledNobs; else { //Debug.Log($\"{ClassAndRoomName} No AI controlled nobs found.\"); return null; } } public void RemoveFromUnitComponents() { foreach (var nobs in UnitCharacters) { int netId = nobs; if (UnitComponentsDict.ContainsKey(netId)) { UnitComponentsDict.Remove(netId); } } } /* Like SyncVars the callback offers an asServer option * to indicate if the callback is occurring on the server * or the client. As SyncVars do, changes have already been * made to the collection before the callback occurs. */ protected void SpawnedUnitObjectsOnChange(SyncListOperation op, int index, int oldItem, int newItem, bool asServer) { switch (op) { /* An object was added to the list. Index * will be where it was added, which will be the end * of the list, while newItem is the value added. */ case SyncListOperation.Add: OnSpawnedUnitObjectsChanged?.Invoke(newItem); DebugWrite.Log($\"{ClassAndRoomName} SpawnedUnitObjectsOnChange: {newItem} added to list at index {index}\"); break; /* An object was removed from the list. Index * is from where the object was removed. oldItem * will contain the removed item. */ case SyncListOperation.RemoveAt: DebugWrite.Log($\"{ClassAndRoomName} SpawnedUnitObjectsOnChange: {oldItem} removed from list at index {index}\"); break; /* An object was inserted into the list. Index * is where the obejct was inserted. newItem * contains the item inserted. */ case SyncListOperation.Insert: DebugWrite.Log($\"{ClassAndRoomName} SpawnedUnitObjectsOnChange: {newItem} inserted into list at index {index}\"); break; /* An object replaced another. Index * is where the object was replaced. oldItem * is the item that was replaced, while * newItem is the item which now has it's place. */ case SyncListOperation.Set: DebugWrite.Log($\"{ClassAndRoomName} SpawnedUnitObjectsOnChange: {oldItem} replaced with {newItem} at index {index}\"); break; /* All objects have been cleared. Index, oldValue, * and newValue are default. */ case SyncListOperation.Clear: DebugWrite.Log($\"{ClassAndRoomName} SpawnedUnitObjectsOnChange: list cleared\"); break; /* When complete calls all changes have been * made to the collection. You may use this * to refresh information in relation to * the list changes, rather than doing so * after every entry change. Like Clear * Index, oldItem, and newItem are all default. */ case SyncListOperation.Complete: Debug.Log($\"{ClassAndRoomName} SpawnedUnitObjectsOnChange: list changes complete\"); break; } } protected void _teams_TeamsOnChange(SyncDictionaryOperation op, int index, RoomDetails.Team newItem, bool asServer) { StringBuilder sb = new StringBuilder($\"[GameplayManager][_teams_TeamsOnChange] {op} \"); if (asServer) sb.Append(\"asServer \"); else sb.Append(\"asClient \"); switch (op) { case SyncDictionaryOperation.Add: break; case SyncDictionaryOperation.Set: break; case SyncDictionaryOperation.Clear: break; case SyncDictionaryOperation.Complete: return; break; } sb.Append($\"teamId: {index}; \"); for (int i = 0; i < newItem.Slots.Length; i++) { if (newItem.Slots[i] != null) sb.Append($\"member[{i}]: {newItem.Slots[i].name}; \"); } Debug.Log(sb.ToString()); } [Server] protected IEnumerator GenerateEscapePoint() { while (true) { yield return new WaitForSeconds(SPAWN_POINT_GENERATION_TIME); int randomIndex = UnityEngine.Random.Range(0, _escapePoints.Count); EscapeCitySource escapePoint = Instantiate(_escapeCitySourcePrefab, _escapePoints[randomIndex], Quaternion.identity); escapePoint.Init(this); Debug.Log($\"{ClassAndRoomName} EscapePoint generated at {_escapePoints[randomIndex]}\"); } } [Server] public void RpcWinForPlayer(NetworkConnection conn = null) { DebugWrite.Log($\"{ClassAndRoomName} RpcWinForPlayer from client #{conn.ClientId}\", gameObject, _isDebug); NetworkObject playerHero = GetPlayerNob(conn); ServerInventoryBackup.Instance.SavePlayerSuccessfullEscape(playerHero); WinForPlayer(conn); ClientInstance cli = ClientInstance.GetClientInstance(conn); TargetLoadMainMenu(conn); DespawnPlayer(cli); Debug.Log($\"{ClassAndRoomName} Player #{cli.OwnerId} has escaped\"); cli.Owner.Disconnect(true); //if (cli != null) _lobbyNetwork.TryLeaveRoom(cli.NetworkObject); } [TargetRpc] private void TargetLoadMainMenu(NetworkConnection conn) { UnitySceneManager.LoadScene(\"Main\"); } protected void DespawnPlayer(ClientInstance cli) { if (cli == null) return; var playerHero = cli.PlayerHero.HealthController; SpawnedPlayerHeroes.Remove(playerHero.NetworkObject); playerHero.Despawn(); } [TargetRpc] public void WinForPlayer(NetworkConnection conn = null) { DebugWrite.Log($\"{ClassAndRoomName} WinForPlayer\", gameObject, _isDebug); _winCanvasGroup.Show(); StartCoroutine(ThrowPlayerFromRoom()); } [Client] protected IEnumerator ThrowPlayerFromRoom() { yield return new WaitForSeconds(THROW_TO_MAIN_MENU_TIMER); MainMenuCamera.ActivateMainMenuCamera(); //throw player from room } [TargetRpc] public void LoseForPlayer(NetworkConnection conn = null) { _looseCanvasGroup.Show(); } [ServerRpc(RequireOwnership = false)] public void CmdClientFinishedLoadingGPM(NetworkConnection sender = null) { if (!IsHost) Debug.Log($\"{ClassAndRoomName} CmdClientLoadedDungeon from client #{sender.ClientId}\", gameObject); AddPlayerToLoadedList(sender); } [Server] public void PopulateSpawnPoints(List<Vector3> spawnPositions) { _spawnPointsForPlayers = spawnPositions; StringBuilder sb = new StringBuilder($\"{ClassAndRoomName} added spawn points for players: \"); foreach (var pos in _spawnPointsForPlayers) { sb.Append($\"{pos}; \"); } Debug.Log(sb.ToString()); } [Server] public void AddPlayerToLoadedList(NetworkConnection sender) { Debug.Log($\"{ClassAndRoomName} AddPlayerToLoadedList _connectionsToSpawn++ {_connectionsToSpawn.Count}\", gameObject); _connectionsToSpawn.Add(sender); if (!IsHost) Debug.Log($\"{ClassAndRoomName} Client #{sender.ClientId} loaded game scene.\"); } [Server] protected IEnumerator SpawnPlayersThatLoadedDungeon() { var cooldownTime = 5f; yield return new WaitUntil(() => SpawnPointsForPlayers.Count > 0); while (true) { if (_connectionsToSpawn.Count < NUMBER_OF_PLAYERS_BEFORE_SPAWN) { yield return cooldownTime; } yield return new WaitForSeconds(cooldownTime - 1f); var copyConnectionsToSpawn = new List<NetworkConnection>(_connectionsToSpawn); foreach (var conn in copyConnectionsToSpawn) { if (SpawnPointsForPlayers.Count < 1) { Debug.LogError($\"{ClassAndRoomName} Not enough spawn points to spawn players\"); continue; } if (!IsClientAlreadySpawned(conn)) _playerSpawnManager.SpawnPlayer(conn); } yield return cooldownTime; } } [Server] protected void FishnetInvectorManager_OnPlayerPositionChanged(NetworkObject player, Vector3 newPos) { int objectId = player.ObjectId; if (_playerPositions.ContainsKey(objectId)) { if (player == null) { _playerPositions.Remove(objectId); return; } _playerPositions[objectId] = newPos; } else { _playerPositions.Add(objectId, newPos); } } public void RegisterCollider(Collider which, FishnetInvectorHealthController healthController) { if (!_collidersToHealthControllers.ContainsKey(which)) { _collidersToHealthControllers.Add(which, healthController); } } public FishnetInvectorHealthController GetHealthController(Collider collider) { if (_collidersToHealthControllers.ContainsKey(collider)) { return _collidersToHealthControllers[collider]; } //Debug.Log($\"{ClassAndRoomName} No health controller found for collider {collider.name}\", collider); return null; } [ServerRpc(RequireOwnership = false)] public void CmdRegisterMeleeHitDamage(int targetId, FNvDamage fnvDamage) { string logText = $\"{ClassAndRoomName} CmdRegisterDamage SwingCounter: {fnvDamage.SwingCounter}; inputDamage: {fnvDamage.damageValue}\"; vDamage damage = fnvDamage.ToVDamage(); var unitComponents = GetUnitComponentsServerAndClient(targetId); unitComponents.HealthController.TakeDamage(damage); Debug.Log(logText); } /// <summary> /// Called when AI hit player /// </summary> /// <param name=\"npcObjectId\"></param> /// <param name=\"targetObjectId\"></param> /// <param name=\"bodyMemberId\"></param> /// <param name=\"hitPosition\"></param> /// <param name=\"sender\"></param> [ServerRpc(RequireOwnership = false)] public void CmdRegisterHitByAI(int npcObjectId, int targetObjectId, int bodyMemberId, Vector3 hitPosition, NetworkConnection sender = null) { Debug.Log($\"{ClassAndRoomName} RegisterHitByAI AI id: {npcObjectId}; targetUnitId: {targetObjectId}; hitPosition: {hitPosition}; sender: {sender}\"); NetworkObject npc = GetUnitNob(npcObjectId); var dealerUnitComps = SaveUnitComponents(npc); UnitComponents targetUnitComps = null; vMeleeAttackObject damageDealingSource = dealerUnitComps.MeleeManager.Members[bodyMemberId].attackObject; vDamage damage = new vDamage(); damage.Copy(damageDealingSource.damage); damage.hitPosition = hitPosition; damage.Sender = npc.transform; damage.senderNetworkObjectID = npcObjectId; if (targetObjectId > 0) { targetUnitComps = GetUnitComponentsServerAndClient(targetObjectId); } else { Debug.LogError($\"{ClassAndRoomName} RegisterHitByAI targetUnitId: {targetObjectId} targetUnitComps is null\"); } targetUnitComps.HealthController.TakeDamage(damage); } [Server] public void RemoveDespawnedUnit(NetworkObject nob) { _spawnedUnitObjects.Remove(nob.ObjectId); } public Transform GetTargetTransformServerAndClient(int targetId) { var unitComps = GetUnitComponentsServerAndClient(targetId); return unitComps.HealthController.transform; } [Server] public virtual void DropLootBag(AIUnit aiUnit) { float chanceMod = aiUnit.EnemyDefinition.LootBagChanceMod; CratesSystem.Zone zone = aiUnit.EnemyDefinition.LootBagZone; int itemsCount = aiUnit.EnemyDefinition.LootBagItemsCount; List<ItemReference> items = _lootDropSystem.GenerateLoot(aiUnit.EnemyDefinition.ItemsDropChances, aiUnit.EnemyDefinition.LootBagItemsCount, aiUnit.EnemyDefinition.LootBagChanceMod); _lootDropSystem.AddGoldDrop(aiUnit.EnemyDefinition.GoldDropChance, aiUnit.EnemyDefinition.MinGoldDrop, aiUnit.EnemyDefinition.MaxGoldDrop, ref items); //generate random pos in circle around unit with radius 1 var randomPosInCircleWorld = Unit.GetRandomPosInCircleShapeAround(aiUnit.transform.position, 1f); //_lootDropSystem.DropLootBag(items, aiUnit.transform.position, chanceMod, zone, itemsCount); _lootDropSystem.DropLootItems(items, aiUnit.transform.position); } [field: SerializeField] public int Seed => (int)_dungeonNetworkManager.Seed; protected void GenerateRandomIfNeed() { _random ??= new System.Random((int)_dungeonNetworkManager.Seed); } public int GetRandomInt(int min, int max) { GenerateRandomIfNeed(); return _random.Next(min, max); } public int GetRandomInt() { GenerateRandomIfNeed(); return _random.Next(); } public byte GetRandomByte() { GenerateRandomIfNeed(); return (byte)_random.Next(); } public float GetRandomFloat(float min, float max) { GenerateRandomIfNeed(); return (float)_random.NextDouble() * (max - min) + min; } #if UNITY_EDITOR public void SetPlayerPrefab(NetworkObject newPrefab) { _playerPrefab = newPrefab; } public void ChangeDungeonLoadingFromSave(bool isOn) { IsLoadDungeonFromSave = isOn; } #endif public static bool IsOwningPlayer(Collider other) { if (!other.CompareTag(\"Player\")) return false; var health = Instance.GetHealthController(other); if (health == null) return false; return health.IsOwner; } public int GetUnitTeamId(int objectId) { if (!unitToTeamId.ContainsKey(objectId)) { var unitComps = GetUnitComponentsServerAndClient(objectId); if (unitComps == null) return -1; if (unitComps.AIUnit != null) { if (unitComps.AIUnit.CompareTag(SERVER_AI_CONTROLLED_TAGS[MONSTER_TAG_ID])) { unitToTeamId.Add(objectId, MONSTER_TEAM_ID); } else//Player controlled AI { int teamId = GetOwningPlayerTeamId(objectId); unitToTeamId.Add(objectId, teamId); } } else// Player { if (unitComps.HealthController.CompareTag(\"Player\")) { if (isTeamsMode) { foreach (var team in RoomDetails.Teams) { for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] == null) continue; if (team.Slots[i].GetComponent<ClientInstance>().PlayerHero.InvectorManager.ObjectId == objectId) { unitToTeamId.Add(objectId, RoomDetails.Teams.IndexOf(team)); } } } } else { unitToTeamId.Add(objectId, unitComps.HealthController.Owner.ClientId); } } } } return unitToTeamId[objectId]; } private int GetOwningPlayerTeamId(int objectId) { //TODO Implement return 0; } public static float GetCurrentServerTime() { return (float)InstanceFinder.TimeManager.TicksToTime(InstanceFinder.TimeManager.Tick); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "GameplayManager",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": " #if UNITY_EDITOR #endif using System; using System.Collections; using System.Collections.Generic; using System.Linq; using System.Text; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Clients; using FirstGearGames.LobbyAndWorld.Lobbies; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using FishNet; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using FishNet.Transporting; using FishnetInvector; using InRoomSystems; using Invector; using Invector.vItemManager; using Invector.vMelee; using JetBrains.Annotations; using My; using ParrelSync; using Pathfinding.RVO; using UnityEngine; using UnityEngine.AddressableAssets; using UnityEngine.ResourceManagement.AsyncOperations; using Zomb; using Zomb.Creatures.Module; using UnitySceneManager = UnityEngine.SceneManagement.SceneManager; using Random = UnityEngine.Random; namespace _ZombieRoyale.Scripts.Core { public class GameplayManager : NetworkBehaviour { // Serialized [Header(\"Spawning\")] /// <summary> /// Region players may spawn. /// </summary> [Tooltip(\"Region players may spawn.\")] [SerializeField] protected Vector3 _spawnRegion = Vector3.one; public List<Vector3> SpawnPointsForPlayers => _spawnPointsForPlayers; protected List<Vector3> _spawnPointsForPlayers = new List<Vector3>(); /// <summary> /// Prefab to spawn. /// </summary> [Tooltip(\"Prefab to spawn.\")] public NetworkObject PlayerPrefab => _playerPrefab; [SerializeField] protected NetworkObject _playerPrefab = null; public NetworkObject MalePrefab => _malePrefab; [SerializeField] protected NetworkObject _malePrefab; public NetworkObject FemalePrefab => _femalePrefab; [SerializeField] protected NetworkObject _femalePrefab; [SerializeField] protected bool isTeamsMode = false; public CreaturesFactory CreaturesFactory => _creaturesFactory; [SerializeField] protected CreaturesFactory _creaturesFactory; [SerializeField] protected EscapeCitySource _escapeCitySourcePrefab; [SerializeField] protected UICanvasGroupDecorator _winCanvasGroup; [SerializeField] protected UICanvasGroupDecorator _looseCanvasGroup; [SerializeField] protected List<Vector3> _escapePoints = new List<Vector3>(); [SerializeField] protected RVOSimulator _rvoSimulator; [SerializeField] protected EscapePortalController _escapePortalPrefab; [SerializeField] protected HealthSphereController _healthSpherePrefab; [SerializeField] protected BookExpController _BookExpPrefab; [SerializeField] protected RewardAbilityManager _rewardAbilityManager; [SerializeField] protected LootDropSystem _lootDropSystem; [SerializeField] protected ServerPlayerManager _serverPlayerManager; [SerializeField] protected DungeonNetworkManager _dungeonNetworkManager; [SerializeField] protected ObjectsRoomManager _objectsManager; [SerializeField] protected MyDungeonListener _dungeonListener; [SerializeField] protected OptimizeServerFromComponents _optimizeServerFromComponents; /// <summary> /// DeathDummy to spawn. /// </summary> [Tooltip(\"DeathDummy to spawn.\")] [SerializeField] protected GameObject _deathDummy = null; /// <summary> /// RoomDetails for this game. Only available on the server. /// </summary> public RoomDetails RoomDetails => _roomDetails.FirstOrDefault(); [SyncObject] protected readonly SyncHashSet<RoomDetails> _roomDetails = new (); [SyncObject] protected readonly SyncDictionary<int, RoomDetails.Team> _teams = new (); protected List<RoomDetails.Team> _lastTeams = new (); /// <summary> /// LobbyNetwork. /// </summary> protected LobbyNetwork _lobbyNetwork = null; /// <summary> /// Becomes true once someone has won. /// </summary> protected bool _winner = false; /// <summary> /// Currently spawned player objects. Synchronized between server and client. /// </summary> public SyncList<int> UnitCharacters => _spawnedUnitObjects; public SyncList<int> SpawnedUnitObjects => _spawnedUnitObjects; [SyncObject] protected readonly SyncList<int> _spawnedUnitObjects = new SyncList<int>(); public List<NetworkObject> SpawnedPlayerHeroes { get; protected set;} = new (); public Action<int> OnSpawnedUnitObjectsChanged; public Dictionary<int,Vector3> PlayerPositions => _playerPositions; protected Dictionary<int,Vector3> _playerPositions = new Dictionary<int, Vector3>(); public static Action<string, List<NetworkObject>> OnRoomDetailsUpdated; public static Action<NetworkObject> OnPlayerJoinedRoom; public Action<int> OnPlayerHeroSpawned; public static Action OnAllPlayersSpawned; protected RoomDataManagement _clientRoomDataManagement; protected static Dictionary<int, UnitComponents> UnitComponentsDict = new Dictionary<int, UnitComponents>(); protected static float SPAWN_POINT_GENERATION_TIME = 30f; protected string ClassAndRoomName => $\"[GPM][<color=#FFFF00>{RoomDetails.Name}</color>]\"; protected static string COLOR_INITIALIZATION = $\"<color=#00dd00>\"; public static string TAG_PLAYER = \"Player\"; public static string[] SERVER_AI_CONTROLLED_TAGS = new string[] { \"Enemy\" }; public static int MONSTER_TAG_ID = 0; public static int MONSTER_TEAM_ID = -2; protected const float THROW_TO_MAIN_MENU_TIMER = 5f; public string RoomName => RoomDetails.Name; public RewardAbilityManager RewardAbilityManager => _rewardAbilityManager; public LootDropSystem LootDropSystem => _lootDropSystem; /// <summary> /// for clients to find GPM in current room /// </summary> public static GameplayManager LocalPlayer => AllGameplayManagers.FirstOrDefault(); /// <summary> /// Mostly used by server, but can be used by clients too /// </summary> public static List<GameplayManager> AllGameplayManagers { get; protected set; } = new List<GameplayManager>(); protected static int NUMBER_OF_PLAYERS_BEFORE_SPAWN = 1; public List<NetworkConnection> ConnectionsToSpawn => _connectionsToSpawn; protected List<NetworkConnection> _connectionsToSpawn = new List<NetworkConnection>(); public AstarPath AstarPath => _astarPath; [SerializeField] protected AstarPath _astarPath; [field: SerializeField] public bool IsDungeonBuilt { get; protected set; } public Action OnDungeonBuilt; public Action OnServerOptimizationFinished; protected Dictionary<Collider, FishnetInvectorHealthController> _collidersToHealthControllers = new Dictionary<Collider,FishnetInvectorHealthController>(); public PhysicsSimulator PhysicsSimulator => _physicsSimulator; [SerializeField] protected PhysicsSimulator _physicsSimulator; protected bool _isDebug = false; public bool IsAllPlayersSpawned => _isAllPlayersSpawned; protected bool _isAllPlayersSpawned; protected System.Random _random = null; public float RoomStartTime { get; protected set; } protected RespawnManager _respawnManager; public static Action OnRoomReady; public static Action OnClientLoadedGameplayManager; public static Action OnLocalClientInitStarted; protected AbilityManager _abilityManager; protected BossLocationNotifier _bossLocationNotifier; [field:SerializeField] public bool IsLoadDungeonFromSave { get; protected set; } public static GameplayManager Instance { get; protected set; } public static Action<NetworkConnection, NetworkObject, UnitComponents> OnUnitComponentsCreated; public DungeonHolder DungeonHolder => _dungeonHolder; private DungeonHolder _dungeonHolder; private Dictionary<int,int> unitToTeamId = new Dictionary<int, int>(); protected PlayerSpawnManager _playerSpawnManager; /// <summary> /// [ServerRpc(RunLocally = true)] - метод выполнится на вызвавшем клиенте, не выполнится на сервере /// [ObserversRpc(RunLocally = true)] - метод выполнится на сервере и на вызвавшем клиенте /// </summary> protected override void OnValidate() { base.OnValidate(); _creaturesFactory ??= FindObjectOfType<CreaturesFactory>(); _rvoSimulator ??= FindObjectOfType<RVOSimulator>(); _rewardAbilityManager ??= FindObjectOfType<RewardAbilityManager>(); _lootDropSystem ??= FindObjectOfType<LootDropSystem>(); _serverPlayerManager ??= FindObjectOfType<ServerPlayerManager>(); _dungeonNetworkManager ??= FindObjectOfType<DungeonNetworkManager>(); _dungeonListener ??= FindObjectOfType<MyDungeonListener>(); _objectsManager ??= FindObjectOfType<ObjectsRoomManager>(); _optimizeServerFromComponents ??= GetComponent<OptimizeServerFromComponents>(); _astarPath ??= FindObjectOfType<AstarPath>(); } [Client] public void ReportDungeonBuilt() { IsDungeonBuilt = true; OnDungeonBuilt?.Invoke(); } /// Initialization and Deinitialization. protected void OnDestroy() { if (_lobbyNetwork != null) { _lobbyNetwork.OnClientJoinedRoom -= LobbyNetwork_OnClientStarted; _lobbyNetwork.OnClientLeftRoom -= LobbyNetwork_OnClientLeftRoom; RoomDetails.OnRoomDetailsUpdated -= RoomDetails_OnRoomDetailsUpdated; RemoveFromUnitComponents(); } } protected virtual void Update() { } /// <summary> /// Initializes this script for use. /// </summary> public void FirstInitialize(RoomDetails roomDetails, LobbyNetwork lobbyNetwork) { //_roomDetails = roomDetails; _lobbyNetwork = lobbyNetwork; _lobbyNetwork.OnClientStarted += LobbyNetwork_OnClientStarted;  ",
          "content_tokens": 2366,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "protected void Awake() { _astarPath = GameObject.FindObjectOfType<AstarPath>(); _rewardAbilityManager = FindObjectOfType<RewardAbilityManager>(); _abilityManager = FindObjectOfType<AbilityManager>(); _bossLocationNotifier = FindObjectOfType<BossLocationNotifier>(); _serverPlayerManager = FindObjectOfType<ServerPlayerManager>(); _creaturesFactory = FindObjectOfType<CreaturesFactory>(); _dungeonNetworkManager = FindObjectOfType<DungeonNetworkManager>(); _dungeonListener = FindObjectOfType<MyDungeonListener>(); _rvoSimulator = FindObjectOfType<RVOSimulator>(); _lootDropSystem = FindObjectOfType<LootDropSystem>(); _objectsManager = FindObjectOfType<ObjectsRoomManager>(); AllGameplayManagers.Add(this); _spawnedUnitObjects.OnChange += SpawnedUnitObjectsOnChange; _teams.OnChange += _teams_TeamsOnChange; _respawnManager = CreaturesFactory.GetComponent<RespawnManager>(); _optimizeServerFromComponents = GetComponent<OptimizeServerFromComponents>(); if (Instance != null) { Debug.LogError($\"[GameplayManager] Instance already exists!\"); Destroy(Instance); } else { Instance = this; } } public override void OnStopNetwork() { base.OnStopNetwork(); AllGameplayManagers.Remove(this); _spawnedUnitObjects.OnChange -= SpawnedUnitObjectsOnChange; } public override void OnStartNetwork() { base.OnStartNetwork(); try { if (IsServer) { RoomDetails rd = new RoomDetails(); _roomDetails.Add(rd); }else if (base.IsClientOnly) { Destroy(_physicsSimulator); }  ",
          "content_tokens": 401,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "catch(Exception e) { Debug.LogError(e); } } public override void OnStartServer() { base.OnStartServer(); if (isTeamsMode) RoomDetails.SetIsTeamsMode(true); StartCoroutine(InitServer()); InstanceFinder.ServerManager.OnRemoteConnectionState += UpdateRoomInfoIfPlayerLeft; RoomDetails.OnRoomDetailsUpdated += RoomDetails_OnRoomDetailsUpdated; //StartCoroutine(GenerateEscapePoint());  ",
          "content_tokens": 103,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "protected void UpdateRoomInfoIfPlayerLeft(NetworkConnection conn, RemoteConnectionStateArgs connState) { if (connState.ConnectionState == RemoteConnectionState.Stopped) { LobbyNetwork_OnClientLeftRoom(RoomDetails, conn.FirstObject); Debug.Log($\"[GameplayManager] Player #{conn.ClientId} {connState.ConnectionState}\"); } } protected virtual IEnumerator InitServer() { var startTime = Time.time; string color = String.Empty; string endColor = String.Empty; #if UNITY_EDITOR color = COLOR_INITIALIZATION; endColor = \"</color>\"; #endif //TODO: Create Scriptable Objects, dungeons generator saver uint seed = 1;//903244736; _playerSpawnManager = new PlayerSpawnManager(this, MalePrefab, FemalePrefab); var time = new WaitForSeconds(1f); //Because ParrelSync can't load addressables #if UNITY_EDITOR if (IsLoadDungeonFromSave && !ClonesManager.IsClone()) { #else if (IsLoadDungeonFromSave) { #endif _dungeonNetworkManager.SetSeed(seed); Debug.Log($\"{color}===========[{RoomDetails.Name}]...New seed: {seed}. Waiting until IsDungeonSpawned...==========={endColor}\", _dungeonNetworkManager); yield return new WaitUntil(()=> _dungeonNetworkManager.IsDungeonSpawned); } else { CreateSeedAndStartBuildingDungeon(seed); yield return new WaitUntil(()=> _dungeonListener.IsDungeonBuilt); yield return time; yield return time; } _dungeonHolder = FindObjectOfType<DungeonHolder>(); _dungeonHolder.SetupCollapsingTimes(); Debug.Log($\"{color}===========[{RoomDetails.Name}]...IsDungeonSpawned -> Storing Spawn Points...==========={endColor}\"); InitPlayerSpawnPoints(); Debug.Log($\"{color}===========[{RoomDetails.Name}]...!Storing Spawn Points finished!...==========={endColor}\"); Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting Spawning Networked objects...==========={endColor}\"); _objectsManager.SpawnObjects(); yield return new WaitUntil(()=>_objectsManager.IsObjectsSpawned); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Spawnning Networked objects finished!==========={endColor}\"); if (!IsHost) { Debug.Log($\"{color}===========...[{RoomDetails.Name}] Starting removing lights...==========={endColor}\"); _optimizeServerFromComponents.RemoveGameObjectsNotNeededForServer(); _optimizeServerFromComponents.OptimizeLights(); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Removing lights finished!==========={endColor}\"); } Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting NavMesh build...==========={endColor}\"); #if UNITY_EDITOR if (IsLoadDungeonFromSave && !ClonesManager.IsClone()) { #else if (IsLoadDungeonFromSave) { #endif LoadPathFroAStarFromAddressables(seed); } else { AstarPath.Scan(); new WaitUntil(()=>!AstarPath.isScanning); } Debug.Log($\"{color}===========[{RoomDetails.Name}]!NavMesh builded!==========={endColor}\"); //yield return time; Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting populating spawn points with monsters...==========={endColor}\"); _respawnManager.MonsterSpawnPointsPopulate(); _respawnManager.PopulatePortalPoints(); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Populating spawn points finished!==========={endColor}\"); Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting Abilities Initialization...==========={endColor}\"); _abilityManager.Init(true); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Abilities initialization finished!==========={endColor}\"); //yield return time; Debug.Log($\"{color}===========[{RoomDetails.Name}]...Order clients to remove monster spawn points...==========={endColor}\"); //SpawnPlayersThatLoadedDungeon(); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Spawnning Players finished!==========={endColor}\"); //NotifyAllPlayersRoomStartTime(); _respawnManager.InitIfAllRequirementsMet(); OnRoomReady?.Invoke(); _serverPlayerManager.InitServer(); var elapsedTime = Time.time - startTime; StartCoroutine(SpawnPlayersThatLoadedDungeon()); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Room initialization finished! Elapsed time: {elapsedTime}==========={endColor}\"); StartCoroutine(DelayedSpawnEscapePortalsAfterTime(15 * 60)); } protected virtual IEnumerator InitClient() { OnLocalClientInitStarted?.Invoke(); string color = String.Empty; string endColor = String.Empty; #if UNITY_EDITOR color = COLOR_INITIALIZATION; endColor = \"</color>\"; #endif UnitySceneManager.SetActiveScene(UnitySceneManager.GetSceneByName(ClientSceneHandler.ROOM_SCENE_NAME)); //MoveClientInstanceToActiveScene(); var time = new WaitForSeconds(.5f); RegistrationController.Instance.SwitchMainMenuElements(false); if (!IsHost) { Destroy(_rvoSimulator); } #if UNITY_EDITOR if (IsLoadDungeonFromSave && !ClonesManager.IsClone()) { #else if (IsLoadDungeonFromSave) { #endif yield return new WaitUntil(() => _dungeonNetworkManager.IsDungeonSpawned); } else { yield return new WaitUntil(() => _dungeonListener.IsDungeonBuilt); } _dungeonHolder = FindObjectOfType<DungeonHolder>(); _dungeonHolder.SetupCollapsingTimes(); yield return new WaitUntil(()=>_objectsManager.IsObjectsSpawned); Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting removing non network GOs...==========={endColor}\"); _objectsManager.RemoveNonNetworkedObjectsClient(); yield return new WaitUntil(()=> _objectsManager.IsNonNetworkedObjectsRemoved); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Removing non network GOs finished!==========={endColor}\"); if (IsHost) { yield return new WaitUntil(() => _objectsManager.IsObjectsSpawned);  ",
          "content_tokens": 1568,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "if (!IsHost){ Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting Abilities Initialization...==========={endColor}\"); _abilityManager.Init(false); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Abilities initialization finished!==========={endColor}\"); } OnClientLoadedGameplayManager?.Invoke(); if (!IsHost) { yield return new WaitForSeconds(3f); Debug.Log( $\"{color}===========[{RoomDetails.Name}]...Removing monster spawn points...==========={endColor}\"); _respawnManager.RemoveMonsterSpawnPoints(); _respawnManager.RemovePortalSpawnPoints(); } Debug.Log($\"{color}===========[{RoomDetails.Name}]...Waiting for RoomLODController...==========={endColor}\"); yield return new WaitUntil(()=> RoomLODController.Instance != null); RoomLODController.Instance.InitForClient(); MusicController.PlayDungeonMusic(); CmdClientFinishedLoadingGPM(); yield return time;  ",
          "content_tokens": 241,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "private void MoveClientInstanceToActiveScene() { ClientInstance clientInstance = ClientInstance.LocalPlayer; if (clientInstance.gameObject.scene.name != ClientSceneHandler.ROOM_SCENE_NAME) { UnitySceneManager.MoveGameObjectToScene(gameObject, UnitySceneManager.GetSceneByName(ClientSceneHandler.ROOM_SCENE_NAME)); }  private void LoadPathFroAStarFromAddressables(uint seed) { string addressableDungeonAStar = $\"{DungeonNetworkManager.DUNGEON_ADDRESSABLES_PATH}/{seed}/graph-{seed}.bytes\"; Addressables.LoadAssetAsync<TextAsset>(addressableDungeonAStar).Completed += OnAstarPathLoaded;  ",
          "content_tokens": 168,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "protected void OnAstarPathLoaded(AsyncOperationHandle<TextAsset> handle) { if (handle.Status == AsyncOperationStatus.Succeeded) { TextAsset data = handle.Result; AstarPath.data.file_cachedStartup = data; AstarPath.data.LoadFromCache(); } else { Debug.LogError(\"Failed to load the Addressable prefab.\"); } } [Server] protected void CreateSeedAndStartBuildingDungeon(uint newSeed = 0) { if (newSeed == 0) { newSeed = (uint)Random.Range(0, int.MaxValue); } _dungeonNetworkManager.SetSeed(newSeed); Debug.Log(\"Generated seed: \" + newSeed); } [Server] public void InitPlayerSpawnPoints() { List<Vector3> spawnPositions = FindSpawnPoints(); PopulateSpawnPoints(spawnPositions); } [Server] protected List<Vector3> FindSpawnPoints() { var spawnPoints = GameObject.FindGameObjectsWithTag(\"Respawn\"); if (spawnPoints.Length == 0) { Debug.LogError(\"No player spawn points found!\"); return null; } else { Debug.Log($\"[GameplayManager] Found {spawnPoints.Length} spawn points\"); } List<Vector3> spawnPointsList = new List<Vector3>(); foreach (var spawnPoint in spawnPoints) { spawnPointsList.Add(spawnPoint.transform.position);  ",
          "content_tokens": 324,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "foreach (var go in spawnPoints) { Destroy(go); } return spawnPointsList; } public override void OnStartClient() { base.OnStartClient(); StartCoroutine(InitClient()); } #region Room Details Updater public SyncList<NetworkObject> SyncRoomDetailsPlayerCharacters => _syncRoomDetailsPlayerCharacters; [SyncObject] readonly SyncList<NetworkObject> _syncRoomDetailsPlayerCharacters = new (); [Server] protected void RoomDetails_OnRoomDetailsUpdated(RoomDetails.WhichField whichField) { StringBuilder sb = new StringBuilder($\"{ClassAndRoomName} RoomDetails_OnRoomDetailsUpdated \"); switch (whichField) { case RoomDetails.WhichField.EName: sb.Append($\"Name: {RoomDetails.Name}\"); ObserversRoomDetailsNameUpdated(RoomDetails.Name); break; case RoomDetails.WhichField.EMemberIds: sb.Append($\"MemberIds: {RoomDetails.MemberIds.Count}\"); ObserversRoomDetailsMemberIdsUpdated(RoomDetails.MemberIds); break; case RoomDetails.WhichField.EStartedMembers: sb.Append($\"StartedMembers: {RoomDetails.StartedMembers.Count}\"); ObserversRoomDetailsStartedMembersUpdated(RoomDetails.StartedMembers); break; case RoomDetails.WhichField.EIsTeamsMode: sb.Append($\"IsTeamsMode: {RoomDetails.IsTeamsMode}\"); ObserversRoomDetailsIsTeamsModeUpdated(RoomDetails.IsTeamsMode); break; case RoomDetails.WhichField.ETeams: sb.Append($\"Teams: {RoomDetails.Teams.Count}\"); RoomDetails.Team team = new RoomDetails.Team(); for (int i = 0; i < RoomDetails.Teams.Count; i++) { team = RoomDetails.Teams[i]; _teams[i] = team; _teams.Dirty(i);  ",
          "content_tokens": 440,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "ObserversRoomDetailsTeamsUpdated(RoomDetails.Teams); break; case RoomDetails.WhichField.EKickedIds: sb.Append($\"KickedIds: {RoomDetails.KickedIds.Count}\"); ObserversRoomDetailsKickedIdsUpdated(RoomDetails.KickedIds); break; case RoomDetails.WhichField.EPlayerCharacters: sb.Append($\"PlayerCharacters: {RoomDetails.PlayerCharacters.Count}\"); _syncRoomDetailsPlayerCharacters.Clear(); foreach (var nob in RoomDetails.PlayerCharacters) { _syncRoomDetailsPlayerCharacters.Add(nob);  ",
          "content_tokens": 141,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "ObserversRoomDetailsPlayerCharactersUpdated(RoomDetails.PlayerCharacters.ToList()); break; } Debug.Log(sb.ToString()); } [ObserversRpc(BufferLast = true, ExcludeServer = true)] protected void ObserversRoomDetailsMemberIdsUpdated(List<NetworkObject> roomDetailsMemberIds) { Debug.Log($\"{ClassAndRoomName} ObserversRoomDetailsMemberIdsUpdated {roomDetailsMemberIds.Count}\"); RoomDetails.SetMemberIds(roomDetailsMemberIds); } [ObserversRpc(BufferLast = true, ExcludeServer = true)] protected void ObserversRoomDetailsNameUpdated(string roomName) { Debug.Log($\"{ClassAndRoomName} ObserversRoomDetailsNameUpdated {roomName}\"); RoomDetails.SetName(roomName); } [ObserversRpc(BufferLast = true, ExcludeServer = true)] protected void ObserversRoomDetailsStartedMembersUpdated(List<NetworkObject> startedMembers) { Debug.Log($\"{ClassAndRoomName} ObserversRoomDetailsStartedMembersUpdated {startedMembers.Count}\"); RoomDetails.SetStartedMembers(startedMembers); } [ObserversRpc(BufferLast = true, ExcludeServer = true)] protected void ObserversRoomDetailsIsTeamsModeUpdated(bool isTeamsMode) { Debug.Log($\"{ClassAndRoomName} ObserversRoomDetailsIsTeamsModeUpdated {isTeamsMode}\"); RoomDetails.SetIsTeamsMode(isTeamsMode); } [ObserversRpc(BufferLast = true, ExcludeServer = true)] protected void ObserversRoomDetailsTeamsUpdated(List<RoomDetails.Team> teams) { Debug.Log($\"{ClassAndRoomName} ObserversRoomDetailsTeamsUpdated {teams.Count}\"); RoomDetails.SetTeams(teams); } [ObserversRpc(BufferLast = true, ExcludeServer = true)] protected void ObserversRoomDetailsKickedIdsUpdated(List<NetworkObject> kickedIds) { Debug.Log($\"{ClassAndRoomName} ObserversRoomDetailsKickedIdsUpdated {kickedIds.Count}\"); RoomDetails.SetKickedIds(kickedIds); } [ObserversRpc(BufferLast = true, ExcludeServer = true)] protected void ObserversRoomDetailsPlayerCharactersUpdated(List<NetworkObject> playerCharacters) { Debug.Log($\"{ClassAndRoomName} ObserversRoomDetailsPlayerCharactersUpdated {playerCharacters.Count}\"); RoomDetails.SetPlayerCharacters(playerCharacters); } #endregion [ServerRpc(RequireOwnership = false)] protected void IsServerHaveThatObject(int objectId, NetworkConnection conn = null) { NetworkObject nob = GetNetworkObject(objectId); if (nob != null) { IsServerHaveThatObjectResult(conn, true, nob, objectId);  ",
          "content_tokens": 650,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "IsServerHaveThatObjectResult(conn, false, null, objectId); } [TargetRpc] protected void IsServerHaveThatObjectResult(NetworkConnection conn, bool isOk, NetworkObject nob, int objectId) { if (isOk) { DebugWrite.Log($\"{ClassAndRoomName} network object with id {nob.ObjectId} is persist on server\", gameObject, _isDebug); } else { DebugWrite.LogError($\"{ClassAndRoomName} Server could not find network object with id {objectId}.\", gameObject, _isDebug); } } [ItemCanBeNull] protected NetworkObject GetNetworkObject(int objectId, bool isShowError = true) { NetworkObject networkObject = null; if (base.IsServer) { if (InstanceFinder.ServerManager.Objects.Spawned.ContainsKey(objectId)) { networkObject = InstanceFinder.ServerManager.Objects.Spawned[objectId]; } else { if (isShowError) DebugWrite.LogError($\"{ClassAndRoomName} Could not find network object with id {objectId}.\", gameObject, _isDebug); } } else { if (InstanceFinder.ClientManager.Objects.Spawned.ContainsKey(objectId)) { networkObject = InstanceFinder.ClientManager.Objects.Spawned[objectId]; } else { if (isShowError) DebugWrite.LogError($\"{ClassAndRoomName} Could not find network object with id {objectId}.\", gameObject, _isDebug); //IsServerHaveThatObject(objectId); }  ",
          "content_tokens": 351,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "if (networkObject != null) { return networkObject; } else { return null; if (isShowError) DebugWrite.LogError($\"{ClassAndRoomName} Could not find network object with id {objectId}.\"); } return null; } /// <summary> /// Called when a client leaves the room. /// </summary> /// <param name=\"arg1\"></param> /// <param name=\"arg2\"></param> protected void LobbyNetwork_OnClientLeftRoom(RoomDetails arg1, NetworkObject arg2) { //Destroy all of clients objects, except their client instance. for (int i = 0; i < UnitCharacters.Count; i++) { NetworkObject entry = GetNetworkObject(UnitCharacters[i]); //Entry is null. Remove and iterate next. if (entry == null) { _spawnedUnitObjects.RemoveAt(i); i--; continue; } //If same connection to client (owner) as client instance of leaving player. if (entry.Owner == arg2.Owner) { //Destroy entry then remove from collection. Debug.Log($\"{ClassAndRoomName} Destroying client object {entry.name} #{entry.ObjectId}.\"); entry.Despawn(); _spawnedUnitObjects.RemoveAt(i); i--; } } } /// <summary> /// Called when a client starts a game. /// </summary> /// <param name=\"roomDetails\"></param> /// <param name=\"client\"></param> protected void LobbyNetwork_OnClientStarted(RoomDetails roomDetails, NetworkObject client) { //Not for this room. if (roomDetails != RoomDetails) return; //NetIdent is null or not a player. if (client == null || client.Owner == null) return; Debug.Log($\"{ClassAndRoomName} Order Client #{client.ObjectId} to load his local game scene\"); client.GetComponent<ClientSceneHandler>().RpcClientLoadRoomScene(client.Owner); } /// <summary> /// Called when player finishes loading his own local game scene. Is not calling in Dungeon mode. /// </summary> /// <param name=\"conn\"></param> [ServerRpc(RequireOwnership = false)] public void CmdClientLoadedGameSceneNotifier(NetworkConnection conn = null) { Debug.Log($\"{ClassAndRoomName} Client #{conn.ClientId} loaded game scene.\"); if (IsClientAlreadySpawned(conn)) return; /* POSSIBLY USEFUL INFORMATION!!!!! * POSSIBLY USEFUL INFORMATION!!!!! * If you want to wait until all players are in the scene * before spaning then check if roomDetails.StartedMembers.Count * is the same as roomDetails.MemberIds.Count. A member is considered * started AFTER they have loaded all of the scenes. */ if (IsHost) _playerSpawnManager.SpawnPlayer(conn);  ",
          "content_tokens": 621,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "protected bool IsClientAlreadySpawned(NetworkConnection conn) { foreach (var heroNob in SpawnedPlayerHeroes) { if (heroNob.Owner == conn) { //Debug.Log($\"{ClassAndRoomName} Client #{conn.ClientId} is already spawned.\"); return true; } } return false; } #region Death. /// <summary> /// Called when object exits trigger. Used to respawn players. /// </summary> /// <param name=\"other\"></param> protected void OnTriggerExit(Collider other) { if (!base.IsServer) return; NetworkObject netIdent = other.gameObject.GetComponent<NetworkObject>(); //If doesn't have a netIdent or no owning client exit. if (netIdent == null || netIdent.Owner == null) return; //If there is an owning client then destroy the object and respawn. StartCoroutine((__DelayRespawn(netIdent))); } /// <summary> /// Destroys netIdent and respawns player after delay. /// </summary> /// <param name=\"netIdent\"></param> /// <returns></returns> protected IEnumerator __DelayRespawn(NetworkObject netIdent) { //Send Rpc to spawn death dummy then destroy original. RpcSpawnDeathDummy(netIdent.transform.position); NetworkConnection conn = netIdent.Owner; InstanceFinder.ServerManager.Despawn(netIdent.gameObject); //Wait a little to respawn player. yield return new WaitForSeconds(3f); //Don't respawn if someone won. if (_winner) yield break; /* Check for rage quit conditions (left room). */ if (conn == null) yield break; ClientInstance ci = ClientInstance.GetClientInstance(conn); if (ci == null || !RoomDetails.StartedMembers.Contains(ci.NetworkObject)) yield break; //SpawnPlayer(conn); } /// <summary> /// Spawns a dummy player to show death. /// </summary> /// <param name=\"player\"></param> [ObserversRpc] protected void RpcSpawnDeathDummy(Vector3 position) { GameObject go = Instantiate(_deathDummy, position, Quaternion.identity); UnitySceneManager.MoveGameObjectToScene(go, gameObject.scene); Destroy(go, 1f); } #endregion #region Spawns [Server] public void SpawnHealSphere(Vector3 position) { HealthSphereController sphere = Instantiate(_healthSpherePrefab, position, Quaternion.identity); Spawn(sphere.gameObject); sphere.InitServer(this, \"HealSphere\", position, Vector3.zero); } [Server] public void SpawnBookExp(Vector3 position) { BookExpController book = Instantiate(_BookExpPrefab, position, Quaternion.identity); Spawn(book.gameObject); book.InitServer(this, \"Book Exp\", position, Vector3.zero); } #endregion #region Winning. [Server] protected IEnumerator DelayedSpawnEscapePortalsAfterTime(float time) { yield return new WaitForSeconds(time); foreach (var point in _respawnManager.PortalPoints) { SpawnEscapePortal(point); yield return new WaitForSeconds(5f * 60f); } } [Server] public void SpawnEscapePortal(Vector3 position) { EscapePortalController portal = Instantiate(_escapePortalPrefab, position, Quaternion.identity); Spawn(portal.gameObject); portal.InitServer(this, \"EscapePortal\", position, Vector3.zero); } #endregion protected UnitComponents SaveUnitComponents(NetworkObject nob) { if (UnitComponentsDict.ContainsKey(nob.ObjectId)) return UnitComponentsDict[nob.ObjectId]; UnitComponents unitComps = new UnitComponents(nob); UnitComponentsDict.Add(nob.ObjectId, unitComps); AddToSpawnedUnits(nob); return unitComps;  ",
          "content_tokens": 877,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "private void AddToSpawnedUnits(NetworkObject nob) { if (!_spawnedUnitObjects.Contains(nob.ObjectId)) { Debug.Log($\"{ClassAndRoomName} {nob.name} added to _spawnednitObjects\", nob); _spawnedUnitObjects.Add(nob.ObjectId); } } public UnitComponents GetUnitComponents(NetworkObject nob) { if (UnitComponentsDict.ContainsKey(nob.ObjectId)) return UnitComponentsDict[nob.ObjectId]; UnitComponents unitComps = new UnitComponents(nob); UnitComponentsDict.Add(nob.ObjectId, unitComps); AddToSpawnedUnits(nob); return unitComps; } [Server] public UnitComponents SavePlayerToRoom(NetworkObject playerNob) { NetworkConnection conn = playerNob.Owner; ClientInstance ci = ClientInstance.GetClientInstance(conn); AddToSpawnedUnits(playerNob); SpawnedPlayerHeroes.Add(playerNob); RoomDetails.AddPlayerCharacter(playerNob); var unitComps = SaveUnitComponents(playerNob); ci.StoreHero(unitComps); GetUnitTeamId(playerNob.ObjectId); unitComps.InvectorManager.SetupGameplayManager(this); unitComps.HealthController.GameplayManager = this; unitComps.InvectorManager.OnPlayerPositionChanged += FishnetInvectorManager_OnPlayerPositionChanged; RegisterDamageReceivers(unitComps.HealthController.DamageReceivers, unitComps.HealthController); Debug.Log($\"{ClassAndRoomName} Player #{playerNob.Owner.ClientId} {playerNob.name} saved to room.\"); OnPlayerJoinedRoom?.Invoke(playerNob); return unitComps; } [Server] public void SaveNpcToRoom(NetworkObject npcNob) { AddToSpawnedUnits(npcNob); var unitComps = SaveUnitComponents(npcNob); GetUnitTeamId(npcNob.ObjectId); unitComps.HealthController.GameplayManager = this; Collider[] damageReceivers = unitComps.HealthController.DamageReceivers; FishnetInvectorHealthController healthController = unitComps.HealthController; RegisterDamageReceivers(damageReceivers, healthController);  ",
          "content_tokens": 514,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "public void RegisterDamageReceivers(Collider[] damageReceivers, FishnetInvectorHealthController healthController) { for (int i = 0; i < damageReceivers.Length; i++) { RegisterCollider(damageReceivers[i], healthController); } } #region Spawning. [Server] public void InitIfAllPlayersSpawned() { if (RoomDetails.PlayerCharacters.Count == RoomDetails.MemberIds.Count) { _isAllPlayersSpawned = true; OnAllPlayersSpawned?.Invoke(); } } public virtual Vector3 GetAvailableSpawnPosition(NetworkConnection conn) { if (RoomDetails.IsTeamsMode) { int teamId; foreach (RoomDetails.Team team in RoomDetails.Teams) { for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] == null) continue; if (team.Slots[i].Owner != conn) continue; teamId = RoomDetails.Teams.IndexOf(team); DebugWrite.Log($\"{ClassAndRoomName} Found in team #{teamId} for client #{conn.ClientId}\", gameObject, _isDebug); if (SpawnPointsForPlayers[teamId] != null) return SpawnPointsForPlayers[teamId] + Vector3.left + Vector3.right * i; else { DebugWrite.LogError($\"{ClassAndRoomName} Could not find spawn point for team #{teamId} for client #{conn.ClientId}\", gameObject, _isDebug); return SpawnPointsForPlayers[0]; } }  ",
          "content_tokens": 355,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "if (!IsHost) DebugWrite.LogError($\"{ClassAndRoomName} Could not find team for client #{conn.ClientId}\", gameObject, _isDebug); } Vector3 spawnPosition = Vector3.zero; if (SpawnPointsForPlayers.Count == 0) { Debug.LogError($\"{ClassAndRoomName} CRITICAL ERROR!!! No spawn points for players.\", gameObject); } else { spawnPosition = SpawnPointsForPlayers.FirstOrDefault(); _spawnPointsForPlayers.Remove(spawnPosition); Debug.Log($\"{ClassAndRoomName} Removed spawn point {spawnPosition} from spawn points list. {SpawnPointsForPlayers.Count} left.\"); } return spawnPosition; } /// <summary> /// Draw spawn region. /// </summary> protected void OnDrawGizmosSelected() { Gizmos.DrawWireCube(transform.position, _spawnRegion); } #endregion public void GetPlayerHeroComponentsServerAndClient(NetworkConnection conn, Action<UnitComponents> callback) { Debug.Log($\"{ClassAndRoomName} GetPlayerHeroComponentsServerAndClient\"); foreach (var hero in UnitCharacters) { if (GetNetworkObject(hero).Owner == conn) callback(GetUnitComponentsServerAndClient(GetNetworkObject(hero).ObjectId));  ",
          "content_tokens": 285,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "StartCoroutine(CheckGetUnitComponentsServerAndClient(conn)); OnSpawnedUnitObjectsChanged += (spawnedUnitId) => { var nob = GetNetworkObject(spawnedUnitId); if (nob == null) { return;  if (nob.Owner == conn) { callback(GetUnitComponentsServerAndClient(spawnedUnitId)); Debug.Log($\"{ClassAndRoomName} PlayerComponents found for client #{conn.ClientId}. Callback called = #{spawnedUnitId}.\"); } }; } public UnitComponents GetPlayerHeroComponentsServerAndClient(NetworkConnection conn, bool isShowError = true) { foreach (var hero in UnitCharacters) { var possibleHero = GetNetworkObject(hero); if (possibleHero != null && possibleHero.Owner == conn) return GetUnitComponentsServerAndClient(GetNetworkObject(hero).ObjectId);  ",
          "content_tokens": 197,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "if (isShowError) Debug.LogError($\"{ClassAndRoomName} PlayerComponents not found for client #{conn.ClientId}\"); return null; } protected IEnumerator CheckGetUnitComponentsServerAndClient(NetworkConnection conn = null, int objectId = -1) { StringBuilder sb = new StringBuilder($\"{ClassAndRoomName} CheckGetUnitComponentsServerAndClient \"); float timePassed = 0f; bool isFound = false; bool asClient = conn != null; if (asClient) sb.Append($\"asClient \"); else sb.Append($\"asServer \"); while (timePassed < 20f && isFound == false) { foreach (var hero in UnitCharacters) { var nob = GetNetworkObject(hero, false); if (nob == null) continue; if (objectId > 0) { sb.Append($\"Checking for PlayerComponents for client #{objectId}. Timeout {timePassed} secs.\"); isFound = nob.ObjectId == objectId; if (isFound) sb.Append($\"found for object id #{objectId}. Timeout {timePassed} secs.\"); } else { sb.Append($\"Checking for PlayerComponents for client conn #{conn.ClientId}. Timeout {timePassed} secs.\"); isFound = nob.Owner == conn; if (isFound) sb.Append($\"found for object id #{objectId}. Timeout {timePassed} secs.\"); } } Debug.Log(sb.ToString()); yield return new WaitForSeconds(1f); timePassed += 1f; } Debug.LogError($\"{ClassAndRoomName} PlayerComponents not found for client #{conn.ClientId}. Timeout {timePassed} secs.\");  ",
          "content_tokens": 414,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "public void GetUnitComponentsServerAndClient(int objectId, Action<UnitComponents> callback) { Debug.Log($\"{ClassAndRoomName} GetUnitComponentsServerAndClient\"); foreach (var hero in UnitCharacters) { var nob = GetNetworkObject(hero, false); if (nob != null && nob.ObjectId == objectId) callback(GetUnitComponentsServerAndClient(GetNetworkObject(hero).ObjectId));  StartCoroutine(CheckGetUnitComponentsServerAndClient(null, objectId)); OnSpawnedUnitObjectsChanged += (spawnedUnitId) => { var nob = GetNetworkObject(spawnedUnitId); if (nob == null) { return;  ",
          "content_tokens": 154,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "if (nob.ObjectId == objectId) { callback(GetUnitComponentsServerAndClient(spawnedUnitId)); Debug.Log($\"{ClassAndRoomName} PlayerComponents found for object #{objectId}. Callback called = #{spawnedUnitId}.\"); } }; } public static UnitComponents GenerateUnitCompsForMe(NetworkObject obj) { if (!UnitComponentsDict.ContainsKey(obj.ObjectId)) { var pc = new UnitComponents(obj); UnitComponentsDict.Add(obj.ObjectId, pc); OnUnitComponentsCreated?.Invoke(obj.Owner, obj, pc); Debug.Log($\"[GameplayManager] UnitComponents created for object #{obj.ObjectId}\"); return pc; } else { return UnitComponentsDict[obj.ObjectId]; } } public UnitComponents GetUnitComponentsServerAndClient(int targetId) { if (targetId == -1) return null; if (!UnitComponentsDict.ContainsKey(targetId)) { Dictionary<int, NetworkObject> allObjects = null; if (base.IsClient) allObjects = InstanceFinder.ClientManager.Objects.Spawned; else allObjects = InstanceFinder.ServerManager.Objects.Spawned; if (allObjects.ContainsKey(targetId)) { NetworkObject netObj = allObjects[targetId]; var pc = new UnitComponents(netObj); UnitComponentsDict.Add(targetId, pc); Debug.Log($\"[GameplayManager] UnitComponents created for object #{targetId}\"); } else { Debug.LogError($\"{ClassAndRoomName} targetId:{targetId} not found in spawned objects\"); return null; } } return UnitComponentsDict[targetId]; } public NetworkObject GetUnitNob(int objectId) { int objectIdFromUnits = UnitCharacters.Find(x => x == objectId); DebugWrite.Log($\"{ClassAndRoomName} Found unit #{objectIdFromUnits} in UnitCharacters\", gameObject, _isDebug); NetworkObject netObj = GetNetworkObject(objectIdFromUnits); if (netObj != null) DebugWrite.Log($\"{ClassAndRoomName} Found netObj #{netObj.name} from ClientManager.Objects.Spawned[{objectIdFromUnits}];\", gameObject, _isDebug); return netObj; } public List<NetworkObject> GetAllPlayersHeroes() { List<NetworkObject> playersHeroes = new List<NetworkObject>(); foreach (var unitId in UnitCharacters) { var unitNob = GetUnitNob(unitId); if (unitNob == null) continue; if (!unitNob.CompareTag(\"Player\")) continue; DebugWrite.Log($\"{ClassAndRoomName} Found PlayerNob for client #{unitNob.OwnerId}\", gameObject, _isDebug); playersHeroes.Add(unitNob); } return playersHeroes; } [Server] public NetworkObject GetPlayerNob(NetworkConnection conn) { foreach (var connObject in conn.Objects) { foreach (var unitId in UnitCharacters) { if (connObject.ObjectId == unitId) { if (connObject.CompareTag(\"Player\")) { DebugWrite.Log($\"{ClassAndRoomName} Found PlayerNob for client #{conn.ClientId}\", gameObject, _isDebug); return connObject; } } } } DebugWrite.LogError($\"{ClassAndRoomName} PlayerNob not found for client #{conn.ClientId}\", gameObject, _isDebug); return null; } [ItemCanBeNull] public List<NetworkObject> GetAliveAIControlledNobs() { List<NetworkObject> aiControlledNobs = new List<NetworkObject>(); foreach (var unit in UnitCharacters) { NetworkObject unitNob = GetNetworkObject(unit, false); if (unitNob == null) continue; for (int i = 0; i < SERVER_AI_CONTROLLED_TAGS.Length; i++) { if (!unitNob.gameObject.CompareTag(SERVER_AI_CONTROLLED_TAGS[i])) continue; var unitComps = SaveUnitComponents(unitNob); if (unitComps.HealthController.IsDead) continue; aiControlledNobs.Add(unitNob); }  ",
          "content_tokens": 973,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "if (aiControlledNobs.Count > 0) return aiControlledNobs; else { //Debug.Log($\"{ClassAndRoomName} No AI controlled nobs found.\"); return null; } } [ItemCanBeNull] public List<NetworkObject> GetAIControlledNobs() { List<NetworkObject> aiControlledNobs = new List<NetworkObject>(); foreach (var unit in UnitCharacters) { NetworkObject unitNob = GetNetworkObject(unit, false); if (unitNob == null) continue; for (int i = 0; i < SERVER_AI_CONTROLLED_TAGS.Length; i++) { if (unitNob.gameObject.CompareTag(SERVER_AI_CONTROLLED_TAGS[i])) aiControlledNobs.Add(unitNob); }  ",
          "content_tokens": 190,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "if (aiControlledNobs.Count > 0) return aiControlledNobs; else { //Debug.Log($\"{ClassAndRoomName} No AI controlled nobs found.\"); return null; }  ",
          "content_tokens": 48,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "public void RemoveFromUnitComponents() { foreach (var nobs in UnitCharacters) { int netId = nobs; if (UnitComponentsDict.ContainsKey(netId)) { UnitComponentsDict.Remove(netId); } } } /* Like SyncVars the callback offers an asServer option * to indicate if the callback is occurring on the server * or the client. As SyncVars do, changes have already been * made to the collection before the callback occurs. */ protected void SpawnedUnitObjectsOnChange(SyncListOperation op, int index, int oldItem, int newItem, bool asServer) { switch (op) { /* An object was added to the list. Index * will be where it was added, which will be the end * of the list, while newItem is the value added. */ case SyncListOperation.Add: OnSpawnedUnitObjectsChanged?.Invoke(newItem); DebugWrite.Log($\"{ClassAndRoomName} SpawnedUnitObjectsOnChange: {newItem} added to list at index {index}\"); break; /* An object was removed from the list. Index * is from where the object was removed. oldItem * will contain the removed item. */ case SyncListOperation.RemoveAt: DebugWrite.Log($\"{ClassAndRoomName} SpawnedUnitObjectsOnChange: {oldItem} removed from list at index {index}\"); break; /* An object was inserted into the list. Index * is where the obejct was inserted. newItem * contains the item inserted. */ case SyncListOperation.Insert: DebugWrite.Log($\"{ClassAndRoomName} SpawnedUnitObjectsOnChange: {newItem} inserted into list at index {index}\"); break; /* An object replaced another. Index * is where the object was replaced. oldItem * is the item that was replaced, while * newItem is the item which now has it's place. */ case SyncListOperation.Set: DebugWrite.Log($\"{ClassAndRoomName} SpawnedUnitObjectsOnChange: {oldItem} replaced with {newItem} at index {index}\"); break; /* All objects have been cleared. Index, oldValue, * and newValue are default. */ case SyncListOperation.Clear: DebugWrite.Log($\"{ClassAndRoomName} SpawnedUnitObjectsOnChange: list cleared\"); break; /* When complete calls all changes have been * made to the collection. You may use this * to refresh information in relation to * the list changes, rather than doing so * after every entry change. Like Clear * Index, oldItem, and newItem are all default. */ case SyncListOperation.Complete: Debug.Log($\"{ClassAndRoomName} SpawnedUnitObjectsOnChange: list changes complete\"); break; }  ",
          "content_tokens": 607,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "protected void _teams_TeamsOnChange(SyncDictionaryOperation op, int index, RoomDetails.Team newItem, bool asServer) { StringBuilder sb = new StringBuilder($\"[GameplayManager][_teams_TeamsOnChange] {op} \"); if (asServer) sb.Append(\"asServer \"); else sb.Append(\"asClient \"); switch (op) { case SyncDictionaryOperation.Add: break; case SyncDictionaryOperation.Set: break; case SyncDictionaryOperation.Clear: break; case SyncDictionaryOperation.Complete: return; break; } sb.Append($\"teamId: {index}; \"); for (int i = 0; i < newItem.Slots.Length; i++) { if (newItem.Slots[i] != null) sb.Append($\"member[{i}]: {newItem.Slots[i].name}; \"); } Debug.Log(sb.ToString()); } [Server] protected IEnumerator GenerateEscapePoint() { while (true) { yield return new WaitForSeconds(SPAWN_POINT_GENERATION_TIME); int randomIndex = UnityEngine.Random.Range(0, _escapePoints.Count); EscapeCitySource escapePoint = Instantiate(_escapeCitySourcePrefab, _escapePoints[randomIndex], Quaternion.identity); escapePoint.Init(this); Debug.Log($\"{ClassAndRoomName} EscapePoint generated at {_escapePoints[randomIndex]}\"); } } [Server] public void RpcWinForPlayer(NetworkConnection conn = null) { DebugWrite.Log($\"{ClassAndRoomName} RpcWinForPlayer from client #{conn.ClientId}\", gameObject, _isDebug); NetworkObject playerHero = GetPlayerNob(conn); ServerInventoryBackup.Instance.SavePlayerSuccessfullEscape(playerHero); WinForPlayer(conn); ClientInstance cli = ClientInstance.GetClientInstance(conn); TargetLoadMainMenu(conn); DespawnPlayer(cli); Debug.Log($\"{ClassAndRoomName} Player #{cli.OwnerId} has escaped\"); cli.Owner.Disconnect(true); //if (cli != null) _lobbyNetwork.TryLeaveRoom(cli.NetworkObject); } [TargetRpc] private void TargetLoadMainMenu(NetworkConnection conn) { UnitySceneManager.LoadScene(\"Main\");  ",
          "content_tokens": 537,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "protected void DespawnPlayer(ClientInstance cli) { if (cli == null) return; var playerHero = cli.PlayerHero.HealthController; SpawnedPlayerHeroes.Remove(playerHero.NetworkObject); playerHero.Despawn(); } [TargetRpc] public void WinForPlayer(NetworkConnection conn = null) { DebugWrite.Log($\"{ClassAndRoomName} WinForPlayer\", gameObject, _isDebug); _winCanvasGroup.Show(); StartCoroutine(ThrowPlayerFromRoom()); } [Client] protected IEnumerator ThrowPlayerFromRoom() { yield return new WaitForSeconds(THROW_TO_MAIN_MENU_TIMER); MainMenuCamera.ActivateMainMenuCamera(); //throw player from room } [TargetRpc] public void LoseForPlayer(NetworkConnection conn = null) { _looseCanvasGroup.Show(); } [ServerRpc(RequireOwnership = false)] public void CmdClientFinishedLoadingGPM(NetworkConnection sender = null) { if (!IsHost) Debug.Log($\"{ClassAndRoomName} CmdClientLoadedDungeon from client #{sender.ClientId}\", gameObject); AddPlayerToLoadedList(sender); } [Server] public void PopulateSpawnPoints(List<Vector3> spawnPositions) { _spawnPointsForPlayers = spawnPositions; StringBuilder sb = new StringBuilder($\"{ClassAndRoomName} added spawn points for players: \"); foreach (var pos in _spawnPointsForPlayers) { sb.Append($\"{pos}; \"); } Debug.Log(sb.ToString()); } [Server] public void AddPlayerToLoadedList(NetworkConnection sender) { Debug.Log($\"{ClassAndRoomName} AddPlayerToLoadedList _connectionsToSpawn++ {_connectionsToSpawn.Count}\", gameObject); _connectionsToSpawn.Add(sender); if (!IsHost) Debug.Log($\"{ClassAndRoomName} Client #{sender.ClientId} loaded game scene.\"); } [Server] protected IEnumerator SpawnPlayersThatLoadedDungeon() { var cooldownTime = 5f; yield return new WaitUntil(() => SpawnPointsForPlayers.Count > 0); while (true) { if (_connectionsToSpawn.Count < NUMBER_OF_PLAYERS_BEFORE_SPAWN) { yield return cooldownTime; } yield return new WaitForSeconds(cooldownTime - 1f); var copyConnectionsToSpawn = new List<NetworkConnection>(_connectionsToSpawn); foreach (var conn in copyConnectionsToSpawn) { if (SpawnPointsForPlayers.Count < 1) { Debug.LogError($\"{ClassAndRoomName} Not enough spawn points to spawn players\"); continue;  ",
          "content_tokens": 620,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "if (!IsClientAlreadySpawned(conn)) _playerSpawnManager.SpawnPlayer(conn); } yield return cooldownTime; } } [Server] protected void FishnetInvectorManager_OnPlayerPositionChanged(NetworkObject player, Vector3 newPos) { int objectId = player.ObjectId; if (_playerPositions.ContainsKey(objectId)) { if (player == null) { _playerPositions.Remove(objectId); return; } _playerPositions[objectId] = newPos; } else { _playerPositions.Add(objectId, newPos); }  ",
          "content_tokens": 128,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "public void RegisterCollider(Collider which, FishnetInvectorHealthController healthController) { if (!_collidersToHealthControllers.ContainsKey(which)) { _collidersToHealthControllers.Add(which, healthController); } } public FishnetInvectorHealthController GetHealthController(Collider collider) { if (_collidersToHealthControllers.ContainsKey(collider)) { return _collidersToHealthControllers[collider]; } //Debug.Log($\"{ClassAndRoomName} No health controller found for collider {collider.name}\", collider); return null; } [ServerRpc(RequireOwnership = false)] public void CmdRegisterMeleeHitDamage(int targetId, FNvDamage fnvDamage) { string logText = $\"{ClassAndRoomName} CmdRegisterDamage SwingCounter: {fnvDamage.SwingCounter}; inputDamage: {fnvDamage.damageValue}\"; vDamage damage = fnvDamage.ToVDamage(); var unitComponents = GetUnitComponentsServerAndClient(targetId); unitComponents.HealthController.TakeDamage(damage); Debug.Log(logText); } /// <summary> /// Called when AI hit player /// </summary> /// <param name=\"npcObjectId\"></param> /// <param name=\"targetObjectId\"></param> /// <param name=\"bodyMemberId\"></param> /// <param name=\"hitPosition\"></param> /// <param name=\"sender\"></param> [ServerRpc(RequireOwnership = false)] public void CmdRegisterHitByAI(int npcObjectId, int targetObjectId, int bodyMemberId, Vector3 hitPosition, NetworkConnection sender = null) { Debug.Log($\"{ClassAndRoomName} RegisterHitByAI AI id: {npcObjectId}; targetUnitId: {targetObjectId}; hitPosition: {hitPosition}; sender: {sender}\"); NetworkObject npc = GetUnitNob(npcObjectId); var dealerUnitComps = SaveUnitComponents(npc); UnitComponents targetUnitComps = null; vMeleeAttackObject damageDealingSource = dealerUnitComps.MeleeManager.Members[bodyMemberId].attackObject; vDamage damage = new vDamage(); damage.Copy(damageDealingSource.damage); damage.hitPosition = hitPosition; damage.Sender = npc.transform; damage.senderNetworkObjectID = npcObjectId; if (targetObjectId > 0) { targetUnitComps = GetUnitComponentsServerAndClient(targetObjectId); } else { Debug.LogError($\"{ClassAndRoomName} RegisterHitByAI targetUnitId: {targetObjectId} targetUnitComps is null\"); } targetUnitComps.HealthController.TakeDamage(damage); } [Server] public void RemoveDespawnedUnit(NetworkObject nob) { _spawnedUnitObjects.Remove(nob.ObjectId); } public Transform GetTargetTransformServerAndClient(int targetId) { var unitComps = GetUnitComponentsServerAndClient(targetId); return unitComps.HealthController.transform; } [Server] public virtual void DropLootBag(AIUnit aiUnit) { float chanceMod = aiUnit.EnemyDefinition.LootBagChanceMod; CratesSystem.Zone zone = aiUnit.EnemyDefinition.LootBagZone; int itemsCount = aiUnit.EnemyDefinition.LootBagItemsCount; List<ItemReference> items = _lootDropSystem.GenerateLoot(aiUnit.EnemyDefinition.ItemsDropChances, aiUnit.EnemyDefinition.LootBagItemsCount, aiUnit.EnemyDefinition.LootBagChanceMod); _lootDropSystem.AddGoldDrop(aiUnit.EnemyDefinition.GoldDropChance, aiUnit.EnemyDefinition.MinGoldDrop, aiUnit.EnemyDefinition.MaxGoldDrop, ref items); //generate random pos in circle around unit with radius 1 var randomPosInCircleWorld = Unit.GetRandomPosInCircleShapeAround(aiUnit.transform.position, 1f); //_lootDropSystem.DropLootBag(items, aiUnit.transform.position, chanceMod, zone, itemsCount); _lootDropSystem.DropLootItems(items, aiUnit.transform.position); } [field: SerializeField] public int Seed => (int)_dungeonNetworkManager.Seed; protected void GenerateRandomIfNeed() { _random ??= new System.Random((int)_dungeonNetworkManager.Seed);  ",
          "content_tokens": 1022,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "public int GetRandomInt(int min, int max) { GenerateRandomIfNeed(); return _random.Next(min, max);  public int GetRandomInt() { GenerateRandomIfNeed(); return _random.Next();  public byte GetRandomByte() { GenerateRandomIfNeed(); return (byte)_random.Next();  public float GetRandomFloat(float min, float max) { GenerateRandomIfNeed(); return (float)_random.NextDouble() * (max - min) + min; } #if UNITY_EDITOR public void SetPlayerPrefab(NetworkObject newPrefab) { _playerPrefab = newPrefab;  ",
          "content_tokens": 144,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "public void ChangeDungeonLoadingFromSave(bool isOn) { IsLoadDungeonFromSave = isOn; } #endif public static bool IsOwningPlayer(Collider other) { if (!other.CompareTag(\"Player\")) return false; var health = Instance.GetHealthController(other); if (health == null) return false; return health.IsOwner;  ",
          "content_tokens": 81,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "public int GetUnitTeamId(int objectId) { if (!unitToTeamId.ContainsKey(objectId)) { var unitComps = GetUnitComponentsServerAndClient(objectId); if (unitComps == null) return -1; if (unitComps.AIUnit != null) { if (unitComps.AIUnit.CompareTag(SERVER_AI_CONTROLLED_TAGS[MONSTER_TAG_ID])) { unitToTeamId.Add(objectId, MONSTER_TEAM_ID); } else//Player controlled AI { int teamId = GetOwningPlayerTeamId(objectId); unitToTeamId.Add(objectId, teamId); } } else// Player { if (unitComps.HealthController.CompareTag(\"Player\")) { if (isTeamsMode) { foreach (var team in RoomDetails.Teams) { for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] == null) continue; if (team.Slots[i].GetComponent<ClientInstance>().PlayerHero.InvectorManager.ObjectId == objectId) { unitToTeamId.Add(objectId, RoomDetails.Teams.IndexOf(team)); } } } } else { unitToTeamId.Add(objectId, unitComps.HealthController.Owner.ClientId); } } } } return unitToTeamId[objectId];  ",
          "content_tokens": 323,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManager",
          "content": "private int GetOwningPlayerTeamId(int objectId) { //TODO Implement return 0; } public static float GetCurrentServerTime() { return (float)InstanceFinder.TimeManager.TicksToTime(InstanceFinder.TimeManager.Tick); } } }",
          "content_tokens": 61,
          "embedding": []
        }
      ],
      "length": 52763
    },
    {
      "filename": "PlayerSpawnManager",
      "content": "using FirstGearGames.LobbyAndWorld.Clients; using FishNet.Connection; using FishNet.Object; using UnityEngine; using UnitySceneManager = UnityEngine.SceneManagement.SceneManager; namespace _ZombieRoyale.Scripts.Core { public class PlayerSpawnManager { private readonly GameplayManager _gameplayManager; private readonly NetworkObject _malePrefab; private readonly NetworkObject _femalePrefab; public PlayerSpawnManager(GameplayManager gameplayManager, NetworkObject malePrefab, NetworkObject femalePrefab) { _gameplayManager = gameplayManager; _malePrefab = malePrefab; _femalePrefab = femalePrefab; } public void SpawnPlayer(NetworkConnection conn) { var spawnPosition = _gameplayManager.GetAvailableSpawnPosition(conn); int clientId = _gameplayManager.IsHost ? 0 : conn.ClientId; ClientInstance ci = ClientInstance.GetClientInstance(conn); if (ci == null) { Debug.LogError($\"ClientInstance not found for client #{clientId}\"); return; } NetworkObject prefabToSpawn = ci.PlayerSettings.CharacterSkinData.genderId == (int)CharacterSkinData.Gender.Male ? _malePrefab : _femalePrefab; Debug.Log($\"Spawning {prefabToSpawn.name} for client #{clientId} at {spawnPosition}\"); NetworkObject nob = UnityEngine.Object.Instantiate(prefabToSpawn, spawnPosition, Quaternion.identity); UnitySceneManager.MoveGameObjectToScene(nob.gameObject, _gameplayManager.gameObject.scene); _gameplayManager.Spawn(nob.gameObject, conn); _gameplayManager.ConnectionsToSpawn.Remove(conn); _gameplayManager.SavePlayerToRoom(nob); _gameplayManager.OnPlayerHeroSpawned?.Invoke(nob.ObjectId); _gameplayManager.InitIfAllPlayersSpawned(); nob.transform.position = spawnPosition; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PlayerSpawnManager",
          "content": "using FirstGearGames.LobbyAndWorld.Clients; using FishNet.Connection; using FishNet.Object; using UnityEngine; using UnitySceneManager = UnityEngine.SceneManagement.SceneManager; namespace _ZombieRoyale.Scripts.Core { public class PlayerSpawnManager { private readonly GameplayManager _gameplayManager; private readonly NetworkObject _malePrefab; private readonly NetworkObject _femalePrefab; public PlayerSpawnManager(GameplayManager gameplayManager, NetworkObject malePrefab, NetworkObject femalePrefab) { _gameplayManager = gameplayManager; _malePrefab = malePrefab; _femalePrefab = femalePrefab;  ",
          "content_tokens": 143,
          "embedding": []
        },
        {
          "cs_scriptfile": "PlayerSpawnManager",
          "content": "public void SpawnPlayer(NetworkConnection conn) { var spawnPosition = _gameplayManager.GetAvailableSpawnPosition(conn); int clientId = _gameplayManager.IsHost ? 0 : conn.ClientId; ClientInstance ci = ClientInstance.GetClientInstance(conn); if (ci == null) { Debug.LogError($\"ClientInstance not found for client #{clientId}\"); return; } NetworkObject prefabToSpawn = ci.PlayerSettings.CharacterSkinData.genderId == (int)CharacterSkinData.Gender.Male ? _malePrefab : _femalePrefab; Debug.Log($\"Spawning {prefabToSpawn.name} for client #{clientId} at {spawnPosition}\"); NetworkObject nob = UnityEngine.Object.Instantiate(prefabToSpawn, spawnPosition, Quaternion.identity); UnitySceneManager.MoveGameObjectToScene(nob.gameObject, _gameplayManager.gameObject.scene); _gameplayManager.Spawn(nob.gameObject, conn); _gameplayManager.ConnectionsToSpawn.Remove(conn); _gameplayManager.SavePlayerToRoom(nob); _gameplayManager.OnPlayerHeroSpawned?.Invoke(nob.ObjectId); _gameplayManager.InitIfAllPlayersSpawned(); nob.transform.position = spawnPosition; } } }",
          "content_tokens": 292,
          "embedding": []
        }
      ],
      "length": 1649
    },
    {
      "filename": "RoomDetails",
      "content": " using System; using System.Collections.Generic; using System.Linq; using System.Text; using FishNet.Connection; using FishNet.Object; using UnityEngine; using UnityEngine.SceneManagement; namespace _ZombieRoyale.Scripts.Core { [Serializable] public class RoomDetails { public static int TEAM_MEMBERS_AMOUNT = 3; public RoomDetails() { } public RoomDetails(string name,string password, bool lockOnStart, bool isTeamsMode, int maxPlayers, string owner = \"\", bool isStartImmediately = false) { Name = name; Password = password; IsPassworded = !string.IsNullOrEmpty(password); LockOnStart = lockOnStart; MaxPlayers = maxPlayers; IsTeamsMode = isTeamsMode; HashSet<NetworkObject> PlayerCharacters = new HashSet<NetworkObject>(); } /// <summary> /// Name of this room. /// </summary> public string Name = String.Empty; /// <summary> /// Maximum players which may join this room. 11 шы тгьиук ща ызфцткщщьы /// </summary> public int MaxPlayers = TEAM_MEMBERS_AMOUNT * 11; /// <summary> /// True if this room has started. /// </summary> public bool IsStarted; /// <summary> /// True if this room requires a password. /// </summary> public bool IsPassworded; /// <summary> /// Password for this room. This will only exist on the server. /// </summary> [System.NonSerialized] public string Password = string.Empty; /// <summary> /// Keeps players tokens. Only available on server. /// </summary> public Dictionary<NetworkConnection, string> PlayerTokens => _playerTokens; [System.NonSerialized] private Dictionary<NetworkConnection, string> _playerTokens; /// <summary> /// True to lock the room from new joiners after the game starts. /// </summary> public bool LockOnStart; /// <summary> /// Scenes loaded for this room. Only available on server. /// </summary> [System.NonSerialized] public HashSet<Scene> Scenes = new HashSet<Scene>(); /// <summary> /// Members in this room. Using an array so that it can serialize over Mirror. /// </summary> public List<NetworkObject> MemberIds = new List<NetworkObject>(); /// <summary> /// Members which have started the game, and are currently in the game scene. /// </summary> [field: System.NonSerialized] public List<NetworkObject> StartedMembers { get; internal set; } = new List<NetworkObject>(); /// <summary> /// Members kicked from this room. Only stored on the server. /// </summary> [field: System.NonSerialized] public List<NetworkObject> KickedIds { get; internal set; } = new List<NetworkObject>(); public string Owner { get; internal set; } public bool IsStartImmediately { get; internal set; } public bool IsTeamsMode; public List<Team> Teams { get; private set; } = new List<Team>(); public HashSet<NetworkObject> PlayerCharacters => _playerCharacters; private HashSet<NetworkObject> _playerCharacters = new HashSet<NetworkObject>(); [System.NonSerialized] public Coroutine TimeoutCoroutine; [System.NonSerialized] public Action<WhichField> OnRoomDetailsUpdated; public enum WhichField { EName, EPassword, EMaxPlayers, EIsTeamsMode, ETeams, EMemberIds, EIsStartImmediately, EKickedIds, EPlayerCharacters, EStartedMembers } /// <summary> /// Adds to Members. /// </summary> /// <param name=\"clientId\"></param> internal void AddMember(NetworkObject clientId) { if (!MemberIds.Contains(clientId)) { MemberIds.Add(clientId); if (IsTeamsMode) { AddMemberToNewOrExistingTeam(clientId); } Debug.Log($\"[RoomDetails] AddMember MemberIds: {MemberIds.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EMemberIds); } } internal void SetName(string name) { Name = name; Debug.Log($\"[RoomDetails] SetName Name: {Name}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EName); } internal void SetMemberIds(List<NetworkObject> memberIds) { MemberIds = memberIds; Debug.Log($\"[RoomDetails] SetMemberIds MemberIds: {MemberIds.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EMemberIds); } internal void AddMemberToNewOrExistingTeam(NetworkObject clientId) { //Get from Teams with empty slot. foreach (Team team in Teams) { for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] == null) { team.Slots[i] = clientId; Debug.Log($\"[RoomDetails] AddMemberToNewOrExistingTeam MemberIds: {MemberIds.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.ETeams); return; } } } //Create new team. var newTeam = new Team(new NetworkObject[TEAM_MEMBERS_AMOUNT]); newTeam.Slots[0] = clientId; Teams.Add(newTeam); Debug.Log($\"[RoomDetails] AddMemberToNewOrExistingTeam MemberIds: {MemberIds.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.ETeams); } internal void SetTeams(List<Team> teams) { Teams = teams; Debug.Log($\"[RoomDetails] SetTeams MemberIds: {MemberIds.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.ETeams); } public void AddPlayerCharacter(NetworkObject playerChar) { if (!PlayerCharacters.Contains(playerChar)) { _playerCharacters.Add(playerChar); StringBuilder sb = new StringBuilder($\"[RoomDetails] AddPlayerCharacter PlayerCharacters: \"); foreach (var playerHero in PlayerCharacters) { sb.Append($\"{playerHero}, \"); } Debug.Log(sb.ToString()); Debug.Log($\"[RoomDetails] AddPlayerCharacter PlayerCharacters: {PlayerCharacters.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EPlayerCharacters); } } public void RemovePlayerCharacter(NetworkObject playerChar) { if (PlayerCharacters.Contains(playerChar)) { _playerCharacters.Remove(playerChar); Debug.Log($\"[RoomDetails] RemovePlayerCharacter PlayerCharacters: {PlayerCharacters.Count}\"); OnRoomDetailsUpdated?.Invoke( WhichField.EPlayerCharacters); } } internal void SetPlayerCharacters(List<NetworkObject> playerCharacters) { _playerCharacters = new HashSet<NetworkObject>(playerCharacters); StringBuilder sb = new StringBuilder($\"[RoomDetails] SetPlayerCharacters PlayerCharacters: \"); foreach (var playerHero in PlayerCharacters) { sb.Append($\"{playerHero}, \"); } Debug.Log(sb.ToString()); Debug.Log($\"[RoomDetails] SetPlayerCharacters PlayerCharacters: {PlayerCharacters.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EPlayerCharacters); } /// <summary> /// Adds a member to StartedMembers. /// </summary> /// <param name=\"clientId\"></param> internal void AddStartedMember(NetworkObject clientId) { if (!StartedMembers.Contains(clientId)) { StartedMembers.Add(clientId); Debug.Log($\"[RoomDetails] AddStartedMember StartedMembers: {StartedMembers.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EStartedMembers); } } internal void SetStartedMembers(List<NetworkObject> startedMembers) { StartedMembers = startedMembers; Debug.Log($\"[RoomDetails] SetStartedMembers StartedMembers: {StartedMembers.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EStartedMembers); } /// <summary> /// Removes from Members. /// </summary> /// <param name=\"clientId\"></param> internal bool RemoveMember(NetworkObject clientId) { int index = MemberIds.IndexOf(clientId); if (index != -1) { MemberIds.RemoveAt(index); Debug.Log($\"[RoomDetails] RemoveMember MemberIds: {MemberIds.Count}\"); OnRoomDetailsUpdated?.Invoke( WhichField.EMemberIds); //Also try to remove from started. StartedMembers.Remove(clientId); Debug.Log($\"[RoomDetails] RemoveMember StartedMembers: {StartedMembers.Count}\"); OnRoomDetailsUpdated?.Invoke( WhichField.EStartedMembers); if (IsTeamsMode) { RemoveMemberFromTeam(clientId); Debug.Log($\"[RoomDetails] RemoveMember Teams: {Teams.Count}\"); OnRoomDetailsUpdated?.Invoke( WhichField.ETeams); } return true; } else { return false; } } internal void RemoveMemberFromTeam(NetworkObject clientId) { foreach (Team team in Teams) { for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] == clientId) { team.Slots[i] = null; return; } } } } internal void ClearMembers() { MemberIds.Clear(); foreach (Team team in Teams) { team.Slots = new NetworkObject[TEAM_MEMBERS_AMOUNT]; } Debug.Log($\"[RoomDetails] ClearMembers MemberIds: {MemberIds.Count}\"); OnRoomDetailsUpdated?.Invoke( WhichField.EMemberIds); } internal bool IsKickedMember(NetworkObject clientId) { return KickedIds.Contains(clientId); } internal void AddKicked(NetworkObject clientId) { if (IsKickedMember(clientId)) return; KickedIds.Add(clientId); Debug.Log($\"[RoomDetails] AddKicked KickedIds: {KickedIds.Count}\"); OnRoomDetailsUpdated?.Invoke( WhichField.EKickedIds); } internal void SetKickedIds(List<NetworkObject> kickedIds) { KickedIds = kickedIds; Debug.Log($\"[RoomDetails] SetKickedIds KickedIds: {KickedIds.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EKickedIds); } internal void SetOwner(string ownerName) { Owner = ownerName; } internal void SetStartImmediately(bool isStartImmediately) { IsStartImmediately = isStartImmediately; } public bool IsAlly(NetworkConnection ownerA, NetworkConnection ownerB) { if (!IsTeamsMode) return false; foreach (Team team in Teams) { for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] == null) continue; if (team.Slots[i].Owner == ownerA || team.Slots[i].Owner == ownerB) { if (i >= team.Slots.Length - 1) { return false; } for (int j = i+1; j < team.Slots.Length; j++) { if (team.Slots[j] == null) continue; if (team.Slots[j].Owner == ownerA || team.Slots[j].Owner == ownerB) { return true; } } } } } return false; } [Serializable] public class Team { public NetworkObject[] Slots; public Team() { } public Team(NetworkObject[] slots) { Slots = slots; } } /// <summary> /// Returns other members on the same team as the provided player. /// </summary> /// <param name=\"targetPlayerNetworkObject\"></param> /// <returns></returns> public List<NetworkObject> GetActiveTeamClientInstances(NetworkObject targetPlayerNetworkObject) { NetworkObject targetClientInstance = targetPlayerNetworkObject.Owner.FirstObject; Team team = Teams.First(t => t.Slots.Contains(targetClientInstance)); List<NetworkObject> teamMembers = new List<NetworkObject>(); for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] != null) { teamMembers.Add(team.Slots[i]); } } return teamMembers; } /// <summary> /// Returns all team(including targetPlayer) members on the same team as the provided player. /// </summary> /// <param name=\"targetPlayerNetworkObject\"></param> /// <returns></returns> public List<NetworkConnection> GetActiveClientsFromSameTeam(NetworkObject targetPlayerNetworkObject) { NetworkObject targetClientInstance = targetPlayerNetworkObject.Owner.FirstObject; Team team = Teams.First(t => t.Slots.Contains(targetClientInstance)); List<NetworkConnection> teamMembers = new List<NetworkConnection>(); for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] != null) { teamMembers.Add(team.Slots[i].Owner); } } return teamMembers; } /// <summary> /// Returns all team(excluding targetPlayer) members on the same team as the provided player. /// </summary> /// <param name=\"myPlayerNetworkObject\"></param> /// <returns></returns> public List<NetworkConnection> GetActiveClientsFromSameTeamExcludingMe(NetworkObject myPlayerNetworkObject) { NetworkObject myClientInstance = myPlayerNetworkObject.Owner.FirstObject; Team team = Teams.First(t => t.Slots.Contains(myClientInstance)); List<NetworkConnection> teamMembers = new List<NetworkConnection>(); for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] == myClientInstance) continue; if (team.Slots[i] == null) continue; teamMembers.Add(team.Slots[i].Owner); } return teamMembers; } public void StorePlayerTokens(Dictionary<NetworkConnection, string> playerTokens) { _playerTokens = playerTokens; } internal void SetIsTeamsMode(bool isTeamsMode) { IsTeamsMode = isTeamsMode; Debug.Log($\"[RoomDetails] SetIsTeamsMode IsTeamsMode: {IsTeamsMode}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EIsTeamsMode); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RoomDetails",
          "content": " using System; using System.Collections.Generic; using System.Linq; using System.Text; using FishNet.Connection; using FishNet.Object; using UnityEngine; using UnityEngine.SceneManagement; namespace _ZombieRoyale.Scripts.Core { [Serializable] public class RoomDetails { public static int TEAM_MEMBERS_AMOUNT = 3; public RoomDetails() {  ",
          "content_tokens": 88,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomDetails",
          "content": "public RoomDetails(string name,string password, bool lockOnStart, bool isTeamsMode, int maxPlayers, string owner = \"\", bool isStartImmediately = false) { Name = name; Password = password; IsPassworded = !string.IsNullOrEmpty(password); LockOnStart = lockOnStart; MaxPlayers = maxPlayers; IsTeamsMode = isTeamsMode; HashSet<NetworkObject> PlayerCharacters = new HashSet<NetworkObject>(); } /// <summary> /// Name of this room. /// </summary> public string Name = String.Empty; /// <summary> /// Maximum players which may join this room. 11 шы тгьиук ща ызфцткщщьы /// </summary> public int MaxPlayers = TEAM_MEMBERS_AMOUNT * 11; /// <summary> /// True if this room has started. /// </summary> public bool IsStarted; /// <summary> /// True if this room requires a password. /// </summary> public bool IsPassworded; /// <summary> /// Password for this room. This will only exist on the server. /// </summary> [System.NonSerialized] public string Password = string.Empty; /// <summary> /// Keeps players tokens. Only available on server. /// </summary> public Dictionary<NetworkConnection, string> PlayerTokens => _playerTokens; [System.NonSerialized] private Dictionary<NetworkConnection, string> _playerTokens; /// <summary> /// True to lock the room from new joiners after the game starts. /// </summary> public bool LockOnStart; /// <summary> /// Scenes loaded for this room. Only available on server. /// </summary> [System.NonSerialized] public HashSet<Scene> Scenes = new HashSet<Scene>(); /// <summary> /// Members in this room. Using an array so that it can serialize over Mirror. /// </summary> public List<NetworkObject> MemberIds = new List<NetworkObject>(); /// <summary> /// Members which have started the game, and are currently in the game scene. /// </summary> [field: System.NonSerialized] public List<NetworkObject> StartedMembers { get; internal set; } = new List<NetworkObject>(); /// <summary> /// Members kicked from this room. Only stored on the server. /// </summary> [field: System.NonSerialized] public List<NetworkObject> KickedIds { get; internal set; } = new List<NetworkObject>(); public string Owner { get; internal set; } public bool IsStartImmediately { get; internal set; } public bool IsTeamsMode; public List<Team> Teams { get; private set; } = new List<Team>(); public HashSet<NetworkObject> PlayerCharacters => _playerCharacters; private HashSet<NetworkObject> _playerCharacters = new HashSet<NetworkObject>(); [System.NonSerialized] public Coroutine TimeoutCoroutine; [System.NonSerialized] public Action<WhichField> OnRoomDetailsUpdated; public enum WhichField { EName, EPassword, EMaxPlayers, EIsTeamsMode, ETeams, EMemberIds, EIsStartImmediately, EKickedIds, EPlayerCharacters, EStartedMembers } /// <summary> /// Adds to Members. /// </summary> /// <param name=\"clientId\"></param> internal void AddMember(NetworkObject clientId) { if (!MemberIds.Contains(clientId)) { MemberIds.Add(clientId); if (IsTeamsMode) { AddMemberToNewOrExistingTeam(clientId); } Debug.Log($\"[RoomDetails] AddMember MemberIds: {MemberIds.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EMemberIds); }  ",
          "content_tokens": 838,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomDetails",
          "content": "internal void SetName(string name) { Name = name; Debug.Log($\"[RoomDetails] SetName Name: {Name}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EName);  internal void SetMemberIds(List<NetworkObject> memberIds) { MemberIds = memberIds; Debug.Log($\"[RoomDetails] SetMemberIds MemberIds: {MemberIds.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EMemberIds);  ",
          "content_tokens": 113,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomDetails",
          "content": "internal void AddMemberToNewOrExistingTeam(NetworkObject clientId) { //Get from Teams with empty slot. foreach (Team team in Teams) { for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] == null) { team.Slots[i] = clientId; Debug.Log($\"[RoomDetails] AddMemberToNewOrExistingTeam MemberIds: {MemberIds.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.ETeams); return; } } } //Create new team. var newTeam = new Team(new NetworkObject[TEAM_MEMBERS_AMOUNT]); newTeam.Slots[0] = clientId; Teams.Add(newTeam); Debug.Log($\"[RoomDetails] AddMemberToNewOrExistingTeam MemberIds: {MemberIds.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.ETeams);  ",
          "content_tokens": 218,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomDetails",
          "content": "internal void SetTeams(List<Team> teams) { Teams = teams; Debug.Log($\"[RoomDetails] SetTeams MemberIds: {MemberIds.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.ETeams);  public void AddPlayerCharacter(NetworkObject playerChar) { if (!PlayerCharacters.Contains(playerChar)) { _playerCharacters.Add(playerChar); StringBuilder sb = new StringBuilder($\"[RoomDetails] AddPlayerCharacter PlayerCharacters: \"); foreach (var playerHero in PlayerCharacters) { sb.Append($\"{playerHero}, \"); } Debug.Log(sb.ToString()); Debug.Log($\"[RoomDetails] AddPlayerCharacter PlayerCharacters: {PlayerCharacters.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EPlayerCharacters); }  ",
          "content_tokens": 185,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomDetails",
          "content": "public void RemovePlayerCharacter(NetworkObject playerChar) { if (PlayerCharacters.Contains(playerChar)) { _playerCharacters.Remove(playerChar); Debug.Log($\"[RoomDetails] RemovePlayerCharacter PlayerCharacters: {PlayerCharacters.Count}\"); OnRoomDetailsUpdated?.Invoke( WhichField.EPlayerCharacters); }  ",
          "content_tokens": 73,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomDetails",
          "content": "internal void SetPlayerCharacters(List<NetworkObject> playerCharacters) { _playerCharacters = new HashSet<NetworkObject>(playerCharacters); StringBuilder sb = new StringBuilder($\"[RoomDetails] SetPlayerCharacters PlayerCharacters: \"); foreach (var playerHero in PlayerCharacters) { sb.Append($\"{playerHero}, \"); } Debug.Log(sb.ToString()); Debug.Log($\"[RoomDetails] SetPlayerCharacters PlayerCharacters: {PlayerCharacters.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EPlayerCharacters); } /// <summary> /// Adds a member to StartedMembers. /// </summary> /// <param name=\"clientId\"></param> internal void AddStartedMember(NetworkObject clientId) { if (!StartedMembers.Contains(clientId)) { StartedMembers.Add(clientId); Debug.Log($\"[RoomDetails] AddStartedMember StartedMembers: {StartedMembers.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EStartedMembers); }  ",
          "content_tokens": 225,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomDetails",
          "content": "internal void SetStartedMembers(List<NetworkObject> startedMembers) { StartedMembers = startedMembers; Debug.Log($\"[RoomDetails] SetStartedMembers StartedMembers: {StartedMembers.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EStartedMembers); } /// <summary> /// Removes from Members. /// </summary> /// <param name=\"clientId\"></param> internal bool RemoveMember(NetworkObject clientId) { int index = MemberIds.IndexOf(clientId); if (index != -1) { MemberIds.RemoveAt(index); Debug.Log($\"[RoomDetails] RemoveMember MemberIds: {MemberIds.Count}\"); OnRoomDetailsUpdated?.Invoke( WhichField.EMemberIds); //Also try to remove from started. StartedMembers.Remove(clientId); Debug.Log($\"[RoomDetails] RemoveMember StartedMembers: {StartedMembers.Count}\"); OnRoomDetailsUpdated?.Invoke( WhichField.EStartedMembers); if (IsTeamsMode) { RemoveMemberFromTeam(clientId); Debug.Log($\"[RoomDetails] RemoveMember Teams: {Teams.Count}\"); OnRoomDetailsUpdated?.Invoke( WhichField.ETeams); } return true; } else { return false; }  ",
          "content_tokens": 285,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomDetails",
          "content": "internal void RemoveMemberFromTeam(NetworkObject clientId) { foreach (Team team in Teams) { for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] == clientId) { team.Slots[i] = null; return; } } }  internal void ClearMembers() { MemberIds.Clear(); foreach (Team team in Teams) { team.Slots = new NetworkObject[TEAM_MEMBERS_AMOUNT]; } Debug.Log($\"[RoomDetails] ClearMembers MemberIds: {MemberIds.Count}\"); OnRoomDetailsUpdated?.Invoke( WhichField.EMemberIds);  internal bool IsKickedMember(NetworkObject clientId) { return KickedIds.Contains(clientId);  ",
          "content_tokens": 180,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomDetails",
          "content": "internal void AddKicked(NetworkObject clientId) { if (IsKickedMember(clientId)) return; KickedIds.Add(clientId); Debug.Log($\"[RoomDetails] AddKicked KickedIds: {KickedIds.Count}\"); OnRoomDetailsUpdated?.Invoke( WhichField.EKickedIds);  internal void SetKickedIds(List<NetworkObject> kickedIds) { KickedIds = kickedIds; Debug.Log($\"[RoomDetails] SetKickedIds KickedIds: {KickedIds.Count}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EKickedIds);  internal void SetOwner(string ownerName) { Owner = ownerName;  internal void SetStartImmediately(bool isStartImmediately) { IsStartImmediately = isStartImmediately;  ",
          "content_tokens": 193,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomDetails",
          "content": "public bool IsAlly(NetworkConnection ownerA, NetworkConnection ownerB) { if (!IsTeamsMode) return false; foreach (Team team in Teams) { for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] == null) continue; if (team.Slots[i].Owner == ownerA || team.Slots[i].Owner == ownerB) { if (i >= team.Slots.Length - 1) { return false;  ",
          "content_tokens": 115,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomDetails",
          "content": "for (int j = i+1; j < team.Slots.Length; j++) { if (team.Slots[j] == null) continue; if (team.Slots[j].Owner == ownerA || team.Slots[j].Owner == ownerB) { return true; } } } } } return false; } [Serializable] public class Team { public NetworkObject[] Slots; public Team() {  ",
          "content_tokens": 95,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomDetails",
          "content": "public Team(NetworkObject[] slots) { Slots = slots; } } /// <summary> /// Returns other members on the same team as the provided player. /// </summary> /// <param name=\"targetPlayerNetworkObject\"></param> /// <returns></returns> public List<NetworkObject> GetActiveTeamClientInstances(NetworkObject targetPlayerNetworkObject) { NetworkObject targetClientInstance = targetPlayerNetworkObject.Owner.FirstObject; Team team = Teams.First(t => t.Slots.Contains(targetClientInstance)); List<NetworkObject> teamMembers = new List<NetworkObject>(); for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] != null) { teamMembers.Add(team.Slots[i]); } } return teamMembers; } /// <summary> /// Returns all team(including targetPlayer) members on the same team as the provided player. /// </summary> /// <param name=\"targetPlayerNetworkObject\"></param> /// <returns></returns> public List<NetworkConnection> GetActiveClientsFromSameTeam(NetworkObject targetPlayerNetworkObject) { NetworkObject targetClientInstance = targetPlayerNetworkObject.Owner.FirstObject; Team team = Teams.First(t => t.Slots.Contains(targetClientInstance)); List<NetworkConnection> teamMembers = new List<NetworkConnection>(); for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] != null) { teamMembers.Add(team.Slots[i].Owner); } } return teamMembers; } /// <summary> /// Returns all team(excluding targetPlayer) members on the same team as the provided player. /// </summary> /// <param name=\"myPlayerNetworkObject\"></param> /// <returns></returns> public List<NetworkConnection> GetActiveClientsFromSameTeamExcludingMe(NetworkObject myPlayerNetworkObject) { NetworkObject myClientInstance = myPlayerNetworkObject.Owner.FirstObject; Team team = Teams.First(t => t.Slots.Contains(myClientInstance)); List<NetworkConnection> teamMembers = new List<NetworkConnection>(); for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i] == myClientInstance) continue; if (team.Slots[i] == null) continue; teamMembers.Add(team.Slots[i].Owner); } return teamMembers;  ",
          "content_tokens": 549,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomDetails",
          "content": "public void StorePlayerTokens(Dictionary<NetworkConnection, string> playerTokens) { _playerTokens = playerTokens;  internal void SetIsTeamsMode(bool isTeamsMode) { IsTeamsMode = isTeamsMode; Debug.Log($\"[RoomDetails] SetIsTeamsMode IsTeamsMode: {IsTeamsMode}\"); OnRoomDetailsUpdated?.Invoke(WhichField.EIsTeamsMode); } } }",
          "content_tokens": 97,
          "embedding": []
        }
      ],
      "length": 11501
    },
    {
      "filename": "UnitComponents",
      "content": "using System; using _ZombieRoyale.Scripts.Clients; using FishNet.Object; using FishnetInvector; using Zomb.Creatures.Helpers; namespace _ZombieRoyale.Scripts.Core { [Serializable] public class UnitComponents { public FishnetInvectorManager InvectorManager; public FishnetInvectorItemManager ItemManager; public FishnetInvectorHealthController HealthController; public FishnetInvectorShooterManager ShooterManager; public FishnetInvectorProjectilesManager ProjectilesManager; public FNStatsController StatsController; public FNXpController XpController; public FNAbilityController AbilityController; public FNvMeleeManager MeleeManager; public AttachmentPoints AttachmentPoints; public AIUnit AIUnit; public TeamUIController TeamUiController; public FishnetInvectorBuffController BuffController; public AnimatorDecorator AnimatorDecorator; public UnitComponents(NetworkObject netObj) { InvectorManager = netObj.GetComponent<FishnetInvectorManager>(); ItemManager = netObj.GetComponent<FishnetInvectorItemManager>(); HealthController = netObj.GetComponent<FishnetInvectorHealthController>(); ShooterManager = netObj.GetComponent<FishnetInvectorShooterManager>(); ProjectilesManager = netObj.GetComponent<FishnetInvectorProjectilesManager>(); StatsController = netObj.GetComponent<FNStatsController>(); XpController = netObj.GetComponent<FNXpController>(); AbilityController = netObj.GetComponent<FNAbilityController>(); MeleeManager = netObj.GetComponent<FNvMeleeManager>(); AttachmentPoints = netObj.GetComponent<AttachmentPoints>(); AIUnit = netObj.GetComponent<AIUnit>(); TeamUiController = netObj.GetComponent<TeamUIController>(); BuffController = netObj.GetComponent<FishnetInvectorBuffController>(); AnimatorDecorator = netObj.GetComponent<AnimatorDecorator>(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "UnitComponents",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "UnitComponents",
          "content": "using System; using _ZombieRoyale.Scripts.Clients; using FishNet.Object; using FishnetInvector; using Zomb.Creatures.Helpers; namespace _ZombieRoyale.Scripts.Core { [Serializable] public class UnitComponents { public FishnetInvectorManager InvectorManager; public FishnetInvectorItemManager ItemManager; public FishnetInvectorHealthController HealthController; public FishnetInvectorShooterManager ShooterManager; public FishnetInvectorProjectilesManager ProjectilesManager; public FNStatsController StatsController; public FNXpController XpController; public FNAbilityController AbilityController; public FNvMeleeManager MeleeManager; public AttachmentPoints AttachmentPoints; public AIUnit AIUnit; public TeamUIController TeamUiController; public FishnetInvectorBuffController BuffController; public AnimatorDecorator AnimatorDecorator; public UnitComponents(NetworkObject netObj) { InvectorManager = netObj.GetComponent<FishnetInvectorManager>(); ItemManager = netObj.GetComponent<FishnetInvectorItemManager>(); HealthController = netObj.GetComponent<FishnetInvectorHealthController>(); ShooterManager = netObj.GetComponent<FishnetInvectorShooterManager>(); ProjectilesManager = netObj.GetComponent<FishnetInvectorProjectilesManager>(); StatsController = netObj.GetComponent<FNStatsController>(); XpController = netObj.GetComponent<FNXpController>(); AbilityController = netObj.GetComponent<FNAbilityController>(); MeleeManager = netObj.GetComponent<FNvMeleeManager>(); AttachmentPoints = netObj.GetComponent<AttachmentPoints>(); AIUnit = netObj.GetComponent<AIUnit>(); TeamUiController = netObj.GetComponent<TeamUIController>(); BuffController = netObj.GetComponent<FishnetInvectorBuffController>(); AnimatorDecorator = netObj.GetComponent<AnimatorDecorator>(); } } }",
          "content_tokens": 440,
          "embedding": []
        }
      ],
      "length": 1771
    },
    {
      "filename": "ItemReferenceNetworked",
      "content": "using System; using Invector.vItemManager; using SingletonsExtension; [Serializable] public class ItemReferenceNetworked { public int id; public int amount; public ItemReference ToNonNetworked() { vItem item = MasterManager.GetVItem(id); if (item == null) { return null; } ItemReference itemReference = item.ToItemReference(); return itemReference; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ItemReferenceNetworked",
          "content": "using System; using Invector.vItemManager; using SingletonsExtension; [Serializable] public class ItemReferenceNetworked { public int id; public int amount; public ItemReference ToNonNetworked() { vItem item = MasterManager.GetVItem(id); if (item == null) { return null; } ItemReference itemReference = item.ToItemReference(); return itemReference; } }",
          "content_tokens": 87,
          "embedding": []
        }
      ],
      "length": 352
    },
    {
      "filename": "DiscordController",
      "content": "using Discord; using UnityEngine; using UnityEngine.SceneManagement; using DDCore; public class DiscordController : MonoBehaviour { private long ApplicationId = 1181308922603262113; public Discord.Discord Discord; public static DiscordController Instance { get; private set; } private string activityDetail = \"In-Game\"; private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); } else { Destroy(this); } } void Start() { UpdateDiscordActivity(); } void FixedUpdate() { if (NetworkHudCanvases.Instance.IsAutoStartServer) return; #if UNITY_SERVER return; #endif try { if (Discord == null) { InitDiscord(); } var activityManager = Discord.GetActivityManager(); var activity = new Activity { State = activityDetail }; #if !UNITY_EDITOR activityManager.UpdateActivity(activity, (res) => { if (res == Result.Ok) { //Debug.Log(\"Successfully updated activity\"); } else { Debug.LogError(\"Failed connecting to Discord\"); } }); #endif Discord.RunCallbacks(); } catch (Discord.ResultException ex) { if (ex.Result != Result.Ok) InitDiscord(); return; } } public void UpdateDiscordActivity() { activityDetail = GetSceneDescription(); } private void InitDiscord() { Discord = new Discord.Discord(ApplicationId, (System.UInt64)CreateFlags.NoRequireDiscord); } private string GetSceneDescription() { for (int i = 0; i < SceneManager.sceneCount; i++) { Scene scene = SceneManager.GetSceneAt(i); if (scene.name == \"RoomDynamic\") { return \"In-Game\"; } } switch (SceneManager.GetActiveScene().name) { case \"Main\": return \"In Main menu\"; case \"CharacterCreation\": return \"Character creation\"; default: return \"In Game\"; } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DiscordController",
          "content": "using Discord; using UnityEngine; using UnityEngine.SceneManagement; using DDCore; public class DiscordController : MonoBehaviour { private long ApplicationId = 1181308922603262113; public Discord.Discord Discord; public static DiscordController Instance { get; private set; } private string activityDetail = \"In-Game\"; private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); } else { Destroy(this); }  void Start() { UpdateDiscordActivity();  ",
          "content_tokens": 120,
          "embedding": []
        },
        {
          "cs_scriptfile": "DiscordController",
          "content": "void FixedUpdate() { if (NetworkHudCanvases.Instance.IsAutoStartServer) return; #if UNITY_SERVER return; #endif try { if (Discord == null) { InitDiscord(); } var activityManager = Discord.GetActivityManager(); var activity = new Activity { State = activityDetail }; #if !UNITY_EDITOR activityManager.UpdateActivity(activity, (res) => { if (res == Result.Ok) { //Debug.Log(\"Successfully updated activity\"); } else { Debug.LogError(\"Failed connecting to Discord\"); } }); #endif Discord.RunCallbacks();  catch (Discord.ResultException ex) { if (ex.Result != Result.Ok) InitDiscord(); return; }  public void UpdateDiscordActivity() { activityDetail = GetSceneDescription();  ",
          "content_tokens": 182,
          "embedding": []
        },
        {
          "cs_scriptfile": "DiscordController",
          "content": "private void InitDiscord() { Discord = new Discord.Discord(ApplicationId, (System.UInt64)CreateFlags.NoRequireDiscord);  private string GetSceneDescription() { for (int i = 0; i < SceneManager.sceneCount; i++) { Scene scene = SceneManager.GetSceneAt(i); if (scene.name == \"RoomDynamic\") { return \"In-Game\"; }  switch (SceneManager.GetActiveScene().name) { case \"Main\": return \"In Main menu\"; case \"CharacterCreation\": return \"Character creation\"; default: return \"In Game\"; } } }",
          "content_tokens": 134,
          "embedding": []
        }
      ],
      "length": 1641
    },
    {
      "filename": "Program",
      "content": " using System; using System.Linq; using System.Threading; using System.Text; using System.Runtime.InteropServices; class Program { // Request user's avatar data. Sizes can be powers of 2 between 16 and 2048 static void FetchAvatar(Discord.ImageManager imageManager, Int64 userID) { imageManager.Fetch(Discord.ImageHandle.User(userID), (result, handle) => { { if (result == Discord.Result.Ok) { // You can also use GetTexture2D within Unity. // These return raw RGBA. var data = imageManager.GetData(handle); Console.WriteLine(\"image updated {0} {1}\", handle.Id, data.Length); } else { Console.WriteLine(\"image error {0}\", handle.Id); } } }); } // Update user's activity for your game. // Party and secrets are vital. // Read https://discordapp.com/developers/docs/rich-presence/how-to for more details. static void UpdateActivity(Discord.Discord discord, Discord.Lobby lobby) { var activityManager = discord.GetActivityManager(); var lobbyManager = discord.GetLobbyManager(); var activity = new Discord.Activity { State = \"olleh\", Details = \"foo details\", Timestamps = { Start = 5, End = 6, }, Assets = { LargeImage = \"foo largeImageKey\", LargeText = \"foo largeImageText\", SmallImage = \"foo smallImageKey\", SmallText = \"foo smallImageText\", }, Party = { Id = lobby.Id.ToString(), Size = { CurrentSize = lobbyManager.MemberCount(lobby.Id), MaxSize = (int)lobby.Capacity, }, }, Secrets = { Join = lobbyManager.GetLobbyActivitySecret(lobby.Id), }, Instance = true, }; activityManager.UpdateActivity(activity, result => { Console.WriteLine(\"Update Activity {0}\", result); // Send an invite to another user for this activity. // Receiver should see an invite in their DM. // Use a relationship user's ID for this. // activityManager // .SendInvite( // 364843917537050624, // Discord.ActivityActionType.Join, // \"\", // inviteResult => // { // Console.WriteLine(\"Invite {0}\", inviteResult); // } // ); }); } static void Main(string[] args) { // Use your client ID from Discord's developer site. var clientID = Environment.GetEnvironmentVariable(\"DISCORD_CLIENT_ID\"); if (clientID == null) { clientID = \"418559331265675294\"; } var discord = new Discord.Discord(Int64.Parse(clientID), (UInt64)Discord.CreateFlags.Default); discord.SetLogHook(Discord.LogLevel.Debug, (level, message) => { Console.WriteLine(\"Log[{0}] {1}\", level, message); }); var applicationManager = discord.GetApplicationManager(); // Get the current locale. This can be used to determine what text or audio the user wants. Console.WriteLine(\"Current Locale: {0}\", applicationManager.GetCurrentLocale()); // Get the current branch. For example alpha or beta. Console.WriteLine(\"Current Branch: {0}\", applicationManager.GetCurrentBranch()); // If you want to verify information from your game's server then you can // grab the access token and send it to your server. // // This automatically looks for an environment variable passed by the Discord client, // if it does not exist the Discord client will focus itself for manual authorization. // // By-default the SDK grants the identify and rpc scopes. // Read more at https://discordapp.com/developers/docs/topics/oauth2 // applicationManager.GetOAuth2Token((Discord.Result result, ref Discord.OAuth2Token oauth2Token) => // { // Console.WriteLine(\"Access Token {0}\", oauth2Token.AccessToken); // }); var activityManager = discord.GetActivityManager(); var lobbyManager = discord.GetLobbyManager(); // Received when someone accepts a request to join or invite. // Use secrets to receive back the information needed to add the user to the group/party/match activityManager.OnActivityJoin += secret => { Console.WriteLine(\"OnJoin {0}\", secret); lobbyManager.ConnectLobbyWithActivitySecret(secret, (Discord.Result result, ref Discord.Lobby lobby) => { Console.WriteLine(\"Connected to lobby: {0}\", lobby.Id); lobbyManager.ConnectNetwork(lobby.Id); lobbyManager.OpenNetworkChannel(lobby.Id, 0, true); foreach (var user in lobbyManager.GetMemberUsers(lobby.Id)) { lobbyManager.SendNetworkMessage(lobby.Id, user.Id, 0, Encoding.UTF8.GetBytes(String.Format(\"Hello, {0}!\", user.Username))); } UpdateActivity(discord, lobby); }); }; // Received when someone accepts a request to spectate activityManager.OnActivitySpectate += secret => { Console.WriteLine(\"OnSpectate {0}\", secret); }; // A join request has been received. Render the request on the UI. activityManager.OnActivityJoinRequest += (ref Discord.User user) => { Console.WriteLine(\"OnJoinRequest {0} {1}\", user.Id, user.Username); }; // An invite has been received. Consider rendering the user / activity on the UI. activityManager.OnActivityInvite += (Discord.ActivityActionType Type, ref Discord.User user, ref Discord.Activity activity2) => { Console.WriteLine(\"OnInvite {0} {1} {2}\", Type, user.Username, activity2.Name); // activityManager.AcceptInvite(user.Id, result => // { // Console.WriteLine(\"AcceptInvite {0}\", result); // }); }; // This is used to register the game in the registry such that Discord can find it. // This is only needed by games acquired from other platforms, like Steam. // activityManager.RegisterCommand(); var imageManager = discord.GetImageManager(); var userManager = discord.GetUserManager(); // The auth manager fires events as information about the current user changes. // This event will fire once on init. // // GetCurrentUser will error until this fires once. userManager.OnCurrentUserUpdate += () => { var currentUser = userManager.GetCurrentUser(); Console.WriteLine(currentUser.Username); Console.WriteLine(currentUser.Id); }; // If you store Discord user ids in a central place like a leaderboard and want to render them. // The users manager can be used to fetch arbitrary Discord users. This only provides basic // information and does not automatically update like relationships. userManager.GetUser(450795363658366976, (Discord.Result result, ref Discord.User user) => { if (result == Discord.Result.Ok) { Console.WriteLine(\"user fetched: {0}\", user.Username); // Request users's avatar data. // This can only be done after a user is successfully fetched. FetchAvatar(imageManager, user.Id); } else { Console.WriteLine(\"user fetch error: {0}\", result); } }); var relationshipManager = discord.GetRelationshipManager(); // It is important to assign this handle right away to get the initial relationships refresh. // This callback will only be fired when the whole list is initially loaded or was reset relationshipManager.OnRefresh += () => { // Filter a user's relationship list to be just friends relationshipManager.Filter((ref Discord.Relationship relationship) => { return relationship.Type == Discord.RelationshipType.Friend; }); // Loop over all friends a user has. Console.WriteLine(\"relationships updated: {0}\", relationshipManager.Count()); for (var i = 0; i < Math.Min(relationshipManager.Count(), 10); i++) { // Get an individual relationship from the list var r = relationshipManager.GetAt((uint)i); Console.WriteLine(\"relationships: {0} {1} {2} {3}\", r.Type, r.User.Username, r.Presence.Status, r.Presence.Activity.Name); // Request relationship's avatar data. FetchAvatar(imageManager, r.User.Id); } }; // All following relationship updates are delivered individually. // These are fired when a user gets a new friend, removes a friend, or a relationship's presence changes. relationshipManager.OnRelationshipUpdate += (ref Discord.Relationship r) => { Console.WriteLine(\"relationship updated: {0} {1} {2} {3}\", r.Type, r.User.Username, r.Presence.Status, r.Presence.Activity.Name); }; lobbyManager.OnLobbyMessage += (lobbyID, userID, data) => { Console.WriteLine(\"lobby message: {0} {1}\", lobbyID, Encoding.UTF8.GetString(data)); }; lobbyManager.OnNetworkMessage += (lobbyId, userId, channelId, data) => { Console.WriteLine(\"network message: {0} {1} {2} {3}\", lobbyId, userId, channelId, Encoding.UTF8.GetString(data)); }; lobbyManager.OnSpeaking += (lobbyID, userID, speaking) => { Console.WriteLine(\"lobby speaking: {0} {1} {2}\", lobbyID, userID, speaking); }; // Create a lobby. var transaction = lobbyManager.GetLobbyCreateTransaction(); transaction.SetCapacity(6); transaction.SetType(Discord.LobbyType.Public); transaction.SetMetadata(\"a\", \"123\"); transaction.SetMetadata(\"a\", \"456\"); transaction.SetMetadata(\"b\", \"111\"); transaction.SetMetadata(\"c\", \"222\"); lobbyManager.CreateLobby(transaction, (Discord.Result result, ref Discord.Lobby lobby) => { if (result != Discord.Result.Ok) { return; } // Check the lobby's configuration. Console.WriteLine(\"lobby {0} with capacity {1} and secret {2}\", lobby.Id, lobby.Capacity, lobby.Secret); // Check lobby metadata. foreach (var key in new string[] { \"a\", \"b\", \"c\" }) { Console.WriteLine(\"{0} = {1}\", key, lobbyManager.GetLobbyMetadataValue(lobby.Id, key)); } // Print all the members of the lobby. foreach (var user in lobbyManager.GetMemberUsers(lobby.Id)) { Console.WriteLine(\"lobby member: {0}\", user.Username); } // Send everyone a message. lobbyManager.SendLobbyMessage(lobby.Id, \"Hello from C#!\", (_) => { Console.WriteLine(\"sent message\"); }); // Update lobby. var lobbyTransaction = lobbyManager.GetLobbyUpdateTransaction(lobby.Id); lobbyTransaction.SetMetadata(\"d\", \"e\"); lobbyTransaction.SetCapacity(16); lobbyManager.UpdateLobby(lobby.Id, lobbyTransaction, (_) => { Console.WriteLine(\"lobby has been updated\"); }); // Update a member. var lobbyID = lobby.Id; var userID = lobby.OwnerId; var memberTransaction = lobbyManager.GetMemberUpdateTransaction(lobbyID, userID); memberTransaction.SetMetadata(\"hello\", \"there\"); lobbyManager.UpdateMember(lobbyID, userID, memberTransaction, (_) => { Console.WriteLine(\"lobby member has been updated: {0}\", lobbyManager.GetMemberMetadataValue(lobbyID, userID, \"hello\")); }); // Search lobbies. var query = lobbyManager.GetSearchQuery(); // Filter by a metadata value. query.Filter(\"metadata.a\", Discord.LobbySearchComparison.GreaterThan, Discord.LobbySearchCast.Number, \"455\"); query.Sort(\"metadata.a\", Discord.LobbySearchCast.Number, \"0\"); // Only return 1 result max. query.Limit(1); lobbyManager.Search(query, (_) => { Console.WriteLine(\"search returned {0} lobbies\", lobbyManager.LobbyCount()); if (lobbyManager.LobbyCount() == 1) { Console.WriteLine(\"first lobby secret: {0}\", lobbyManager.GetLobby(lobbyManager.GetLobbyId(0)).Secret); } }); // Connect to voice chat. lobbyManager.ConnectVoice(lobby.Id, (_) => { Console.WriteLine(\"Connected to voice chat!\"); }); // Setup networking. lobbyManager.ConnectNetwork(lobby.Id); lobbyManager.OpenNetworkChannel(lobby.Id, 0, true); // Update activity. UpdateActivity(discord, lobby); }); /* var overlayManager = discord.GetOverlayManager(); overlayManager.OnOverlayLocked += locked => { Console.WriteLine(\"Overlay Locked: {0}\", locked); }; overlayManager.SetLocked(false); */ var storageManager = discord.GetStorageManager(); var contents = new byte[20000]; var random = new Random(); random.NextBytes(contents); Console.WriteLine(\"storage path: {0}\", storageManager.GetPath()); storageManager.WriteAsync(\"foo\", contents, res => { var files = storageManager.Files(); foreach (var file in files) { Console.WriteLine(\"file: {0} size: {1} last_modified: {2}\", file.Filename, file.Size, file.LastModified); } storageManager.ReadAsyncPartial(\"foo\", 400, 50, (result, data) => { Console.WriteLine(\"partial contents of foo match {0}\", Enumerable.SequenceEqual(data, new ArraySegment<byte>(contents, 400, 50))); }); storageManager.ReadAsync(\"foo\", (result, data) => { Console.WriteLine(\"length of contents {0} data {1}\", contents.Length, data.Length); Console.WriteLine(\"contents of foo match {0}\", Enumerable.SequenceEqual(data, contents)); Console.WriteLine(\"foo exists? {0}\", storageManager.Exists(\"foo\")); storageManager.Delete(\"foo\"); Console.WriteLine(\"post-delete foo exists? {0}\", storageManager.Exists(\"foo\")); }); }); var storeManager = discord.GetStoreManager(); storeManager.OnEntitlementCreate += (ref Discord.Entitlement entitlement) => { Console.WriteLine(\"Entitlement Create1: {0}\", entitlement.Id); }; // Start a purchase flow. // storeManager.StartPurchase(487507201519255552, result => // { // if (result == Discord.Result.Ok) // { // Console.WriteLine(\"Purchase Complete\"); // } // else // { // Console.WriteLine(\"Purchase Canceled\"); // } // }); // Get all entitlements. storeManager.FetchEntitlements(result => { if (result == Discord.Result.Ok) { foreach (var entitlement in storeManager.GetEntitlements()) { Console.WriteLine(\"entitlement: {0} - {1} {2}\", entitlement.Id, entitlement.Type, entitlement.SkuId); } } }); // Get all SKUs. storeManager.FetchSkus(result => { if (result == Discord.Result.Ok) { foreach (var sku in storeManager.GetSkus()) { Console.WriteLine(\"sku: {0} - {1} {2}\", sku.Name, sku.Price.Amount, sku.Price.Currency); } } }); // Pump the event look to ensure all callbacks continue to get fired. try { while (true) { discord.RunCallbacks(); lobbyManager.FlushNetwork(); Thread.Sleep(1000 / 60); } } finally { discord.Dispose(); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Program",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "Program",
          "content": " using System; using System.Linq; using System.Threading; using System.Text; using System.Runtime.InteropServices; class Program { // Request user's avatar data. Sizes can be powers of 2 between 16 and 2048 static void FetchAvatar(Discord.ImageManager imageManager, Int64 userID) { imageManager.Fetch(Discord.ImageHandle.User(userID), (result, handle) => { { if (result == Discord.Result.Ok) { // You can also use GetTexture2D within Unity. // These return raw RGBA. var data = imageManager.GetData(handle); Console.WriteLine(\"image updated {0} {1}\", handle.Id, data.Length); } else { Console.WriteLine(\"image error {0}\", handle.Id); } } }); } // Update user's activity for your game. // Party and secrets are vital. // Read https://discordapp.com/developers/docs/rich-presence/how-to for more details. static void UpdateActivity(Discord.Discord discord, Discord.Lobby lobby) { var activityManager = discord.GetActivityManager(); var lobbyManager = discord.GetLobbyManager(); var activity = new Discord.Activity { State = \"olleh\", Details = \"foo details\", Timestamps = { Start = 5, End = 6, }, Assets = { LargeImage = \"foo largeImageKey\", LargeText = \"foo largeImageText\", SmallImage = \"foo smallImageKey\", SmallText = \"foo smallImageText\", }, Party = { Id = lobby.Id.ToString(), Size = { CurrentSize = lobbyManager.MemberCount(lobby.Id), MaxSize = (int)lobby.Capacity, }, }, Secrets = { Join = lobbyManager.GetLobbyActivitySecret(lobby.Id), }, Instance = true, }; activityManager.UpdateActivity(activity, result => { Console.WriteLine(\"Update Activity {0}\", result); // Send an invite to another user for this activity. // Receiver should see an invite in their DM. // Use a relationship user's ID for this. // activityManager // .SendInvite( // 364843917537050624, // Discord.ActivityActionType.Join, // \"\", // inviteResult => // { // Console.WriteLine(\"Invite {0}\", inviteResult); // } // ); });  ",
          "content_tokens": 522,
          "embedding": []
        },
        {
          "cs_scriptfile": "Program",
          "content": "static void Main(string[] args) { // Use your client ID from Discord's developer site. var clientID = Environment.GetEnvironmentVariable(\"DISCORD_CLIENT_ID\"); if (clientID == null) { clientID = \"418559331265675294\"; } var discord = new Discord.Discord(Int64.Parse(clientID), (UInt64)Discord.CreateFlags.Default); discord.SetLogHook(Discord.LogLevel.Debug, (level, message) => { Console.WriteLine(\"Log[{0}] {1}\", level, message); }); var applicationManager = discord.GetApplicationManager(); // Get the current locale. This can be used to determine what text or audio the user wants. Console.WriteLine(\"Current Locale: {0}\", applicationManager.GetCurrentLocale()); // Get the current branch. For example alpha or beta. Console.WriteLine(\"Current Branch: {0}\", applicationManager.GetCurrentBranch()); // If you want to verify information from your game's server then you can // grab the access token and send it to your server. // // This automatically looks for an environment variable passed by the Discord client, // if it does not exist the Discord client will focus itself for manual authorization. // // By-default the SDK grants the identify and rpc scopes. // Read more at https://discordapp.com/developers/docs/topics/oauth2 // applicationManager.GetOAuth2Token((Discord.Result result, ref Discord.OAuth2Token oauth2Token) => // { // Console.WriteLine(\"Access Token {0}\", oauth2Token.AccessToken); // }); var activityManager = discord.GetActivityManager(); var lobbyManager = discord.GetLobbyManager(); // Received when someone accepts a request to join or invite. // Use secrets to receive back the information needed to add the user to the group/party/match activityManager.OnActivityJoin += secret => { Console.WriteLine(\"OnJoin {0}\", secret); lobbyManager.ConnectLobbyWithActivitySecret(secret, (Discord.Result result, ref Discord.Lobby lobby) => { Console.WriteLine(\"Connected to lobby: {0}\", lobby.Id); lobbyManager.ConnectNetwork(lobby.Id); lobbyManager.OpenNetworkChannel(lobby.Id, 0, true); foreach (var user in lobbyManager.GetMemberUsers(lobby.Id)) { lobbyManager.SendNetworkMessage(lobby.Id, user.Id, 0, Encoding.UTF8.GetBytes(String.Format(\"Hello, {0}!\", user.Username)));  ",
          "content_tokens": 579,
          "embedding": []
        },
        {
          "cs_scriptfile": "Program",
          "content": "UpdateActivity(discord, lobby); }); }; // Received when someone accepts a request to spectate activityManager.OnActivitySpectate += secret => { Console.WriteLine(\"OnSpectate {0}\", secret); }; // A join request has been received. Render the request on the UI. activityManager.OnActivityJoinRequest += (ref Discord.User user) => { Console.WriteLine(\"OnJoinRequest {0} {1}\", user.Id, user.Username); }; // An invite has been received. Consider rendering the user / activity on the UI. activityManager.OnActivityInvite += (Discord.ActivityActionType Type, ref Discord.User user, ref Discord.Activity activity2) => { Console.WriteLine(\"OnInvite {0} {1} {2}\", Type, user.Username, activity2.Name); // activityManager.AcceptInvite(user.Id, result => // { // Console.WriteLine(\"AcceptInvite {0}\", result); // }); }; // This is used to register the game in the registry such that Discord can find it. // This is only needed by games acquired from other platforms, like Steam. // activityManager.RegisterCommand(); var imageManager = discord.GetImageManager(); var userManager = discord.GetUserManager(); // The auth manager fires events as information about the current user changes. // This event will fire once on init. // // GetCurrentUser will error until this fires once. userManager.OnCurrentUserUpdate += () => { var currentUser = userManager.GetCurrentUser(); Console.WriteLine(currentUser.Username); Console.WriteLine(currentUser.Id); }; // If you store Discord user ids in a central place like a leaderboard and want to render them. // The users manager can be used to fetch arbitrary Discord users. This only provides basic // information and does not automatically update like relationships. userManager.GetUser(450795363658366976, (Discord.Result result, ref Discord.User user) => { if (result == Discord.Result.Ok) { Console.WriteLine(\"user fetched: {0}\", user.Username); // Request users's avatar data. // This can only be done after a user is successfully fetched. FetchAvatar(imageManager, user.Id); } else { Console.WriteLine(\"user fetch error: {0}\", result); } }); var relationshipManager = discord.GetRelationshipManager(); // It is important to assign this handle right away to get the initial relationships refresh. // This callback will only be fired when the whole list is initially loaded or was reset relationshipManager.OnRefresh += () => { // Filter a user's relationship list to be just friends relationshipManager.Filter((ref Discord.Relationship relationship) => { return relationship.Type == Discord.RelationshipType.Friend; }); // Loop over all friends a user has. Console.WriteLine(\"relationships updated: {0}\", relationshipManager.Count()); for (var i = 0; i < Math.Min(relationshipManager.Count(), 10); i++) { // Get an individual relationship from the list var r = relationshipManager.GetAt((uint)i); Console.WriteLine(\"relationships: {0} {1} {2} {3}\", r.Type, r.User.Username, r.Presence.Status, r.Presence.Activity.Name); // Request relationship's avatar data. FetchAvatar(imageManager, r.User.Id); } }; // All following relationship updates are delivered individually. // These are fired when a user gets a new friend, removes a friend, or a relationship's presence changes. relationshipManager.OnRelationshipUpdate += (ref Discord.Relationship r) => { Console.WriteLine(\"relationship updated: {0} {1} {2} {3}\", r.Type, r.User.Username, r.Presence.Status, r.Presence.Activity.Name); }; lobbyManager.OnLobbyMessage += (lobbyID, userID, data) => { Console.WriteLine(\"lobby message: {0} {1}\", lobbyID, Encoding.UTF8.GetString(data)); }; lobbyManager.OnNetworkMessage += (lobbyId, userId, channelId, data) => { Console.WriteLine(\"network message: {0} {1} {2} {3}\", lobbyId, userId, channelId, Encoding.UTF8.GetString(data)); }; lobbyManager.OnSpeaking += (lobbyID, userID, speaking) => { Console.WriteLine(\"lobby speaking: {0} {1} {2}\", lobbyID, userID, speaking); }; // Create a lobby. var transaction = lobbyManager.GetLobbyCreateTransaction(); transaction.SetCapacity(6); transaction.SetType(Discord.LobbyType.Public); transaction.SetMetadata(\"a\", \"123\"); transaction.SetMetadata(\"a\", \"456\"); transaction.SetMetadata(\"b\", \"111\"); transaction.SetMetadata(\"c\", \"222\"); lobbyManager.CreateLobby(transaction, (Discord.Result result, ref Discord.Lobby lobby) => { if (result != Discord.Result.Ok) { return; } // Check the lobby's configuration. Console.WriteLine(\"lobby {0} with capacity {1} and secret {2}\", lobby.Id, lobby.Capacity, lobby.Secret); // Check lobby metadata. foreach (var key in new string[] { \"a\", \"b\", \"c\" }) { Console.WriteLine(\"{0} = {1}\", key, lobbyManager.GetLobbyMetadataValue(lobby.Id, key)); } // Print all the members of the lobby. foreach (var user in lobbyManager.GetMemberUsers(lobby.Id)) { Console.WriteLine(\"lobby member: {0}\", user.Username); } // Send everyone a message. lobbyManager.SendLobbyMessage(lobby.Id, \"Hello from C#!\", (_) => { Console.WriteLine(\"sent message\"); }); // Update lobby. var lobbyTransaction = lobbyManager.GetLobbyUpdateTransaction(lobby.Id); lobbyTransaction.SetMetadata(\"d\", \"e\"); lobbyTransaction.SetCapacity(16); lobbyManager.UpdateLobby(lobby.Id, lobbyTransaction, (_) => { Console.WriteLine(\"lobby has been updated\"); }); // Update a member. var lobbyID = lobby.Id; var userID = lobby.OwnerId; var memberTransaction = lobbyManager.GetMemberUpdateTransaction(lobbyID, userID); memberTransaction.SetMetadata(\"hello\", \"there\"); lobbyManager.UpdateMember(lobbyID, userID, memberTransaction, (_) => { Console.WriteLine(\"lobby member has been updated: {0}\", lobbyManager.GetMemberMetadataValue(lobbyID, userID, \"hello\")); }); // Search lobbies. var query = lobbyManager.GetSearchQuery(); // Filter by a metadata value. query.Filter(\"metadata.a\", Discord.LobbySearchComparison.GreaterThan, Discord.LobbySearchCast.Number, \"455\"); query.Sort(\"metadata.a\", Discord.LobbySearchCast.Number, \"0\"); // Only return 1 result max. query.Limit(1); lobbyManager.Search(query, (_) => { Console.WriteLine(\"search returned {0} lobbies\", lobbyManager.LobbyCount()); if (lobbyManager.LobbyCount() == 1) { Console.WriteLine(\"first lobby secret: {0}\", lobbyManager.GetLobby(lobbyManager.GetLobbyId(0)).Secret); } }); // Connect to voice chat. lobbyManager.ConnectVoice(lobby.Id, (_) => { Console.WriteLine(\"Connected to voice chat!\"); }); // Setup networking. lobbyManager.ConnectNetwork(lobby.Id); lobbyManager.OpenNetworkChannel(lobby.Id, 0, true); // Update activity. UpdateActivity(discord, lobby); }); /* var overlayManager = discord.GetOverlayManager(); overlayManager.OnOverlayLocked += locked => { Console.WriteLine(\"Overlay Locked: {0}\", locked); }; overlayManager.SetLocked(false); */ var storageManager = discord.GetStorageManager(); var contents = new byte[20000]; var random = new Random(); random.NextBytes(contents); Console.WriteLine(\"storage path: {0}\", storageManager.GetPath()); storageManager.WriteAsync(\"foo\", contents, res => { var files = storageManager.Files(); foreach (var file in files) { Console.WriteLine(\"file: {0} size: {1} last_modified: {2}\", file.Filename, file.Size, file.LastModified); } storageManager.ReadAsyncPartial(\"foo\", 400, 50, (result, data) => { Console.WriteLine(\"partial contents of foo match {0}\", Enumerable.SequenceEqual(data, new ArraySegment<byte>(contents, 400, 50))); }); storageManager.ReadAsync(\"foo\", (result, data) => { Console.WriteLine(\"length of contents {0} data {1}\", contents.Length, data.Length); Console.WriteLine(\"contents of foo match {0}\", Enumerable.SequenceEqual(data, contents)); Console.WriteLine(\"foo exists? {0}\", storageManager.Exists(\"foo\")); storageManager.Delete(\"foo\"); Console.WriteLine(\"post-delete foo exists? {0}\", storageManager.Exists(\"foo\")); }); }); var storeManager = discord.GetStoreManager(); storeManager.OnEntitlementCreate += (ref Discord.Entitlement entitlement) => { Console.WriteLine(\"Entitlement Create1: {0}\", entitlement.Id); }; // Start a purchase flow. // storeManager.StartPurchase(487507201519255552, result => // { // if (result == Discord.Result.Ok) // { // Console.WriteLine(\"Purchase Complete\"); // } // else // { // Console.WriteLine(\"Purchase Canceled\"); // } // }); // Get all entitlements. storeManager.FetchEntitlements(result => { if (result == Discord.Result.Ok) { foreach (var entitlement in storeManager.GetEntitlements()) { Console.WriteLine(\"entitlement: {0} - {1} {2}\", entitlement.Id, entitlement.Type, entitlement.SkuId); } } }); // Get all SKUs. storeManager.FetchSkus(result => { if (result == Discord.Result.Ok) { foreach (var sku in storeManager.GetSkus()) { Console.WriteLine(\"sku: {0} - {1} {2}\", sku.Name, sku.Price.Amount, sku.Price.Currency); } } }); // Pump the event look to ensure all callbacks continue to get fired. try { while (true) { discord.RunCallbacks(); lobbyManager.FlushNetwork(); Thread.Sleep(1000 / 60); } } finally { discord.Dispose(); } } }",
          "content_tokens": 2440,
          "embedding": []
        }
      ],
      "length": 12951
    },
    {
      "filename": "DoorsHider",
      "content": "using UnityEngine; public class DoorsHider : MonoBehaviour { private GameObject[] _doors; public void HideDoors() { _doors = GameObject.FindGameObjectsWithTag(\"Door\"); for (int i = 0; i < _doors.Length; i++) { _doors[i].SetActive(false); } Debug.Log($\"{_doors.Length}xDoors hidden\"); } public void ShowDoors() { for (int i = 0; i < _doors.Length; i++) { _doors[i].SetActive(true); } Debug.Log($\"{_doors.Length}xDoors shown\"); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DoorsHider",
          "content": "using UnityEngine; public class DoorsHider : MonoBehaviour { private GameObject[] _doors; public void HideDoors() { _doors = GameObject.FindGameObjectsWithTag(\"Door\"); for (int i = 0; i < _doors.Length; i++) { _doors[i].SetActive(false); } Debug.Log($\"{_doors.Length}xDoors hidden\"); } public void ShowDoors() { for (int i = 0; i < _doors.Length; i++) { _doors[i].SetActive(true); } Debug.Log($\"{_doors.Length}xDoors shown\"); } }",
          "content_tokens": 142,
          "embedding": []
        }
      ],
      "length": 429
    },
    {
      "filename": "DungeonNetworkManager",
      "content": "using System; using System.Text; using DungeonArchitect; using FishNet.Object; using FishNet.Object.Synchronizing; #if UNITY_EDITOR using ParrelSync; #endif using UnityEngine; using UnityEngine.AddressableAssets; using UnityEngine.ResourceManagement.AsyncOperations; public class DungeonNetworkManager : RoomManager { public uint Seed => _seed; [SyncVar(OnChange = nameof(OnSeedChanged))] private uint _seed; private Dungeon _dungeon; public MyDungeonListener DungeonListener { get; private set; } public bool IsDungeonSpawned { get; private set; } public static string DUNGEON_ADDRESSABLES_PATH = \"Assets/-ZombieRoyale/Prefabs/SavedDungeons\"; public static DungeonNetworkManager Instance { get; private set; } public Action OnDungeonLoaded; private void Awake() { _dungeon = GetComponent<Dungeon>(); Instance = this; OnDungeonLoaded += OnDungeonBuilded; } private void OnDungeonBuilded() { IsDungeonSpawned = true; if (IsClient) { GameplayManager.ReportDungeonBuilt(); Debug.Log($\"{ClassAndRoomName} ReportClientLoadedDungeon\"); } } private void OnDisable() { if (DungeonListener) DungeonListener.OnDungeonBuilded -= OnDungeonBuilded; } public void SetSeed(uint seed) { _seed = seed; SetDungeonSeed(); #if UNITY_EDITOR if (!ClonesManager.IsClone()) return; #endif if (GameplayManager.IsLoadDungeonFromSave) return; InitDungeonBuilding(); } private void InitDungeonBuilding() { if (_dungeon != null) { Debug.Log(\"=======Starting building dungeon========\"); _dungeon.Build(); } } private void OnSeedChanged(uint oldSeed, uint newSeed, bool asServer) { StringBuilder sb = new StringBuilder($\"[DungeonNetworkManager] \"); if (asServer) { sb.Append($\"asServer\"); } else { sb.Append($\"asClient\"); } sb.Append($\" seed: {oldSeed} -> {newSeed}\"); if (GameplayManager.IsLoadDungeonFromSave #if UNITY_EDITOR && !ClonesManager.IsClone() #endif ) { if (asServer) { sb.Append($\"Loading Dungeon\"); LoadDungeon(newSeed); } else { if (IsHost) { sb.Append($\"HostClient don't load dungeon. Just put IsDungeonSpawned = true and wait until DungeonHolder will be Instantiated.\"); } else { sb.Append($\"Loading dungeon from addressable for dedicated server connection\"); LoadDungeon(newSeed); } } Debug.Log(sb.ToString()); } else { if (!asServer) { SetDungeonSeed(); DungeonListener = GetComponent<MyDungeonListener>(); DungeonListener.OnDungeonBuilded += OnDungeonBuilded; if (_dungeon != null) { Debug.Log(\"=======Starting building dungeon========\"); _dungeon.Build(); } } } } private void SetDungeonSeed() { _dungeon.Config.Seed = _seed; Debug.Log(\"dungeon seed changed to \" + _seed); } public void LoadDungeon(uint seed) { string addressableDungeonKey = $\"{DUNGEON_ADDRESSABLES_PATH}/{seed}/DungeonHolder-{seed}.prefab\"; Addressables.LoadAssetAsync<GameObject>(addressableDungeonKey).Completed += OnPrefabLoaded; } private void OnPrefabLoaded(AsyncOperationHandle<GameObject> handle) { if (handle.Status == AsyncOperationStatus.Succeeded) { GameObject prefab = handle.Result; Instantiate(prefab, transform); } else { Debug.LogError(\"Failed to load the Addressable prefab.\"); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DungeonNetworkManager",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonNetworkManager",
          "content": "using System; using System.Text; using DungeonArchitect; using FishNet.Object; using FishNet.Object.Synchronizing; #if UNITY_EDITOR using ParrelSync; #endif using UnityEngine; using UnityEngine.AddressableAssets; using UnityEngine.ResourceManagement.AsyncOperations; public class DungeonNetworkManager : RoomManager { public uint Seed => _seed; [SyncVar(OnChange = nameof(OnSeedChanged))] private uint _seed; private Dungeon _dungeon; public MyDungeonListener DungeonListener { get; private set; } public bool IsDungeonSpawned { get; private set; } public static string DUNGEON_ADDRESSABLES_PATH = \"Assets/-ZombieRoyale/Prefabs/SavedDungeons\"; public static DungeonNetworkManager Instance { get; private set; } public Action OnDungeonLoaded; private void Awake() { _dungeon = GetComponent<Dungeon>(); Instance = this; OnDungeonLoaded += OnDungeonBuilded;  ",
          "content_tokens": 232,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonNetworkManager",
          "content": "private void OnDungeonBuilded() { IsDungeonSpawned = true; if (IsClient) { GameplayManager.ReportDungeonBuilt(); Debug.Log($\"{ClassAndRoomName} ReportClientLoadedDungeon\"); }  private void OnDisable() { if (DungeonListener) DungeonListener.OnDungeonBuilded -= OnDungeonBuilded;  public void SetSeed(uint seed) { _seed = seed; SetDungeonSeed(); #if UNITY_EDITOR if (!ClonesManager.IsClone()) return; #endif if (GameplayManager.IsLoadDungeonFromSave) return; InitDungeonBuilding();  private void InitDungeonBuilding() { if (_dungeon != null) { Debug.Log(\"=======Starting building dungeon========\"); _dungeon.Build(); }  ",
          "content_tokens": 180,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonNetworkManager",
          "content": "private void OnSeedChanged(uint oldSeed, uint newSeed, bool asServer) { StringBuilder sb = new StringBuilder($\"[DungeonNetworkManager] \"); if (asServer) { sb.Append($\"asServer\"); } else { sb.Append($\"asClient\"); } sb.Append($\" seed: {oldSeed} -> {newSeed}\"); if (GameplayManager.IsLoadDungeonFromSave #if UNITY_EDITOR && !ClonesManager.IsClone() #endif ) { if (asServer) { sb.Append($\"Loading Dungeon\"); LoadDungeon(newSeed); } else { if (IsHost) { sb.Append($\"HostClient don't load dungeon. Just put IsDungeonSpawned = true and wait until DungeonHolder will be Instantiated.\"); } else { sb.Append($\"Loading dungeon from addressable for dedicated server connection\"); LoadDungeon(newSeed); } } Debug.Log(sb.ToString()); } else { if (!asServer) { SetDungeonSeed(); DungeonListener = GetComponent<MyDungeonListener>(); DungeonListener.OnDungeonBuilded += OnDungeonBuilded; if (_dungeon != null) { Debug.Log(\"=======Starting building dungeon========\"); _dungeon.Build(); } } }  ",
          "content_tokens": 303,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonNetworkManager",
          "content": "private void SetDungeonSeed() { _dungeon.Config.Seed = _seed; Debug.Log(\"dungeon seed changed to \" + _seed);  public void LoadDungeon(uint seed) { string addressableDungeonKey = $\"{DUNGEON_ADDRESSABLES_PATH}/{seed}/DungeonHolder-{seed}.prefab\"; Addressables.LoadAssetAsync<GameObject>(addressableDungeonKey).Completed += OnPrefabLoaded;  private void OnPrefabLoaded(AsyncOperationHandle<GameObject> handle) { if (handle.Status == AsyncOperationStatus.Succeeded) { GameObject prefab = handle.Result; Instantiate(prefab, transform); } else { Debug.LogError(\"Failed to load the Addressable prefab.\"); } } }",
          "content_tokens": 187,
          "embedding": []
        }
      ],
      "length": 3060
    },
    {
      "filename": "DoorsHiderEditor",
      "content": "using UnityEditor; using UnityEngine; [CustomEditor(typeof(DoorsHider))] public class DoorsHiderEditor : Editor { private DoorsHider _doorsHider; private void OnEnable() { _doorsHider = (DoorsHider)target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); if (GUILayout.Button(\"HideDoors\")) { _doorsHider.HideDoors(); } if (GUILayout.Button(\"ShowDoors\")) { _doorsHider.ShowDoors(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DoorsHiderEditor",
          "content": "using UnityEditor; using UnityEngine; [CustomEditor(typeof(DoorsHider))] public class DoorsHiderEditor : Editor { private DoorsHider _doorsHider; private void OnEnable() { _doorsHider = (DoorsHider)target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); if (GUILayout.Button(\"HideDoors\")) { _doorsHider.HideDoors(); } if (GUILayout.Button(\"ShowDoors\")) { _doorsHider.ShowDoors(); } } }",
          "content_tokens": 127,
          "embedding": []
        }
      ],
      "length": 402
    },
    {
      "filename": "MyDungeonListener",
      "content": "using System; using DungeonArchitect; using UnityEngine; using UnityEngine.Events; public class MyDungeonListener : DungeonEventListener { public Action OnDungeonBuilded; public bool IsDungeonBuilt { get; private set; } public override void OnPostDungeonBuild(Dungeon dungeon, DungeonModel model) { Debug.Log(\"=======Dungeon build complete========\"); OnDungeonBuilded?.Invoke(); IsDungeonBuilt = true; // Write your logic here } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MyDungeonListener",
          "content": "using System; using DungeonArchitect; using UnityEngine; using UnityEngine.Events; public class MyDungeonListener : DungeonEventListener { public Action OnDungeonBuilded; public bool IsDungeonBuilt { get; private set; } public override void OnPostDungeonBuild(Dungeon dungeon, DungeonModel model) { Debug.Log(\"=======Dungeon build complete========\"); OnDungeonBuilded?.Invoke(); IsDungeonBuilt = true; // Write your logic here } }",
          "content_tokens": 104,
          "embedding": []
        }
      ],
      "length": 431
    },
    {
      "filename": "AddLODGroupAndCleanupEditor",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; [CustomEditor(typeof(AddLODGroupAndCleanup))] public class AddLODGroupAndCleanupEditor : Editor { private AddLODGroupAndCleanup _addLODGroupAndCleanup; private void OnEnable() { _addLODGroupAndCleanup = (AddLODGroupAndCleanup)target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); if (!_addLODGroupAndCleanup.WorkIsDone) _addLODGroupAndCleanup.Init(_addLODGroupAndCleanup.gameObject); if (GUILayout.Button(\"Do For All Children\")) { _addLODGroupAndCleanup.DoForAllChildren(); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AddLODGroupAndCleanupEditor",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; [CustomEditor(typeof(AddLODGroupAndCleanup))] public class AddLODGroupAndCleanupEditor : Editor { private AddLODGroupAndCleanup _addLODGroupAndCleanup; private void OnEnable() { _addLODGroupAndCleanup = (AddLODGroupAndCleanup)target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); if (!_addLODGroupAndCleanup.WorkIsDone) _addLODGroupAndCleanup.Init(_addLODGroupAndCleanup.gameObject); if (GUILayout.Button(\"Do For All Children\")) { _addLODGroupAndCleanup.DoForAllChildren(); } } }",
          "content_tokens": 172,
          "embedding": []
        }
      ],
      "length": 597
    },
    {
      "filename": "AssetFlipperEditor",
      "content": "using System.Collections.Generic; using UnityEngine; using UnityEditor; using System.IO; using _ZombieRoyale.Scripts.Core; using DungeonArchitect.Builders.SnapGridFlow; using DungeonArchitect.Flow.Impl.SnapGridFlow; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Managing.Object; using FishNet.Object; public class AssetFlipperEditor : EditorWindow { private GameplayManager gameplayManagerPrefab; private NetworkObject lowpolyMainCharPrefab; private NetworkObject highresFemaleMainCharPrefab; private EnemyDefinitionsHolderSO enemyDefinitionsHolder; private SnapGridFlowConfig dungeonManagerPrefab; private SinglePrefabObjects mySinglePrefabObjects; private const string enemyDefinitionsHolderPath = \"Assets/-ZombieRoyale/Scripts/AI/Creatures/Resources/SOEnemyDefinitionsHolder.asset\"; private const string mySinglePrefabObjectsPath = \"Assets/-ZombieRoyale/Scripts/MySinglePrefabObjects.asset\"; private const string lowPolyDungeonPath = \"Assets/-ZombieRoyale/DungeonThemes/SnapGridFlow.asset\"; private const string lowPolyModuleDB = \"Assets/-ZombieRoyale/DungeonThemes/SnapGridFlowModuleDB.asset\"; private const string realismDungeonPath = \"Assets/-ZombieRoyale/DungeonThemes/SnapGridFlow (Light Realism).asset\"; private const string realismModuleDB = \"Assets/-ZombieRoyale/DungeonThemes/SnapGridFlowModuleDB Realism.asset\"; private const string lowPolyAIUnitsPath = \"Assets/-ZombieRoyale/Prefabs/Networked/AIUnits/LowPoly\"; private const string realismAIUnitsPath = \"Assets/-ZombieRoyale/Prefabs/Networked/AIUnits/Realism\"; private const string gameplayManagerPath = \"Assets/-ZombieRoyale/Prefabs/Networked/GameplayManagers/GameplayManager.prefab\"; private const string dungeonManagerPath = \"Assets/-ZombieRoyale/Prefabs/Networked/MyDungeonSnapGridFlow.prefab\"; private const string lowpolyMainCharPath = \"Assets/-ZombieRoyale/Prefabs/Networked/PlayerChar.prefab\"; private const string highresFemaleMainCharPath = \"Assets/-ZombieRoyale/Prefabs/Networked/PlayerChar HighResolution 3.prefab\"; /// <summary> /// MySinglePrefabObjects Clearing /// </summary> private string[] realismPathes = new string[] { \"Assets/-ZombieRoyale/Prefabs/Networked/AIUnits/Realism/GoblinNetworked.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/DeadBody/GoblinNetworked_DeadBody.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/AIUnits/Realism/KoboldNetworked.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/DeadBody/KoboldNetworked_DeadBody.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/AIUnits/Realism/CavecrawlerNetworked.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/DeadBody/CavecrawlerNetworked_DeadBody.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/AIUnits/Realism/GorosaurusNetworked.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/DeadBody/GorosaurusNetworked_DeadBody.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/AIUnits/Realism/HellcreeperNetworked.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/DeadBody/HellcreeperNetworked_DeadBody.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/Door_03 Realism (Networked).prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/Torch_01 Realism (Networked).prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/PlayerChar HighResolution 3.prefab\", }; private string assetState; [MenuItem(\"Tools/AssetFlipper\")] public static void ShowWindow() { GetWindow<AssetFlipperEditor>(\"Asset Flipper\"); } private void OnEnable() { mySinglePrefabObjects = AssetDatabase.LoadAssetAtPath<SinglePrefabObjects>(mySinglePrefabObjectsPath); dungeonManagerPrefab = AssetDatabase.LoadAssetAtPath<SnapGridFlowConfig>(dungeonManagerPath); gameplayManagerPrefab = AssetDatabase.LoadAssetAtPath<GameplayManager>(gameplayManagerPath); lowpolyMainCharPrefab = AssetDatabase.LoadAssetAtPath<NetworkObject>(lowpolyMainCharPath); highresFemaleMainCharPrefab = AssetDatabase.LoadAssetAtPath<NetworkObject>(highresFemaleMainCharPath); enemyDefinitionsHolder = AssetDatabase.LoadAssetAtPath<EnemyDefinitionsHolderSO>(enemyDefinitionsHolderPath); if (gameplayManagerPrefab != null) { if (gameplayManagerPrefab.PlayerPrefab == lowpolyMainCharPrefab) { assetState = \"LowPoly\"; } else { assetState = \"HighRes\"; } } } private void OnGUI() { GUILayout.Label(\"Asset Flipper\", EditorStyles.boldLabel); mySinglePrefabObjects = EditorGUILayout.ObjectField(\"My Single Prefab Objects\", mySinglePrefabObjects, typeof(SinglePrefabObjects), false) as SinglePrefabObjects; dungeonManagerPrefab = EditorGUILayout.ObjectField(\"Dungeon Manager\", dungeonManagerPrefab, typeof(SnapGridFlowConfig), false) as SnapGridFlowConfig; gameplayManagerPrefab = EditorGUILayout.ObjectField(\"Gameplay Manager\", gameplayManagerPrefab, typeof(GameplayManager), false) as GameplayManager; lowpolyMainCharPrefab = EditorGUILayout.ObjectField(\"Low Poly Main Char\", lowpolyMainCharPrefab, typeof(NetworkObject), false) as NetworkObject; highresFemaleMainCharPrefab = EditorGUILayout.ObjectField(\"High Res Female Main Char\", highresFemaleMainCharPrefab, typeof(NetworkObject), false) as NetworkObject; EditorGUILayout.LabelField(\"Enemy Definitions\", EditorStyles.boldLabel); EditorGUILayout.ObjectField(\"Enemy Definitions Holder\", enemyDefinitionsHolder, typeof(EnemyDefinitionsHolderSO), false); if (GUILayout.Button(\"Flip\")) { FlipAssets(); AssetDatabase.Refresh(); } //status text: GUILayout.Label(\"Current State: \" + assetState); } private void FlipAssets() { // Assuming the GameplayManager has a field called `PlayerPrefab` and it's a GameObject. // You would need to replace `GameplayManager` with the correct namespace and class name. var gameplayManager = gameplayManagerPrefab.GetComponent<GameplayManager>(); if (gameplayManager != null) { string aiUnitsPath; string dungeonPath; string moduleDBPath; List<NetworkObject> realismPrefabs = new List<NetworkObject>(); foreach (var realismObjectPath in realismPathes) { NetworkObject networkObject = AssetDatabase.LoadAssetAtPath<NetworkObject>(realismObjectPath); realismPrefabs.Add(networkObject); } if (gameplayManager.PlayerPrefab == lowpolyMainCharPrefab) { gameplayManager.SetPlayerPrefab(highresFemaleMainCharPrefab); gameplayManager.ChangeDungeonLoadingFromSave(false); aiUnitsPath = realismAIUnitsPath; dungeonPath = realismDungeonPath; moduleDBPath = realismModuleDB; assetState = \"HighRes\"; List<NetworkObject> prefabs = new List<NetworkObject>(mySinglePrefabObjects.Prefabs); foreach (var current in realismPrefabs) { if (prefabs.Contains(current)) { continue; } prefabs.Add(current); } mySinglePrefabObjects.SetPrefabObjects(prefabs); } else { gameplayManager.SetPlayerPrefab(lowpolyMainCharPrefab); gameplayManager.ChangeDungeonLoadingFromSave(true); aiUnitsPath = lowPolyAIUnitsPath; dungeonPath = lowPolyDungeonPath; moduleDBPath = lowPolyModuleDB; assetState = \"LowPoly\"; List<NetworkObject> singlePrefabsCopy = new List<NetworkObject>(mySinglePrefabObjects.Prefabs); foreach (var current in singlePrefabsCopy) { if (realismPrefabs.Contains(current)) { List<NetworkObject> newSinglePrefabsCopy = new List<NetworkObject>(mySinglePrefabObjects.Prefabs); newSinglePrefabsCopy.Remove(current); mySinglePrefabObjects.SetPrefabObjects(newSinglePrefabsCopy); } } } // Flip Enemy Definitions based on the selected player prefab. EnemyDefinition[] enemyDefinitions = LoadEnemyDefinitions(aiUnitsPath); enemyDefinitionsHolder.SetEnemyDefinitions(enemyDefinitions); // Flip Dungeon Manager SnapGridFlowModuleDatabase moduleDb = AssetDatabase.LoadAssetAtPath<SnapGridFlowModuleDatabase>(moduleDBPath); dungeonManagerPrefab.moduleDatabase = moduleDb; dungeonManagerPrefab.flowGraph = AssetDatabase.LoadAssetAtPath<SnapGridFlowAsset>(dungeonPath); EditorUtility.SetDirty(gameplayManagerPrefab); } } private EnemyDefinition[] LoadEnemyDefinitions(string path) { List<AIUnit> aiUnits = new List<AIUnit>(); TryGetUnityObjectsOfTypeFromPath<AIUnit>(path, aiUnits); EnemyDefinition[] enemyDefinitionsArray = new EnemyDefinition[aiUnits.Count]; for (int i = 0; i < aiUnits.Count; i++) { enemyDefinitionsArray[i] = aiUnits[i].EnemyDefinition; } return enemyDefinitionsArray; } #if UNITY_EDITOR /// <summary> /// Adds newly (if not already in the list) found assets. /// Returns how many found (not how many added) /// </summary> /// <typeparam name=\"T\"></typeparam> /// <param name=\"path\"></param> /// <param name=\"assetsFound\">Adds to this list if it is not already there</param> /// <returns></returns> public static int TryGetUnityObjectsOfTypeFromPath<T>(string path, List<T> assetsFound) where T : UnityEngine.Object { string[] filePaths = System.IO.Directory.GetFiles(path); int countFound = 0; //Debug.Log(filePaths.Length); if (filePaths != null && filePaths.Length > 0) { for (int i = 0; i < filePaths.Length; i++) { UnityEngine.Object obj = UnityEditor.AssetDatabase.LoadAssetAtPath(filePaths[i], typeof(T)); if (obj is T asset) { countFound++; if (!assetsFound.Contains(asset)) { assetsFound.Add(asset); } } } } return countFound; } #endif }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AssetFlipperEditor",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "AssetFlipperEditor",
          "content": "using System.Collections.Generic; using UnityEngine; using UnityEditor; using System.IO; using _ZombieRoyale.Scripts.Core; using DungeonArchitect.Builders.SnapGridFlow; using DungeonArchitect.Flow.Impl.SnapGridFlow; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Managing.Object; using FishNet.Object; public class AssetFlipperEditor : EditorWindow { private GameplayManager gameplayManagerPrefab; private NetworkObject lowpolyMainCharPrefab; private NetworkObject highresFemaleMainCharPrefab; private EnemyDefinitionsHolderSO enemyDefinitionsHolder; private SnapGridFlowConfig dungeonManagerPrefab; private SinglePrefabObjects mySinglePrefabObjects; private const string enemyDefinitionsHolderPath = \"Assets/-ZombieRoyale/Scripts/AI/Creatures/Resources/SOEnemyDefinitionsHolder.asset\"; private const string mySinglePrefabObjectsPath = \"Assets/-ZombieRoyale/Scripts/MySinglePrefabObjects.asset\"; private const string lowPolyDungeonPath = \"Assets/-ZombieRoyale/DungeonThemes/SnapGridFlow.asset\"; private const string lowPolyModuleDB = \"Assets/-ZombieRoyale/DungeonThemes/SnapGridFlowModuleDB.asset\"; private const string realismDungeonPath = \"Assets/-ZombieRoyale/DungeonThemes/SnapGridFlow (Light Realism).asset\"; private const string realismModuleDB = \"Assets/-ZombieRoyale/DungeonThemes/SnapGridFlowModuleDB Realism.asset\"; private const string lowPolyAIUnitsPath = \"Assets/-ZombieRoyale/Prefabs/Networked/AIUnits/LowPoly\"; private const string realismAIUnitsPath = \"Assets/-ZombieRoyale/Prefabs/Networked/AIUnits/Realism\"; private const string gameplayManagerPath = \"Assets/-ZombieRoyale/Prefabs/Networked/GameplayManagers/GameplayManager.prefab\"; private const string dungeonManagerPath = \"Assets/-ZombieRoyale/Prefabs/Networked/MyDungeonSnapGridFlow.prefab\"; private const string lowpolyMainCharPath = \"Assets/-ZombieRoyale/Prefabs/Networked/PlayerChar.prefab\"; private const string highresFemaleMainCharPath = \"Assets/-ZombieRoyale/Prefabs/Networked/PlayerChar HighResolution 3.prefab\"; /// <summary> /// MySinglePrefabObjects Clearing /// </summary> private string[] realismPathes = new string[] { \"Assets/-ZombieRoyale/Prefabs/Networked/AIUnits/Realism/GoblinNetworked.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/DeadBody/GoblinNetworked_DeadBody.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/AIUnits/Realism/KoboldNetworked.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/DeadBody/KoboldNetworked_DeadBody.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/AIUnits/Realism/CavecrawlerNetworked.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/DeadBody/CavecrawlerNetworked_DeadBody.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/AIUnits/Realism/GorosaurusNetworked.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/DeadBody/GorosaurusNetworked_DeadBody.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/AIUnits/Realism/HellcreeperNetworked.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/DeadBody/HellcreeperNetworked_DeadBody.prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/Door_03 Realism (Networked).prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/Torch_01 Realism (Networked).prefab\", \"Assets/-ZombieRoyale/Prefabs/Networked/PlayerChar HighResolution 3.prefab\", }; private string assetState; [MenuItem(\"Tools/AssetFlipper\")] public static void ShowWindow() { GetWindow<AssetFlipperEditor>(\"Asset Flipper\");  ",
          "content_tokens": 1018,
          "embedding": []
        },
        {
          "cs_scriptfile": "AssetFlipperEditor",
          "content": "private void OnEnable() { mySinglePrefabObjects = AssetDatabase.LoadAssetAtPath<SinglePrefabObjects>(mySinglePrefabObjectsPath); dungeonManagerPrefab = AssetDatabase.LoadAssetAtPath<SnapGridFlowConfig>(dungeonManagerPath); gameplayManagerPrefab = AssetDatabase.LoadAssetAtPath<GameplayManager>(gameplayManagerPath); lowpolyMainCharPrefab = AssetDatabase.LoadAssetAtPath<NetworkObject>(lowpolyMainCharPath); highresFemaleMainCharPrefab = AssetDatabase.LoadAssetAtPath<NetworkObject>(highresFemaleMainCharPath); enemyDefinitionsHolder = AssetDatabase.LoadAssetAtPath<EnemyDefinitionsHolderSO>(enemyDefinitionsHolderPath); if (gameplayManagerPrefab != null) { if (gameplayManagerPrefab.PlayerPrefab == lowpolyMainCharPrefab) { assetState = \"LowPoly\"; } else { assetState = \"HighRes\"; } }  ",
          "content_tokens": 211,
          "embedding": []
        },
        {
          "cs_scriptfile": "AssetFlipperEditor",
          "content": "private void OnGUI() { GUILayout.Label(\"Asset Flipper\", EditorStyles.boldLabel); mySinglePrefabObjects = EditorGUILayout.ObjectField(\"My Single Prefab Objects\", mySinglePrefabObjects, typeof(SinglePrefabObjects), false) as SinglePrefabObjects; dungeonManagerPrefab = EditorGUILayout.ObjectField(\"Dungeon Manager\", dungeonManagerPrefab, typeof(SnapGridFlowConfig), false) as SnapGridFlowConfig; gameplayManagerPrefab = EditorGUILayout.ObjectField(\"Gameplay Manager\", gameplayManagerPrefab, typeof(GameplayManager), false) as GameplayManager; lowpolyMainCharPrefab = EditorGUILayout.ObjectField(\"Low Poly Main Char\", lowpolyMainCharPrefab, typeof(NetworkObject), false) as NetworkObject; highresFemaleMainCharPrefab = EditorGUILayout.ObjectField(\"High Res Female Main Char\", highresFemaleMainCharPrefab, typeof(NetworkObject), false) as NetworkObject; EditorGUILayout.LabelField(\"Enemy Definitions\", EditorStyles.boldLabel); EditorGUILayout.ObjectField(\"Enemy Definitions Holder\", enemyDefinitionsHolder, typeof(EnemyDefinitionsHolderSO), false); if (GUILayout.Button(\"Flip\")) { FlipAssets(); AssetDatabase.Refresh(); } //status text: GUILayout.Label(\"Current State: \" + assetState);  ",
          "content_tokens": 326,
          "embedding": []
        },
        {
          "cs_scriptfile": "AssetFlipperEditor",
          "content": "private void FlipAssets() { // Assuming the GameplayManager has a field called `PlayerPrefab` and it's a GameObject. // You would need to replace `GameplayManager` with the correct namespace and class name. var gameplayManager = gameplayManagerPrefab.GetComponent<GameplayManager>(); if (gameplayManager != null) { string aiUnitsPath; string dungeonPath; string moduleDBPath; List<NetworkObject> realismPrefabs = new List<NetworkObject>(); foreach (var realismObjectPath in realismPathes) { NetworkObject networkObject = AssetDatabase.LoadAssetAtPath<NetworkObject>(realismObjectPath); realismPrefabs.Add(networkObject);  ",
          "content_tokens": 149,
          "embedding": []
        },
        {
          "cs_scriptfile": "AssetFlipperEditor",
          "content": "if (gameplayManager.PlayerPrefab == lowpolyMainCharPrefab) { gameplayManager.SetPlayerPrefab(highresFemaleMainCharPrefab); gameplayManager.ChangeDungeonLoadingFromSave(false); aiUnitsPath = realismAIUnitsPath; dungeonPath = realismDungeonPath; moduleDBPath = realismModuleDB; assetState = \"HighRes\"; List<NetworkObject> prefabs = new List<NetworkObject>(mySinglePrefabObjects.Prefabs); foreach (var current in realismPrefabs) { if (prefabs.Contains(current)) { continue; } prefabs.Add(current); } mySinglePrefabObjects.SetPrefabObjects(prefabs); } else { gameplayManager.SetPlayerPrefab(lowpolyMainCharPrefab); gameplayManager.ChangeDungeonLoadingFromSave(true); aiUnitsPath = lowPolyAIUnitsPath; dungeonPath = lowPolyDungeonPath; moduleDBPath = lowPolyModuleDB; assetState = \"LowPoly\"; List<NetworkObject> singlePrefabsCopy = new List<NetworkObject>(mySinglePrefabObjects.Prefabs); foreach (var current in singlePrefabsCopy) { if (realismPrefabs.Contains(current)) { List<NetworkObject> newSinglePrefabsCopy = new List<NetworkObject>(mySinglePrefabObjects.Prefabs); newSinglePrefabsCopy.Remove(current); mySinglePrefabObjects.SetPrefabObjects(newSinglePrefabsCopy); } } } // Flip Enemy Definitions based on the selected player prefab. EnemyDefinition[] enemyDefinitions = LoadEnemyDefinitions(aiUnitsPath); enemyDefinitionsHolder.SetEnemyDefinitions(enemyDefinitions); // Flip Dungeon Manager SnapGridFlowModuleDatabase moduleDb = AssetDatabase.LoadAssetAtPath<SnapGridFlowModuleDatabase>(moduleDBPath); dungeonManagerPrefab.moduleDatabase = moduleDb; dungeonManagerPrefab.flowGraph = AssetDatabase.LoadAssetAtPath<SnapGridFlowAsset>(dungeonPath); EditorUtility.SetDirty(gameplayManagerPrefab); } } private EnemyDefinition[] LoadEnemyDefinitions(string path) { List<AIUnit> aiUnits = new List<AIUnit>(); TryGetUnityObjectsOfTypeFromPath<AIUnit>(path, aiUnits); EnemyDefinition[] enemyDefinitionsArray = new EnemyDefinition[aiUnits.Count]; for (int i = 0; i < aiUnits.Count; i++) { enemyDefinitionsArray[i] = aiUnits[i].EnemyDefinition; } return enemyDefinitionsArray; } #if UNITY_EDITOR /// <summary> /// Adds newly (if not already in the list) found assets. /// Returns how many found (not how many added) /// </summary> /// <typeparam name=\"T\"></typeparam> /// <param name=\"path\"></param> /// <param name=\"assetsFound\">Adds to this list if it is not already there</param> /// <returns></returns> public static int TryGetUnityObjectsOfTypeFromPath<T>(string path, List<T> assetsFound) where T : UnityEngine.Object { string[] filePaths = System.IO.Directory.GetFiles(path); int countFound = 0; //Debug.Log(filePaths.Length); if (filePaths != null && filePaths.Length > 0) { for (int i = 0; i < filePaths.Length; i++) { UnityEngine.Object obj = UnityEditor.AssetDatabase.LoadAssetAtPath(filePaths[i], typeof(T)); if (obj is T asset) { countFound++; if (!assetsFound.Contains(asset)) { assetsFound.Add(asset); } } } } return countFound; } #endif }",
          "content_tokens": 840,
          "embedding": []
        }
      ],
      "length": 8895
    },
    {
      "filename": "EditorGUILayoutExtensions",
      "content": "using UnityEditor; using UnityEngine; public static class EditorGUILayoutExtensions { public class DecimalFieldOptions { public string label; public bool drawLabel = false; public bool allowNegative = true; public bool allowDecimal = true; } public static decimal DecimalField(decimal value, float width, DecimalFieldOptions options = null) { options ??= new DecimalFieldOptions(); string stringValue = value.ToString(); EditorGUI.BeginChangeCheck(); if (options.drawLabel) { EditorGUILayout.LabelField(options.label); } if (options.allowNegative) { stringValue = EditorGUILayout.TextField(options.label, stringValue, GUILayout.Width(width)); } else { stringValue = EditorGUILayout.TextField(options.label, stringValue.Replace(\"-\", \"\"), GUILayout.Width(width)); } if (EditorGUI.EndChangeCheck()) { if (options.allowDecimal) { if (decimal.TryParse(stringValue, out decimal newValue)) { return newValue; } } else { if (int.TryParse(stringValue, out int intValue)) { return intValue; } } } return value; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "EditorGUILayoutExtensions",
          "content": "using UnityEditor; using UnityEngine; public static class EditorGUILayoutExtensions { public class DecimalFieldOptions { public string label; public bool drawLabel = false; public bool allowNegative = true; public bool allowDecimal = true; } public static decimal DecimalField(decimal value, float width, DecimalFieldOptions options = null) { options ??= new DecimalFieldOptions(); string stringValue = value.ToString(); EditorGUI.BeginChangeCheck(); if (options.drawLabel) { EditorGUILayout.LabelField(options.label);  ",
          "content_tokens": 125,
          "embedding": []
        },
        {
          "cs_scriptfile": "EditorGUILayoutExtensions",
          "content": "if (options.allowNegative) { stringValue = EditorGUILayout.TextField(options.label, stringValue, GUILayout.Width(width)); } else { stringValue = EditorGUILayout.TextField(options.label, stringValue.Replace(\"-\", \"\"), GUILayout.Width(width));  if (EditorGUI.EndChangeCheck()) { if (options.allowDecimal) { if (decimal.TryParse(stringValue, out decimal newValue)) { return newValue; } } else { if (int.TryParse(stringValue, out int intValue)) { return intValue; } } } return value; } }",
          "content_tokens": 150,
          "embedding": []
        }
      ],
      "length": 1004
    },
    {
      "filename": "FavouriteObjectsWindow",
      "content": "#if UNITY_EDITOR using System.Collections.Generic; using UnityEditor; using UnityEngine; public class FavouriteObjectsWindow : EditorWindow { private List<Object> favouriteObjects = new List<Object>(); private const string FAVOURITE_PREF_KEY = \"FAVOURITE_OBJECTS_PREF\"; [MenuItem(\"Window/Favourite Objects\")] public static void ShowWindow() { GetWindow<FavouriteObjectsWindow>(\"Favourite Objects\"); } private void OnEnable() { LoadFavouriteObjects(); } private void OnDisable() { SaveFavouriteObjects(); } private void OnGUI() { for (int i = 0; i < favouriteObjects.Count; i++) { EditorGUILayout.BeginHorizontal(); favouriteObjects[i] = EditorGUILayout.ObjectField(favouriteObjects[i], typeof(Object), true); if (GUILayout.Button(\"F\")) { EditorGUIUtility.PingObject(favouriteObjects[i]); Selection.activeObject = favouriteObjects[i]; } if (GUILayout.Button(\"-\")) { favouriteObjects.RemoveAt(i); return; } EditorGUILayout.EndHorizontal(); } if (GUILayout.Button(\"Add Favourite\")) { favouriteObjects.Add(null); } } private void SaveFavouriteObjects() { string favObjectPaths = \"\"; foreach (var obj in favouriteObjects) { if (obj != null) { string assetPath = AssetDatabase.GetAssetPath(obj); favObjectPaths += assetPath + \";\"; } } EditorPrefs.SetString(FAVOURITE_PREF_KEY, favObjectPaths); } private void LoadFavouriteObjects() { favouriteObjects.Clear(); string storedPaths = EditorPrefs.GetString(FAVOURITE_PREF_KEY, \"\"); if (!string.IsNullOrEmpty(storedPaths)) { string[] paths = storedPaths.Split(';'); foreach (string path in paths) { if (!string.IsNullOrEmpty(path)) { Object obj = AssetDatabase.LoadAssetAtPath(path, typeof(Object)); if (obj != null) { favouriteObjects.Add(obj); } } } } } } #endif ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "FavouriteObjectsWindow",
          "content": "#if UNITY_EDITOR using System.Collections.Generic; using UnityEditor; using UnityEngine; public class FavouriteObjectsWindow : EditorWindow { private List<Object> favouriteObjects = new List<Object>(); private const string FAVOURITE_PREF_KEY = \"FAVOURITE_OBJECTS_PREF\"; [MenuItem(\"Window/Favourite Objects\")] public static void ShowWindow() { GetWindow<FavouriteObjectsWindow>(\"Favourite Objects\");  private void OnEnable() { LoadFavouriteObjects();  private void OnDisable() { SaveFavouriteObjects();  ",
          "content_tokens": 142,
          "embedding": []
        },
        {
          "cs_scriptfile": "FavouriteObjectsWindow",
          "content": "private void OnGUI() { for (int i = 0; i < favouriteObjects.Count; i++) { EditorGUILayout.BeginHorizontal(); favouriteObjects[i] = EditorGUILayout.ObjectField(favouriteObjects[i], typeof(Object), true); if (GUILayout.Button(\"F\")) { EditorGUIUtility.PingObject(favouriteObjects[i]); Selection.activeObject = favouriteObjects[i];  if (GUILayout.Button(\"-\")) { favouriteObjects.RemoveAt(i); return; } EditorGUILayout.EndHorizontal();  if (GUILayout.Button(\"Add Favourite\")) { favouriteObjects.Add(null); }  ",
          "content_tokens": 166,
          "embedding": []
        },
        {
          "cs_scriptfile": "FavouriteObjectsWindow",
          "content": "private void SaveFavouriteObjects() { string favObjectPaths = \"\"; foreach (var obj in favouriteObjects) { if (obj != null) { string assetPath = AssetDatabase.GetAssetPath(obj); favObjectPaths += assetPath + \";\"; } } EditorPrefs.SetString(FAVOURITE_PREF_KEY, favObjectPaths);  ",
          "content_tokens": 86,
          "embedding": []
        },
        {
          "cs_scriptfile": "FavouriteObjectsWindow",
          "content": "private void LoadFavouriteObjects() { favouriteObjects.Clear(); string storedPaths = EditorPrefs.GetString(FAVOURITE_PREF_KEY, \"\"); if (!string.IsNullOrEmpty(storedPaths)) { string[] paths = storedPaths.Split(';'); foreach (string path in paths) { if (!string.IsNullOrEmpty(path)) { Object obj = AssetDatabase.LoadAssetAtPath(path, typeof(Object)); if (obj != null) { favouriteObjects.Add(obj); } } } } } } #endif",
          "content_tokens": 129,
          "embedding": []
        }
      ],
      "length": 1704
    },
    {
      "filename": "FixJawBoneKeyframes",
      "content": "//Copyright(c) 2021 Robin Promesberger (schema_unity on forum.unity3d.com) // // Permission is hereby granted, free of charge, to any person obtaining a copy of this // software and associated documentation files (the \"Software\"), to deal in the Software without // restriction, including without limitation the rights to use, copy, modify, merge, publish, // distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the // Software is furnished to do so, subject to // the following conditions: // The above copyright notice and this permission notice shall be included in all copies or // substantial portions of the Software. // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND // NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER // IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR // IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE // SOFTWARE. using UnityEngine; using UnityEditor; using System.Collections.Generic; using System.Linq; public class FixJawBoneKeyframes : EditorWindow { [MenuItem(\"Window/Fix Jawbone Keyframes\")] public static void OpenWindow() { var window = GetWindow<FixJawBoneKeyframes>(); window.titleContent = new GUIContent(\"Jaw Fixer\"); } private GUIContent statusContent = new GUIContent(\"Waiting...\"); public List<AnimationClip> animations = new List<AnimationClip>(); private Transform rootBone; Vector2 scrollPos; private float keyValue = 1; private string bindingName = \"Jaw Close\"; private string statusText = \"Waiting...\"; private void OnGUI() { keyValue = EditorGUILayout.FloatField(\"Jaw Keyframe val\", keyValue); GUIStyle GuistyleBoxDND = new GUIStyle(GUI.skin.box); Rect myRect = GUILayoutUtility.GetRect(0, 40, GUILayout.ExpandWidth(true)); GUI.Box(myRect, \"Drag and Drop AnimationClips to this Box!\", GuistyleBoxDND); //drag and drop box if (myRect.Contains(Event.current.mousePosition)) { if (Event.current.type == EventType.DragUpdated) { DragAndDrop.visualMode = DragAndDropVisualMode.Copy; Event.current.Use(); } else if (Event.current.type == EventType.DragPerform) { Debug.Log(DragAndDrop.objectReferences.Length); for (int i = 0; i < DragAndDrop.objectReferences.Length; i++) { if(DragAndDrop.objectReferences[i] is AnimationClip) { animations.Add(DragAndDrop.objectReferences[i] as AnimationClip); } } Event.current.Use(); } } EditorGUILayout.BeginHorizontal(); scrollPos = EditorGUILayout.BeginScrollView(scrollPos, true, true); //list of animation clips var list = animations; int newCount = Mathf.Max(0, EditorGUILayout.DelayedIntField(\"size\", list.Count)); while (newCount < list.Count) list.RemoveAt(list.Count - 1); while (newCount > list.Count) list.Add(null); for (int i = 0; i < list.Count; i++) { list[i] = EditorGUILayout.ObjectField(list[i], typeof(AnimationClip), true) as AnimationClip; } EditorGUILayout.EndScrollView(); EditorGUILayout.EndHorizontal(); bool enabled = (list != null && list.Count > 0); if (!enabled) { statusText = \"Add animation clips to process.\"; } GUI.enabled = enabled; //processing if (GUILayout.Button(\"Fix Jaw Bones\")) { statusText = \"++ Processing animations... ++\\n\\n\"; // process clips foreach(AnimationClip clip in list) { EditorCurveBinding[] binding = AnimationUtility.GetCurveBindings(clip); bool found = false; ; //we could reference the name directly, but since performance is not an issue, it's more convenient and safer to use the existing binding for (int i = 0; i < binding.Length; i++) { if (binding[i].propertyName == bindingName) { found = true; AnimationCurve curve = AnimationUtility.GetEditorCurve(clip, binding[i]); //set each existing keyframe to the value provided (by default unity creates one at the start and end) Keyframe[] copy = curve.keys; //this creates a copy of the array for (int k = 0; k < copy.Length; k++) { copy[k].value = keyValue; } curve.keys = copy; //this copies the array into the curve statusText += \"Processed keyframes of \" + clip.name+\"\\n\"; //set the curve for the binding AnimationUtility.SetEditorCurve(clip, binding[i], curve); break; } } if (!found) { statusText += \"ERROR: '\"+ bindingName+\"' binding not found. Animation has to be humanoid\\n\"; break; } } } // Draw status info statusContent.text = statusText; EditorStyles.label.wordWrap = true; EditorGUILayout.BeginHorizontal(); scrollPos = EditorGUILayout.BeginScrollView(scrollPos, true, true); GUILayout.Label(statusContent); EditorGUILayout.EndScrollView(); EditorGUILayout.EndHorizontal(); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "FixJawBoneKeyframes",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "FixJawBoneKeyframes",
          "content": "//Copyright(c) 2021 Robin Promesberger (schema_unity on forum.unity3d.com) // // Permission is hereby granted, free of charge, to any person obtaining a copy of this // software and associated documentation files (the \"Software\"), to deal in the Software without // restriction, including without limitation the rights to use, copy, modify, merge, publish, // distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the // Software is furnished to do so, subject to // the following conditions: // The above copyright notice and this permission notice shall be included in all copies or // substantial portions of the Software. // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND // NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER // IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR // IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE // SOFTWARE. using UnityEngine; using UnityEditor; using System.Collections.Generic; using System.Linq; public class FixJawBoneKeyframes : EditorWindow { [MenuItem(\"Window/Fix Jawbone Keyframes\")] public static void OpenWindow() { var window = GetWindow<FixJawBoneKeyframes>(); window.titleContent = new GUIContent(\"Jaw Fixer\"); } private GUIContent statusContent = new GUIContent(\"Waiting...\"); public List<AnimationClip> animations = new List<AnimationClip>(); private Transform rootBone; Vector2 scrollPos; private float keyValue = 1; private string bindingName = \"Jaw Close\"; private string statusText = \"Waiting...\"; private void OnGUI() { keyValue = EditorGUILayout.FloatField(\"Jaw Keyframe val\", keyValue); GUIStyle GuistyleBoxDND = new GUIStyle(GUI.skin.box); Rect myRect = GUILayoutUtility.GetRect(0, 40, GUILayout.ExpandWidth(true)); GUI.Box(myRect, \"Drag and Drop AnimationClips to this Box!\", GuistyleBoxDND); //drag and drop box if (myRect.Contains(Event.current.mousePosition)) { if (Event.current.type == EventType.DragUpdated) { DragAndDrop.visualMode = DragAndDropVisualMode.Copy; Event.current.Use(); } else if (Event.current.type == EventType.DragPerform) { Debug.Log(DragAndDrop.objectReferences.Length); for (int i = 0; i < DragAndDrop.objectReferences.Length; i++) { if(DragAndDrop.objectReferences[i] is AnimationClip) { animations.Add(DragAndDrop.objectReferences[i] as AnimationClip); } } Event.current.Use(); } } EditorGUILayout.BeginHorizontal(); scrollPos = EditorGUILayout.BeginScrollView(scrollPos, true, true); //list of animation clips var list = animations; int newCount = Mathf.Max(0, EditorGUILayout.DelayedIntField(\"size\", list.Count)); while (newCount < list.Count) list.RemoveAt(list.Count - 1); while (newCount > list.Count) list.Add(null); for (int i = 0; i < list.Count; i++) { list[i] = EditorGUILayout.ObjectField(list[i], typeof(AnimationClip), true) as AnimationClip; } EditorGUILayout.EndScrollView(); EditorGUILayout.EndHorizontal(); bool enabled = (list != null && list.Count > 0); if (!enabled) { statusText = \"Add animation clips to process.\"; } GUI.enabled = enabled; //processing if (GUILayout.Button(\"Fix Jaw Bones\")) { statusText = \"++ Processing animations... ++\\n\\n\"; // process clips foreach(AnimationClip clip in list) { EditorCurveBinding[] binding = AnimationUtility.GetCurveBindings(clip); bool found = false; ; //we could reference the name directly, but since performance is not an issue, it's more convenient and safer to use the existing binding for (int i = 0; i < binding.Length; i++) { if (binding[i].propertyName == bindingName) { found = true; AnimationCurve curve = AnimationUtility.GetEditorCurve(clip, binding[i]); //set each existing keyframe to the value provided (by default unity creates one at the start and end) Keyframe[] copy = curve.keys; //this creates a copy of the array for (int k = 0; k < copy.Length; k++) { copy[k].value = keyValue; } curve.keys = copy; //this copies the array into the curve statusText += \"Processed keyframes of \" + clip.name+\"\\n\"; //set the curve for the binding AnimationUtility.SetEditorCurve(clip, binding[i], curve); break; }  ",
          "content_tokens": 1176,
          "embedding": []
        },
        {
          "cs_scriptfile": "FixJawBoneKeyframes",
          "content": "if (!found) { statusText += \"ERROR: '\"+ bindingName+\"' binding not found. Animation has to be humanoid\\n\"; break; } } } // Draw status info statusContent.text = statusText; EditorStyles.label.wordWrap = true; EditorGUILayout.BeginHorizontal(); scrollPos = EditorGUILayout.BeginScrollView(scrollPos, true, true); GUILayout.Label(statusContent); EditorGUILayout.EndScrollView(); EditorGUILayout.EndHorizontal(); } }",
          "content_tokens": 121,
          "embedding": []
        }
      ],
      "length": 4688
    },
    {
      "filename": "PoseCorrectorEditor",
      "content": "using UnityEditor; using UnityEngine; [CustomEditor(typeof(PoseCorrector))] public class PoseCorrectorEditor : Editor { public override void OnInspectorGUI() { DrawDefaultInspector(); PoseCorrector myScript = (PoseCorrector)target; if(GUILayout.Button(\"Fix\")) { myScript.Fix(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PoseCorrectorEditor",
          "content": "using UnityEditor; using UnityEngine; [CustomEditor(typeof(PoseCorrector))] public class PoseCorrectorEditor : Editor { public override void OnInspectorGUI() { DrawDefaultInspector(); PoseCorrector myScript = (PoseCorrector)target; if(GUILayout.Button(\"Fix\")) { myScript.Fix(); } } }",
          "content_tokens": 80,
          "embedding": []
        }
      ],
      "length": 283
    },
    {
      "filename": "RespawnSpotsHolderEditor",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; [CustomEditor(typeof(RespawnSpotsHolder))] public class RespawnSpotsHolderEditor : Editor { private RespawnSpotsHolder m_RespawnSpotsHolder; public override void OnInspectorGUI() { m_RespawnSpotsHolder = (RespawnSpotsHolder)target; DrawDefaultInspector(); if (GUILayout.Button(\"Store Positions\")) { m_RespawnSpotsHolder.SpawnPositions.Clear(); GeneratePoints(); } } private void GeneratePoints() { foreach (Transform child in m_RespawnSpotsHolder.transform) { m_RespawnSpotsHolder.SpawnPositions.Add(child.position); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RespawnSpotsHolderEditor",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; [CustomEditor(typeof(RespawnSpotsHolder))] public class RespawnSpotsHolderEditor : Editor { private RespawnSpotsHolder m_RespawnSpotsHolder; public override void OnInspectorGUI() { m_RespawnSpotsHolder = (RespawnSpotsHolder)target; DrawDefaultInspector(); if (GUILayout.Button(\"Store Positions\")) { m_RespawnSpotsHolder.SpawnPositions.Clear(); GeneratePoints(); } } private void GeneratePoints() { foreach (Transform child in m_RespawnSpotsHolder.transform) { m_RespawnSpotsHolder.SpawnPositions.Add(child.position); } } }",
          "content_tokens": 182,
          "embedding": []
        }
      ],
      "length": 621
    },
    {
      "filename": "UISpellDatabaseEditor",
      "content": "using UnityEditor; using UnityEngine; using DuloGames.UI; public class UISpellDatabaseEditor : EditorWindow { [MenuItem(\"Window/UISpellDatabase Editor\")] public static void ShowWindow() { EditorWindow.GetWindow(typeof(UISpellDatabaseEditor)); } private void OnGUI() { // Add the button if (GUILayout.Button(\"Localize\")) { UISpellDatabase.Instance.UpdateLocSource(); } // Add the label GUI.color = Color.green; // This sets the color of the following GUI control, in this case the Label, to green. GUILayout.Label(\"Status: Localization process completed\"); GUI.color = Color.white; // Reset the color after using. } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "UISpellDatabaseEditor",
          "content": "using UnityEditor; using UnityEngine; using DuloGames.UI; public class UISpellDatabaseEditor : EditorWindow { [MenuItem(\"Window/UISpellDatabase Editor\")] public static void ShowWindow() { EditorWindow.GetWindow(typeof(UISpellDatabaseEditor)); } private void OnGUI() { // Add the button if (GUILayout.Button(\"Localize\")) { UISpellDatabase.Instance.UpdateLocSource(); } // Add the label GUI.color = Color.green; // This sets the color of the following GUI control, in this case the Label, to green. GUILayout.Label(\"Status: Localization process completed\"); GUI.color = Color.white; // Reset the color after using. } }",
          "content_tokens": 160,
          "embedding": []
        }
      ],
      "length": 617
    },
    {
      "filename": "EventEditor",
      "content": " // ---------------------------------------------------------------------------- // Unite 2017 - Game Architecture with Scriptable Objects // // Author: Ryan Hipple // Date: 10/04/17 // ---------------------------------------------------------------------------- using UnityEditor; using UnityEngine; [CustomEditor(typeof(GameEvent), editorForChildClasses: true)] public class EventEditor : Editor { public override void OnInspectorGUI() { base.OnInspectorGUI(); GUI.enabled = Application.isPlaying; GameEvent e = target as GameEvent; if (GUILayout.Button(\"Raise\")) e.Raise(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "EventEditor",
          "content": "// ---------------------------------------------------------------------------- // Unite 2017 - Game Architecture with Scriptable Objects // // Author: Ryan Hipple // Date: 10/04/17 // ---------------------------------------------------------------------------- using UnityEditor; using UnityEngine; [CustomEditor(typeof(GameEvent), editorForChildClasses: true)] public class EventEditor : Editor { public override void OnInspectorGUI() { base.OnInspectorGUI(); GUI.enabled = Application.isPlaying; GameEvent e = target as GameEvent; if (GUILayout.Button(\"Raise\")) e.Raise(); } }",
          "content_tokens": 120,
          "embedding": []
        }
      ],
      "length": 581
    },
    {
      "filename": "GameEvent",
      "content": " // ---------------------------------------------------------------------------- // Unite 2017 - Game Architecture with Scriptable Objects // // Author: Ryan Hipple // Date: 10/04/17 // ---------------------------------------------------------------------------- using System.Collections.Generic; using UnityEngine; [CreateAssetMenu(fileName = \"Game Event\", menuName = \"ScriptableObjects/New Game Event\")] public class GameEvent : ScriptableObject { /// <summary> /// The list of listeners that this event will notify if it is raised. /// </summary> //[SerializeField] private readonly List<GameEventListener> eventListeners = new List<GameEventListener>(); public void Raise() { Debug.Log($\"{this.name} Raised!\"); for(int i = eventListeners.Count -1; i >= 0; i--) eventListeners[i].OnEventRaised(this); } public void RegisterListener(GameEventListener listener) { if (!eventListeners.Contains(listener)) eventListeners.Add(listener); } public void UnregisterListener(GameEventListener listener) { if (eventListeners.Contains(listener)) eventListeners.Remove(listener); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "GameEvent",
          "content": " // ---------------------------------------------------------------------------- // Unite 2017 - Game Architecture with Scriptable Objects // // Author: Ryan Hipple // Date: 10/04/17 // ---------------------------------------------------------------------------- using System.Collections.Generic; using UnityEngine; [CreateAssetMenu(fileName = \"Game Event\", menuName = \"ScriptableObjects/New Game Event\")] public class GameEvent : ScriptableObject { /// <summary> /// The list of listeners that this event will notify if it is raised. /// </summary> //[SerializeField] private readonly List<GameEventListener> eventListeners = new List<GameEventListener>(); public void Raise() { Debug.Log($\"{this.name} Raised!\"); for(int i = eventListeners.Count -1; i >= 0; i--) eventListeners[i].OnEventRaised(this);  ",
          "content_tokens": 182,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameEvent",
          "content": "public void RegisterListener(GameEventListener listener) { if (!eventListeners.Contains(listener)) eventListeners.Add(listener);  public void UnregisterListener(GameEventListener listener) { if (eventListeners.Contains(listener)) eventListeners.Remove(listener); } }",
          "content_tokens": 68,
          "embedding": []
        }
      ],
      "length": 1073
    },
    {
      "filename": "GameEventListener",
      "content": " // ---------------------------------------------------------------------------- // Unite 2017 - Game Architecture with Scriptable Objects // // Author: Ryan Hipple // Date: 10/04/17 // ---------------------------------------------------------------------------- using UnityEngine; using UnityEngine.Events; public class GameEventListener : MonoBehaviour { [Tooltip(\"Event to register with.\")] public GameEvent[] Event = new GameEvent[1]; [Tooltip(\"Response to invoke when Event is raised.\")] public UnityEvent[] Response = new UnityEvent[1]; private void OnEnable() { for (int i = 0; i < Event.Length; i++) { Event[i].RegisterListener(this); } } private void OnDisable() { for (int i = 0; i < Event.Length; i++) { Event[i].UnregisterListener(this); } } public void OnEventRaised(GameEvent which) { Debug.Log(Event[0].name); for (int i = 0; i < Event.Length; i++) { if (Event[i] == which) Response[i].Invoke(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "GameEventListener",
          "content": " // ---------------------------------------------------------------------------- // Unite 2017 - Game Architecture with Scriptable Objects // // Author: Ryan Hipple // Date: 10/04/17 // ---------------------------------------------------------------------------- using UnityEngine; using UnityEngine.Events; public class GameEventListener : MonoBehaviour { [Tooltip(\"Event to register with.\")] public GameEvent[] Event = new GameEvent[1]; [Tooltip(\"Response to invoke when Event is raised.\")] public UnityEvent[] Response = new UnityEvent[1]; private void OnEnable() { for (int i = 0; i < Event.Length; i++) { Event[i].RegisterListener(this); }  private void OnDisable() { for (int i = 0; i < Event.Length; i++) { Event[i].UnregisterListener(this); }  ",
          "content_tokens": 167,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameEventListener",
          "content": "public void OnEventRaised(GameEvent which) { Debug.Log(Event[0].name); for (int i = 0; i < Event.Length; i++) { if (Event[i] == which) Response[i].Invoke(); } } }",
          "content_tokens": 57,
          "embedding": []
        }
      ],
      "length": 916
    },
    {
      "filename": "FirebaseAuthenticator",
      "content": " using FishNet.Authenticating; using FishNet.Broadcast; using FishNet.Connection; using FishNet.Example.Authenticating; using FishNet.Managing; using FishNet.Managing.Logging; using FishNet.Transporting; using Newtonsoft.Json; using System; using System.Collections; using System.Linq; using System.Text; using UnityEngine; using UnityEngine.Networking; using Zomb; public class FirebaseAuthenticator : Authenticator { public struct TokenBroadcast : IBroadcast { public int TokenType; public string Value; } #region Public. /// <summary> /// Called when authenticator has concluded a result for a connection. Boolean is true if authentication passed, false if failed. /// Server listens for this event automatically. /// </summary> public override event Action<NetworkConnection, bool> OnAuthenticationResult; #endregion public override void InitializeOnce(NetworkManager networkManager) { base.InitializeOnce(networkManager); //Listen for connection state change as client. base.NetworkManager.ClientManager.OnClientConnectionState += ClientManager_OnClientConnectionState; //Listen for broadcast from client. Be sure to set requireAuthentication to false. base.NetworkManager.ServerManager.RegisterBroadcast<TokenBroadcast>(OnTokenBroadcast, false); //Listen to response from server. base.NetworkManager.ClientManager.RegisterBroadcast<ResponseBroadcast>(OnResponseBroadcast); } private class TokenBag { public string Token; public string RefreshToken; public string CharacterId; } /// <summary> /// Called when a connection state changes for the local client. /// </summary> private void ClientManager_OnClientConnectionState(ClientConnectionStateArgs args) { /* If anything but the started state then exit early. * Only try to authenticate on started state. The server * doesn't have to send an authentication request before client * can authenticate, that is entirely optional and up to you. In this * example the client tries to authenticate soon as they connect. */ if (args.ConnectionState != LocalConnectionState.Started) return; // // base.NetworkManager.ClientManager.Broadcast(new TokenBroadcast() { Value = TokenManager.Instance.Token, TokenType = 0 }); // base.NetworkManager.ClientManager.Broadcast(new TokenBroadcast() { Value = TokenManager.Instance.RefreshToken, TokenType = 1 }); // base.NetworkManager.ClientManager.Broadcast(new TokenBroadcast() { Value = LoginManager.CharacterId, TokenType = 2 }); } /// <summary> /// Received on server when a client sends the password broadcast message. /// </summary> /// <param name=\"conn\">Connection sending broadcast.</param> /// <param name=\"pb\"></param> private void OnTokenBroadcast(NetworkConnection conn, TokenBroadcast pb) { /* If client is already authenticated this could be an attack. Connections * are removed when a client disconnects so there is no reason they should * already be considered authenticated. */ if (conn.Authenticated) { conn.Disconnect(true); return; } var bag = new TokenBag(); if(conn.CustomData is TokenBag existingBag) { bag = existingBag; } else { conn.CustomData = bag; } switch (pb.TokenType) { case 0: bag.Token = pb.Value; break; case 1: bag.RefreshToken = pb.Value; break; case 2: bag.CharacterId = pb.Value; break; } if (bag.Token != null && bag.RefreshToken != null && bag.CharacterId != null) { StartCoroutine(AuthenticateAsync(conn, bag.Token, bag.RefreshToken, bag.CharacterId)); } } public static byte[] RemoveBOM(byte[] data) { byte[] bom = Encoding.UTF8.GetPreamble(); if (data.Length > bom.Length) { for (int i = 0; i < bom.Length; i++) { if (data[i] != bom[i]) return data; } } else { return data; } return data.Skip(3).ToArray(); } IEnumerator AuthenticateAsync(NetworkConnection conn, string token, string refreshToken, string characterId) { CharacterModel model; using (UnityWebRequest www = UnityWebRequest.Get($\"http://api.zomfi.org/character/{characterId}\")) { www.SetRequestHeader(\"Content-Type\", \"application/json\"); www.SetRequestHeader(\"Authorization\", token); yield return www.SendWebRequest(); try { model = JsonConvert.DeserializeObject<CharacterModel>(System.Text.Encoding.UTF8.GetString(RemoveBOM(www.downloadHandler.data))); } catch(Exception ex) { Debug.Log(ex); model = null; } } conn.CustomData = new Zomb.PlayerData() { // Id = characterId, // Model = model, // Token = token, // RefreshToken = refreshToken, }; OnAuthenticationResult?.Invoke(conn, model != null); } /// <summary> /// Received on client after server sends an authentication response. /// </summary> /// <param name=\"rb\"></param> private void OnResponseBroadcast(ResponseBroadcast rb) { string result = (rb.Passed) ? \"Authentication complete.\" : \"Authentication failed.\"; if (NetworkManager.CanLog(LoggingType.Common)) Debug.Log(result); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "FirebaseAuthenticator",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "FirebaseAuthenticator",
          "content": " using FishNet.Authenticating; using FishNet.Broadcast; using FishNet.Connection; using FishNet.Example.Authenticating; using FishNet.Managing; using FishNet.Managing.Logging; using FishNet.Transporting; using Newtonsoft.Json; using System; using System.Collections; using System.Linq; using System.Text; using UnityEngine; using UnityEngine.Networking; using Zomb; public class FirebaseAuthenticator : Authenticator { public struct TokenBroadcast : IBroadcast { public int TokenType; public string Value; } #region Public. /// <summary> /// Called when authenticator has concluded a result for a connection. Boolean is true if authentication passed, false if failed. /// Server listens for this event automatically. /// </summary> public override event Action<NetworkConnection, bool> OnAuthenticationResult; #endregion public override void InitializeOnce(NetworkManager networkManager) { base.InitializeOnce(networkManager); //Listen for connection state change as client. base.NetworkManager.ClientManager.OnClientConnectionState += ClientManager_OnClientConnectionState; //Listen for broadcast from client. Be sure to set requireAuthentication to false. base.NetworkManager.ServerManager.RegisterBroadcast<TokenBroadcast>(OnTokenBroadcast, false); //Listen to response from server. base.NetworkManager.ClientManager.RegisterBroadcast<ResponseBroadcast>(OnResponseBroadcast); } private class TokenBag { public string Token; public string RefreshToken; public string CharacterId; } /// <summary> /// Called when a connection state changes for the local client. /// </summary> private void ClientManager_OnClientConnectionState(ClientConnectionStateArgs args) { /* If anything but the started state then exit early. * Only try to authenticate on started state. The server * doesn't have to send an authentication request before client * can authenticate, that is entirely optional and up to you. In this * example the client tries to authenticate soon as they connect. */ if (args.ConnectionState != LocalConnectionState.Started) return; // // base.NetworkManager.ClientManager.Broadcast(new TokenBroadcast() { Value = TokenManager.Instance.Token, TokenType = 0 }); // base.NetworkManager.ClientManager.Broadcast(new TokenBroadcast() { Value = TokenManager.Instance.RefreshToken, TokenType = 1 }); // base.NetworkManager.ClientManager.Broadcast(new TokenBroadcast() { Value = LoginManager.CharacterId, TokenType = 2 }); } /// <summary> /// Received on server when a client sends the password broadcast message. /// </summary> /// <param name=\"conn\">Connection sending broadcast.</param> /// <param name=\"pb\"></param> private void OnTokenBroadcast(NetworkConnection conn, TokenBroadcast pb) { /* If client is already authenticated this could be an attack. Connections * are removed when a client disconnects so there is no reason they should * already be considered authenticated. */ if (conn.Authenticated) { conn.Disconnect(true); return; } var bag = new TokenBag(); if(conn.CustomData is TokenBag existingBag) { bag = existingBag; } else { conn.CustomData = bag;  ",
          "content_tokens": 701,
          "embedding": []
        },
        {
          "cs_scriptfile": "FirebaseAuthenticator",
          "content": "switch (pb.TokenType) { case 0: bag.Token = pb.Value; break; case 1: bag.RefreshToken = pb.Value; break; case 2: bag.CharacterId = pb.Value; break;  ",
          "content_tokens": 55,
          "embedding": []
        },
        {
          "cs_scriptfile": "FirebaseAuthenticator",
          "content": "if (bag.Token != null && bag.RefreshToken != null && bag.CharacterId != null) { StartCoroutine(AuthenticateAsync(conn, bag.Token, bag.RefreshToken, bag.CharacterId)); } } public static byte[] RemoveBOM(byte[] data) { byte[] bom = Encoding.UTF8.GetPreamble(); if (data.Length > bom.Length) { for (int i = 0; i < bom.Length; i++) { if (data[i] != bom[i]) return data; } } else { return data; } return data.Skip(3).ToArray(); } IEnumerator AuthenticateAsync(NetworkConnection conn, string token, string refreshToken, string characterId) { CharacterModel model; using (UnityWebRequest www = UnityWebRequest.Get($\"http://api.zomfi.org/character/{characterId}\")) { www.SetRequestHeader(\"Content-Type\", \"application/json\"); www.SetRequestHeader(\"Authorization\", token); yield return www.SendWebRequest(); try { model = JsonConvert.DeserializeObject<CharacterModel>(System.Text.Encoding.UTF8.GetString(RemoveBOM(www.downloadHandler.data)));  ",
          "content_tokens": 277,
          "embedding": []
        },
        {
          "cs_scriptfile": "FirebaseAuthenticator",
          "content": "catch(Exception ex) { Debug.Log(ex); model = null; } } conn.CustomData = new Zomb.PlayerData() { // Id = characterId, // Model = model, // Token = token, // RefreshToken = refreshToken, }; OnAuthenticationResult?.Invoke(conn, model != null); } /// <summary> /// Received on client after server sends an authentication response. /// </summary> /// <param name=\"rb\"></param> private void OnResponseBroadcast(ResponseBroadcast rb) { string result = (rb.Passed) ? \"Authentication complete.\" : \"Authentication failed.\"; if (NetworkManager.CanLog(LoggingType.Common)) Debug.Log(result); } }",
          "content_tokens": 157,
          "embedding": []
        }
      ],
      "length": 4738
    },
    {
      "filename": "GameDesignDocument",
      "content": "public class GameDesignDocument { public string content = \"Here is the Game design Document: 'Adventurer's Gambit: Dungeons of Fortune' (A Fantasy ExtractionRPG Adventure) Game description The game transports players to the mystical tower that consists of floors of dungeons, an epic fantasy realm where adventure and danger go hand in hand. In this groundbreaking third-person action RPG, players will experience an exhilarating blend of dungeon crawling, deck-building, and strategic PvPvE encounters. Inspired by legendary titles such as Dungeons & Dragons, roguelikes, Hearthstone Battlegrounds, and Escape from Tarkov, The game offers a fresh and thrilling take on the genre. Core Experience: - Thrilling PvPvE Gameplay: Engage in intense matches lasting 20-25 minutes, where up to 21 players—alone or in groups—navigate through a series of interconnected rooms, face off against formidable enemies, and vie for supremacy against other players. - Diverse Ability System: Players start each match in a SpawnRoom, equipped with basic gear (only weapon for new player). As they progress, they can level up and select from one of three random abilities, ultimately crafting a loadout of up to 6 active and 6 passive skills. This deck-building mechanic allows for unique and varied playstyles. - Boundless Exploration: The game offers a vast world to explore, from sprawling fields to complex dungeons. The game world is rich with discovery, and players will face dynamically changing environments, including mazes and assorted challenges. - Loot and Extraction: Players must defeat monsters, complete quests, and outsmart the competition to gather precious loot. The ultimate goal is to find a portal and escape the dungeon with your bounty, adding a thrilling extraction element to the game. - Character Customization: Craft your own legendary hero by selecting weapons, armor, and magic to match your desired playstyle. Whether you choose the path of a mighty warrior or a master sorcerer, your character's skills and appearance can be tailored to your vision. - Engrossing Narrative: The story of The game unfolds in fragments, with the motivations of various characters interweaving to create a compelling drama set against the backdrop of ancient myths. - Innovative Online Play: Experience a unique asynchronous online environment that emphasizes the presence of fellow adventurers. Team up with others, or compete against them, as you journey together through the immersive world. Very close genre games are: Dark and Darker, Dungeonborne, Dungeon Stalkers Core Loop Explore the dungeon Get XP (Monsters, Quests, PvP), Level up, Select random draft ability Search for loot and get stronger Find a portal and escape the dungeon with loot Hero Player controls single entity in a third person view. Death When a hero's HP drops to 0, the hero dies. If player has alive allies in party, instead of death animation, player should play “need help” animation like in PUBG/Apex so that other players can take them up in 5 seconds. When player dies in PvP mode he loses all loot, in PvE only that which was not with him when he entered the dungeon. Level When a hero gains enough experience points, they will level up by one level. Abilities At the beginning of the game, heroes are given one random ability by choosing from three provided options. The hero has 6 slots for active abilities (Q, E, R, T, Z, G) and 6 for passive abilities. Appendix 8. Abilities. Inventory The inventory has 18 slots for storing items. Items stored in these slots do not provide bonuses; the inventory serves as a storage space. Items The item table and their descriptions are presented in Appendix 1. Items and their descriptions. Consumable. Healing potion Equippable. Weapon. Right now we have these animations: Two-handed - for 2 handed sword Dual wield - for 2xShort swords/axes (Planned)Shield+Sword (Planned)Shield+Spear (Planned)Rapier (Planned)Hammer Armor. All armor equippables prefabs are presented in game Quests Quests can be obtained in SpawnRoom from Allied NPCs Questgivers. Quests can be Unique and Common. Common Quests Player can take several common quests. Common quests gives (experience && (armor || weapons)) . The list is available at Appendix 6. Common quests. Unique Quests Player can take only 1 unique quest in SpawnRoom. Others will be disabled. The list is available at Appendix 7. Common quests. Room All rooms are rectangle-shaped. During the game, some rooms receive room buffs (positive, negative, unpredictable), which can be global or local to the player. Rooms can have several types. SpawnRoom In this room, the player starts the game. The room contains merchants, quest givers. Puzzle Room This room is filled with traps and puzzles, and inside room player can find chest. If the player dies in the room, nothing is lost. It dynamically generates from trap pieces: spikes emerging from the ground, projectiles flying at intervals. The room is rectangular and elongated. At the end, there are 1-3 exits, with each exit having its own wall. Puzzle structures in escape rooms: basic structures: open, sequential and path-based; a complex, hybrid structure, such as a pyramid. Squares are puzzles and the rectangles are metapuzzles (adapted from Nicholson, 2015) Example: The puzzle room is divided into 12 chunks. During generation, the algorithm must determine a path leading to the exits from the room. Pre-designed trap prefabs and walls are strategically placed. Traps: Grinder and Spikes trap; Moving Axe. Boss Rooms Throne of the Stone Sentinel. Is a grand, cavernous space etched into the side of an ancient, crumbled fortress. Massive stone pillars, engraved with runes of power and protection, stretch up to support the fractured ceiling from which roots and vines dangle, suggesting the room's great age and the relentless encroachment of the Lands Between. At the center lies a dais of weathered stone, upon which the boss, the Rock Golem, stands dormant. It's a colossal, stony figure, with glowing runes pulsating across its body, each beat like the heartbeat of the mountain itself. The air in the room is thick with magical energy, and the ground is littered with the debris of fallen challengers. Crystals jut out from the walls and floor, their inner light providing an ominous illumination that casts long and treacherous shadows. Occasionally, a pulse of energy from the golem sends a shiver through the crystals, creating a disorienting light show that could distract players during the encounter. Torches set in sconces along the walls flicker as if afraid of the ancient power they sit so close to. The room's ambience is haunting, filled with whispering echoes—a stark reminder that this is a place where history sleeps and nightmares dwell. This room is a testament to the golem's dominion; it's not just a battleground but a sacred space where the boss has absorbed the essence of countless fallen heroes over centuries. Intruders must navigate through this oppressive atmosphere and face the Rock Golem in an epic showdown where the very room itself seems to conspire against them. Players must be wary, for the boss isn't the only threat. Traps and hazards await those who are not vigilant, as the room is designed to protect its master. Environmental challenges, such as falling debris or sudden eruptions of magical energy from the crystals, must be avoided while battling the golem, adding layers of complexity to the encounter. The Throne of the Stone Sentinel is more than a room; it is a crucible where legends are forged and the unworthy are crushed beneath the weight of forgotten time. Minions Room In the room, there should be P(N+3) minions, where N is the level of the room, and P is the number of players. Duel Room The PvP room, where hearts are not lost upon death. Players can challenge any other player to a duel. The reward for completing the room. For completing the room, the player will be able to open the chest with an increased chance of dropping good loot. Buffed Rooms Room statuses: Monster Amplification: all monster HP + 25% Monster Weakening: all monster HP - 25% Mana Drain: every second drains 1MP from player Stamina Drain: every second drains 1SP from player Room Collapsing Since within the framework of a multi-level dungeon with 2+ floors, the shrinking circle system (for example, the zone from PUBG) is not suitable, we have decided to destroy rooms through pinpoint strikes. Each dungeon has a preset graph of connections between rooms, based on this data, we eliminate distant rooms. Spawn Rooms have a timer of 2 minutes regardless of their location. For example: In the example graph below, rooms 1, 2, 5, and 6 can be considered distant. We can set the same destruction time for these rooms. In this case, only rooms 3 and 4 will remain in the next stage. In the case where only 2 rooms remain, the room to be destroyed will be chosen randomly. Example graph: {'nodes': [{'id': '1'},{'id': '2'},{'id': '3'},{'id': '4'},{'id': '5'},{'id': '6'}], 'edges': [{'source': '1', 'target': '3'},{'source': '2', 'target': '4'},{'source': '3', 'target': '4'},{'source': '3', 'target': '5'},{'source': '4', 'target': '5'},{'source': '4','target': '6'}]} Creatures There are Neutral, Hostile, and Allied monsters. For characteristics, refer to the table. Allied Merchants, pets, quest givers, etc. Neutral Neutral NPCs can be found in Dungeon, by default they are not hostile. But if player deals damage to them, they will start combat. Their purpose is to be quest target NPCs or quest givers. Hostile For the full list of creatures look at Appendix 4 Creatures. Economy Chest Gold drop: 50% chance of dropping between 10 and 15 gold coins. Loot: 1-2 items chance is defined by LottDrop Table Gold coins The primary in-game currency is gold coins. It is obtained from monsters and chests. Reward Calculation for Monsters The amount of gold dropped in loot is calculated by the formula: 1-5 gold coins * 50%. Mechanics Reward Window: Ability Minimum quantity: 3 abilities Maximum quantity: 7 abilities Time allotted for selection: 30 seconds Shuffle cost: 100 xp A reward window opens for the player, where they can choose only 1 ability; the rest are destroyed. If the player fails to make a choice in time, a random ability is given to them. Shuffle The player should have the option to shuffle the abilities provided for selection by pressing a button to request a new distribution. In the new distribution, abilities from previous distributions may appear again. An example from the Hearthstone game mode 'Battlegrounds': In Hearthstone's Battlegrounds mode, players are presented with a selection of minions to recruit for their team at the start of each round. This selection typically consists of three randomly chosen minions from a predefined pool. Players have a limited time to choose which minion to recruit for their team. If they don't make a selection within the time limit, one is automatically chosen for them. Similar to the proposed scenario, Hearthstone Battlegrounds also allows players to refresh their available minion options by spending in-game currency called gold. This refresh gives players a new set of minions to choose from, which may include minions that were in previous sets. Overall, the concept of selecting from a set of options, having the ability to refresh those options, and the potential for previously seen options to appear again aligns with the example from Hearthstone's Battlegrounds mode. Hearthstone game mode 'Battlegrounds' Reward Window: Items Before the player, a reward window opens, in which they can choose only 1 item; the rest are destroyed. If the player fails to make a choice in time, a random item is given to them. Appendix 1. Items and Their Descriptions. Stored in ScriptableObject: “vShooterMelee_ItemListData_Stylized” Item stats tables Trash Common Rare Epic Appendix 2. Abilities and Their Descriptions. Stored in ScriptableObject: “AbilityDefinitionHolderSO” Appendix 4. Creatures. Stored in: “SOEnemyDefinitionsHolder” [{ 'Name': 'Abomination', 'Type': 'Monster', 'Strength': 10, 'RunSpeed': 1.6, 'MaxHealth': 125, 'Attack cooldown': 2, 'Attack distance': 1.9, 'Attack animation': 1.533333, 'RewardExperience': 125, 'ChanceToSpawn': 0.11, },{ 'Name': ' Bone Golem', 'Type': 'Monster', 'Strength': 15, 'RunSpeed': 2, 'MaxHealth': 200, 'Attack cooldown': 3, 'Attack distance': 2, 'Attack animation': 1.200001, 'RewardExperience': 200, 'ChanceToSpawn': 0.12, },{ 'Name': 'Rock Golem', 'Type': 'Boss', 'Strength': 10, 'RunSpeed': 1, 'MaxHealth': 500, 'Attack cooldown': 3, 'Attack distance': 4, 'Attack animation': 2, 'RewardExperience': 1000, 'ChanceToSpawn': 0.00, },{ 'Name': 'HumanoidScarab', 'Type': 'Monster', 'Strength': 10, 'RunSpeed': 2, 'MaxHealth': 100, 'Attack cooldown': 3, 'Attack distance': 1.7, 'Attack animation': 1.166667, 'RewardExperience': 100, 'ChanceToSpawn': 0.29, },{ 'Name': 'SlimeManToxic', 'Type': 'Monster', 'Strength': 10, 'RunSpeed': 1.5, 'MaxHealth': 200, 'Attack cooldown': 4, 'Attack distance': 2.3, 'Attack animation': 1.533333, 'RewardExperience': 200, 'ChanceToSpawn': 0.10, },{ 'Name': 'SlimeToxic', 'Type': 'Summon', 'Strength': 10, 'RunSpeed': 1.5, 'MaxHealth': 25, 'Attack cooldown': 3, 'Attack distance': 1, 'Attack animation': 1.000001, 'RewardExperience': 0, 'ChanceToSpawn': 0.30, },{ 'Name': 'SwampHound', 'Type': 'Monster', 'Strength': 10, 'RunSpeed': 2, 'MaxHealth': 100, 'Attack cooldown': 3, 'Attack distance': 2, 'Attack animation': 1.333336, 'RewardExperience': 100, 'ChanceToSpawn': 0.00, },{ 'Name': 'ZombieHound', 'Type': 'Monster', 'Strength': 10, 'RunSpeed': 2, 'MaxHealth': 100, 'Attack cooldown': 3, 'Attack distance': 1.6, 'Attack animation': 1.333336, 'RewardExperience': 100, 'ChanceToSpawn': 0.30, }] Appendix 5. 3D Assets. Modular Fantasy Stylized Human Male Modular Fantasy Stylized Human Female Stylized Human Zombie Customization Stylized Fantasy Outfits #2 Stylized Fantasy Mimic Treasure Chest Stylized Fantasy Newbie Outfits Pack Stylized Newbie Weapons Pack Stylized Craft Assets Stylized Fantasy Enemy NPC Bundle Stylized Fantasy Enemy NPC Bundle #2 Stylized Fantasy Girls NPC Pack #2 Stylized Fantasy Weapons #2 Stylized Pirate Port City (Modular) Ghoul Crew - Hand Painted Z ! Low Poly Cave Pack Appendix 6. Common quests. [ { 'Title': 'Arcane Collector', 'Description': 'Collect 3 rare spell tomes from the Puzzle Rooms scattered throughout the dungeon.', 'Reward': 'Experience points and a rare magical artifact for your inventory.' }, { 'Title': 'Monster Slayer', 'Description': 'Defeat at least one of each hostile creature type listed in Appendix 4 within a single match.', 'Reward': 'Experience points and a weapon with a special enchantment against monsters.' }, { 'Title': 'Dungeon Navigator', 'Description': 'Successfully navigate through 5 different Puzzle Rooms without triggering any traps.', 'Reward': 'Experience points and a pair of boots that grant increased speed.' }, { 'Title': 'PvP Champion', 'Description': 'Win a duel in the Duel Room without losing more than 25% of your HP.', 'Reward': 'Experience points and a piece of armor that provides damage reduction against other players.' }, { 'Title': 'Master of Mazes', 'Description': 'Find and extract a hidden treasure from the depths of the most complex maze.', 'Reward': 'Experience points and a magic compass that points to nearby treasure chests.' }, { 'Title': 'Beast Tamer', 'Description': 'Subdue and recruit a Neutral NPC to aid you in battle.', 'Reward': 'Experience points and an amulet that enhances the abilities of allied minions.' }, { 'Title': 'The Healer's Path', 'Description': 'Use healing abilities or items to restore a total of 1000 HP to allied players.', 'Reward': 'Experience points and a robe that increases healing effectiveness.' }, { 'Title': 'Treasure Hunter', 'Description': 'Open 10 chests in a single match and survive to extract with the loot.', 'Reward': 'Experience points and a key that unlocks a special chest in the SpawnRoom.' }, { 'Title': 'Elemental Adept', 'Description': 'Use abilities of at least four different elemental types (Fire, Water, Earth, Air) to defeat enemies.', 'Reward': 'Experience points and a ring that grants resistance to elemental damage.' }, { 'Title': 'Escape Artist', 'Description': 'Successfully evade or survive monster amplification in three Buffed Rooms.', 'Reward': 'Experience points and a cloak that grants a temporary stealth ability.' }] Appendix 7. Unique quests. [{ 'Title': 'Untouchable', 'Description': 'Do not receive damage until level 5', 'Reward': 'HP -20%, Damage +20%' },{ 'Title': 'Support for the life', 'Description': 'Heal total 500 HP.', 'Reward': 'Increases all your healing by 20%.' }, { 'Title': 'Mana Surge', 'Description': 'Defeat 20 Enemies using only magic spells.', 'Reward': 'Increases your mana regeneration by 50% for 60 seconds after defeating an enemy.' }, { 'Title': 'Arcanist’s Insight', 'Description': 'Cast 20 spells.', 'Reward': 'Reduces the mana cost of all spells by 15%.' }, { 'Title': 'Warrior’s Focus', 'Description': 'Defeat 20 enemies without using any spells.', 'Reward': 'Melee attacks gain a 15% chance to stun enemies for 2 seconds.' }, { 'Title': 'Ember Mastery', 'Description': 'Defeat 20 enemies with fire-based spells.', 'Reward': 'Fire spells have a 20% chance to ignite enemies, dealing an additional 20% damage over 6 seconds.' }, { 'Title': 'Boss Challenge', 'Description': 'Defeat a boss using only magic spells.', 'Reward': 'Increases your mana regeneration by 50% for 60 seconds after defeating an enemy.' }, { 'Title': 'Arcane Aegis', 'Description': 'Successfully block 20 enemy spells with a magic shield.', 'Reward': 'Your magic shield now reflects 10% of spell damage back to the attacker.' }, { 'Title': 'Arcanist’s Insight', 'Description': 'Cast 100 spells.', 'Reward': 'Reduces the mana cost of all spells by 15%.' }, { 'Title': 'Curse Resistance', 'Description': 'Survive for 10 minutes in the cursed lands without using healing items.', 'Reward': 'Reduces damage taken from cursed lands by 25% and grants immunity to curse-related status effects.' }, { 'Title': 'Warrior’s Focus', 'Description': 'Complete a level without using any spells.', 'Reward': 'Melee attacks gain a 15% chance to stun enemies for 2 seconds.' }, { 'Title': 'Ember Mastery', 'Description': 'Defeat 50 enemies with fire-based spells.', 'Reward': 'Fire spells have a 20% chance to ignite enemies, dealing an additional 20% damage over 6 seconds.' }, { 'Title': 'Pact of the Summoner', 'Description': 'Summon 30 creatures to aid you in battle.', 'Reward': 'Your summoned creatures gain 25% increased health and damage.' }, { 'Title': 'Galeforce', 'Description': 'Finish a level using only wind spells.', 'Reward': 'Wind spells now have a 50% chance to knock back enemies and reduce their attack speed by 20% for 3 seconds.' }, { 'Title': 'Frost’s Embrace', 'Description': 'Use ice spells to freeze 50 enemies.', 'Reward': 'Enemies remain frozen for an additional second, and your ice spells reduce the target's defense by 10%.' }, { 'Title': 'Storm Conductor', 'Description': 'Chain lightning spells to hit 100 enemies.', 'Reward': 'Increases the chain range of your lightning spells by 50% and adds a 10% chance to stun affected enemies for 1 second.' } ] Appendix 8. Abilities. [{ 'Name': 'Blink', 'Description': 'Teleports player a short distance forward. This ability does not deal direct damage but is invaluable for dodging enemy attacks and traversing the battlefield quickly.', 'QuestDescription': '', },{ 'Name': 'Energy Shield', 'Description': 'Summon energy around you creating shield that avoids @@@ instances of damage. Duration 5 secs.', 'QuestDescription': '', },{ 'Name': 'Regeneration', 'Description': 'Recovers a percentage of maximum health every few seconds (e.g., 5% of max health every 3 seconds) for a 5 ticks.', 'QuestDescription': '', },{ 'Name': 'Flesh Explosion', 'Description': 'Deals damage equal to 75% of current health to self and others.', 'QuestDescription': '', },{ 'Name': 'Backtrack', 'Description': 'Returns health, mana and stamina to 5 seconds ago.', 'QuestDescription': '', },{ 'Name': 'Teleportation Circle', 'Description': 'Creates magic circle at location. Upon second activation teleports player to that location.', 'QuestDescription': '', },{ 'Name': 'Mountain Splitter Strike'(Passive), 'Description': 'Every first attack is a critical hit, dealing @@@ of the attack's damage.', 'QuestDescription': 'Quest: practice this strike @@@@ times to unlock the next rank.', },{ 'Name': 'Rock Skin'(Passive), 'Description': 'Passively reduces incoming damage by @@@.', 'QuestDescription': 'Quest: every @@@@ taken damage increases absorbtion by @@@@@.', },{ 'Name': 'Vampiric Touch'(Passive), 'Description': 'Converts @@@ of any damage into health.', 'QuestDescription': 'Quest: every @@@@ regenerated health increases this effect by @@@@@.', },{ 'Name': 'Weak Spot'(Passive), 'Description': 'Increases melee critical strike damage by @@@.', 'QuestDescription': 'Quest: practice this strike @@@@ times to unlock the next rank.', },{ 'Name': 'Thorn Shell'(Passive), 'Description': 'Returns @@@ of incoming damage back to attacker.', 'QuestDescription': 'Quest: every @@@@ taken damage increases absorbtion by @@@@@.', },{ 'Name': 'Resilience Globules'(Passive), 'Description': 'Increases HP by @@@.', 'QuestDescription': 'Quest: every @@@@ healing spheres increases max HP by @@@@@.', },{ 'Name': 'ItemHealingPotion', 'Description': 'Heals @@@ HP over 5 seconds,', 'QuestDescription': '', },{ 'Name': 'Divine Shield', 'Description': 'For @@@ seconds player becomes invulnerable.', 'QuestDescription': '', },{ 'Name': 'Posion Nova', 'Description': 'Unleashes a wave of toxic energy, poisoning all enemies in its radius upon activation. The poison inflicts @@@ damage over time.', 'QuestDescription': '', }]\"; }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "GameDesignDocument",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameDesignDocument",
          "content": "public class GameDesignDocument { public string content = \"Here is the Game design Document: 'Adventurer's Gambit: Dungeons of Fortune' (A Fantasy ExtractionRPG Adventure) Game description The game transports players to the mystical tower that consists of floors of dungeons, an epic fantasy realm where adventure and danger go hand in hand. In this groundbreaking third-person action RPG, players will experience an exhilarating blend of dungeon crawling, deck-building, and strategic PvPvE encounters. Inspired by legendary titles such as Dungeons & Dragons, roguelikes, Hearthstone Battlegrounds, and Escape from Tarkov, The game offers a fresh and thrilling take on the genre. Core Experience: - Thrilling PvPvE Gameplay: Engage in intense matches lasting 20-25 minutes, where up to 21 players—alone or in groups—navigate through a series of interconnected rooms, face off against formidable enemies, and vie for supremacy against other players. - Diverse Ability System: Players start each match in a SpawnRoom, equipped with basic gear (only weapon for new player). As they progress, they can level up and select from one of three random abilities, ultimately crafting a loadout of up to 6 active and 6 passive skills. This deck-building mechanic allows for unique and varied playstyles. - Boundless Exploration: The game offers a vast world to explore, from sprawling fields to complex dungeons. The game world is rich with discovery, and players will face dynamically changing environments, including mazes and assorted challenges. - Loot and Extraction: Players must defeat monsters, complete quests, and outsmart the competition to gather precious loot. The ultimate goal is to find a portal and escape the dungeon with your bounty, adding a thrilling extraction element to the game. - Character Customization: Craft your own legendary hero by selecting weapons, armor, and magic to match your desired playstyle. Whether you choose the path of a mighty warrior or a master sorcerer, your character's skills and appearance can be tailored to your vision. - Engrossing Narrative: The story of The game unfolds in fragments, with the motivations of various characters interweaving to create a compelling drama set against the backdrop of ancient myths. - Innovative Online Play: Experience a unique asynchronous online environment that emphasizes the presence of fellow adventurers. Team up with others, or compete against them, as you journey together through the immersive world. Very close genre games are: Dark and Darker, Dungeonborne, Dungeon Stalkers Core Loop Explore the dungeon Get XP (Monsters, Quests, PvP), Level up, Select random draft ability Search for loot and get stronger Find a portal and escape the dungeon with loot Hero Player controls single entity in a third person view. Death When a hero's HP drops to 0, the hero dies. If player has alive allies in party, instead of death animation, player should play “need help” animation like in PUBG/Apex so that other players can take them up in 5 seconds. When player dies in PvP mode he loses all loot, in PvE only that which was not with him when he entered the dungeon. Level When a hero gains enough experience points, they will level up by one level. Abilities At the beginning of the game, heroes are given one random ability by choosing from three provided options. The hero has 6 slots for active abilities (Q, E, R, T, Z, G) and 6 for passive abilities. Appendix 8. Abilities. Inventory The inventory has 18 slots for storing items. Items stored in these slots do not provide bonuses; the inventory serves as a storage space. Items The item table and their descriptions are presented in Appendix 1. Items and their descriptions. Consumable. Healing potion Equippable. Weapon. Right now we have these animations: Two-handed - for 2 handed sword Dual wield - for 2xShort swords/axes (Planned)Shield+Sword (Planned)Shield+Spear (Planned)Rapier (Planned)Hammer Armor. All armor equippables prefabs are presented in game Quests Quests can be obtained in SpawnRoom from Allied NPCs Questgivers. Quests can be Unique and Common. Common Quests Player can take several common quests. Common quests gives (experience && (armor || weapons)) . The list is available at Appendix 6. Common quests. Unique Quests Player can take only 1 unique quest in SpawnRoom. Others will be disabled. The list is available at Appendix 7. Common quests. Room All rooms are rectangle-shaped. During the game, some rooms receive room buffs (positive, negative, unpredictable), which can be global or local to the player. Rooms can have several types. SpawnRoom In this room, the player starts the game. The room contains merchants, quest givers. Puzzle Room This room is filled with traps and puzzles, and inside room player can find chest. If the player dies in the room, nothing is lost. It dynamically generates from trap pieces: spikes emerging from the ground, projectiles flying at intervals. The room is rectangular and elongated. At the end, there are 1-3 exits, with each exit having its own wall. Puzzle structures in escape rooms: basic structures: open, sequential and path-based; a complex, hybrid structure, such as a pyramid. Squares are puzzles and the rectangles are metapuzzles (adapted from Nicholson, 2015) Example: The puzzle room is divided into 12 chunks. During generation, the algorithm must determine a path leading to the exits from the room. Pre-designed trap prefabs and walls are strategically placed. Traps: Grinder and Spikes trap; Moving Axe. Boss Rooms Throne of the Stone Sentinel. Is a grand, cavernous space etched into the side of an ancient, crumbled fortress. Massive stone pillars, engraved with runes of power and protection, stretch up to support the fractured ceiling from which roots and vines dangle, suggesting the room's great age and the relentless encroachment of the Lands Between. At the center lies a dais of weathered stone, upon which the boss, the Rock Golem, stands dormant. It's a colossal, stony figure, with glowing runes pulsating across its body, each beat like the heartbeat of the mountain itself. The air in the room is thick with magical energy, and the ground is littered with the debris of fallen challengers. Crystals jut out from the walls and floor, their inner light providing an ominous illumination that casts long and treacherous shadows. Occasionally, a pulse of energy from the golem sends a shiver through the crystals, creating a disorienting light show that could distract players during the encounter. Torches set in sconces along the walls flicker as if afraid of the ancient power they sit so close to. The room's ambience is haunting, filled with whispering echoes—a stark reminder that this is a place where history sleeps and nightmares dwell. This room is a testament to the golem's dominion; it's not just a battleground but a sacred space where the boss has absorbed the essence of countless fallen heroes over centuries. Intruders must navigate through this oppressive atmosphere and face the Rock Golem in an epic showdown where the very room itself seems to conspire against them. Players must be wary, for the boss isn't the only threat. Traps and hazards await those who are not vigilant, as the room is designed to protect its master. Environmental challenges, such as falling debris or sudden eruptions of magical energy from the crystals, must be avoided while battling the golem, adding layers of complexity to the encounter. The Throne of the Stone Sentinel is more than a room; it is a crucible where legends are forged and the unworthy are crushed beneath the weight of forgotten time. Minions Room In the room, there should be P(N+3) minions, where N is the level of the room, and P is the number of players. Duel Room The PvP room, where hearts are not lost upon death. Players can challenge any other player to a duel. The reward for completing the room. For completing the room, the player will be able to open the chest with an increased chance of dropping good loot. Buffed Rooms Room statuses: Monster Amplification: all monster HP + 25% Monster Weakening: all monster HP - 25% Mana Drain: every second drains 1MP from player Stamina Drain: every second drains 1SP from player Room Collapsing Since within the framework of a multi-level dungeon with 2+ floors, the shrinking circle system (for example, the zone from PUBG) is not suitable, we have decided to destroy rooms through pinpoint strikes. Each dungeon has a preset graph of connections between rooms, based on this data, we eliminate distant rooms. Spawn Rooms have a timer of 2 minutes regardless of their location. For example: In the example graph below, rooms 1, 2, 5, and 6 can be considered distant. We can set the same destruction time for these rooms. In this case, only rooms 3 and 4 will remain in the next stage. In the case where only 2 rooms remain, the room to be destroyed will be chosen randomly. Example graph: {'nodes': [{'id': '1'},{'id': '2'},{'id': '3'},{'id': '4'},{'id': '5'},{'id': '6'}], 'edges': [{'source': '1', 'target': '3'},{'source': '2', 'target': '4'},{'source': '3', 'target': '4'},{'source': '3', 'target': '5'},{'source': '4', 'target': '5'},{'source': '4','target': '6'}]} Creatures There are Neutral, Hostile, and Allied monsters. For characteristics, refer to the table. Allied Merchants, pets, quest givers, etc. Neutral Neutral NPCs can be found in Dungeon, by default they are not hostile. But if player deals damage to them, they will start combat. Their purpose is to be quest target NPCs or quest givers. Hostile For the full list of creatures look at Appendix 4 Creatures. Economy Chest Gold drop: 50% chance of dropping between 10 and 15 gold coins. Loot: 1-2 items chance is defined by LottDrop Table Gold coins The primary in-game currency is gold coins. It is obtained from monsters and chests. Reward Calculation for Monsters The amount of gold dropped in loot is calculated by the formula: 1-5 gold coins * 50%. Mechanics Reward Window: Ability Minimum quantity: 3 abilities Maximum quantity: 7 abilities Time allotted for selection: 30 seconds Shuffle cost: 100 xp A reward window opens for the player, where they can choose only 1 ability; the rest are destroyed. If the player fails to make a choice in time, a random ability is given to them. Shuffle The player should have the option to shuffle the abilities provided for selection by pressing a button to request a new distribution. In the new distribution, abilities from previous distributions may appear again. An example from the Hearthstone game mode 'Battlegrounds': In Hearthstone's Battlegrounds mode, players are presented with a selection of minions to recruit for their team at the start of each round. This selection typically consists of three randomly chosen minions from a predefined pool. Players have a limited time to choose which minion to recruit for their team. If they don't make a selection within the time limit, one is automatically chosen for them. Similar to the proposed scenario, Hearthstone Battlegrounds also allows players to refresh their available minion options by spending in-game currency called gold. This refresh gives players a new set of minions to choose from, which may include minions that were in previous sets. Overall, the concept of selecting from a set of options, having the ability to refresh those options, and the potential for previously seen options to appear again aligns with the example from Hearthstone's Battlegrounds mode. Hearthstone game mode 'Battlegrounds' Reward Window: Items Before the player, a reward window opens, in which they can choose only 1 item; the rest are destroyed. If the player fails to make a choice in time, a random item is given to them. Appendix 1. Items and Their Descriptions. Stored in ScriptableObject: “vShooterMelee_ItemListData_Stylized” Item stats tables Trash Common Rare Epic Appendix 2. Abilities and Their Descriptions. Stored in ScriptableObject: “AbilityDefinitionHolderSO” Appendix 4. Creatures. Stored in: “SOEnemyDefinitionsHolder” [{ 'Name': 'Abomination', 'Type': 'Monster', 'Strength': 10, 'RunSpeed': 1.6, 'MaxHealth': 125, 'Attack cooldown': 2, 'Attack distance': 1.9, 'Attack animation': 1.533333, 'RewardExperience': 125, 'ChanceToSpawn': 0.11, },{ 'Name': ' Bone Golem', 'Type': 'Monster', 'Strength': 15, 'RunSpeed': 2, 'MaxHealth': 200, 'Attack cooldown': 3, 'Attack distance': 2, 'Attack animation': 1.200001, 'RewardExperience': 200, 'ChanceToSpawn': 0.12, },{ 'Name': 'Rock Golem', 'Type': 'Boss', 'Strength': 10, 'RunSpeed': 1, 'MaxHealth': 500, 'Attack cooldown': 3, 'Attack distance': 4, 'Attack animation': 2, 'RewardExperience': 1000, 'ChanceToSpawn': 0.00, },{ 'Name': 'HumanoidScarab', 'Type': 'Monster', 'Strength': 10, 'RunSpeed': 2, 'MaxHealth': 100, 'Attack cooldown': 3, 'Attack distance': 1.7, 'Attack animation': 1.166667, 'RewardExperience': 100, 'ChanceToSpawn': 0.29, },{ 'Name': 'SlimeManToxic', 'Type': 'Monster', 'Strength': 10, 'RunSpeed': 1.5, 'MaxHealth': 200, 'Attack cooldown': 4, 'Attack distance': 2.3, 'Attack animation': 1.533333, 'RewardExperience': 200, 'ChanceToSpawn': 0.10, },{ 'Name': 'SlimeToxic', 'Type': 'Summon', 'Strength': 10, 'RunSpeed': 1.5, 'MaxHealth': 25, 'Attack cooldown': 3, 'Attack distance': 1, 'Attack animation': 1.000001, 'RewardExperience': 0, 'ChanceToSpawn': 0.30, },{ 'Name': 'SwampHound', 'Type': 'Monster', 'Strength': 10, 'RunSpeed': 2, 'MaxHealth': 100, 'Attack cooldown': 3, 'Attack distance': 2, 'Attack animation': 1.333336, 'RewardExperience': 100, 'ChanceToSpawn': 0.00, },{ 'Name': 'ZombieHound', 'Type': 'Monster', 'Strength': 10, 'RunSpeed': 2, 'MaxHealth': 100, 'Attack cooldown': 3, 'Attack distance': 1.6, 'Attack animation': 1.333336, 'RewardExperience': 100, 'ChanceToSpawn': 0.30, }] Appendix 5. 3D Assets. Modular Fantasy Stylized Human Male Modular Fantasy Stylized Human Female Stylized Human Zombie Customization Stylized Fantasy Outfits #2 Stylized Fantasy Mimic Treasure Chest Stylized Fantasy Newbie Outfits Pack Stylized Newbie Weapons Pack Stylized Craft Assets Stylized Fantasy Enemy NPC Bundle Stylized Fantasy Enemy NPC Bundle #2 Stylized Fantasy Girls NPC Pack #2 Stylized Fantasy Weapons #2 Stylized Pirate Port City (Modular) Ghoul Crew - Hand Painted Z ! Low Poly Cave Pack Appendix 6. Common quests. [ { 'Title': 'Arcane Collector', 'Description': 'Collect 3 rare spell tomes from the Puzzle Rooms scattered throughout the dungeon.', 'Reward': 'Experience points and a rare magical artifact for your inventory.' }, { 'Title': 'Monster Slayer', 'Description': 'Defeat at least one of each hostile creature type listed in Appendix 4 within a single match.', 'Reward': 'Experience points and a weapon with a special enchantment against monsters.' }, { 'Title': 'Dungeon Navigator', 'Description': 'Successfully navigate through 5 different Puzzle Rooms without triggering any traps.', 'Reward': 'Experience points and a pair of boots that grant increased speed.' }, { 'Title': 'PvP Champion', 'Description': 'Win a duel in the Duel Room without losing more than 25% of your HP.', 'Reward': 'Experience points and a piece of armor that provides damage reduction against other players.' }, { 'Title': 'Master of Mazes', 'Description': 'Find and extract a hidden treasure from the depths of the most complex maze.', 'Reward': 'Experience points and a magic compass that points to nearby treasure chests.' }, { 'Title': 'Beast Tamer', 'Description': 'Subdue and recruit a Neutral NPC to aid you in battle.', 'Reward': 'Experience points and an amulet that enhances the abilities of allied minions.' }, { 'Title': 'The Healer's Path', 'Description': 'Use healing abilities or items to restore a total of 1000 HP to allied players.', 'Reward': 'Experience points and a robe that increases healing effectiveness.' }, { 'Title': 'Treasure Hunter', 'Description': 'Open 10 chests in a single match and survive to extract with the loot.', 'Reward': 'Experience points and a key that unlocks a special chest in the SpawnRoom.' }, { 'Title': 'Elemental Adept', 'Description': 'Use abilities of at least four different elemental types (Fire, Water, Earth, Air) to defeat enemies.', 'Reward': 'Experience points and a ring that grants resistance to elemental damage.' }, { 'Title': 'Escape Artist', 'Description': 'Successfully evade or survive monster amplification in three Buffed Rooms.', 'Reward': 'Experience points and a cloak that grants a temporary stealth ability.' }] Appendix 7. Unique quests. [{ 'Title': 'Untouchable', 'Description': 'Do not receive damage until level 5', 'Reward': 'HP -20%, Damage +20%' },{ 'Title': 'Support for the life', 'Description': 'Heal total 500 HP.', 'Reward': 'Increases all your healing by 20%.' }, { 'Title': 'Mana Surge', 'Description': 'Defeat 20 Enemies using only magic spells.', 'Reward': 'Increases your mana regeneration by 50% for 60 seconds after defeating an enemy.' }, { 'Title': 'Arcanist’s Insight', 'Description': 'Cast 20 spells.', 'Reward': 'Reduces the mana cost of all spells by 15%.' }, { 'Title': 'Warrior’s Focus', 'Description': 'Defeat 20 enemies without using any spells.', 'Reward': 'Melee attacks gain a 15% chance to stun enemies for 2 seconds.' }, { 'Title': 'Ember Mastery', 'Description': 'Defeat 20 enemies with fire-based spells.', 'Reward': 'Fire spells have a 20% chance to ignite enemies, dealing an additional 20% damage over 6 seconds.' }, { 'Title': 'Boss Challenge', 'Description': 'Defeat a boss using only magic spells.', 'Reward': 'Increases your mana regeneration by 50% for 60 seconds after defeating an enemy.' }, { 'Title': 'Arcane Aegis', 'Description': 'Successfully block 20 enemy spells with a magic shield.', 'Reward': 'Your magic shield now reflects 10% of spell damage back to the attacker.' }, { 'Title': 'Arcanist’s Insight', 'Description': 'Cast 100 spells.', 'Reward': 'Reduces the mana cost of all spells by 15%.' }, { 'Title': 'Curse Resistance', 'Description': 'Survive for 10 minutes in the cursed lands without using healing items.', 'Reward': 'Reduces damage taken from cursed lands by 25% and grants immunity to curse-related status effects.' }, { 'Title': 'Warrior’s Focus', 'Description': 'Complete a level without using any spells.', 'Reward': 'Melee attacks gain a 15% chance to stun enemies for 2 seconds.' }, { 'Title': 'Ember Mastery', 'Description': 'Defeat 50 enemies with fire-based spells.', 'Reward': 'Fire spells have a 20% chance to ignite enemies, dealing an additional 20% damage over 6 seconds.' }, { 'Title': 'Pact of the Summoner', 'Description': 'Summon 30 creatures to aid you in battle.', 'Reward': 'Your summoned creatures gain 25% increased health and damage.' }, { 'Title': 'Galeforce', 'Description': 'Finish a level using only wind spells.', 'Reward': 'Wind spells now have a 50% chance to knock back enemies and reduce their attack speed by 20% for 3 seconds.' }, { 'Title': 'Frost’s Embrace', 'Description': 'Use ice spells to freeze 50 enemies.', 'Reward': 'Enemies remain frozen for an additional second, and your ice spells reduce the target's defense by 10%.' }, { 'Title': 'Storm Conductor', 'Description': 'Chain lightning spells to hit 100 enemies.', 'Reward': 'Increases the chain range of your lightning spells by 50% and adds a 10% chance to stun affected enemies for 1 second.' } ] Appendix 8. Abilities. [{ 'Name': 'Blink', 'Description': 'Teleports player a short distance forward. This ability does not deal direct damage but is invaluable for dodging enemy attacks and traversing the battlefield quickly.', 'QuestDescription': '', },{ 'Name': 'Energy Shield', 'Description': 'Summon energy around you creating shield that avoids @@@ instances of damage. Duration 5 secs.', 'QuestDescription': '', },{ 'Name': 'Regeneration', 'Description': 'Recovers a percentage of maximum health every few seconds (e.g., 5% of max health every 3 seconds) for a 5 ticks.', 'QuestDescription': '', },{ 'Name': 'Flesh Explosion', 'Description': 'Deals damage equal to 75% of current health to self and others.', 'QuestDescription': '', },{ 'Name': 'Backtrack', 'Description': 'Returns health, mana and stamina to 5 seconds ago.', 'QuestDescription': '', },{ 'Name': 'Teleportation Circle', 'Description': 'Creates magic circle at location. Upon second activation teleports player to that location.', 'QuestDescription': '', },{ 'Name': 'Mountain Splitter Strike'(Passive), 'Description': 'Every first attack is a critical hit, dealing @@@ of the attack's damage.', 'QuestDescription': 'Quest: practice this strike @@@@ times to unlock the next rank.', },{ 'Name': 'Rock Skin'(Passive), 'Description': 'Passively reduces incoming damage by @@@.', 'QuestDescription': 'Quest: every @@@@ taken damage increases absorbtion by @@@@@.', },{ 'Name': 'Vampiric Touch'(Passive), 'Description': 'Converts @@@ of any damage into health.', 'QuestDescription': 'Quest: every @@@@ regenerated health increases this effect by @@@@@.', },{ 'Name': 'Weak Spot'(Passive), 'Description': 'Increases melee critical strike damage by @@@.', 'QuestDescription': 'Quest: practice this strike @@@@ times to unlock the next rank.', },{ 'Name': 'Thorn Shell'(Passive), 'Description': 'Returns @@@ of incoming damage back to attacker.', 'QuestDescription': 'Quest: every @@@@ taken damage increases absorbtion by @@@@@.', },{ 'Name': 'Resilience Globules'(Passive), 'Description': 'Increases HP by @@@.', 'QuestDescription': 'Quest: every @@@@ healing spheres increases max HP by @@@@@.', },{ 'Name': 'ItemHealingPotion', 'Description': 'Heals @@@ HP over 5 seconds,', 'QuestDescription': '', },{ 'Name': 'Divine Shield', 'Description': 'For @@@ seconds player becomes invulnerable.', 'QuestDescription': '', },{ 'Name': 'Posion Nova', 'Description': 'Unleashes a wave of toxic energy, poisoning all enemies in its radius upon activation. The poison inflicts @@@ damage over time.', 'QuestDescription': '', }]\"; }",
          "content_tokens": 5185,
          "embedding": []
        }
      ],
      "length": 21943
    },
    {
      "filename": "AdminCommandsMenu",
      "content": "using System.Collections; using System.Collections.Generic; using System.Linq; using System.Text; using _ZombieRoyale.Scripts.Core; using DuloGames.UI; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using FishnetInvector; using Invector; using Invector.vItemManager; using UnityEngine; namespace InRoomSystems { public class AdminCommandsMenu : RoomManager { [SerializeField] private byte abilityIdToAdd = 3; [SerializeField] private ushort creatureIdToSpawn = 4; [SerializeField] private Vector2Int itemIdsToTest = new Vector2Int(35, 303); [Server] public void SpawnPortalsNearPlayers() { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { GameplayManager.SpawnEscapePortal(player.transform.position + Vector3.forward * 2); } } [Server] public void SpawnHealSpheresNearPlayers() { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { GameplayManager.SpawnHealSphere(player.transform.position + Vector3.forward * 2); } } [Server] public void SpawnBookExpNearPlayers() { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { //foreach (var item in FishnetInvectorItemManager.LocalPlayer.ItemManager.GetAllItems()) //{ // if (item.id == 753) // { // GameplayManager.LocalPlayer.LootDropSystem.DropLootItems(new List<ItemReference> { item.ToItemReference() }, player.transform.position + Vector3.forward * 2); // } //} GameplayManager.SpawnBookExp(player.transform.position + Vector3.forward * 2); } } [Server] public void KillAllPlayers() { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { UnitComponents unitComponents = GameplayManager.Instance.GetUnitComponents(player); vDamage damage = new vDamage((int)unitComponents.HealthController.MaxHealth); damage.Sender = player.transform; damage.senderNetworkObjectID = player.ObjectId; damage.receiver = player.transform; unitComponents.HealthController.TakeDamage(damage); } } [Server] public void KillEnemiesNearAllPlayers() { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { vDamage damage = new vDamage(1000); damage.Sender = player.transform; damage.senderNetworkObjectID = player.ObjectId; AOEDamageTargets(player.ObjectId, 10.0f, new vDamage(1000)); } } [Server] protected void AOEDamageTargets(int casterNetId, float radius, vDamage damage) { var playerComps = GameplayManager.GetUnitComponentsServerAndClient(casterNetId); var targets = TargetsInSphereSelection(playerComps.HealthController.transform, radius); for (int i = 0; i < targets.Count; i++) { damage.receiver = targets[i].transform; targets[i].TakeDamage(damage); } } [Server] public void AddShoulderArmorToAllPlayers() { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { var playerComps = GameplayManager.GetUnitComponentsServerAndClient(player.ObjectId); FishnetInvectorItemManager itemManager = playerComps.ItemManager; itemManager.ServerAddItemIds(new int[] { 60,61,72,73,92,93,275,276,263,264,295, 296,245,246,119,120, 28,29,30,31}); } } [Server] protected List<FishnetInvectorHealthController> TargetsInSphereSelection(Transform caster, float radius) { List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>(); //check targets foreach (var target in GameplayManager.UnitCharacters) { var targetNob = GameplayManager.GetUnitNob(target); if (IsNotValidTargetEnemy(targetNob, caster)) { continue; } if (CommonMath.Math.IsWithinRange(caster.position, targetNob.transform.position, radius)) { var unitComps = GameplayManager.GetUnitComponentsServerAndClient(target); targets.Add(unitComps.HealthController); } } return targets; } [Server] public void AddXpToAllPlayers(float amount) { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { var playerComps = GameplayManager.GetUnitComponentsServerAndClient(player.ObjectId); playerComps.XpController.AddXp(amount); } } [Server] public void SetAllUnitsHPToMax() { var units = GameplayManager.UnitCharacters; foreach (var unit in units) { var unitComps = GameplayManager.GetUnitComponentsServerAndClient(unit); var healData = new FishnetInvectorHealthController.HealData(); healData.amount = 10000f; unitComps.HealthController.SetHealth(FishnetInvectorHealthController.HealthType.Max, healData); unitComps.HealthController.SetHealth(FishnetInvectorHealthController.HealthType.Current, healData); } } [Server] public void AddTestAbilityToAllPlayers() { RewardAbilityManager.Instance.TestAddAbilitiesToAllPlayers(abilityIdToAdd); } [Server] public void SpawnUnitNearAllPlayer() { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { var playerPos = player.transform.position + Vector3.forward * 2; GameplayManager.CreaturesFactory.AllocateCreature(creatureIdToSpawn, playerPos, GameplayManager.Instance); } } [Server] public IEnumerator RunItemTest() { #if UNITY_EDITOR FishnetInvectorItemManager itemManager = FindObjectOfType<FishnetInvectorItemManager>(); RpgUIInventory rpgInventory = FindObjectOfType<RpgUIInventory>(); int start = itemIdsToTest.x; int end = itemIdsToTest.y; int length = end - start; Debug.Log($\"{ClassAndRoomName} RunItemTest: Starting test with {length} items. {start}->{end}\"); for (int i = 0; i < length; i++) { int itemId = start + i; if (SingletonsExtension.MasterManager.GetVItem(itemId).equipArea == vItem.EquipAreaNames.cape) continue; Debug.Log($\"{ClassAndRoomName} RunItemTest add item #{itemId}: \"); itemManager.ServerAddItemIds(new int[] { itemId }); yield return new WaitForSeconds(1f); vItem item = FNvItemManager.LocalPlayer.items.FirstOrDefault(item => item.id == itemId); if (item == null) { Debug.LogError($\"{ClassAndRoomName} RunItemTest: ItemId #{itemId} not found. Skipping...\"); continue; } if (!item.isArmorItem) { Debug.Log($\"{ClassAndRoomName} RunItemTest ItemId #{itemId} is not armor item\"); } itemManager.ArmorSlotsController.CmdEquipArmor(item.id); Debug.Log($\"{ClassAndRoomName} RunItemTest CmdEquipArmor\"); yield return new WaitForSeconds(1f); UIEquipmentType equipmentType = item.GetEquipmentType(); itemManager.ArmorSlotsController.CmdUnequipArmor((ushort)equipmentType); Debug.Log($\"{ClassAndRoomName} RunItemTest Unequipped\"); yield return new WaitForSeconds(1f); item = FNvItemManager.LocalPlayer.items.FirstOrDefault(item => item.id == itemId); rpgInventory.DestroyItemInInventory(item, item.amount); itemManager.ServerRemoveItem(itemId, item.amount); FNvItemManager.LocalPlayer.inventory.UpdateInventory(); Debug.Log($\"{ClassAndRoomName} RunItemTest Destroyed\"); } #endif yield return null; } protected bool IsNotValidTargetEnemy(NetworkObject target, Transform caster) { Transform targetTransform = target.transform; if (targetTransform == caster) { return true; } if (target.CompareTag(GameplayManager.TAG_PLAYER)) { return false; } if (target.CompareTag(\"Enemy\")) { return false; } return false; } public void AddTestItem() { FishnetInvectorItemManager itemManager = FindObjectOfType<FishnetInvectorItemManager>(); itemManager.ServerAddItemIds(new int[] { itemIdsToTest.x }); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AdminCommandsMenu",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "AdminCommandsMenu",
          "content": "using System.Collections; using System.Collections.Generic; using System.Linq; using System.Text; using _ZombieRoyale.Scripts.Core; using DuloGames.UI; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using FishnetInvector; using Invector; using Invector.vItemManager; using UnityEngine; namespace InRoomSystems { public class AdminCommandsMenu : RoomManager { [SerializeField] private byte abilityIdToAdd = 3; [SerializeField] private ushort creatureIdToSpawn = 4; [SerializeField] private Vector2Int itemIdsToTest = new Vector2Int(35, 303); [Server] public void SpawnPortalsNearPlayers() { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { GameplayManager.SpawnEscapePortal(player.transform.position + Vector3.forward * 2); } } [Server] public void SpawnHealSpheresNearPlayers() { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { GameplayManager.SpawnHealSphere(player.transform.position + Vector3.forward * 2); } } [Server] public void SpawnBookExpNearPlayers() { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { //foreach (var item in FishnetInvectorItemManager.LocalPlayer.ItemManager.GetAllItems()) //{ // if (item.id == 753) // { // GameplayManager.LocalPlayer.LootDropSystem.DropLootItems(new List<ItemReference> { item.ToItemReference() }, player.transform.position + Vector3.forward * 2); // } //} GameplayManager.SpawnBookExp(player.transform.position + Vector3.forward * 2); } } [Server] public void KillAllPlayers() { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { UnitComponents unitComponents = GameplayManager.Instance.GetUnitComponents(player); vDamage damage = new vDamage((int)unitComponents.HealthController.MaxHealth); damage.Sender = player.transform; damage.senderNetworkObjectID = player.ObjectId; damage.receiver = player.transform; unitComponents.HealthController.TakeDamage(damage); } } [Server] public void KillEnemiesNearAllPlayers() { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { vDamage damage = new vDamage(1000); damage.Sender = player.transform; damage.senderNetworkObjectID = player.ObjectId; AOEDamageTargets(player.ObjectId, 10.0f, new vDamage(1000)); } } [Server] protected void AOEDamageTargets(int casterNetId, float radius, vDamage damage) { var playerComps = GameplayManager.GetUnitComponentsServerAndClient(casterNetId); var targets = TargetsInSphereSelection(playerComps.HealthController.transform, radius); for (int i = 0; i < targets.Count; i++) { damage.receiver = targets[i].transform; targets[i].TakeDamage(damage); } } [Server] public void AddShoulderArmorToAllPlayers() { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { var playerComps = GameplayManager.GetUnitComponentsServerAndClient(player.ObjectId); FishnetInvectorItemManager itemManager = playerComps.ItemManager; itemManager.ServerAddItemIds(new int[] { 60,61,72,73,92,93,275,276,263,264,295, 296,245,246,119,120, 28,29,30,31}); } } [Server] protected List<FishnetInvectorHealthController> TargetsInSphereSelection(Transform caster, float radius) { List<FishnetInvectorHealthController> targets = new List<FishnetInvectorHealthController>(); //check targets foreach (var target in GameplayManager.UnitCharacters) { var targetNob = GameplayManager.GetUnitNob(target); if (IsNotValidTargetEnemy(targetNob, caster)) { continue;  ",
          "content_tokens": 969,
          "embedding": []
        },
        {
          "cs_scriptfile": "AdminCommandsMenu",
          "content": "if (CommonMath.Math.IsWithinRange(caster.position, targetNob.transform.position, radius)) { var unitComps = GameplayManager.GetUnitComponentsServerAndClient(target); targets.Add(unitComps.HealthController); } } return targets; } [Server] public void AddXpToAllPlayers(float amount) { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { var playerComps = GameplayManager.GetUnitComponentsServerAndClient(player.ObjectId); playerComps.XpController.AddXp(amount); } } [Server] public void SetAllUnitsHPToMax() { var units = GameplayManager.UnitCharacters; foreach (var unit in units) { var unitComps = GameplayManager.GetUnitComponentsServerAndClient(unit); var healData = new FishnetInvectorHealthController.HealData(); healData.amount = 10000f; unitComps.HealthController.SetHealth(FishnetInvectorHealthController.HealthType.Max, healData); unitComps.HealthController.SetHealth(FishnetInvectorHealthController.HealthType.Current, healData); } } [Server] public void AddTestAbilityToAllPlayers() { RewardAbilityManager.Instance.TestAddAbilitiesToAllPlayers(abilityIdToAdd); } [Server] public void SpawnUnitNearAllPlayer() { var players = GameplayManager.GetAllPlayersHeroes(); foreach (var player in players) { var playerPos = player.transform.position + Vector3.forward * 2; GameplayManager.CreaturesFactory.AllocateCreature(creatureIdToSpawn, playerPos, GameplayManager.Instance); } } [Server] public IEnumerator RunItemTest() { #if UNITY_EDITOR FishnetInvectorItemManager itemManager = FindObjectOfType<FishnetInvectorItemManager>(); RpgUIInventory rpgInventory = FindObjectOfType<RpgUIInventory>(); int start = itemIdsToTest.x; int end = itemIdsToTest.y; int length = end - start; Debug.Log($\"{ClassAndRoomName} RunItemTest: Starting test with {length} items. {start}->{end}\"); for (int i = 0; i < length; i++) { int itemId = start + i; if (SingletonsExtension.MasterManager.GetVItem(itemId).equipArea == vItem.EquipAreaNames.cape) continue; Debug.Log($\"{ClassAndRoomName} RunItemTest add item #{itemId}: \"); itemManager.ServerAddItemIds(new int[] { itemId }); yield return new WaitForSeconds(1f); vItem item = FNvItemManager.LocalPlayer.items.FirstOrDefault(item => item.id == itemId); if (item == null) { Debug.LogError($\"{ClassAndRoomName} RunItemTest: ItemId #{itemId} not found. Skipping...\"); continue;  ",
          "content_tokens": 677,
          "embedding": []
        },
        {
          "cs_scriptfile": "AdminCommandsMenu",
          "content": "if (!item.isArmorItem) { Debug.Log($\"{ClassAndRoomName} RunItemTest ItemId #{itemId} is not armor item\"); } itemManager.ArmorSlotsController.CmdEquipArmor(item.id); Debug.Log($\"{ClassAndRoomName} RunItemTest CmdEquipArmor\"); yield return new WaitForSeconds(1f); UIEquipmentType equipmentType = item.GetEquipmentType(); itemManager.ArmorSlotsController.CmdUnequipArmor((ushort)equipmentType); Debug.Log($\"{ClassAndRoomName} RunItemTest Unequipped\"); yield return new WaitForSeconds(1f); item = FNvItemManager.LocalPlayer.items.FirstOrDefault(item => item.id == itemId); rpgInventory.DestroyItemInInventory(item, item.amount); itemManager.ServerRemoveItem(itemId, item.amount); FNvItemManager.LocalPlayer.inventory.UpdateInventory(); Debug.Log($\"{ClassAndRoomName} RunItemTest Destroyed\"); } #endif yield return null;  ",
          "content_tokens": 247,
          "embedding": []
        },
        {
          "cs_scriptfile": "AdminCommandsMenu",
          "content": "protected bool IsNotValidTargetEnemy(NetworkObject target, Transform caster) { Transform targetTransform = target.transform; if (targetTransform == caster) { return true;  if (target.CompareTag(GameplayManager.TAG_PLAYER)) { return false;  if (target.CompareTag(\"Enemy\")) { return false; } return false;  public void AddTestItem() { FishnetInvectorItemManager itemManager = FindObjectOfType<FishnetInvectorItemManager>(); itemManager.ServerAddItemIds(new int[] { itemIdsToTest.x }); } } }",
          "content_tokens": 129,
          "embedding": []
        }
      ],
      "length": 7156
    },
    {
      "filename": "ClientSceneHandler",
      "content": "using System; using System.Collections; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using UnityEngine; using UnityEngine.SceneManagement; using DDCore; using FishnetInvector; using UnitySceneManager = UnityEngine.SceneManagement.SceneManager; public class ClientSceneHandler : NetworkBehaviour { public static readonly string ROOM_SCENE_NAME = \"Room\"; public static ClientSceneHandler Instance { get; private set; } public override void OnStartClient() { base.OnStartClient(); if (base.IsOwner) { if (Instance == null) { Instance = this; } else { Destroy(this); } FishnetInvectorManager.OnOwnerInitialized += OnPlayerHeroSpawned; } } public void OrderToLoadGameScene() { Debug.Log($\"[ClientSceneHandler] sending order to {gameObject.name} to load scene {ROOM_SCENE_NAME}.\"); RpcClientLoadRoomScene(NetworkObject.Owner); } [TargetRpc] public void RpcClientLoadRoomScene(NetworkConnection conn) { Debug.Log($\"[ClientSceneHandler] Issued order from server to load scene {ROOM_SCENE_NAME}.\"); Action onSceneLoaded = () => { Debug.Log($\"[ClientSceneHandler] Scene {ROOM_SCENE_NAME} was loaded 90%.\"); }; CustomSceneManager.LoadSceneAsync(ROOM_SCENE_NAME, LoadSceneMode.Additive, onSceneLoaded); } private void OnPlayerHeroSpawned() { RegistrationController.Instance.SwitchMainMenuElements(false); Debug.Log($\"[FishnetGameplayManager] Making room scene as main.\"); } [TargetRpc] public void RpcClientUnloadScene(NetworkConnection conn) { //ShowMainMenuUI(); UnloadRoomScene(); } public static void UnloadRoomScene() { Debug.Log($\"[ClientSceneHandler] Unloading scene {ROOM_SCENE_NAME}.\"); CustomSceneManager.OnSceneLoaded += OnSceneUnloaded; CustomSceneManager.UnloadSceneAsync(ROOM_SCENE_NAME); } public void DelayedUnloadRoomScene() { StartCoroutine(DelayedUnloadRoomSceneCoroutine()); } IEnumerator DelayedUnloadRoomSceneCoroutine() { yield return new WaitForSeconds(1f); Debug.Log($\"[ClientSceneHandler] Unloading scene {ROOM_SCENE_NAME}.\"); CustomSceneManager.OnSceneLoaded += OnSceneUnloaded; CustomSceneManager.UnloadSceneAsync(ROOM_SCENE_NAME); } private static void OnSceneUnloaded(string arg0) { Debug.Log($\"[ClientSceneHandler.OnSceneUnloaded] {ROOM_SCENE_NAME} was successfully unloaded!\"); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ClientSceneHandler",
          "content": "using System; using System.Collections; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using UnityEngine; using UnityEngine.SceneManagement; using DDCore; using FishnetInvector; using UnitySceneManager = UnityEngine.SceneManagement.SceneManager; public class ClientSceneHandler : NetworkBehaviour { public static readonly string ROOM_SCENE_NAME = \"Room\"; public static ClientSceneHandler Instance { get; private set; } public override void OnStartClient() { base.OnStartClient(); if (base.IsOwner) { if (Instance == null) { Instance = this; } else { Destroy(this); } FishnetInvectorManager.OnOwnerInitialized += OnPlayerHeroSpawned; }  ",
          "content_tokens": 176,
          "embedding": []
        },
        {
          "cs_scriptfile": "ClientSceneHandler",
          "content": "public void OrderToLoadGameScene() { Debug.Log($\"[ClientSceneHandler] sending order to {gameObject.name} to load scene {ROOM_SCENE_NAME}.\"); RpcClientLoadRoomScene(NetworkObject.Owner); } [TargetRpc] public void RpcClientLoadRoomScene(NetworkConnection conn) { Debug.Log($\"[ClientSceneHandler] Issued order from server to load scene {ROOM_SCENE_NAME}.\"); Action onSceneLoaded = () => { Debug.Log($\"[ClientSceneHandler] Scene {ROOM_SCENE_NAME} was loaded 90%.\"); }; CustomSceneManager.LoadSceneAsync(ROOM_SCENE_NAME, LoadSceneMode.Additive, onSceneLoaded);  ",
          "content_tokens": 166,
          "embedding": []
        },
        {
          "cs_scriptfile": "ClientSceneHandler",
          "content": "private void OnPlayerHeroSpawned() { RegistrationController.Instance.SwitchMainMenuElements(false); Debug.Log($\"[FishnetGameplayManager] Making room scene as main.\"); } [TargetRpc] public void RpcClientUnloadScene(NetworkConnection conn) { //ShowMainMenuUI(); UnloadRoomScene(); } public static void UnloadRoomScene() { Debug.Log($\"[ClientSceneHandler] Unloading scene {ROOM_SCENE_NAME}.\"); CustomSceneManager.OnSceneLoaded += OnSceneUnloaded; CustomSceneManager.UnloadSceneAsync(ROOM_SCENE_NAME);  ",
          "content_tokens": 136,
          "embedding": []
        },
        {
          "cs_scriptfile": "ClientSceneHandler",
          "content": "public void DelayedUnloadRoomScene() { StartCoroutine(DelayedUnloadRoomSceneCoroutine()); } IEnumerator DelayedUnloadRoomSceneCoroutine() { yield return new WaitForSeconds(1f); Debug.Log($\"[ClientSceneHandler] Unloading scene {ROOM_SCENE_NAME}.\"); CustomSceneManager.OnSceneLoaded += OnSceneUnloaded; CustomSceneManager.UnloadSceneAsync(ROOM_SCENE_NAME); } private static void OnSceneUnloaded(string arg0) { Debug.Log($\"[ClientSceneHandler.OnSceneUnloaded] {ROOM_SCENE_NAME} was successfully unloaded!\"); } }",
          "content_tokens": 147,
          "embedding": []
        }
      ],
      "length": 2260
    },
    {
      "filename": "CustomSceneManager",
      "content": "using System; using System.Collections.Generic; using System.Diagnostics; using System.Text.RegularExpressions; using System.Timers; using UnityEngine; using UnityEngine.Events; using UnityEngine.SceneManagement; using Debug = UnityEngine.Debug; namespace DDCore { public static class CustomSceneManager { private static List<string> _openedScenesList = new List<string>(); public static List<string> OpenedScenes => _openedScenesList; private static List<string> _shownScenesList = new List<string>(); public static List<string> ShownScenes => _shownScenesList; public delegate void TerrainsCollectionChanged(); public static event TerrainsCollectionChanged OnTerrainsCollectionChanged; public static UnityAction<string> OnSceneLoaded; public static UnityAction<string> OnSceneUnloaded; public static AsyncOperation LoadSceneAsync(string scenePath, LoadSceneMode mode, Action callback, bool isLoadDuplicate = false, int[] args = null) { string sceneName = ScenePathToSceneName(scenePath); if (!isLoadDuplicate) { if (_openedScenesList.Contains(sceneName)) { SceneManager.UnloadSceneAsync(sceneName); } } var operation = SceneManager.LoadSceneAsync(scenePath, mode); PerformSceneLoadingAsync(operation,sceneName,callback); return operation; } private static async void PerformSceneLoadingAsync(AsyncOperation operation, string sceneName, Action callback) { Stopwatch watch = new Stopwatch(); watch.Start(); operation.allowSceneActivation = false; while (true) { if (operation.progress>=0.9f) break; } operation.allowSceneActivation = true; watch.Stop(); var elapsedTime = watch.ElapsedMilliseconds; Debug.Log($\"Loading scene {sceneName} took: {elapsedTime} ms\"); callback?.Invoke(); OnSceneLoaded?.Invoke(sceneName); AddSceneToCollection(sceneName); } private static async void PerformSceneUnloadingAsync(AsyncOperation operation, string sceneName) { Stopwatch watch = new Stopwatch(); watch.Start(); operation.allowSceneActivation = false; while (true) { if (operation.progress>=0.9f) break; } RemoveSceneFromCollection(sceneName); operation.allowSceneActivation = true; watch.Stop(); var elapsedTime = watch.ElapsedMilliseconds; Debug.Log($\"[CustomSceneManager] Unloading scene {sceneName} took: {elapsedTime} ms\"); OnSceneUnloaded?.Invoke(sceneName); } public static void HideScene(string sceneName) { _shownScenesList.Remove(sceneName); } public static void ShowScene(string sceneName) { _shownScenesList.Add(sceneName); } private static void AddSceneToCollection(string sceneName) { _openedScenesList.Add(sceneName); _shownScenesList.Add(sceneName); Debug.Log($\"[CustomSceneManager] Scene {sceneName} was added to openedScenes collection.\"); if (OnTerrainsCollectionChanged != null) { OnTerrainsCollectionChanged(); Debug.Log(\"OnTerrainsCollectionChanged Raised!\"); } } private static void RemoveSceneFromCollection(string sceneName) { _openedScenesList.Remove(sceneName); _shownScenesList.Remove(sceneName); } public static string ScenePathToSceneName(string scenePath) { string[] tempParse = scenePath.Split('/'); string sceneName = tempParse[tempParse.Length - 1]; return Regex.Replace(sceneName, @\"\\.unity\", \"\"); } public static void UnloadSceneAsync(string sceneName) { var operation = SceneManager.UnloadSceneAsync(sceneName); PerformSceneUnloadingAsync(operation, sceneName); RemoveSceneFromCollection(sceneName); } public static void SetSceneAsMain(string sceneName) { SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneName)); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CustomSceneManager",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomSceneManager",
          "content": "using System; using System.Collections.Generic; using System.Diagnostics; using System.Text.RegularExpressions; using System.Timers; using UnityEngine; using UnityEngine.Events; using UnityEngine.SceneManagement; using Debug = UnityEngine.Debug; namespace DDCore { public static class CustomSceneManager { private static List<string> _openedScenesList = new List<string>(); public static List<string> OpenedScenes => _openedScenesList; private static List<string> _shownScenesList = new List<string>(); public static List<string> ShownScenes => _shownScenesList; public delegate void TerrainsCollectionChanged(); public static event TerrainsCollectionChanged OnTerrainsCollectionChanged; public static UnityAction<string> OnSceneLoaded; public static UnityAction<string> OnSceneUnloaded; public static AsyncOperation LoadSceneAsync(string scenePath, LoadSceneMode mode, Action callback, bool isLoadDuplicate = false, int[] args = null) { string sceneName = ScenePathToSceneName(scenePath); if (!isLoadDuplicate) { if (_openedScenesList.Contains(sceneName)) { SceneManager.UnloadSceneAsync(sceneName); } } var operation = SceneManager.LoadSceneAsync(scenePath, mode); PerformSceneLoadingAsync(operation,sceneName,callback); return operation; } private static async void PerformSceneLoadingAsync(AsyncOperation operation, string sceneName, Action callback) { Stopwatch watch = new Stopwatch(); watch.Start(); operation.allowSceneActivation = false; while (true) { if (operation.progress>=0.9f) break; } operation.allowSceneActivation = true; watch.Stop(); var elapsedTime = watch.ElapsedMilliseconds; Debug.Log($\"Loading scene {sceneName} took: {elapsedTime} ms\"); callback?.Invoke(); OnSceneLoaded?.Invoke(sceneName); AddSceneToCollection(sceneName); } private static async void PerformSceneUnloadingAsync(AsyncOperation operation, string sceneName) { Stopwatch watch = new Stopwatch(); watch.Start(); operation.allowSceneActivation = false; while (true) { if (operation.progress>=0.9f) break;  ",
          "content_tokens": 498,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomSceneManager",
          "content": "RemoveSceneFromCollection(sceneName); operation.allowSceneActivation = true; watch.Stop(); var elapsedTime = watch.ElapsedMilliseconds; Debug.Log($\"[CustomSceneManager] Unloading scene {sceneName} took: {elapsedTime} ms\"); OnSceneUnloaded?.Invoke(sceneName); } public static void HideScene(string sceneName) { _shownScenesList.Remove(sceneName); } public static void ShowScene(string sceneName) { _shownScenesList.Add(sceneName); } private static void AddSceneToCollection(string sceneName) { _openedScenesList.Add(sceneName); _shownScenesList.Add(sceneName); Debug.Log($\"[CustomSceneManager] Scene {sceneName} was added to openedScenes collection.\"); if (OnTerrainsCollectionChanged != null) { OnTerrainsCollectionChanged(); Debug.Log(\"OnTerrainsCollectionChanged Raised!\"); } } private static void RemoveSceneFromCollection(string sceneName) { _openedScenesList.Remove(sceneName); _shownScenesList.Remove(sceneName); } public static string ScenePathToSceneName(string scenePath) { string[] tempParse = scenePath.Split('/'); string sceneName = tempParse[tempParse.Length - 1]; return Regex.Replace(sceneName, @\"\\.unity\", \"\"); } public static void UnloadSceneAsync(string sceneName) { var operation = SceneManager.UnloadSceneAsync(sceneName); PerformSceneUnloadingAsync(operation, sceneName); RemoveSceneFromCollection(sceneName); } public static void SetSceneAsMain(string sceneName) { SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneName)); } } }",
          "content_tokens": 388,
          "embedding": []
        }
      ],
      "length": 3456
    },
    {
      "filename": "AdminCommandsMenuEditor",
      "content": "using UnityEngine; using UnityEditor; using InRoomSystems; [CustomEditor(typeof(AdminCommandsMenu))] public class AdminCommandsMenuEditor : Editor { public override void OnInspectorGUI() { DrawDefaultInspector(); AdminCommandsMenu myScript = (AdminCommandsMenu)target; if (GUILayout.Button(\"Spawn Portals Near Players\")) { myScript.SpawnPortalsNearPlayers(); } if (GUILayout.Button(\"Spawn Heal Spheres Near Players\")) { myScript.SpawnHealSpheresNearPlayers(); } if (GUILayout.Button(\"Spawn Book Exp Near Players\")) { myScript.SpawnBookExpNearPlayers(); } if (GUILayout.Button(\"Kill All Players\")) { myScript.KillAllPlayers(); } if (GUILayout.Button(\"Kill Enemies Near All Players\")) { myScript.KillEnemiesNearAllPlayers(); } if (GUILayout.Button(\"Add shoulder armor to all players\")) { myScript.AddShoulderArmorToAllPlayers(); } if (GUILayout.Button(\"Add 1000 xp to all players\")) { myScript.AddXpToAllPlayers(1000); } if (GUILayout.Button(\"Add test abilities all players\")) { myScript.AddTestAbilityToAllPlayers(); } if (GUILayout.Button(\"Add test item\")) { myScript.AddTestItem(); } if (GUILayout.Button(\"Set all units HP = 10000\")) { myScript.SetAllUnitsHPToMax(); } if (GUILayout.Button(\"SpawnCreature\")) { myScript.SpawnUnitNearAllPlayer(); } if (GUILayout.Button(\"RunItemEquippingTest\")) { myScript.StartCoroutine(myScript.RunItemTest()); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AdminCommandsMenuEditor",
          "content": "using UnityEngine; using UnityEditor; using InRoomSystems; [CustomEditor(typeof(AdminCommandsMenu))] public class AdminCommandsMenuEditor : Editor { public override void OnInspectorGUI() { DrawDefaultInspector(); AdminCommandsMenu myScript = (AdminCommandsMenu)target; if (GUILayout.Button(\"Spawn Portals Near Players\")) { myScript.SpawnPortalsNearPlayers();  if (GUILayout.Button(\"Spawn Heal Spheres Near Players\")) { myScript.SpawnHealSpheresNearPlayers();  if (GUILayout.Button(\"Spawn Book Exp Near Players\")) { myScript.SpawnBookExpNearPlayers();  if (GUILayout.Button(\"Kill All Players\")) { myScript.KillAllPlayers();  if (GUILayout.Button(\"Kill Enemies Near All Players\")) { myScript.KillEnemiesNearAllPlayers();  ",
          "content_tokens": 199,
          "embedding": []
        },
        {
          "cs_scriptfile": "AdminCommandsMenuEditor",
          "content": "if (GUILayout.Button(\"Add shoulder armor to all players\")) { myScript.AddShoulderArmorToAllPlayers();  if (GUILayout.Button(\"Add 1000 xp to all players\")) { myScript.AddXpToAllPlayers(1000);  if (GUILayout.Button(\"Add test abilities all players\")) { myScript.AddTestAbilityToAllPlayers();  if (GUILayout.Button(\"Add test item\")) { myScript.AddTestItem();  if (GUILayout.Button(\"Set all units HP = 10000\")) { myScript.SetAllUnitsHPToMax();  if (GUILayout.Button(\"SpawnCreature\")) { myScript.SpawnUnitNearAllPlayer();  if (GUILayout.Button(\"RunItemEquippingTest\")) { myScript.StartCoroutine(myScript.RunItemTest()); } } }",
          "content_tokens": 194,
          "embedding": []
        }
      ],
      "length": 1350
    },
    {
      "filename": "TestBackendCallsEditor",
      "content": " using UnityEditor; using UnityEngine; namespace _ZombieRoyale.Scripts.GlobalSystems.Editor { [CustomEditor(typeof(TestBackendCalls))] public class TestBackendCallsEditor: UnityEditor.Editor { public override void OnInspectorGUI() { base.OnInspectorGUI(); TestBackendCalls testBackendCalls = (TestBackendCalls) target; if (GUILayout.Button(\"RegisterNewPlayer\")) { testBackendCalls.RegisterNewPlayer(); } if (GUILayout.Button(\"SetAbilityStacks\")) { testBackendCalls.TestSetAbilityStacks(); } if (GUILayout.Button(\"GetAbilityStacks\")) { testBackendCalls.TestGetAbilityStacks(); } if (GUILayout.Button(\"SaveItemsToCharacterData\")) { testBackendCalls.SaveItemsToCharacterData(); } if (GUILayout.Button(\"DeleteItemsFromCharacterData\")) { testBackendCalls.DeleteItemsFromCharacterData(); } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "TestBackendCallsEditor",
          "content": " using UnityEditor; using UnityEngine; namespace _ZombieRoyale.Scripts.GlobalSystems.Editor { [CustomEditor(typeof(TestBackendCalls))] public class TestBackendCallsEditor: UnityEditor.Editor { public override void OnInspectorGUI() { base.OnInspectorGUI(); TestBackendCalls testBackendCalls = (TestBackendCalls) target; if (GUILayout.Button(\"RegisterNewPlayer\")) { testBackendCalls.RegisterNewPlayer();  if (GUILayout.Button(\"SetAbilityStacks\")) { testBackendCalls.TestSetAbilityStacks();  if (GUILayout.Button(\"GetAbilityStacks\")) { testBackendCalls.TestGetAbilityStacks();  ",
          "content_tokens": 172,
          "embedding": []
        },
        {
          "cs_scriptfile": "TestBackendCallsEditor",
          "content": "if (GUILayout.Button(\"SaveItemsToCharacterData\")) { testBackendCalls.SaveItemsToCharacterData();  if (GUILayout.Button(\"DeleteItemsFromCharacterData\")) { testBackendCalls.DeleteItemsFromCharacterData(); } } } }",
          "content_tokens": 61,
          "embedding": []
        }
      ],
      "length": 789
    },
    {
      "filename": "FishnetCustomPlayerSpawner",
      "content": "using FishNet.Connection; using FishNet.Managing; using FishNet.Object; using System; using FishNet; using UnityEngine; using System.Collections; namespace FishnetCustomScripts { public class FishnetCustomPlayerSpawner : MonoBehaviour { /// <summary> /// Spawns a player object for clients when they connect. /// Must be placed on or beneath the NetworkManager object. /// </summary> #region Public. /// <summary> /// Called on the server when a player is spawned. /// </summary> public event Action<NetworkObject> OnSpawned; #endregion #region Serialized. /// <summary> /// Prefab to spawn for the player. /// </summary> [Tooltip(\"Prefab to spawn for the player.\")] [SerializeField] private NetworkObject _playerPrefab; [SerializeField] private Vector3[] _spawnPoints; //[SerializeField] private string _waitSceneNameToLoadBeforeSpawn; /// <summary> /// True to add player to the active scene when no global scenes are specified through the SceneManager. /// </summary> [Tooltip(\"True to add player to the active scene when no global scenes are specified through the SceneManager.\")] private bool _addToDefaultScene = true; /// <summary> /// Areas in which players may spawn. /// </summary> [Tooltip(\"Areas in which players may spawn.\")] //[FormerlySerializedAs(\"_spawns\")] public Transform[] Spawns = new Transform[0]; #endregion #region Private. /// <summary> /// NetworkManager on this object or within this objects parents. /// </summary> private NetworkManager _networkManager; /// <summary> /// Next spawns to use. /// </summary> private int _nextSpawn; #endregion private void Start() { InitializeOnce(); } private void OnDestroy() { if (_networkManager != null) _networkManager.SceneManager.OnClientLoadedStartScenes -= SceneManager_OnClientLoadedStartScenes; } /// <summary> /// Initializes this script for use. /// </summary> private void InitializeOnce() { _networkManager = InstanceFinder.NetworkManager; if (_networkManager == null) { Debug.LogWarning($\"PlayerSpawner on {gameObject.name} cannot work as NetworkManager wasn't found on this object or within parent objects.\"); return; } _networkManager.SceneManager.OnClientLoadedStartScenes += SceneManager_OnClientLoadedStartScenes; } IEnumerator DelayedSpawnPlayer(NetworkConnection conn) { float secondsDelay = .1f; yield return new WaitForSeconds(secondsDelay); Vector3 position; Quaternion rotation; SetSpawn(_playerPrefab.transform, out position, out rotation); NetworkObject nob = Instantiate(_playerPrefab, position, rotation, transform); _networkManager.ServerManager.Spawn(nob, conn); //If there are no global scenes if (_addToDefaultScene) _networkManager.SceneManager.AddOwnerToDefaultScene(nob); OnSpawned?.Invoke(nob); Debug.Log($\"[Server] {_playerPrefab.name} for Client #{conn.ClientId} was spawned.\"); } /// <summary> /// Called when a client loads initial scenes after connecting. /// </summary> private void SceneManager_OnClientLoadedStartScenes(NetworkConnection conn, bool asServer) { if (!asServer) return; if (_playerPrefab == null) { Debug.LogWarning($\"Player prefab is empty and cannot be spawned for connection {conn.ClientId}.\"); return; } Debug.Log($\"[Server] Spawn {_playerPrefab.name} for ClientId:{conn.ClientId} after 5 secs\"); StartCoroutine(DelayedSpawnPlayer(conn)); } /// <summary> /// Sets a spawn position and rotation. /// </summary> /// <param name=\"pos\"></param> /// <param name=\"rot\"></param> private void SetSpawn(Transform prefab, out Vector3 pos, out Quaternion rot) { //No spawns specified. if (_spawnPoints.Length == 0) { SetSpawnUsingPrefab(prefab, out pos, out rot); return; } Vector3 result = _spawnPoints[_nextSpawn]; if (result == null) { SetSpawnUsingPrefab(prefab, out pos, out rot); }else { pos = result; rot = Quaternion.identity; } //Increase next spawn and reset if needed. _nextSpawn++; if (_nextSpawn >= Spawns.Length) _nextSpawn = 0; } /// <summary> /// Sets spawn using values from prefab. /// </summary> /// <param name=\"prefab\"></param> /// <param name=\"pos\"></param> /// <param name=\"rot\"></param> private void SetSpawnUsingPrefab(Transform prefab, out Vector3 pos, out Quaternion rot) { pos = prefab.position; rot = prefab.rotation; } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "FishnetCustomPlayerSpawner",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "FishnetCustomPlayerSpawner",
          "content": "using FishNet.Connection; using FishNet.Managing; using FishNet.Object; using System; using FishNet; using UnityEngine; using System.Collections; namespace FishnetCustomScripts { public class FishnetCustomPlayerSpawner : MonoBehaviour { /// <summary> /// Spawns a player object for clients when they connect. /// Must be placed on or beneath the NetworkManager object. /// </summary> #region Public. /// <summary> /// Called on the server when a player is spawned. /// </summary> public event Action<NetworkObject> OnSpawned; #endregion #region Serialized. /// <summary> /// Prefab to spawn for the player. /// </summary> [Tooltip(\"Prefab to spawn for the player.\")] [SerializeField] private NetworkObject _playerPrefab; [SerializeField] private Vector3[] _spawnPoints; //[SerializeField] private string _waitSceneNameToLoadBeforeSpawn; /// <summary> /// True to add player to the active scene when no global scenes are specified through the SceneManager. /// </summary> [Tooltip(\"True to add player to the active scene when no global scenes are specified through the SceneManager.\")] private bool _addToDefaultScene = true; /// <summary> /// Areas in which players may spawn. /// </summary> [Tooltip(\"Areas in which players may spawn.\")] //[FormerlySerializedAs(\"_spawns\")] public Transform[] Spawns = new Transform[0]; #endregion #region Private. /// <summary> /// NetworkManager on this object or within this objects parents. /// </summary> private NetworkManager _networkManager; /// <summary> /// Next spawns to use. /// </summary> private int _nextSpawn; #endregion private void Start() { InitializeOnce();  ",
          "content_tokens": 384,
          "embedding": []
        },
        {
          "cs_scriptfile": "FishnetCustomPlayerSpawner",
          "content": "private void OnDestroy() { if (_networkManager != null) _networkManager.SceneManager.OnClientLoadedStartScenes -= SceneManager_OnClientLoadedStartScenes; } /// <summary> /// Initializes this script for use. /// </summary> private void InitializeOnce() { _networkManager = InstanceFinder.NetworkManager; if (_networkManager == null) { Debug.LogWarning($\"PlayerSpawner on {gameObject.name} cannot work as NetworkManager wasn't found on this object or within parent objects.\"); return; } _networkManager.SceneManager.OnClientLoadedStartScenes += SceneManager_OnClientLoadedStartScenes; } IEnumerator DelayedSpawnPlayer(NetworkConnection conn) { float secondsDelay = .1f; yield return new WaitForSeconds(secondsDelay); Vector3 position; Quaternion rotation; SetSpawn(_playerPrefab.transform, out position, out rotation); NetworkObject nob = Instantiate(_playerPrefab, position, rotation, transform); _networkManager.ServerManager.Spawn(nob, conn); //If there are no global scenes if (_addToDefaultScene) _networkManager.SceneManager.AddOwnerToDefaultScene(nob); OnSpawned?.Invoke(nob); Debug.Log($\"[Server] {_playerPrefab.name} for Client #{conn.ClientId} was spawned.\"); } /// <summary> /// Called when a client loads initial scenes after connecting. /// </summary> private void SceneManager_OnClientLoadedStartScenes(NetworkConnection conn, bool asServer) { if (!asServer) return; if (_playerPrefab == null) { Debug.LogWarning($\"Player prefab is empty and cannot be spawned for connection {conn.ClientId}.\"); return; } Debug.Log($\"[Server] Spawn {_playerPrefab.name} for ClientId:{conn.ClientId} after 5 secs\"); StartCoroutine(DelayedSpawnPlayer(conn)); } /// <summary> /// Sets a spawn position and rotation. /// </summary> /// <param name=\"pos\"></param> /// <param name=\"rot\"></param> private void SetSpawn(Transform prefab, out Vector3 pos, out Quaternion rot) { //No spawns specified. if (_spawnPoints.Length == 0) { SetSpawnUsingPrefab(prefab, out pos, out rot); return; } Vector3 result = _spawnPoints[_nextSpawn]; if (result == null) { SetSpawnUsingPrefab(prefab, out pos, out rot); }else { pos = result; rot = Quaternion.identity; } //Increase next spawn and reset if needed. _nextSpawn++; if (_nextSpawn >= Spawns.Length) _nextSpawn = 0; } /// <summary> /// Sets spawn using values from prefab. /// </summary> /// <param name=\"prefab\"></param> /// <param name=\"pos\"></param> /// <param name=\"rot\"></param> private void SetSpawnUsingPrefab(Transform prefab, out Vector3 pos, out Quaternion rot) { pos = prefab.position; rot = prefab.rotation; } } }",
          "content_tokens": 685,
          "embedding": []
        }
      ],
      "length": 4170
    },
    {
      "filename": "FishnetCustomTugboat",
      "content": "using FishNet.Component.Utility; using FishNet.Managing; using FishNet.Managing.Timing; using FishNet.Transporting.Tugboat; using ScriptableObjectVariables; using UnityEngine; namespace FishnetCustomScripts { [RequireComponent(typeof(NetworkManager))] [RequireComponent(typeof(PingDisplay))] [RequireComponent(typeof(TimeManager))] public class FishnetCustomTugboat : Tugboat { [Header(\"IMPORTANT!!! Don't use client address!!! Use this instead:\")] [SerializeField] private VariableString _serverVariableAddress; private void Awake() { var ip = _serverVariableAddress.Value; if (ip == \"\") ip = \"localhost\"; Debug.Log($\"[Client] Setting connection address to: {ip}\"); SetClientAddress(ip); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "FishnetCustomTugboat",
          "content": "using FishNet.Component.Utility; using FishNet.Managing; using FishNet.Managing.Timing; using FishNet.Transporting.Tugboat; using ScriptableObjectVariables; using UnityEngine; namespace FishnetCustomScripts { [RequireComponent(typeof(NetworkManager))] [RequireComponent(typeof(PingDisplay))] [RequireComponent(typeof(TimeManager))] public class FishnetCustomTugboat : Tugboat { [Header(\"IMPORTANT!!! Don't use client address!!! Use this instead:\")] [SerializeField] private VariableString _serverVariableAddress; private void Awake() { var ip = _serverVariableAddress.Value; if (ip == \"\") ip = \"localhost\"; Debug.Log($\"[Client] Setting connection address to: {ip}\"); SetClientAddress(ip); } } }",
          "content_tokens": 188,
          "embedding": []
        }
      ],
      "length": 695
    },
    {
      "filename": "GameObjectDispatcher",
      "content": "using System; using UnityEngine; public class GameObjectDispatcher : MonoBehaviour { public static GameObjectDispatcher MainMenuInstance { get; private set; } public Action OnActivated; public Action OnDeactivated; private void Awake() { if (gameObject.name == \"bg\") { MainMenuInstance = this; } } public void Toggle() { gameObject.SetActive(!gameObject.activeSelf); } public void Activate() { if (gameObject.activeSelf) return; gameObject.SetActive(true); OnActivated?.Invoke(); Debug.Log($\"{gameObject} was activated\", gameObject); } public void Deactivate() { if (!gameObject.activeSelf) return; gameObject.SetActive(false); OnDeactivated?.Invoke(); Debug.Log($\"{gameObject} was deactivated\", gameObject); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "GameObjectDispatcher",
          "content": "using System; using UnityEngine; public class GameObjectDispatcher : MonoBehaviour { public static GameObjectDispatcher MainMenuInstance { get; private set; } public Action OnActivated; public Action OnDeactivated; private void Awake() { if (gameObject.name == \"bg\") { MainMenuInstance = this; } } public void Toggle() { gameObject.SetActive(!gameObject.activeSelf); } public void Activate() { if (gameObject.activeSelf) return; gameObject.SetActive(true); OnActivated?.Invoke(); Debug.Log($\"{gameObject} was activated\", gameObject); } public void Deactivate() { if (!gameObject.activeSelf) return; gameObject.SetActive(false); OnDeactivated?.Invoke(); Debug.Log($\"{gameObject} was deactivated\", gameObject); } }",
          "content_tokens": 189,
          "embedding": []
        }
      ],
      "length": 713
    },
    {
      "filename": "RoomSystemHandler",
      "content": "using System.Collections; using System.Text; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Lobbies; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using FishNet.Object; using UnityEngine; using UnityEngine.UI; using DDCore; public class RoomSystemHandler : MonoBehaviour { [Header(\"WillTurnOffWhenGameStarts\")] [SerializeField] private GameObjectDispatcher _mainMenuCanvas; [SerializeField] private GameObjectDispatcher _loadingScreen; [SerializeField] private Button[] _mainMenuButtons; public static RoomSystemHandler Instance { get; private set; } // [SerializeField] private Characterdata _characterdata; [SerializeField] private CurrentRoomMenu _currentRoomMenu; private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } } private void Start() { StartCoroutine(CatchReadyLobbyNetwork()); } private void OnDisable() { // ReadyLobbyNetwork.OnGameStarting -= DeactivateLobbyCamera; // ReadyLobbyNetwork.Instance.OnClientJoinedRoom -= LobbyNetwork_OnClientJoinedRoom; // ReadyLobbyNetwork.Instance.OnClientJoinedRoomFromSoloButton -= OnClientJoinedRoomFromSoloButton; // ReadyLobbyNetwork.OnLocalPlayerLeftRoom -= NetworkHudCanvases_OnDisconnectedFromServer; } private void OnClientJoinedRoomFromSoloButton(RoomDetails arg1) { CurrentRoomMenu.OnStartResponceChanged += CurrentRoomMenu_OnStartResponceChanged; } private void CurrentRoomMenu_OnStartResponceChanged(bool isServerGaveGreenLightStatus) { if (isServerGaveGreenLightStatus) _currentRoomMenu.OnClick_StartGame(); } public void DeactivateLobbyCamera() { RegistrationController.Instance.SwitchMainMenuElements(false); } public void ActivateLobbyUI() { RegistrationController.Instance.SwitchMainMenuElements(true); RegistrationController.Instance.SwithButtons(_mainMenuButtons, true); ShowCursor(true); LockCursor(false); } public static void ShowCursor(bool value) { Debug.Log($\"[ShowCursor]({value})\"); Cursor.visible = value; } public static void LockCursor(bool isLock) { StringBuilder sb = new StringBuilder(); sb.Append($\"[LockCursor]({isLock}) \"); if (isLock) { Cursor.lockState = CursorLockMode.Locked; sb.Append($\"Cursor locked to the center of the Game view; \"); } else { Cursor.lockState = CursorLockMode.None; sb.Append($\"Cursor behavior is unmodified; \"); } sb.Append($\"after: {Cursor.lockState}\"); Debug.Log(sb.ToString()); } private IEnumerator CatchReadyLobbyNetwork() { yield return new WaitUntil(() => ReadyLobbyNetwork.Instance != null); ReadyLobbyNetwork.Instance.OnClientJoinedRoom += LobbyNetwork_OnClientJoinedRoom; ReadyLobbyNetwork.OnGameStarting += DeactivateLobbyCamera; ReadyLobbyNetwork.Instance.OnClientJoinedRoomFromSoloButton += OnClientJoinedRoomFromSoloButton; NetworkHudCanvases.OnDisconnectedFromServer += NetworkHudCanvases_OnDisconnectedFromServer; ReadyLobbyNetwork.OnLocalPlayerLeftRoom += NetworkHudCanvases_OnDisconnectedFromServer; Debug.Log($\"[RoomSystemHandler] Catched ReadyLobbyNetwork\"); } private void NetworkHudCanvases_OnDisconnectedFromServer() { ActivateLobbyUI(); } private void LobbyNetwork_OnClientJoinedRoom(RoomDetails arg1, NetworkObject arg2) { // if (arg1.Owner == _characterdata.Username && arg1.IsStartImmediately) { // _currentRoomMenu.OnClick_StartGame(); // } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RoomSystemHandler",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomSystemHandler",
          "content": "using System.Collections; using System.Text; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Lobbies; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using FishNet.Object; using UnityEngine; using UnityEngine.UI; using DDCore; public class RoomSystemHandler : MonoBehaviour { [Header(\"WillTurnOffWhenGameStarts\")] [SerializeField] private GameObjectDispatcher _mainMenuCanvas; [SerializeField] private GameObjectDispatcher _loadingScreen; [SerializeField] private Button[] _mainMenuButtons; public static RoomSystemHandler Instance { get; private set; } // [SerializeField] private Characterdata _characterdata; [SerializeField] private CurrentRoomMenu _currentRoomMenu; private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); }  ",
          "content_tokens": 214,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomSystemHandler",
          "content": "private void Start() { StartCoroutine(CatchReadyLobbyNetwork());  private void OnDisable() { // ReadyLobbyNetwork.OnGameStarting -= DeactivateLobbyCamera; // ReadyLobbyNetwork.Instance.OnClientJoinedRoom -= LobbyNetwork_OnClientJoinedRoom; // ReadyLobbyNetwork.Instance.OnClientJoinedRoomFromSoloButton -= OnClientJoinedRoomFromSoloButton; // ReadyLobbyNetwork.OnLocalPlayerLeftRoom -= NetworkHudCanvases_OnDisconnectedFromServer;  private void OnClientJoinedRoomFromSoloButton(RoomDetails arg1) { CurrentRoomMenu.OnStartResponceChanged += CurrentRoomMenu_OnStartResponceChanged;  private void CurrentRoomMenu_OnStartResponceChanged(bool isServerGaveGreenLightStatus) { if (isServerGaveGreenLightStatus) _currentRoomMenu.OnClick_StartGame();  ",
          "content_tokens": 195,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomSystemHandler",
          "content": "public void DeactivateLobbyCamera() { RegistrationController.Instance.SwitchMainMenuElements(false);  ",
          "content_tokens": 24,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomSystemHandler",
          "content": "public void ActivateLobbyUI() { RegistrationController.Instance.SwitchMainMenuElements(true); RegistrationController.Instance.SwithButtons(_mainMenuButtons, true); ShowCursor(true); LockCursor(false); } public static void ShowCursor(bool value) { Debug.Log($\"[ShowCursor]({value})\"); Cursor.visible = value; } public static void LockCursor(bool isLock) { StringBuilder sb = new StringBuilder(); sb.Append($\"[LockCursor]({isLock}) \"); if (isLock) { Cursor.lockState = CursorLockMode.Locked; sb.Append($\"Cursor locked to the center of the Game view; \"); } else { Cursor.lockState = CursorLockMode.None; sb.Append($\"Cursor behavior is unmodified; \"); } sb.Append($\"after: {Cursor.lockState}\"); Debug.Log(sb.ToString()); } private IEnumerator CatchReadyLobbyNetwork() { yield return new WaitUntil(() => ReadyLobbyNetwork.Instance != null); ReadyLobbyNetwork.Instance.OnClientJoinedRoom += LobbyNetwork_OnClientJoinedRoom; ReadyLobbyNetwork.OnGameStarting += DeactivateLobbyCamera; ReadyLobbyNetwork.Instance.OnClientJoinedRoomFromSoloButton += OnClientJoinedRoomFromSoloButton; NetworkHudCanvases.OnDisconnectedFromServer += NetworkHudCanvases_OnDisconnectedFromServer; ReadyLobbyNetwork.OnLocalPlayerLeftRoom += NetworkHudCanvases_OnDisconnectedFromServer; Debug.Log($\"[RoomSystemHandler] Catched ReadyLobbyNetwork\");  ",
          "content_tokens": 378,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomSystemHandler",
          "content": "private void NetworkHudCanvases_OnDisconnectedFromServer() { ActivateLobbyUI();  private void LobbyNetwork_OnClientJoinedRoom(RoomDetails arg1, NetworkObject arg2) { // if (arg1.Owner == _characterdata.Username && arg1.IsStartImmediately) { // _currentRoomMenu.OnClick_StartGame(); // } } }",
          "content_tokens": 83,
          "embedding": []
        }
      ],
      "length": 3262
    },
    {
      "filename": "SettingsWindow",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using DuloGames.UI.Tweens; using DuloGames.UI; using System; #if !(UNITY_SERVER || HEADLESS) using UnityEngine.Audio; using UnityEngine.SceneManagement; public class SettingsWindow : MonoBehaviour { [SerializeField] UISelectField Options; [SerializeField] UISelectField DisplayMode; [SerializeField] UISelectField Resolutions; [SerializeField] Toggle vsyncToggle; [SerializeField] Toggle soundToggle; [SerializeField] Slider masterVolSlider; [SerializeField] Slider musicVolSlider; [SerializeField] Slider ambietVolSlider; AudioMixer audioMixer; bool isFullscreen; void Start() { //Set Quality Level On Start int value = PlayerPrefs.GetInt(\"Quality\"); if(value !=0) { if (value == 1) { QualitySettings.SetQualityLevel(0, true); //FindObjectOfType<QualityManager>().SetQualityLevel(false); Options.SelectOption(\"Low\"); } if (value == 2) { QualitySettings.SetQualityLevel(1, true); //FindObjectOfType<QualityManager>().SetQualityLevel(false); Options.SelectOption(\"Medium\"); } if (value == 3) { QualitySettings.SetQualityLevel(2, true); //FindObjectOfType<QualityManager>().SetQualityLevel(false); Options.SelectOption(\"High\"); } } //Set Vsync Value on Start int toggleValue = PlayerPrefs.GetInt(\"Vsync\"); QualitySettings.vSyncCount = toggleValue; if(toggleValue ==0) vsyncToggle.isOn = false; else vsyncToggle.isOn = true; //Set DisplayMode on Start int displayModeValue = PlayerPrefs.GetInt(\"DisplayMode\"); if (displayModeValue == 1) { Screen.fullScreenMode = FullScreenMode.FullScreenWindow; DisplayMode.SelectOption(\"Fullscreen\"); } else if (displayModeValue == 2) { Screen.fullScreenMode = FullScreenMode.Windowed; DisplayMode.SelectOption(\"Windowed\"); } //Set Resolutions on Start Resolution[] resolutions = Screen.resolutions; for (int i = 0; i < resolutions.Length; i++) { if (resolutions[i].ToString().Contains(\"2560\") && resolutions[i].ToString().Contains(\"1440\")) { Resolutions.options.Add(resolutions[i].ToString()); } if (resolutions[i].ToString().Contains(\"1920\") && resolutions[i].ToString().Contains(\"1080\")) { Resolutions.options.Add(resolutions[i].ToString()); } if (resolutions[i].ToString().Contains(\"1768\") && resolutions[i].ToString().Contains(\"992\")) { Resolutions.options.Add(resolutions[i].ToString()); } if (resolutions[i].ToString().Contains(\"1664\") && resolutions[i].ToString().Contains(\"936\")) { Resolutions.options.Add(resolutions[i].ToString()); } if (resolutions[i].ToString().Contains(\"1600\") && resolutions[i].ToString().Contains(\"900\")) { Resolutions.options.Add(resolutions[i].ToString()); } if (resolutions[i].ToString().Contains(\"1408\") && resolutions[i].ToString().Contains(\"792\")) { Resolutions.options.Add(resolutions[i].ToString()); } if (resolutions[i].ToString().Contains(\"1280\") && resolutions[i].ToString().Contains(\"720\")) { Resolutions.options.Add(resolutions[i].ToString()); } } int width = PlayerPrefs.GetInt(\"Width\"); int height = PlayerPrefs.GetInt(\"Height\"); int fullscreen = PlayerPrefs.GetInt(\"iSFullscreen\"); int res = PlayerPrefs.GetInt(\"ResolutionIndex\"); string resolution = \"\"; if (res < Resolutions.options.Count) { resolution = Resolutions.options[res]; } if (fullscreen == 1) isFullscreen = true; else if(fullscreen == 2) isFullscreen = false; if(width != 0 && height !=0) { Screen.SetResolution(width, height, isFullscreen); Resolutions.SelectOption(resolution); } else { ChangeResolution(); } //Set Audio Mixer Settings audioMixer = Resources.Load(\"ZomfiAudioMixer\") as AudioMixer; //Master Volume float master = PlayerPrefs.GetFloat(\"masterVol\"); if(master != 0) { masterVolSlider.value = master; audioMixer.SetFloat(\"masterVol\", Mathf.Log10(master) * 20); } //Music Volume float music = PlayerPrefs.GetFloat(\"musicVol\"); if (music != 0) { musicVolSlider.value = music; audioMixer.SetFloat(\"musicVol\", Mathf.Log10(music) * 20); } //Ambiuent Volume float ambient = PlayerPrefs.GetFloat(\"ambientVol\"); if (ambient != 0) { ambietVolSlider.value = ambient; audioMixer.SetFloat(\"ambientVol\", Mathf.Log10(ambient) * 20); } //SoundToggle int sound = PlayerPrefs.GetInt(\"soundToggle\"); if (sound == 1) { audioMixer.SetFloat(\"masterVol\", -80f); soundToggle.isOn = false; } else if (sound == 2) { audioMixer.SetFloat(\"masterVol\", Mathf.Log10(masterVolSlider.value) * 20); soundToggle.isOn = true; } } public void ChangeQualitySettings() { if (Options.value == \"Low\") { QualitySettings.SetQualityLevel(0, true); PlayerPrefs.SetInt(\"Quality\", 1); //FindObjectOfType<QualityManager>().SetQualityLevel(true); } if (Options.value == \"Medium\") { QualitySettings.SetQualityLevel(1, true); PlayerPrefs.SetInt(\"Quality\", 2); //FindObjectOfType<QualityManager>().SetQualityLevel(true); } if (Options.value == \"High\") { QualitySettings.SetQualityLevel(2, true); PlayerPrefs.SetInt(\"Quality\", 3); //FindObjectOfType<QualityManager>().SetQualityLevel(true); } } public void VsyncToggle() { if(vsyncToggle.isOn) { QualitySettings.vSyncCount = 1; PlayerPrefs.SetInt(\"Vsync\", 1); } else { QualitySettings.vSyncCount = 0; PlayerPrefs.SetInt(\"Vsync\", 0); } } public void ChangeDisplayMode() { if (DisplayMode.value == \"Fullscreen\") { Screen.fullScreenMode = FullScreenMode.FullScreenWindow; isFullscreen = true; PlayerPrefs.SetInt(\"DisplayMode\", 1); PlayerPrefs.SetInt(\"isFullscreen\", 1); } if (DisplayMode.value == \"Windowed\") { Screen.fullScreenMode = FullScreenMode.Windowed; isFullscreen = false; PlayerPrefs.SetInt(\"DisplayMode\", 2); PlayerPrefs.SetInt(\"isFullscreen\", 2); } } public void ChangeResolution() { int index = Resolutions.options.IndexOf(Resolutions.value); string widthValue = Resolutions.value; string heightValue = Resolutions.value; int xIndex = widthValue.IndexOf(\"x\"); if (xIndex >= 0) widthValue = widthValue.Substring(0, xIndex - 1); int yIndex = heightValue.IndexOf(\"@\"); if (yIndex >= 0) heightValue = heightValue[(xIndex + 2)..yIndex]; int width = Convert.ToInt32(widthValue); int height = Convert.ToInt32(heightValue); Screen.SetResolution(width, height, isFullscreen); PlayerPrefs.SetInt(\"Width\", width); PlayerPrefs.SetInt(\"Height\", height); PlayerPrefs.SetInt(\"ResolutionIndex\", index); } public void SoundToggle() { if(soundToggle.isOn ==false) { audioMixer.SetFloat(\"masterVol\", -80f); PlayerPrefs.SetInt(\"soundToggle\", 1); } if(soundToggle.isOn ==true) { audioMixer.SetFloat(\"masterVol\", Mathf.Log10(masterVolSlider.value) * 20); PlayerPrefs.SetInt(\"soundToggle\", 2); } } public void SetMasterVolume() { audioMixer.SetFloat(\"masterVol\", Mathf.Log10(masterVolSlider.value) * 20); PlayerPrefs.SetFloat(\"masterVol\", masterVolSlider.value); } public void SetMusicVolume() { audioMixer.SetFloat(\"musicVol\", Mathf.Log10(musicVolSlider.value) * 20); PlayerPrefs.SetFloat(\"musicVol\", musicVolSlider.value); } public void SetAmbientVolume() { audioMixer.SetFloat(\"ambientVol\", Mathf.Log10(ambietVolSlider.value) * 20); PlayerPrefs.SetFloat(\"ambientVol\", ambietVolSlider.value); } public void QuitGame() { Application.Quit(); } public void LeaveGame() { SceneManager.LoadScene(\"LoginScene\"); //Test } } #endif",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SettingsWindow",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "SettingsWindow",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using DuloGames.UI.Tweens; using DuloGames.UI; using System; #if !(UNITY_SERVER || HEADLESS) using UnityEngine.Audio; using UnityEngine.SceneManagement; public class SettingsWindow : MonoBehaviour { [SerializeField] UISelectField Options; [SerializeField] UISelectField DisplayMode; [SerializeField] UISelectField Resolutions; [SerializeField] Toggle vsyncToggle; [SerializeField] Toggle soundToggle; [SerializeField] Slider masterVolSlider; [SerializeField] Slider musicVolSlider; [SerializeField] Slider ambietVolSlider; AudioMixer audioMixer; bool isFullscreen; void Start() { //Set Quality Level On Start int value = PlayerPrefs.GetInt(\"Quality\"); if(value !=0) { if (value == 1) { QualitySettings.SetQualityLevel(0, true); //FindObjectOfType<QualityManager>().SetQualityLevel(false); Options.SelectOption(\"Low\");  ",
          "content_tokens": 256,
          "embedding": []
        },
        {
          "cs_scriptfile": "SettingsWindow",
          "content": "if (value == 2) { QualitySettings.SetQualityLevel(1, true); //FindObjectOfType<QualityManager>().SetQualityLevel(false); Options.SelectOption(\"Medium\");  ",
          "content_tokens": 43,
          "embedding": []
        },
        {
          "cs_scriptfile": "SettingsWindow",
          "content": "if (value == 3) { QualitySettings.SetQualityLevel(2, true); //FindObjectOfType<QualityManager>().SetQualityLevel(false); Options.SelectOption(\"High\"); } } //Set Vsync Value on Start int toggleValue = PlayerPrefs.GetInt(\"Vsync\"); QualitySettings.vSyncCount = toggleValue; if(toggleValue ==0) vsyncToggle.isOn = false; else vsyncToggle.isOn = true; //Set DisplayMode on Start int displayModeValue = PlayerPrefs.GetInt(\"DisplayMode\"); if (displayModeValue == 1) { Screen.fullScreenMode = FullScreenMode.FullScreenWindow; DisplayMode.SelectOption(\"Fullscreen\"); } else if (displayModeValue == 2) { Screen.fullScreenMode = FullScreenMode.Windowed; DisplayMode.SelectOption(\"Windowed\"); } //Set Resolutions on Start Resolution[] resolutions = Screen.resolutions; for (int i = 0; i < resolutions.Length; i++) { if (resolutions[i].ToString().Contains(\"2560\") && resolutions[i].ToString().Contains(\"1440\")) { Resolutions.options.Add(resolutions[i].ToString());  ",
          "content_tokens": 268,
          "embedding": []
        },
        {
          "cs_scriptfile": "SettingsWindow",
          "content": "if (resolutions[i].ToString().Contains(\"1920\") && resolutions[i].ToString().Contains(\"1080\")) { Resolutions.options.Add(resolutions[i].ToString());  if (resolutions[i].ToString().Contains(\"1768\") && resolutions[i].ToString().Contains(\"992\")) { Resolutions.options.Add(resolutions[i].ToString());  if (resolutions[i].ToString().Contains(\"1664\") && resolutions[i].ToString().Contains(\"936\")) { Resolutions.options.Add(resolutions[i].ToString());  if (resolutions[i].ToString().Contains(\"1600\") && resolutions[i].ToString().Contains(\"900\")) { Resolutions.options.Add(resolutions[i].ToString());  ",
          "content_tokens": 184,
          "embedding": []
        },
        {
          "cs_scriptfile": "SettingsWindow",
          "content": "if (resolutions[i].ToString().Contains(\"1408\") && resolutions[i].ToString().Contains(\"792\")) { Resolutions.options.Add(resolutions[i].ToString());  if (resolutions[i].ToString().Contains(\"1280\") && resolutions[i].ToString().Contains(\"720\")) { Resolutions.options.Add(resolutions[i].ToString()); } } int width = PlayerPrefs.GetInt(\"Width\"); int height = PlayerPrefs.GetInt(\"Height\"); int fullscreen = PlayerPrefs.GetInt(\"iSFullscreen\"); int res = PlayerPrefs.GetInt(\"ResolutionIndex\"); string resolution = \"\"; if (res < Resolutions.options.Count) { resolution = Resolutions.options[res];  ",
          "content_tokens": 175,
          "embedding": []
        },
        {
          "cs_scriptfile": "SettingsWindow",
          "content": "if (fullscreen == 1) isFullscreen = true; else if(fullscreen == 2) isFullscreen = false; if(width != 0 && height !=0) { Screen.SetResolution(width, height, isFullscreen); Resolutions.SelectOption(resolution); } else { ChangeResolution(); } //Set Audio Mixer Settings audioMixer = Resources.Load(\"ZomfiAudioMixer\") as AudioMixer; //Master Volume float master = PlayerPrefs.GetFloat(\"masterVol\"); if(master != 0) { masterVolSlider.value = master; audioMixer.SetFloat(\"masterVol\", Mathf.Log10(master) * 20); } //Music Volume float music = PlayerPrefs.GetFloat(\"musicVol\"); if (music != 0) { musicVolSlider.value = music; audioMixer.SetFloat(\"musicVol\", Mathf.Log10(music) * 20); } //Ambiuent Volume float ambient = PlayerPrefs.GetFloat(\"ambientVol\"); if (ambient != 0) { ambietVolSlider.value = ambient; audioMixer.SetFloat(\"ambientVol\", Mathf.Log10(ambient) * 20); } //SoundToggle int sound = PlayerPrefs.GetInt(\"soundToggle\"); if (sound == 1) { audioMixer.SetFloat(\"masterVol\", -80f); soundToggle.isOn = false; } else if (sound == 2) { audioMixer.SetFloat(\"masterVol\", Mathf.Log10(masterVolSlider.value) * 20); soundToggle.isOn = true; }  ",
          "content_tokens": 358,
          "embedding": []
        },
        {
          "cs_scriptfile": "SettingsWindow",
          "content": "public void ChangeQualitySettings() { if (Options.value == \"Low\") { QualitySettings.SetQualityLevel(0, true); PlayerPrefs.SetInt(\"Quality\", 1); //FindObjectOfType<QualityManager>().SetQualityLevel(true);  if (Options.value == \"Medium\") { QualitySettings.SetQualityLevel(1, true); PlayerPrefs.SetInt(\"Quality\", 2); //FindObjectOfType<QualityManager>().SetQualityLevel(true);  if (Options.value == \"High\") { QualitySettings.SetQualityLevel(2, true); PlayerPrefs.SetInt(\"Quality\", 3); //FindObjectOfType<QualityManager>().SetQualityLevel(true); }  ",
          "content_tokens": 156,
          "embedding": []
        },
        {
          "cs_scriptfile": "SettingsWindow",
          "content": "public void VsyncToggle() { if(vsyncToggle.isOn) { QualitySettings.vSyncCount = 1; PlayerPrefs.SetInt(\"Vsync\", 1); } else { QualitySettings.vSyncCount = 0; PlayerPrefs.SetInt(\"Vsync\", 0); }  public void ChangeDisplayMode() { if (DisplayMode.value == \"Fullscreen\") { Screen.fullScreenMode = FullScreenMode.FullScreenWindow; isFullscreen = true; PlayerPrefs.SetInt(\"DisplayMode\", 1); PlayerPrefs.SetInt(\"isFullscreen\", 1);  if (DisplayMode.value == \"Windowed\") { Screen.fullScreenMode = FullScreenMode.Windowed; isFullscreen = false; PlayerPrefs.SetInt(\"DisplayMode\", 2); PlayerPrefs.SetInt(\"isFullscreen\", 2); }  ",
          "content_tokens": 190,
          "embedding": []
        },
        {
          "cs_scriptfile": "SettingsWindow",
          "content": "public void ChangeResolution() { int index = Resolutions.options.IndexOf(Resolutions.value); string widthValue = Resolutions.value; string heightValue = Resolutions.value; int xIndex = widthValue.IndexOf(\"x\"); if (xIndex >= 0) widthValue = widthValue.Substring(0, xIndex - 1); int yIndex = heightValue.IndexOf(\"@\"); if (yIndex >= 0) heightValue = heightValue[(xIndex + 2)..yIndex]; int width = Convert.ToInt32(widthValue); int height = Convert.ToInt32(heightValue); Screen.SetResolution(width, height, isFullscreen); PlayerPrefs.SetInt(\"Width\", width); PlayerPrefs.SetInt(\"Height\", height); PlayerPrefs.SetInt(\"ResolutionIndex\", index);  ",
          "content_tokens": 186,
          "embedding": []
        },
        {
          "cs_scriptfile": "SettingsWindow",
          "content": "public void SoundToggle() { if(soundToggle.isOn ==false) { audioMixer.SetFloat(\"masterVol\", -80f); PlayerPrefs.SetInt(\"soundToggle\", 1);  if(soundToggle.isOn ==true) { audioMixer.SetFloat(\"masterVol\", Mathf.Log10(masterVolSlider.value) * 20); PlayerPrefs.SetInt(\"soundToggle\", 2); }  public void SetMasterVolume() { audioMixer.SetFloat(\"masterVol\", Mathf.Log10(masterVolSlider.value) * 20); PlayerPrefs.SetFloat(\"masterVol\", masterVolSlider.value);  ",
          "content_tokens": 152,
          "embedding": []
        },
        {
          "cs_scriptfile": "SettingsWindow",
          "content": "public void SetMusicVolume() { audioMixer.SetFloat(\"musicVol\", Mathf.Log10(musicVolSlider.value) * 20); PlayerPrefs.SetFloat(\"musicVol\", musicVolSlider.value);  public void SetAmbientVolume() { audioMixer.SetFloat(\"ambientVol\", Mathf.Log10(ambietVolSlider.value) * 20); PlayerPrefs.SetFloat(\"ambientVol\", ambietVolSlider.value);  public void QuitGame() { Application.Quit();  public void LeaveGame() { SceneManager.LoadScene(\"LoginScene\"); //Test } } #endif}",
          "content_tokens": 141,
          "embedding": []
        }
      ],
      "length": 7071
    },
    {
      "filename": "TestBackendCalls",
      "content": " using System; using _ZombieRoyale.Scripts.Clients; using Newtonsoft.Json; using Proyecto26; using Sirenix.OdinInspector; using UnityEngine; namespace _ZombieRoyale.Scripts.GlobalSystems { public class TestBackendCalls: MonoBehaviour { [SerializeField] private string _username; [SerializeField] private string _password; [SerializeField] private string _email; public void RegisterNewPlayer() { BackendReadWrites.Player _player = new BackendReadWrites.Player(); _player.username = _username; _player.password = _password; _player.email = _email; Debug.Log($\"_username: {_username}; _password: {_password}; _email: {_email}\"); Action<RequestException, ResponseHelper, string> callback = (ex, rh, text) => { bool isSuccessful = true; if (ex != null) { Debug.Log(ex.Message); return; } if (isSuccessful) { BackendReadWrites.Token token = JsonConvert.DeserializeObject<BackendReadWrites.Token>(text); Debug.Log($\"token: {token}\"); } }; BackendReadWrites.RegisterUser(_player, callback); } public void TestSetAbilityStacks() { string token = PlayerData.Instance.Token; AbilityInfo[] abilityInfos = new AbilityInfo[3]; for (int i = 0; i < abilityInfos.Length; i++) { abilityInfos[i] = new AbilityInfo(); abilityInfos[i].Id = (byte)(i + 4); abilityInfos[i].Rank = 1; abilityInfos[i].Stacks = (uint)i + 2; } Action<int> callback = (result) => { }; BackendReadWrites.SetAbilityStacks(token, abilityInfos, callback); } public void TestGetAbilityStacks() { int characterId = CharacterDataController.Instance.CharacterData.id; BackendReadWrites.GetAbilityStacksForCharacter(characterId, 1, (result) => { string resultString = JsonConvert.SerializeObject(result); Debug.Log($\"resultString: {resultString}\"); }); } public void GetCharacterData() { PlayerData.PlayerRegisterData _playerRegisterData = new PlayerData.PlayerRegisterData(); _playerRegisterData.email = _email; _playerRegisterData.password = _password; Action<RequestException, ResponseHelper, string> callback = (ex, rh, text) => { bool isSuccessful = true; if (ex != null) { Debug.Log(ex.Message); return; } if (isSuccessful) { BackendReadWrites.Token token = JsonConvert.DeserializeObject<BackendReadWrites.Token>(text); Debug.Log($\"token: {token}\"); } }; BackendReadWrites.GetCharacterData(_playerRegisterData, callback); } public void SaveItemsToCharacterData() { PlayerData playerData = PlayerData.Instance; BackendReadWrites.CharacterDataDTO characterDataDto = new BackendReadWrites.CharacterDataDTO(); characterDataDto.id = 41; BackendReadWrites.SlotItem[] bank_items = new BackendReadWrites.SlotItem[3]; for (int i = 0; i < bank_items.Length; i++) { bank_items[i] = new BackendReadWrites.SlotItem(); bank_items[i].slotId = i; bank_items[i].itemId = 78; bank_items[i].amount = 79; } BackendReadWrites.SlotItem[] backpack_items = new BackendReadWrites.SlotItem[3]; for (int i = 0; i < backpack_items.Length; i++) { backpack_items[i] = new BackendReadWrites.SlotItem(); backpack_items[i].slotId = i; backpack_items[i].itemId = 80; backpack_items[i].amount = 81; } BackendReadWrites.SlotItem[] equipment_items = new BackendReadWrites.SlotItem[3]; for (int i = 0; i < equipment_items.Length; i++) { equipment_items[i] = new BackendReadWrites.SlotItem(); equipment_items[i].slotId = i; equipment_items[i].itemId = 82; equipment_items[i].amount = 83; } characterDataDto.bank_items = bank_items; characterDataDto.backpack_items = backpack_items; characterDataDto.equipment_items = equipment_items; BackendReadWrites.AddInventory(characterDataDto, (result) => { string resultString = JsonConvert.SerializeObject(result); Debug.Log($\"resultString: {resultString}\"); }); } public void DeleteItemsFromCharacterData() { BackendReadWrites.CharacterDataDTO characterDataDto = new BackendReadWrites.CharacterDataDTO(); characterDataDto.id = 41; BackendReadWrites.SlotItem[] bank_items = new BackendReadWrites.SlotItem[3]; for (int i = 0; i < bank_items.Length; i++) { bank_items[i] = new BackendReadWrites.SlotItem(); bank_items[i].slotId = i; bank_items[i].itemId = 78; } BackendReadWrites.SlotItem[] backpack_items = new BackendReadWrites.SlotItem[3]; for (int i = 0; i < backpack_items.Length; i++) { backpack_items[i] = new BackendReadWrites.SlotItem(); backpack_items[i].slotId = i; backpack_items[i].itemId = 80; } BackendReadWrites.SlotItem[] equipment_items = new BackendReadWrites.SlotItem[3]; for (int i = 0; i < equipment_items.Length; i++) { equipment_items[i] = new BackendReadWrites.SlotItem(); equipment_items[i].slotId = i; equipment_items[i].itemId = 82; } characterDataDto.bank_items = bank_items; characterDataDto.backpack_items = backpack_items; characterDataDto.equipment_items = equipment_items; BackendReadWrites.DeleteInventory(characterDataDto, (result) => { string resultString = JsonConvert.SerializeObject(result); Debug.Log($\"resultString: {resultString}\"); }); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "TestBackendCalls",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "TestBackendCalls",
          "content": " using System; using _ZombieRoyale.Scripts.Clients; using Newtonsoft.Json; using Proyecto26; using Sirenix.OdinInspector; using UnityEngine; namespace _ZombieRoyale.Scripts.GlobalSystems { public class TestBackendCalls: MonoBehaviour { [SerializeField] private string _username; [SerializeField] private string _password; [SerializeField] private string _email; public void RegisterNewPlayer() { BackendReadWrites.Player _player = new BackendReadWrites.Player(); _player.username = _username; _player.password = _password; _player.email = _email; Debug.Log($\"_username: {_username}; _password: {_password}; _email: {_email}\"); Action<RequestException, ResponseHelper, string> callback = (ex, rh, text) => { bool isSuccessful = true; if (ex != null) { Debug.Log(ex.Message); return;  ",
          "content_tokens": 224,
          "embedding": []
        },
        {
          "cs_scriptfile": "TestBackendCalls",
          "content": "if (isSuccessful) { BackendReadWrites.Token token = JsonConvert.DeserializeObject<BackendReadWrites.Token>(text); Debug.Log($\"token: {token}\"); } }; BackendReadWrites.RegisterUser(_player, callback);  public void TestSetAbilityStacks() { string token = PlayerData.Instance.Token; AbilityInfo[] abilityInfos = new AbilityInfo[3]; for (int i = 0; i < abilityInfos.Length; i++) { abilityInfos[i] = new AbilityInfo(); abilityInfos[i].Id = (byte)(i + 4); abilityInfos[i].Rank = 1; abilityInfos[i].Stacks = (uint)i + 2; } Action<int> callback = (result) => { }; BackendReadWrites.SetAbilityStacks(token, abilityInfos, callback);  ",
          "content_tokens": 199,
          "embedding": []
        },
        {
          "cs_scriptfile": "TestBackendCalls",
          "content": "public void TestGetAbilityStacks() { int characterId = CharacterDataController.Instance.CharacterData.id; BackendReadWrites.GetAbilityStacksForCharacter(characterId, 1, (result) => { string resultString = JsonConvert.SerializeObject(result); Debug.Log($\"resultString: {resultString}\"); });  public void GetCharacterData() { PlayerData.PlayerRegisterData _playerRegisterData = new PlayerData.PlayerRegisterData(); _playerRegisterData.email = _email; _playerRegisterData.password = _password; Action<RequestException, ResponseHelper, string> callback = (ex, rh, text) => { bool isSuccessful = true; if (ex != null) { Debug.Log(ex.Message); return;  ",
          "content_tokens": 170,
          "embedding": []
        },
        {
          "cs_scriptfile": "TestBackendCalls",
          "content": "if (isSuccessful) { BackendReadWrites.Token token = JsonConvert.DeserializeObject<BackendReadWrites.Token>(text); Debug.Log($\"token: {token}\"); } }; BackendReadWrites.GetCharacterData(_playerRegisterData, callback);  ",
          "content_tokens": 67,
          "embedding": []
        },
        {
          "cs_scriptfile": "TestBackendCalls",
          "content": "public void SaveItemsToCharacterData() { PlayerData playerData = PlayerData.Instance; BackendReadWrites.CharacterDataDTO characterDataDto = new BackendReadWrites.CharacterDataDTO(); characterDataDto.id = 41; BackendReadWrites.SlotItem[] bank_items = new BackendReadWrites.SlotItem[3]; for (int i = 0; i < bank_items.Length; i++) { bank_items[i] = new BackendReadWrites.SlotItem(); bank_items[i].slotId = i; bank_items[i].itemId = 78; bank_items[i].amount = 79; } BackendReadWrites.SlotItem[] backpack_items = new BackendReadWrites.SlotItem[3]; for (int i = 0; i < backpack_items.Length; i++) { backpack_items[i] = new BackendReadWrites.SlotItem(); backpack_items[i].slotId = i; backpack_items[i].itemId = 80; backpack_items[i].amount = 81; } BackendReadWrites.SlotItem[] equipment_items = new BackendReadWrites.SlotItem[3]; for (int i = 0; i < equipment_items.Length; i++) { equipment_items[i] = new BackendReadWrites.SlotItem(); equipment_items[i].slotId = i; equipment_items[i].itemId = 82; equipment_items[i].amount = 83; } characterDataDto.bank_items = bank_items; characterDataDto.backpack_items = backpack_items; characterDataDto.equipment_items = equipment_items; BackendReadWrites.AddInventory(characterDataDto, (result) => { string resultString = JsonConvert.SerializeObject(result); Debug.Log($\"resultString: {resultString}\"); });  ",
          "content_tokens": 426,
          "embedding": []
        },
        {
          "cs_scriptfile": "TestBackendCalls",
          "content": "public void DeleteItemsFromCharacterData() { BackendReadWrites.CharacterDataDTO characterDataDto = new BackendReadWrites.CharacterDataDTO(); characterDataDto.id = 41; BackendReadWrites.SlotItem[] bank_items = new BackendReadWrites.SlotItem[3]; for (int i = 0; i < bank_items.Length; i++) { bank_items[i] = new BackendReadWrites.SlotItem(); bank_items[i].slotId = i; bank_items[i].itemId = 78; } BackendReadWrites.SlotItem[] backpack_items = new BackendReadWrites.SlotItem[3]; for (int i = 0; i < backpack_items.Length; i++) { backpack_items[i] = new BackendReadWrites.SlotItem(); backpack_items[i].slotId = i; backpack_items[i].itemId = 80; } BackendReadWrites.SlotItem[] equipment_items = new BackendReadWrites.SlotItem[3]; for (int i = 0; i < equipment_items.Length; i++) { equipment_items[i] = new BackendReadWrites.SlotItem(); equipment_items[i].slotId = i; equipment_items[i].itemId = 82; } characterDataDto.bank_items = bank_items; characterDataDto.backpack_items = backpack_items; characterDataDto.equipment_items = equipment_items; BackendReadWrites.DeleteInventory(characterDataDto, (result) => { string resultString = JsonConvert.SerializeObject(result); Debug.Log($\"resultString: {resultString}\"); }); } } }",
          "content_tokens": 387,
          "embedding": []
        }
      ],
      "length": 4838
    },
    {
      "filename": "ActionTriggerEvents",
      "content": "using InRoomSystems; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.Events; public class ActionTriggerEvents : MonoBehaviour { private FNvTimedAction _timedActions; public void Start() { _timedActions = GetComponent<FNvTimedAction>(); _timedActions.OnPlayerEnter.AddListener(HoldBarToggle); _timedActions.OnPlayerExit.AddListener(HoldBarToggle); _timedActions.OnPressActionInput.AddListener(() => HoldBarToggle()); _timedActions.OnCancelActionInput.AddListener(() => HoldBarToggle()); } private void HoldBarToggle(GameObject go = null) { HoldBar.Instance.ToggleHoldBar(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ActionTriggerEvents",
          "content": "using InRoomSystems; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.Events; public class ActionTriggerEvents : MonoBehaviour { private FNvTimedAction _timedActions; public void Start() { _timedActions = GetComponent<FNvTimedAction>(); _timedActions.OnPlayerEnter.AddListener(HoldBarToggle); _timedActions.OnPlayerExit.AddListener(HoldBarToggle); _timedActions.OnPressActionInput.AddListener(() => HoldBarToggle()); _timedActions.OnCancelActionInput.AddListener(() => HoldBarToggle()); } private void HoldBarToggle(GameObject go = null) { HoldBar.Instance.ToggleHoldBar(); } }",
          "content_tokens": 179,
          "embedding": []
        }
      ],
      "length": 626
    },
    {
      "filename": "BossHealthDisplay",
      "content": " using UnityEngine; using UnityEngine.UI; namespace InRoomSystems { [RequireComponent(typeof(UICanvasGroupDecorator))] public class BossHealthDisplay: MonoBehaviour { private UICanvasGroupDecorator _canvasGroupDecorator; private Slider _healthSlider; private void Awake() { _canvasGroupDecorator = GetComponent<UICanvasGroupDecorator>(); _healthSlider = GetComponentInChildren<Slider>(); } private void Start() { BossRoomHealthDisplayController.Instance.OnBossHealthShow += BossRoomHealthDisplay_OnBossHealthShow; BossRoomHealthDisplayController.Instance.OnBossHealthHide += BossRoomHealthDisplay_OnBossHealthHide; BossRoomHealthDisplayController.Instance.OnBossHealthUpdate += BossRoomHealthDisplay_OnBossHealthUpdate; } private void BossRoomHealthDisplay_OnBossHealthUpdate(float currentHealth) { _healthSlider.value = currentHealth; } private void BossRoomHealthDisplay_OnBossHealthHide() { _canvasGroupDecorator.Hide(); } private void BossRoomHealthDisplay_OnBossHealthShow(float currentHealth, float maxHealth) { _canvasGroupDecorator.Show(true); _healthSlider.maxValue = maxHealth; _healthSlider.value = currentHealth; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BossHealthDisplay",
          "content": " using UnityEngine; using UnityEngine.UI; namespace InRoomSystems { [RequireComponent(typeof(UICanvasGroupDecorator))] public class BossHealthDisplay: MonoBehaviour { private UICanvasGroupDecorator _canvasGroupDecorator; private Slider _healthSlider; private void Awake() { _canvasGroupDecorator = GetComponent<UICanvasGroupDecorator>(); _healthSlider = GetComponentInChildren<Slider>();  private void Start() { BossRoomHealthDisplayController.Instance.OnBossHealthShow += BossRoomHealthDisplay_OnBossHealthShow; BossRoomHealthDisplayController.Instance.OnBossHealthHide += BossRoomHealthDisplay_OnBossHealthHide; BossRoomHealthDisplayController.Instance.OnBossHealthUpdate += BossRoomHealthDisplay_OnBossHealthUpdate;  ",
          "content_tokens": 187,
          "embedding": []
        },
        {
          "cs_scriptfile": "BossHealthDisplay",
          "content": "private void BossRoomHealthDisplay_OnBossHealthUpdate(float currentHealth) { _healthSlider.value = currentHealth;  private void BossRoomHealthDisplay_OnBossHealthHide() { _canvasGroupDecorator.Hide();  private void BossRoomHealthDisplay_OnBossHealthShow(float currentHealth, float maxHealth) { _canvasGroupDecorator.Show(true); _healthSlider.maxValue = maxHealth; _healthSlider.value = currentHealth; } } }",
          "content_tokens": 109,
          "embedding": []
        }
      ],
      "length": 1130
    },
    {
      "filename": "BossRoomHealthDisplayController",
      "content": "using System; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishnetInvector; using Invector; using UnityEngine; namespace InRoomSystems { public class BossRoomHealthDisplayController : MonoBehaviour { public static BossRoomHealthDisplayController Instance; public Action OnPlayerEnter; public Action<float, float> OnBossHealthShow; public Action OnBossHealthHide; public Action<float> OnBossHealthUpdate; private GameplayManager _gameplayManager; private FishnetInvectorHealthController _bossHealthController; [SerializeField] private bool _isDebug = true; [SerializeField] private BossRoomLockExit _bossRoomLockExit; private void Awake() { Instance = this; } /// <summary> /// Detectable only on local player, because it's a trigger collider. /// </summary> /// <param name=\"other\"></param> private void OnTriggerEnter(Collider other) { if (other.gameObject.layer == LayerMask.NameToLayer(\"Player\")) { DebugWrite.Log($\"[BossRoomHealthDisplay] OnTriggerEnter: {other.gameObject}\", other.gameObject, _isDebug); GetOrSetGameplayManager(other.gameObject); var targetHealthController = GameplayManager.Instance.GetHealthController(other); if (targetHealthController.IsOwner) { OnPlayerEnter?.Invoke(); OnBossHealthShow?.Invoke(_bossHealthController.CurrentHealth, _bossHealthController.MaxHealth); LockExit(); } } if (other.gameObject.layer == LayerMask.NameToLayer(\"Enemy\")) { DebugWrite.Log($\"[BossRoomHealthDisplay] OnTriggerEnter: {other.gameObject}\", other.gameObject, _isDebug); GetOrSetBossHealthController(other.gameObject); _bossHealthController.OnMineHealthChanged += BossHealthController_OnOnHealthChanged; _bossHealthController.OnDead += BossHealthController_OnDead; } } private void BossHealthController_OnDead(vDamage obj) { _bossRoomLockExit.UnlockExit(); } private void LockExit() { _bossRoomLockExit.LockExit(); } private void OnTriggerExit(Collider other) { if (other.gameObject.layer == LayerMask.NameToLayer(\"Player\")) { DebugWrite.Log($\"[BossRoomHealthDisplay] OnTriggerExit: {other.gameObject}\", other.gameObject, _isDebug); var targetHealthController = GameplayManager.Instance.GetHealthController(other); if (targetHealthController.IsOwner) { OnBossHealthHide?.Invoke(); } } if (other.gameObject.layer == LayerMask.NameToLayer(\"Enemy\")) { } } private void BossHealthController_OnOnHealthChanged(FishnetInvectorHealthController.HealthType type, float newAmount) { DebugWrite.Log($\"[BossRoomHealthDisplay] BossHealthController_OnOnHealthChanged: {type} {newAmount}\", _bossHealthController.gameObject, _isDebug); if (type == FishnetInvectorHealthController.HealthType.Current) { UpdateBossHealthBar(newAmount); } } private void UpdateBossHealthBar(float newAmount) { DebugWrite.Log($\"[BossRoomHealthDisplay] UpdateBossHealthBar: {newAmount}\", _bossHealthController.gameObject, _isDebug); OnBossHealthUpdate?.Invoke(newAmount); } private GameplayManager GetOrSetGameplayManager(GameObject player) { if (_gameplayManager == null) { _gameplayManager = player.GetComponent<FishnetInvectorManager>().GameplayManager; DebugWrite.Log($\"[BossRoomHealthDisplay][GetOrSetGameplayManager]: {GameplayManager.Instance}\", GameplayManager.Instance.gameObject, _isDebug); } return _gameplayManager; } private FishnetInvectorHealthController GetOrSetBossHealthController(GameObject boss) { if (_bossHealthController == null) { _bossHealthController = boss.GetComponent<FishnetInvectorHealthController>(); DebugWrite.Log($\"[BossRoomHealthDisplay][GetOrSetBossHealthController]: {_bossHealthController}\", _bossHealthController.gameObject, _isDebug); } return _bossHealthController; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BossRoomHealthDisplayController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "BossRoomHealthDisplayController",
          "content": "using System; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishnetInvector; using Invector; using UnityEngine; namespace InRoomSystems { public class BossRoomHealthDisplayController : MonoBehaviour { public static BossRoomHealthDisplayController Instance; public Action OnPlayerEnter; public Action<float, float> OnBossHealthShow; public Action OnBossHealthHide; public Action<float> OnBossHealthUpdate; private GameplayManager _gameplayManager; private FishnetInvectorHealthController _bossHealthController; [SerializeField] private bool _isDebug = true; [SerializeField] private BossRoomLockExit _bossRoomLockExit; private void Awake() { Instance = this; } /// <summary> /// Detectable only on local player, because it's a trigger collider. /// </summary> /// <param name=\"other\"></param> private void OnTriggerEnter(Collider other) { if (other.gameObject.layer == LayerMask.NameToLayer(\"Player\")) { DebugWrite.Log($\"[BossRoomHealthDisplay] OnTriggerEnter: {other.gameObject}\", other.gameObject, _isDebug); GetOrSetGameplayManager(other.gameObject); var targetHealthController = GameplayManager.Instance.GetHealthController(other); if (targetHealthController.IsOwner) { OnPlayerEnter?.Invoke(); OnBossHealthShow?.Invoke(_bossHealthController.CurrentHealth, _bossHealthController.MaxHealth); LockExit(); }  ",
          "content_tokens": 348,
          "embedding": []
        },
        {
          "cs_scriptfile": "BossRoomHealthDisplayController",
          "content": "if (other.gameObject.layer == LayerMask.NameToLayer(\"Enemy\")) { DebugWrite.Log($\"[BossRoomHealthDisplay] OnTriggerEnter: {other.gameObject}\", other.gameObject, _isDebug); GetOrSetBossHealthController(other.gameObject); _bossHealthController.OnMineHealthChanged += BossHealthController_OnOnHealthChanged; _bossHealthController.OnDead += BossHealthController_OnDead; }  private void BossHealthController_OnDead(vDamage obj) { _bossRoomLockExit.UnlockExit();  private void LockExit() { _bossRoomLockExit.LockExit();  ",
          "content_tokens": 141,
          "embedding": []
        },
        {
          "cs_scriptfile": "BossRoomHealthDisplayController",
          "content": "private void OnTriggerExit(Collider other) { if (other.gameObject.layer == LayerMask.NameToLayer(\"Player\")) { DebugWrite.Log($\"[BossRoomHealthDisplay] OnTriggerExit: {other.gameObject}\", other.gameObject, _isDebug); var targetHealthController = GameplayManager.Instance.GetHealthController(other); if (targetHealthController.IsOwner) { OnBossHealthHide?.Invoke(); }  if (other.gameObject.layer == LayerMask.NameToLayer(\"Enemy\")) { }  ",
          "content_tokens": 122,
          "embedding": []
        },
        {
          "cs_scriptfile": "BossRoomHealthDisplayController",
          "content": "private void BossHealthController_OnOnHealthChanged(FishnetInvectorHealthController.HealthType type, float newAmount) { DebugWrite.Log($\"[BossRoomHealthDisplay] BossHealthController_OnOnHealthChanged: {type} {newAmount}\", _bossHealthController.gameObject, _isDebug); if (type == FishnetInvectorHealthController.HealthType.Current) { UpdateBossHealthBar(newAmount); }  ",
          "content_tokens": 95,
          "embedding": []
        },
        {
          "cs_scriptfile": "BossRoomHealthDisplayController",
          "content": "private void UpdateBossHealthBar(float newAmount) { DebugWrite.Log($\"[BossRoomHealthDisplay] UpdateBossHealthBar: {newAmount}\", _bossHealthController.gameObject, _isDebug); OnBossHealthUpdate?.Invoke(newAmount); } private GameplayManager GetOrSetGameplayManager(GameObject player) { if (_gameplayManager == null) { _gameplayManager = player.GetComponent<FishnetInvectorManager>().GameplayManager; DebugWrite.Log($\"[BossRoomHealthDisplay][GetOrSetGameplayManager]: {GameplayManager.Instance}\", GameplayManager.Instance.gameObject, _isDebug); } return _gameplayManager; } private FishnetInvectorHealthController GetOrSetBossHealthController(GameObject boss) { if (_bossHealthController == null) { _bossHealthController = boss.GetComponent<FishnetInvectorHealthController>(); DebugWrite.Log($\"[BossRoomHealthDisplay][GetOrSetBossHealthController]: {_bossHealthController}\", _bossHealthController.gameObject, _isDebug); } return _bossHealthController; } } }",
          "content_tokens": 240,
          "embedding": []
        }
      ],
      "length": 3662
    },
    {
      "filename": "BossRoomLockExit",
      "content": " using UnityEngine; namespace InRoomSystems { public class BossRoomLockExit: MonoBehaviour { private BoxCollider _collider; private void Awake() { _collider = GetComponent<BoxCollider>(); } public void LockExit() { _collider.isTrigger = false; } public void UnlockExit() { _collider.isTrigger = true; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BossRoomLockExit",
          "content": "using UnityEngine; namespace InRoomSystems { public class BossRoomLockExit: MonoBehaviour { private BoxCollider _collider; private void Awake() { _collider = GetComponent<BoxCollider>(); } public void LockExit() { _collider.isTrigger = false; } public void UnlockExit() { _collider.isTrigger = true; } } }",
          "content_tokens": 82,
          "embedding": []
        }
      ],
      "length": 306
    },
    {
      "filename": "CratePositionsHolder",
      "content": "using System.Collections; using System.Collections.Generic; using InRoomSystems; using UnityEngine; public class CratePositionsHolder : MonoBehaviour { [SerializeField] private List<CratesSystem.CratePoint> _allCratePositions = new List<CratesSystem.CratePoint>(); public List<CratesSystem.CratePoint> AllCratePositions {set => _allCratePositions = value; get => _allCratePositions;} } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CratePositionsHolder",
          "content": "using System.Collections; using System.Collections.Generic; using InRoomSystems; using UnityEngine; public class CratePositionsHolder : MonoBehaviour { [SerializeField] private List<CratesSystem.CratePoint> _allCratePositions = new List<CratesSystem.CratePoint>(); public List<CratesSystem.CratePoint> AllCratePositions {set => _allCratePositions = value; get => _allCratePositions;} }",
          "content_tokens": 109,
          "embedding": []
        }
      ],
      "length": 386
    },
    {
      "filename": "CratePositionsTable",
      "content": "using System; using System.Collections; using System.Collections.Generic; using UnityEngine; namespace InRoomSystems { [CreateAssetMenu(fileName = \"CratePositionsTableSO\", menuName = \"ScriptableObjects/CratePositionsTable\")] public class CratePositionsTable : ScriptableObject { [SerializeField] private List<CratePosition> _cratePositions = new List<CratePosition>(); public CratePosition GetCratePosition(int index) { return _cratePositions[index]; } public void AddCratePosition(CratePosition cratePosition) { _cratePositions.Add(cratePosition); } public void RemoveCratePosition(int index) { _cratePositions.RemoveAt(index); } [Serializable] public class CratePosition { public CratesSystem.Zone zone; public Vector3 position; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CratePositionsTable",
          "content": "using System; using System.Collections; using System.Collections.Generic; using UnityEngine; namespace InRoomSystems { [CreateAssetMenu(fileName = \"CratePositionsTableSO\", menuName = \"ScriptableObjects/CratePositionsTable\")] public class CratePositionsTable : ScriptableObject { [SerializeField] private List<CratePosition> _cratePositions = new List<CratePosition>(); public CratePosition GetCratePosition(int index) { return _cratePositions[index]; } public void AddCratePosition(CratePosition cratePosition) { _cratePositions.Add(cratePosition); } public void RemoveCratePosition(int index) { _cratePositions.RemoveAt(index); } [Serializable] public class CratePosition { public CratesSystem.Zone zone; public Vector3 position; } } }",
          "content_tokens": 193,
          "embedding": []
        }
      ],
      "length": 736
    },
    {
      "filename": "DungeonGenerator",
      "content": "using System.Collections.Generic; using System.Linq; using UnityEngine; public class DungeonGenerator : MonoBehaviour { private static int MAX_ROOM_SIZE = 16; private static int MIN_ROOM_SIZE = 4; private static int MAX_CELLS_BETWEEN_ROOMS = 3; private static int CORRIDOR_OFFSET = 1; // Avoid corridors touching each other private static int DUNGEON_WIDTH = 50; [System.Serializable] public class Room { public Vector2Int position; public Vector2Int size; public List<Vector2Int> cells; public List<Room> connectedRooms; public List<Vector2Int> gates; public Room(Vector2Int position, Vector2Int size) { this.position = position; this.size = size; this.cells = new List<Vector2Int>(); this.connectedRooms = new List<Room>(); this.gates = new List<Vector2Int>(); } public bool IsConnectedTo(Room other) { return connectedRooms.Contains(other); } } [SerializeField] private GameObject floorPrefab; [SerializeField] private GameObject wallPrefab; [SerializeField] private int seed; private List<Room> rooms; private List<Vector2Int> corridorTiles; private void Start() { Random.InitState(seed); GenerateDungeon(); } public void GenerateDungeon() { ClearDungeon(); rooms = GenerateRooms(); GenerateGates(rooms); corridorTiles = GenerateCorridors(rooms); } public void ClearDungeon() { for (int i = transform.childCount - 1; i >= 0; i--) { DestroyImmediate(transform.GetChild(i).gameObject); } rooms.Clear(); } public List<Room> GenerateRooms() { bool[,] grid = new bool[DUNGEON_WIDTH, DUNGEON_WIDTH]; int maxAttempts = 1000; // To avoid infinite loops int roomCount = 10; // Adjust the desired number of rooms List<Room> generatedRooms = new List<Room>(); for (int i = 0; i < roomCount; i++) { bool roomPlaced = false; int attempts = 0; while (!roomPlaced && attempts < maxAttempts) { attempts++; int size = Random.Range(MIN_ROOM_SIZE, MAX_ROOM_SIZE + 1); int x = Random.Range(0, DUNGEON_WIDTH - size); int y = Random.Range(0, DUNGEON_WIDTH - size); Room newRoom = new Room(new Vector2Int(x, y), new Vector2Int(size, size)); if (CanPlaceRoom(grid, x, y, size, generatedRooms)) { PlaceRoom(grid, x, y, size, newRoom); generatedRooms.Add(newRoom); roomPlaced = true; } } } return generatedRooms; } private bool CanPlaceRoom(bool[,] grid, int x, int y, int size, List<Room> existingRooms) { for (int i = x - 1; i <= x + size; i++) { for (int j = y - 1; j <= y + size; j++) { if (i < 0 || i >= grid.GetLength(0) || j < 0 || j >= grid.GetLength(1) || grid[i, j]) { return false; } } } foreach (Room room in existingRooms) { int distanceX = Mathf.Abs(room.position.x - x); int distanceY = Mathf.Abs(room.position.y - y); if (distanceX + distanceY <= MAX_CELLS_BETWEEN_ROOMS) { return false; } } return true; } private bool IsCellInAnyRoom(Vector2Int cell, List<Room> rooms) { foreach (Room room in rooms) { if (room.cells.Contains(cell)) { return true; } } return false; } private void PlaceRoom(bool[,] grid, int x, int y, int size, Room room) { // Create a parent GameObject for the room GameObject roomParent = new GameObject($\"Room {room.position} {room.size}\"); roomParent.transform.SetParent(transform); for (int i = x; i < x + size; i++) { for (int j = y; j < y + size; j++) { grid[i, j] = true; room.cells.Add(new Vector2Int(i, j)); GameObject floor = Instantiate(floorPrefab, new Vector3(i, 0, j), Quaternion.identity); floor.name = $\"Room {room.position} {room.size} floor {i}_{j}\"; floor.transform.SetParent(roomParent.transform); } } } private List<Vector2Int> GenerateAStarCorridors(List<Room> rooms) { List<Vector2Int> corridors = new List<Vector2Int>(); for (int i = 0; i < rooms.Count - 1; i++) { Room roomA = rooms[i]; Room roomB = rooms[i + 1]; List<Vector2Int> outerCellsA = GetOuterCells(roomA); List<Vector2Int> outerCellsB = GetOuterCells(roomB); Vector2Int startPoint = outerCellsA[Random.Range(0, outerCellsA.Count)]; Vector2Int endPoint = outerCellsB[Random.Range(0, outerCellsB.Count)]; List<Vector2Int> corridorPath = FindPathAStar(startPoint, endPoint, rooms); if (corridorPath != null) { Debug.Log($\"Generated corridor path between {roomA.position} and {roomB.position}: {string.Join(\", \", corridorPath)}\"); // Create a parent GameObject for the corridor GameObject corridorParent = new GameObject($\"Corridor {roomA.position} {roomA.size} to {roomB.position} {roomB.size}\"); corridorParent.transform.SetParent(transform); foreach (Vector2Int corridorCell in corridorPath) { if (!IsCellInAnyRoom(corridorCell, rooms)) { corridors.Add(corridorCell); GameObject floor = Instantiate(floorPrefab, new Vector3(corridorCell.x, 0, corridorCell.y), Quaternion.identity); floor.name = $\"Corridor {roomA.position} {roomA.size} to {roomB.position} {roomB.size} floor {corridorCell.x}_{corridorCell.y}\"; floor.transform.SetParent(corridorParent.transform); } } roomA.connectedRooms.Add(roomB); roomB.connectedRooms.Add(roomA); } } return corridors; } private List<Vector2Int> GenerateCorridors(List<Room> rooms) { List<Vector2Int> corridors = new List<Vector2Int>(); for (int i = 0; i < rooms.Count; i++) { List<Room> sortedRooms = new List<Room>(rooms); sortedRooms.RemoveAt(i); sortedRooms.Sort((r1, r2) => Vector2Int.Distance(r1.position, rooms[i].position).CompareTo(Vector2Int.Distance(r2.position, rooms[i].position))); // Connect each room to its two nearest neighbors int connectedRoomsCount = 0; for (int j = 0; j < sortedRooms.Count && connectedRoomsCount < 2; j++) { Room roomA = rooms[i]; Room roomB = sortedRooms[j]; // Select gates that are on the opposite sides of the rooms Vector2Int gateA = roomA.gates.OrderByDescending(g => Vector2Int.Distance(g, roomB.position)).First(); Vector2Int gateB = roomB.gates.OrderByDescending(g => Vector2Int.Distance(g, roomA.position)).First(); if (CorridorExists(gateA, gateB)) { continue; } List<Vector2Int> outerCellsA = new List<Vector2Int>(roomA.gates); List<Vector2Int> outerCellsB = new List<Vector2Int>(roomB.gates); Vector2Int startPoint = outerCellsA[Random.Range(0, outerCellsA.Count)]; Vector2Int endPoint = outerCellsB[Random.Range(0, outerCellsB.Count)]; bool validCorridor = true; // Check if the corridor is valid in the horizontal direction for (int x = startPoint.x - CORRIDOR_OFFSET; x <= endPoint.x + CORRIDOR_OFFSET; x++) { if (x < 0 || x >= DUNGEON_WIDTH) { validCorridor = false; break; } Vector2Int corridorCell = new Vector2Int(x, startPoint.y); if (corridors.Contains(corridorCell)) { validCorridor = false; break; } } // Check if the corridor is valid in the vertical direction for (int y = startPoint.y - CORRIDOR_OFFSET; y <= endPoint.y + CORRIDOR_OFFSET; y++) { if (y < 0 || y >= DUNGEON_WIDTH) { validCorridor = false; break; } Vector2Int corridorCell = new Vector2Int(endPoint.x, y); if (corridors.Contains(corridorCell)) { validCorridor = false; break; } } if (validCorridor) { // Create a parent GameObject for the corridor GameObject corridorParent = new GameObject($\"Corridor {roomA.position} {roomA.size} to {roomB.position} {roomB.size}\"); corridorParent.transform.SetParent(transform); for (int x = Mathf.Min(startPoint.x, endPoint.x); x <= Mathf.Max(startPoint.x, endPoint.x); x++) { Vector2Int corridorCell = new Vector2Int(x, startPoint.y); if (!IsCellInAnyRoom(corridorCell, rooms)) { corridors.Add(new Vector2Int(x, startPoint.y)); GameObject floor = Instantiate(floorPrefab, new Vector3(x, 0, startPoint.y), Quaternion.identity); floor.name = $\"Corridor {roomA.position} {roomA.size} to {roomB.position} {roomB.size} floor {x}_{startPoint.y}\"; floor.transform.SetParent(corridorParent.transform); } } for (int y = Mathf.Min(startPoint.y, endPoint.y) + CORRIDOR_OFFSET; y <= Mathf.Max(startPoint.y, endPoint.y) - CORRIDOR_OFFSET; y++) { Vector2Int corridorCell = new Vector2Int(endPoint.x, y); if (!corridors.Contains(corridorCell) && !IsCellInAnyRoom(corridorCell, rooms)) { corridors.Add(corridorCell); GameObject floor = Instantiate(floorPrefab, new Vector3(endPoint.x, 0, y), Quaternion.identity); floor.name = $\"Corridor {roomA.position} {roomA.size} to {roomB.position} {roomB.size} floor {endPoint.x}_{y}\"; floor.transform.SetParent(corridorParent.transform); } } roomA.connectedRooms.Add(roomB); roomB.connectedRooms.Add(roomA); connectedRoomsCount++; } } } return corridors; } private bool CorridorExists(Vector2Int gateA, Vector2Int gateB) { return corridorTiles.Contains(gateA) && corridorTiles.Contains(gateB); } private List<Vector2Int> GetNeighbors(Vector2Int node) { List<Vector2Int> neighbors = new List<Vector2Int>(); for (int x = -1; x <= 1; x++) { for (int y = -1; y <= 1; y++) { if (Mathf.Abs(x) != Mathf.Abs(y)) // Skip diagonal neighbors { int newX = node.x + x; int newY = node.y + y; if (newX >= 0 && newX < DUNGEON_WIDTH && newY >= 0 && newY < DUNGEON_WIDTH) { neighbors.Add(new Vector2Int(newX, newY)); } } } } return neighbors; } private List<Vector2Int> FindPathAStar(Vector2Int start, Vector2Int end, List<Room> rooms) { Dictionary<Vector2Int, Vector2Int> cameFrom = new Dictionary<Vector2Int, Vector2Int>(); Dictionary<Vector2Int, float> gScore = new Dictionary<Vector2Int, float>(); Dictionary<Vector2Int, float> fScore = new Dictionary<Vector2Int, float>(); HashSet<Vector2Int> openSet = new HashSet<Vector2Int> { start }; HashSet<Vector2Int> closedSet = new HashSet<Vector2Int>(); gScore[start] = 0; fScore[start] = Vector2Int.Distance(start, end); while (openSet.Count > 0) { Vector2Int current = openSet.OrderBy(node => fScore[node]).First(); if (current == end) { return ReconstructPath(cameFrom, current); } openSet.Remove(current); closedSet.Add(current); foreach (Vector2Int neighbor in GetNeighbors(current)) { if (closedSet.Contains(neighbor) || IsCellInAnyRoom(neighbor, rooms)) { continue; } float tentativeGScore = gScore[current] + Vector2Int.Distance(current, neighbor); if (!openSet.Contains(neighbor)) { openSet.Add(neighbor); } else if (tentativeGScore >= gScore[neighbor]) { continue; } cameFrom[neighbor] = current; gScore[neighbor] = tentativeGScore; fScore[neighbor] = gScore[neighbor] + Vector2Int.Distance(neighbor, end); } } return null; } private List<Vector2Int> ReconstructPath(Dictionary<Vector2Int, Vector2Int> cameFrom, Vector2Int current) { List<Vector2Int> path = new List<Vector2Int> { current }; while (cameFrom.ContainsKey(current)) { current = cameFrom[current]; path.Add(current); } path.Reverse(); return path; } private List<Vector2Int> GetOuterCells(Room room) { List<Vector2Int> outerCells = new List<Vector2Int>(); for (int x = room.position.x; x < room.position.x + room.size.x; x++) { outerCells.Add(new Vector2Int(x, room.position.y)); outerCells.Add(new Vector2Int(x, room.position.y + room.size.y - 1)); } for (int y = room.position.y + 1; y < room.position.y + room.size.y - 1; y++) { outerCells.Add(new Vector2Int(room.position.x, y)); outerCells.Add(new Vector2Int(room.position.x + room.size.x - 1, y)); } return outerCells; } public void GenerateGates(List<Room> rooms) { foreach (Room room in rooms) { int numberOfGates = Random.Range(2, 4); List<Vector2Int> outerCells = GetOuterCells(room); for (int gateIndex = 0; gateIndex < numberOfGates; gateIndex++) { if (outerCells.Count == 0) { break; } Vector2Int outerCell = outerCells[Random.Range(0, outerCells.Count)]; //remove from outerCells all cells with same y or same x, so that gates are not spawned at same side of room outerCells.RemoveAll(cell => cell.x == outerCell.x || cell.y == outerCell.y); Vector2Int gatePosition = GetAdjacentCellOutsideRoom(room, outerCell); room.gates.Add(gatePosition); // Spawn the gate using floor prefab as outer cell outside of the room GameObject gate = Instantiate(floorPrefab, new Vector3(gatePosition.x, 0, gatePosition.y), Quaternion.identity, transform); gate.name = $\"Room {room.position} {room.size} gate {gatePosition.x}_{gatePosition.y}\"; } } } private Vector2Int GetAdjacentCellOutsideRoom(Room room, Vector2Int outerCell) { List<Vector2Int> directions = new List<Vector2Int> { new Vector2Int(1, 0), new Vector2Int(-1, 0), new Vector2Int(0, 1), new Vector2Int(0, -1) }; foreach (Vector2Int dir in directions) { Vector2Int adjacentCell = outerCell + dir; if (!room.cells.Contains(adjacentCell)) { return adjacentCell; } } // If all adjacent cells are within the room, return the original outer cell as a fallback. return outerCell; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DungeonGenerator",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonGenerator",
          "content": "using System.Collections.Generic; using System.Linq; using UnityEngine; public class DungeonGenerator : MonoBehaviour { private static int MAX_ROOM_SIZE = 16; private static int MIN_ROOM_SIZE = 4; private static int MAX_CELLS_BETWEEN_ROOMS = 3; private static int CORRIDOR_OFFSET = 1; // Avoid corridors touching each other private static int DUNGEON_WIDTH = 50; [System.Serializable] public class Room { public Vector2Int position; public Vector2Int size; public List<Vector2Int> cells; public List<Room> connectedRooms; public List<Vector2Int> gates; public Room(Vector2Int position, Vector2Int size) { this.position = position; this.size = size; this.cells = new List<Vector2Int>(); this.connectedRooms = new List<Room>(); this.gates = new List<Vector2Int>();  ",
          "content_tokens": 219,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonGenerator",
          "content": "public bool IsConnectedTo(Room other) { return connectedRooms.Contains(other); } } [SerializeField] private GameObject floorPrefab; [SerializeField] private GameObject wallPrefab; [SerializeField] private int seed; private List<Room> rooms; private List<Vector2Int> corridorTiles; private void Start() { Random.InitState(seed); GenerateDungeon();  public void GenerateDungeon() { ClearDungeon(); rooms = GenerateRooms(); GenerateGates(rooms); corridorTiles = GenerateCorridors(rooms);  ",
          "content_tokens": 132,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonGenerator",
          "content": "public void ClearDungeon() { for (int i = transform.childCount - 1; i >= 0; i--) { DestroyImmediate(transform.GetChild(i).gameObject); } rooms.Clear(); } public List<Room> GenerateRooms() { bool[,] grid = new bool[DUNGEON_WIDTH, DUNGEON_WIDTH]; int maxAttempts = 1000; // To avoid infinite loops int roomCount = 10; // Adjust the desired number of rooms List<Room> generatedRooms = new List<Room>(); for (int i = 0; i < roomCount; i++) { bool roomPlaced = false; int attempts = 0; while (!roomPlaced && attempts < maxAttempts) { attempts++; int size = Random.Range(MIN_ROOM_SIZE, MAX_ROOM_SIZE + 1); int x = Random.Range(0, DUNGEON_WIDTH - size); int y = Random.Range(0, DUNGEON_WIDTH - size); Room newRoom = new Room(new Vector2Int(x, y), new Vector2Int(size, size)); if (CanPlaceRoom(grid, x, y, size, generatedRooms)) { PlaceRoom(grid, x, y, size, newRoom); generatedRooms.Add(newRoom); roomPlaced = true; } } } return generatedRooms;  ",
          "content_tokens": 310,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonGenerator",
          "content": "private bool CanPlaceRoom(bool[,] grid, int x, int y, int size, List<Room> existingRooms) { for (int i = x - 1; i <= x + size; i++) { for (int j = y - 1; j <= y + size; j++) { if (i < 0 || i >= grid.GetLength(0) || j < 0 || j >= grid.GetLength(1) || grid[i, j]) { return false; } }  foreach (Room room in existingRooms) { int distanceX = Mathf.Abs(room.position.x - x); int distanceY = Mathf.Abs(room.position.y - y); if (distanceX + distanceY <= MAX_CELLS_BETWEEN_ROOMS) { return false; } } return true;  ",
          "content_tokens": 188,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonGenerator",
          "content": "private bool IsCellInAnyRoom(Vector2Int cell, List<Room> rooms) { foreach (Room room in rooms) { if (room.cells.Contains(cell)) { return true; } } return false;  ",
          "content_tokens": 51,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonGenerator",
          "content": "private void PlaceRoom(bool[,] grid, int x, int y, int size, Room room) { // Create a parent GameObject for the room GameObject roomParent = new GameObject($\"Room {room.position} {room.size}\"); roomParent.transform.SetParent(transform); for (int i = x; i < x + size; i++) { for (int j = y; j < y + size; j++) { grid[i, j] = true; room.cells.Add(new Vector2Int(i, j)); GameObject floor = Instantiate(floorPrefab, new Vector3(i, 0, j), Quaternion.identity); floor.name = $\"Room {room.position} {room.size} floor {i}_{j}\"; floor.transform.SetParent(roomParent.transform); } } } private List<Vector2Int> GenerateAStarCorridors(List<Room> rooms) { List<Vector2Int> corridors = new List<Vector2Int>(); for (int i = 0; i < rooms.Count - 1; i++) { Room roomA = rooms[i]; Room roomB = rooms[i + 1]; List<Vector2Int> outerCellsA = GetOuterCells(roomA); List<Vector2Int> outerCellsB = GetOuterCells(roomB); Vector2Int startPoint = outerCellsA[Random.Range(0, outerCellsA.Count)]; Vector2Int endPoint = outerCellsB[Random.Range(0, outerCellsB.Count)]; List<Vector2Int> corridorPath = FindPathAStar(startPoint, endPoint, rooms); if (corridorPath != null) { Debug.Log($\"Generated corridor path between {roomA.position} and {roomB.position}: {string.Join(\", \", corridorPath)}\"); // Create a parent GameObject for the corridor GameObject corridorParent = new GameObject($\"Corridor {roomA.position} {roomA.size} to {roomB.position} {roomB.size}\"); corridorParent.transform.SetParent(transform); foreach (Vector2Int corridorCell in corridorPath) { if (!IsCellInAnyRoom(corridorCell, rooms)) { corridors.Add(corridorCell); GameObject floor = Instantiate(floorPrefab, new Vector3(corridorCell.x, 0, corridorCell.y), Quaternion.identity); floor.name = $\"Corridor {roomA.position} {roomA.size} to {roomB.position} {roomB.size} floor {corridorCell.x}_{corridorCell.y}\"; floor.transform.SetParent(corridorParent.transform); } } roomA.connectedRooms.Add(roomB); roomB.connectedRooms.Add(roomA); } } return corridors; } private List<Vector2Int> GenerateCorridors(List<Room> rooms) { List<Vector2Int> corridors = new List<Vector2Int>(); for (int i = 0; i < rooms.Count; i++) { List<Room> sortedRooms = new List<Room>(rooms); sortedRooms.RemoveAt(i); sortedRooms.Sort((r1, r2) => Vector2Int.Distance(r1.position, rooms[i].position).CompareTo(Vector2Int.Distance(r2.position, rooms[i].position))); // Connect each room to its two nearest neighbors int connectedRoomsCount = 0; for (int j = 0; j < sortedRooms.Count && connectedRoomsCount < 2; j++) { Room roomA = rooms[i]; Room roomB = sortedRooms[j]; // Select gates that are on the opposite sides of the rooms Vector2Int gateA = roomA.gates.OrderByDescending(g => Vector2Int.Distance(g, roomB.position)).First(); Vector2Int gateB = roomB.gates.OrderByDescending(g => Vector2Int.Distance(g, roomA.position)).First(); if (CorridorExists(gateA, gateB)) { continue; } List<Vector2Int> outerCellsA = new List<Vector2Int>(roomA.gates); List<Vector2Int> outerCellsB = new List<Vector2Int>(roomB.gates); Vector2Int startPoint = outerCellsA[Random.Range(0, outerCellsA.Count)]; Vector2Int endPoint = outerCellsB[Random.Range(0, outerCellsB.Count)]; bool validCorridor = true; // Check if the corridor is valid in the horizontal direction for (int x = startPoint.x - CORRIDOR_OFFSET; x <= endPoint.x + CORRIDOR_OFFSET; x++) { if (x < 0 || x >= DUNGEON_WIDTH) { validCorridor = false; break; } Vector2Int corridorCell = new Vector2Int(x, startPoint.y); if (corridors.Contains(corridorCell)) { validCorridor = false; break; } } // Check if the corridor is valid in the vertical direction for (int y = startPoint.y - CORRIDOR_OFFSET; y <= endPoint.y + CORRIDOR_OFFSET; y++) { if (y < 0 || y >= DUNGEON_WIDTH) { validCorridor = false; break; } Vector2Int corridorCell = new Vector2Int(endPoint.x, y); if (corridors.Contains(corridorCell)) { validCorridor = false; break; }  ",
          "content_tokens": 1262,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonGenerator",
          "content": "if (validCorridor) { // Create a parent GameObject for the corridor GameObject corridorParent = new GameObject($\"Corridor {roomA.position} {roomA.size} to {roomB.position} {roomB.size}\"); corridorParent.transform.SetParent(transform); for (int x = Mathf.Min(startPoint.x, endPoint.x); x <= Mathf.Max(startPoint.x, endPoint.x); x++) { Vector2Int corridorCell = new Vector2Int(x, startPoint.y); if (!IsCellInAnyRoom(corridorCell, rooms)) { corridors.Add(new Vector2Int(x, startPoint.y)); GameObject floor = Instantiate(floorPrefab, new Vector3(x, 0, startPoint.y), Quaternion.identity); floor.name = $\"Corridor {roomA.position} {roomA.size} to {roomB.position} {roomB.size} floor {x}_{startPoint.y}\"; floor.transform.SetParent(corridorParent.transform); }  ",
          "content_tokens": 244,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonGenerator",
          "content": "for (int y = Mathf.Min(startPoint.y, endPoint.y) + CORRIDOR_OFFSET; y <= Mathf.Max(startPoint.y, endPoint.y) - CORRIDOR_OFFSET; y++) { Vector2Int corridorCell = new Vector2Int(endPoint.x, y); if (!corridors.Contains(corridorCell) && !IsCellInAnyRoom(corridorCell, rooms)) { corridors.Add(corridorCell); GameObject floor = Instantiate(floorPrefab, new Vector3(endPoint.x, 0, y), Quaternion.identity); floor.name = $\"Corridor {roomA.position} {roomA.size} to {roomB.position} {roomB.size} floor {endPoint.x}_{y}\"; floor.transform.SetParent(corridorParent.transform); } } roomA.connectedRooms.Add(roomB); roomB.connectedRooms.Add(roomA); connectedRoomsCount++; } } } return corridors;  ",
          "content_tokens": 239,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonGenerator",
          "content": "private bool CorridorExists(Vector2Int gateA, Vector2Int gateB) { return corridorTiles.Contains(gateA) && corridorTiles.Contains(gateB); } private List<Vector2Int> GetNeighbors(Vector2Int node) { List<Vector2Int> neighbors = new List<Vector2Int>(); for (int x = -1; x <= 1; x++) { for (int y = -1; y <= 1; y++) { if (Mathf.Abs(x) != Mathf.Abs(y)) // Skip diagonal neighbors { int newX = node.x + x; int newY = node.y + y; if (newX >= 0 && newX < DUNGEON_WIDTH && newY >= 0 && newY < DUNGEON_WIDTH) { neighbors.Add(new Vector2Int(newX, newY)); } } } } return neighbors; } private List<Vector2Int> FindPathAStar(Vector2Int start, Vector2Int end, List<Room> rooms) { Dictionary<Vector2Int, Vector2Int> cameFrom = new Dictionary<Vector2Int, Vector2Int>(); Dictionary<Vector2Int, float> gScore = new Dictionary<Vector2Int, float>(); Dictionary<Vector2Int, float> fScore = new Dictionary<Vector2Int, float>(); HashSet<Vector2Int> openSet = new HashSet<Vector2Int> { start }; HashSet<Vector2Int> closedSet = new HashSet<Vector2Int>(); gScore[start] = 0; fScore[start] = Vector2Int.Distance(start, end); while (openSet.Count > 0) { Vector2Int current = openSet.OrderBy(node => fScore[node]).First(); if (current == end) { return ReconstructPath(cameFrom, current); } openSet.Remove(current); closedSet.Add(current); foreach (Vector2Int neighbor in GetNeighbors(current)) { if (closedSet.Contains(neighbor) || IsCellInAnyRoom(neighbor, rooms)) { continue; } float tentativeGScore = gScore[current] + Vector2Int.Distance(current, neighbor); if (!openSet.Contains(neighbor)) { openSet.Add(neighbor); } else if (tentativeGScore >= gScore[neighbor]) { continue; } cameFrom[neighbor] = current; gScore[neighbor] = tentativeGScore; fScore[neighbor] = gScore[neighbor] + Vector2Int.Distance(neighbor, end); } } return null; } private List<Vector2Int> ReconstructPath(Dictionary<Vector2Int, Vector2Int> cameFrom, Vector2Int current) { List<Vector2Int> path = new List<Vector2Int> { current }; while (cameFrom.ContainsKey(current)) { current = cameFrom[current]; path.Add(current); } path.Reverse(); return path; } private List<Vector2Int> GetOuterCells(Room room) { List<Vector2Int> outerCells = new List<Vector2Int>(); for (int x = room.position.x; x < room.position.x + room.size.x; x++) { outerCells.Add(new Vector2Int(x, room.position.y)); outerCells.Add(new Vector2Int(x, room.position.y + room.size.y - 1));  ",
          "content_tokens": 791,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonGenerator",
          "content": "for (int y = room.position.y + 1; y < room.position.y + room.size.y - 1; y++) { outerCells.Add(new Vector2Int(room.position.x, y)); outerCells.Add(new Vector2Int(room.position.x + room.size.x - 1, y)); } return outerCells;  ",
          "content_tokens": 86,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonGenerator",
          "content": "public void GenerateGates(List<Room> rooms) { foreach (Room room in rooms) { int numberOfGates = Random.Range(2, 4); List<Vector2Int> outerCells = GetOuterCells(room); for (int gateIndex = 0; gateIndex < numberOfGates; gateIndex++) { if (outerCells.Count == 0) { break; } Vector2Int outerCell = outerCells[Random.Range(0, outerCells.Count)]; //remove from outerCells all cells with same y or same x, so that gates are not spawned at same side of room outerCells.RemoveAll(cell => cell.x == outerCell.x || cell.y == outerCell.y); Vector2Int gatePosition = GetAdjacentCellOutsideRoom(room, outerCell); room.gates.Add(gatePosition); // Spawn the gate using floor prefab as outer cell outside of the room GameObject gate = Instantiate(floorPrefab, new Vector3(gatePosition.x, 0, gatePosition.y), Quaternion.identity, transform); gate.name = $\"Room {room.position} {room.size} gate {gatePosition.x}_{gatePosition.y}\"; } } } private Vector2Int GetAdjacentCellOutsideRoom(Room room, Vector2Int outerCell) { List<Vector2Int> directions = new List<Vector2Int> { new Vector2Int(1, 0), new Vector2Int(-1, 0), new Vector2Int(0, 1), new Vector2Int(0, -1) }; foreach (Vector2Int dir in directions) { Vector2Int adjacentCell = outerCell + dir; if (!room.cells.Contains(adjacentCell)) { return adjacentCell; } } // If all adjacent cells are within the room, return the original outer cell as a fallback. return outerCell; } }",
          "content_tokens": 423,
          "embedding": []
        }
      ],
      "length": 12221
    },
    {
      "filename": "DungeonGeneratorEditor",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; [CustomEditor(typeof(DungeonGenerator))] public class DungeonGeneratorEditor : Editor { public override void OnInspectorGUI() { base.OnInspectorGUI(); List<DungeonGenerator.Room> rooms = new List<DungeonGenerator.Room>(); if (GUILayout.Button(\"Generate Dungeon\")) { ((DungeonGenerator)target).GenerateDungeon(); } if (GUILayout.Button(\"Generate Rooms\")) { ((DungeonGenerator)target).ClearDungeon(); rooms = ((DungeonGenerator)target).GenerateRooms(); } if (GUILayout.Button(\"Generate Rooms+Gates\")) { ((DungeonGenerator)target).ClearDungeon(); ((DungeonGenerator)target).GenerateGates(((DungeonGenerator)target).GenerateRooms()); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DungeonGeneratorEditor",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; [CustomEditor(typeof(DungeonGenerator))] public class DungeonGeneratorEditor : Editor { public override void OnInspectorGUI() { base.OnInspectorGUI(); List<DungeonGenerator.Room> rooms = new List<DungeonGenerator.Room>(); if (GUILayout.Button(\"Generate Dungeon\")) { ((DungeonGenerator)target).GenerateDungeon();  if (GUILayout.Button(\"Generate Rooms\")) { ((DungeonGenerator)target).ClearDungeon(); rooms = ((DungeonGenerator)target).GenerateRooms();  ",
          "content_tokens": 155,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonGeneratorEditor",
          "content": "if (GUILayout.Button(\"Generate Rooms+Gates\")) { ((DungeonGenerator)target).ClearDungeon(); ((DungeonGenerator)target).GenerateGates(((DungeonGenerator)target).GenerateRooms()); } } }",
          "content_tokens": 58,
          "embedding": []
        }
      ],
      "length": 734
    },
    {
      "filename": "ReplaceableObject",
      "content": "using FishNet; using UnityEngine; using UnityEngine.Serialization; namespace InRoomSystems { public class ReplaceableObject : MonoBehaviour { public InteractableObjectController InteractableObjectControllerPrefab => interactableObjectControllerPrefab; [FormerlySerializedAs(\"_objectPrefab\")] [SerializeField] private InteractableObjectController interactableObjectControllerPrefab; public GameObject Prefab => _prefab; [SerializeField] private GameObject _prefab; public void ReplaceObject() { GameObject nob = Instantiate(Prefab, transform.position, transform.rotation); InstanceFinder.ServerManager.Spawn(nob); Destroy(gameObject); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ReplaceableObject",
          "content": "using FishNet; using UnityEngine; using UnityEngine.Serialization; namespace InRoomSystems { public class ReplaceableObject : MonoBehaviour { public InteractableObjectController InteractableObjectControllerPrefab => interactableObjectControllerPrefab; [FormerlySerializedAs(\"_objectPrefab\")] [SerializeField] private InteractableObjectController interactableObjectControllerPrefab; public GameObject Prefab => _prefab; [SerializeField] private GameObject _prefab; public void ReplaceObject() { GameObject nob = Instantiate(Prefab, transform.position, transform.rotation); InstanceFinder.ServerManager.Spawn(nob); Destroy(gameObject); } } }",
          "content_tokens": 150,
          "embedding": []
        }
      ],
      "length": 639
    },
    {
      "filename": "DungeonHolder",
      "content": "using System; using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DungeonArchitect; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using InRoomSystems; using NGS.AdvancedCullingSystem.Dynamic; using UnityEngine; public class DungeonHolder : MonoBehaviour { public GameObject[] Doors => _doors; [SerializeField] private List<MeshRenderer> _renderers; [SerializeField] private GameObject[] _doors; [SerializeField] private ushort seed; public List<DungeonSceneProviderData> RoomDatas => _roomData; [SerializeField] private List<DungeonSceneProviderData> _roomData = new (); public RoomCollapsingTimer[] RoomCollapsingDatas => _roomCollapsingTimer; [SerializeField] private RoomCollapsingTimer[] _roomCollapsingTimer; private void OnValidate() { if (RoomDatas.Count == 0) SetupRooms(); } private IEnumerator Start() { bool[] tagSpawned = new bool[ObjectsRoomManager.OBJECT_TAGS.Length]; string[] tags = ObjectsRoomManager.OBJECT_TAGS; int totalSpawned = 0; float delay = .5f; var time = new WaitForSeconds(delay); float totalTimePassed = 0f; for (int i = 0; i < tags.Length; i++) { if (totalSpawned >= tags.Length) break; if (tagSpawned[i]) continue; if (GameObject.FindGameObjectsWithTag(tags[i]).Length > 0) { tagSpawned[i] = true; totalSpawned++; } yield return time; totalTimePassed += delay; if (delay > 10f) { Debug.LogError($\"CRITICAL ERROR!!! [DungeonHolder] Waiting for objects to spawn took too long! {totalTimePassed}s\"); yield break; } } DungeonNetworkManager.Instance.OnDungeonLoaded?.Invoke(); if (DC_Controller.Instance != null) { foreach (var rend in _renderers) { if (rend == null) continue; DC_Controller.Instance.AddObjectForCulling(rend); } } Debug.Log($\"[DungeonHolder] OnDungeonLoaded invoked on {gameObject.name}\", gameObject); } public void SetupRooms() { var rooms = GameObject.FindGameObjectsWithTag(\"Room\"); _roomCollapsingTimer = new RoomCollapsingTimer[rooms.Length]; for (int i = 0; i < rooms.Length; i++) { _roomData.Add(rooms[i].GetComponent<DungeonSceneProviderData>()); var collapsingTimerComponent = rooms[i].GetComponent<RoomCollapsingTimer>(); if (collapsingTimerComponent != null) _roomCollapsingTimer[i] = collapsingTimerComponent; else _roomCollapsingTimer[i] = rooms[i].AddComponent<RoomCollapsingTimer>(); } } public void SetupCollapsingTimes() { //TODO: Implement time calculation by graph for (int i = 0; i < _roomCollapsingTimer.Length; i++) { float addTime = 120000f; if (!_roomCollapsingTimer[i].gameObject.name.Contains(\"Spawn\")) { float randomTime = UnityEngine.Random.Range(240f, 600f); addTime = randomTime; } _roomCollapsingTimer[i].SetCollapsingTime(GameplayManager.GetCurrentServerTime() + addTime); } } public void SetupDoors() { _doors = GameObject.FindGameObjectsWithTag(\"Door\"); } public void SetupRenderers() { _renderers = FindAllRenderersRecursively(transform); } public List<MeshRenderer> FindAllRenderersRecursively(Transform parent) { List<MeshRenderer> renderers = new List<MeshRenderer>(); foreach (Transform child in parent) { renderers.AddRange(child.GetComponentsInChildren<MeshRenderer>()); renderers.AddRange(FindAllRenderersRecursively(child)); } return renderers; } public void RemoveDuplicates() { _renderers = new List<MeshRenderer>(new HashSet<MeshRenderer>(_renderers)); Debug.Log($\"[DungeonHolder] Removed duplicates from {gameObject.name}\", gameObject); } public void SetSeed(ushort newSeed) { seed = newSeed; } [Serializable] public struct RoomData { public GameObject Room; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DungeonHolder",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonHolder",
          "content": "using System; using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DungeonArchitect; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using InRoomSystems; using NGS.AdvancedCullingSystem.Dynamic; using UnityEngine; public class DungeonHolder : MonoBehaviour { public GameObject[] Doors => _doors; [SerializeField] private List<MeshRenderer> _renderers; [SerializeField] private GameObject[] _doors; [SerializeField] private ushort seed; public List<DungeonSceneProviderData> RoomDatas => _roomData; [SerializeField] private List<DungeonSceneProviderData> _roomData = new (); public RoomCollapsingTimer[] RoomCollapsingDatas => _roomCollapsingTimer; [SerializeField] private RoomCollapsingTimer[] _roomCollapsingTimer; private void OnValidate() { if (RoomDatas.Count == 0) SetupRooms(); } private IEnumerator Start() { bool[] tagSpawned = new bool[ObjectsRoomManager.OBJECT_TAGS.Length]; string[] tags = ObjectsRoomManager.OBJECT_TAGS; int totalSpawned = 0; float delay = .5f; var time = new WaitForSeconds(delay); float totalTimePassed = 0f; for (int i = 0; i < tags.Length; i++) { if (totalSpawned >= tags.Length) break; if (tagSpawned[i]) continue; if (GameObject.FindGameObjectsWithTag(tags[i]).Length > 0) { tagSpawned[i] = true; totalSpawned++; } yield return time; totalTimePassed += delay; if (delay > 10f) { Debug.LogError($\"CRITICAL ERROR!!! [DungeonHolder] Waiting for objects to spawn took too long! {totalTimePassed}s\"); yield break; } } DungeonNetworkManager.Instance.OnDungeonLoaded?.Invoke(); if (DC_Controller.Instance != null) { foreach (var rend in _renderers) { if (rend == null) continue; DC_Controller.Instance.AddObjectForCulling(rend); } } Debug.Log($\"[DungeonHolder] OnDungeonLoaded invoked on {gameObject.name}\", gameObject);  ",
          "content_tokens": 537,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonHolder",
          "content": "public void SetupRooms() { var rooms = GameObject.FindGameObjectsWithTag(\"Room\"); _roomCollapsingTimer = new RoomCollapsingTimer[rooms.Length]; for (int i = 0; i < rooms.Length; i++) { _roomData.Add(rooms[i].GetComponent<DungeonSceneProviderData>()); var collapsingTimerComponent = rooms[i].GetComponent<RoomCollapsingTimer>(); if (collapsingTimerComponent != null) _roomCollapsingTimer[i] = collapsingTimerComponent; else _roomCollapsingTimer[i] = rooms[i].AddComponent<RoomCollapsingTimer>(); }  ",
          "content_tokens": 147,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonHolder",
          "content": "public void SetupCollapsingTimes() { //TODO: Implement time calculation by graph for (int i = 0; i < _roomCollapsingTimer.Length; i++) { float addTime = 120000f; if (!_roomCollapsingTimer[i].gameObject.name.Contains(\"Spawn\")) { float randomTime = UnityEngine.Random.Range(240f, 600f); addTime = randomTime; } _roomCollapsingTimer[i].SetCollapsingTime(GameplayManager.GetCurrentServerTime() + addTime); }  public void SetupDoors() { _doors = GameObject.FindGameObjectsWithTag(\"Door\");  ",
          "content_tokens": 148,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonHolder",
          "content": "public void SetupRenderers() { _renderers = FindAllRenderersRecursively(transform); } public List<MeshRenderer> FindAllRenderersRecursively(Transform parent) { List<MeshRenderer> renderers = new List<MeshRenderer>(); foreach (Transform child in parent) { renderers.AddRange(child.GetComponentsInChildren<MeshRenderer>()); renderers.AddRange(FindAllRenderersRecursively(child)); } return renderers;  public void RemoveDuplicates() { _renderers = new List<MeshRenderer>(new HashSet<MeshRenderer>(_renderers)); Debug.Log($\"[DungeonHolder] Removed duplicates from {gameObject.name}\", gameObject);  ",
          "content_tokens": 175,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonHolder",
          "content": "public void SetSeed(ushort newSeed) { seed = newSeed; } [Serializable] public struct RoomData { public GameObject Room; } }",
          "content_tokens": 36,
          "embedding": []
        }
      ],
      "length": 3527
    },
    {
      "filename": "CratePositionsHolderEditor",
      "content": "using System.Collections; using System.Collections.Generic; using InRoomSystems; #if UNITY_EDITOR using UnityEditor; #endif using UnityEngine; using UnityEngine.UIElements; [CustomEditor(typeof(CratePositionsHolder))] public class CratesPositionsHolderEditor : Editor { private CratePositionsHolder m_CratesPositionsHolder; public override void OnInspectorGUI() { m_CratesPositionsHolder = (CratePositionsHolder)target; DrawDefaultInspector(); if (GUILayout.Button(\"Add Crate Positions\")) { m_CratesPositionsHolder.AllCratePositions.Clear(); GenerateCratePoints(); } } private void GenerateCratePoints() { ushort index = 0; List<CratesSystem.CratePoint> cratePoints = new List<CratesSystem.CratePoint>(); foreach (Transform child in m_CratesPositionsHolder.transform) { var cp = new CratesSystem.CratePoint(); cp.Id = index; cp.Zone = CratesSystem.Zone.level1; cp.Position = child.position; cp.Rotation = child.rotation.eulerAngles; cratePoints.Add(cp); index++; } m_CratesPositionsHolder.AllCratePositions = cratePoints; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CratePositionsHolderEditor",
          "content": "using System.Collections; using System.Collections.Generic; using InRoomSystems; #if UNITY_EDITOR using UnityEditor; #endif using UnityEngine; using UnityEngine.UIElements; [CustomEditor(typeof(CratePositionsHolder))] public class CratesPositionsHolderEditor : Editor { private CratePositionsHolder m_CratesPositionsHolder; public override void OnInspectorGUI() { m_CratesPositionsHolder = (CratePositionsHolder)target; DrawDefaultInspector(); if (GUILayout.Button(\"Add Crate Positions\")) { m_CratesPositionsHolder.AllCratePositions.Clear(); GenerateCratePoints(); }  ",
          "content_tokens": 163,
          "embedding": []
        },
        {
          "cs_scriptfile": "CratePositionsHolderEditor",
          "content": "private void GenerateCratePoints() { ushort index = 0; List<CratesSystem.CratePoint> cratePoints = new List<CratesSystem.CratePoint>(); foreach (Transform child in m_CratesPositionsHolder.transform) { var cp = new CratesSystem.CratePoint(); cp.Id = index; cp.Zone = CratesSystem.Zone.level1; cp.Position = child.position; cp.Rotation = child.rotation.eulerAngles; cratePoints.Add(cp); index++; } m_CratesPositionsHolder.AllCratePositions = cratePoints; } }",
          "content_tokens": 143,
          "embedding": []
        }
      ],
      "length": 1025
    },
    {
      "filename": "CratesSystemEditor",
      "content": "using System.Collections; using System.Collections.Generic; using InRoomSystems; using UnityEditor; using UnityEngine; using UnityEngine.UIElements; [CustomEditor(typeof(CratesSystem))] public class CratesSystemEditor : Editor { private CratesSystem m_CratesSystem; public override VisualElement CreateInspectorGUI() { var root = new VisualElement(); m_CratesSystem = (CratesSystem)target; LoadScriptableObjects(); //Draw the default inspector var defaultInspector = new IMGUIContainer(() => base.OnInspectorGUI()); root.Add(defaultInspector); return root; } public void LoadScriptableObjects() { m_CratesSystem.LoadDataTables(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CratesSystemEditor",
          "content": "using System.Collections; using System.Collections.Generic; using InRoomSystems; using UnityEditor; using UnityEngine; using UnityEngine.UIElements; [CustomEditor(typeof(CratesSystem))] public class CratesSystemEditor : Editor { private CratesSystem m_CratesSystem; public override VisualElement CreateInspectorGUI() { var root = new VisualElement(); m_CratesSystem = (CratesSystem)target; LoadScriptableObjects(); //Draw the default inspector var defaultInspector = new IMGUIContainer(() => base.OnInspectorGUI()); root.Add(defaultInspector); return root; } public void LoadScriptableObjects() { m_CratesSystem.LoadDataTables(); } }",
          "content_tokens": 167,
          "embedding": []
        }
      ],
      "length": 634
    },
    {
      "filename": "DungeonHolderEditor",
      "content": "using UnityEditor; using UnityEngine; [CustomEditor(typeof(DungeonHolder))] public class DungeonHolderEditor : Editor { public override void OnInspectorGUI() { DrawDefaultInspector(); DungeonHolder myScript = (DungeonHolder)target; if (GUILayout.Button(\"HideAllDoors\")) { if (myScript.Doors == null || myScript.Doors.Length == 0) myScript.SetupDoors(); foreach (var doorGO in myScript.Doors) { doorGO.SetActive(false); } } if (GUILayout.Button(\"ShowAllDoors\")) { if (myScript.Doors.Length == 0) myScript.SetupDoors(); foreach (var doorGO in myScript.Doors) { doorGO.SetActive(true); } } if (GUILayout.Button(\"SetupRenderers\")) { myScript.SetupRenderers(); myScript.RemoveDuplicates(); } if (GUILayout.Button(\"SetupRooms\")) { myScript.SetupRooms(); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DungeonHolderEditor",
          "content": "using UnityEditor; using UnityEngine; [CustomEditor(typeof(DungeonHolder))] public class DungeonHolderEditor : Editor { public override void OnInspectorGUI() { DrawDefaultInspector(); DungeonHolder myScript = (DungeonHolder)target; if (GUILayout.Button(\"HideAllDoors\")) { if (myScript.Doors == null || myScript.Doors.Length == 0) myScript.SetupDoors(); foreach (var doorGO in myScript.Doors) { doorGO.SetActive(false); }  if (GUILayout.Button(\"ShowAllDoors\")) { if (myScript.Doors.Length == 0) myScript.SetupDoors(); foreach (var doorGO in myScript.Doors) { doorGO.SetActive(true); }  ",
          "content_tokens": 185,
          "embedding": []
        },
        {
          "cs_scriptfile": "DungeonHolderEditor",
          "content": "if (GUILayout.Button(\"SetupRenderers\")) { myScript.SetupRenderers(); myScript.RemoveDuplicates();  if (GUILayout.Button(\"SetupRooms\")) { myScript.SetupRooms(); } } }",
          "content_tokens": 56,
          "embedding": []
        }
      ],
      "length": 754
    },
    {
      "filename": "LootDropDefinitionEditor",
      "content": "using System.Collections.Generic; using System.Linq; using Invector.vItemManager; using UnityEngine; using UnityEditor; namespace InRoomSystems { [CustomEditor(typeof(LootDropDefinition))] public class LootDropDefinitionEditor : Editor { private LootDropDefinition lootDropDefinition; private static CratesSystem.Zone _selectedZone; private Dictionary<CratesSystem.Zone, bool> showZones = new Dictionary<CratesSystem.Zone, bool>(); private void OnEnable() { lootDropDefinition = (LootDropDefinition)target; foreach (var item in lootDropDefinition.LootItemsList) { if (!showZones.ContainsKey(item.zone)) { showZones[item.zone] = true; } } } public override void OnInspectorGUI() { serializedObject.Update(); // Display item list field //EditorGUILayout.PropertyField(serializedObject.FindProperty(\"_itemList\")); // Display list of loot items EditorGUILayout.LabelField(\"Loot Items\", EditorStyles.boldLabel); // Group loot items by zone var groupedItems = lootDropDefinition.LootItemsList.GroupBy(item => item.zone); foreach (var group in groupedItems) { EditorGUILayout.BeginVertical(GUI.skin.box); // Display zone name and add show/hide toggle EditorGUILayout.BeginHorizontal(); showZones[group.Key] = EditorGUILayout.ToggleLeft(group.Key.ToString(), showZones[group.Key], GUILayout.ExpandWidth(false)); EditorGUILayout.EndHorizontal(); // Only display items in zones that are set to show if (showZones[group.Key]) { // Create table header EditorGUILayout.BeginHorizontal(); AddLabel(\"Name\", 100); AddLabel(\"Type\", 80); AddLabel(\"Icon\", 50); AddLabel(\"Chance\", 50); AddLabel(\"Min\", 25); AddLabel(\"Max\", 25); AddLabel(\"vItem\", 60); AddLabel(\"\", 20); EditorGUILayout.EndHorizontal(); // Display each drop table in the group foreach (var zoneLootItems in group) { foreach (LootDropDefinition.DropTable table in zoneLootItems.dropTables) { EditorGUILayout.BeginHorizontal(); // Display item name if (table.item == null) continue; AddLabel(table.item.name, 100); //edit drop type table.dropType = (LootDropDefinition.DropType)EditorGUILayout.EnumPopup(table.dropType, GUILayout.Width(80)); // Display icon field table.item.icon = (Sprite)EditorGUILayout.ObjectField(GUIContent.none, table.item.icon, typeof(Sprite), false, GUILayout.Width(50), GUILayout.Height(50)); // Display chance, min, and max fields table.dropChance = EditorGUILayout.FloatField(table.dropChance, GUILayout.Width(50)); table.min = EditorGUILayout.IntField(table.min, GUILayout.Width(25)); table.max = EditorGUILayout.IntField(table.max, GUILayout.Width(25)); //show vItem link table.item = (vItem)EditorGUILayout.ObjectField(GUIContent.none, table.item, typeof(vItem), false, GUILayout.Width(60)); // Add delete button for each drop table if (GUILayout.Button(\"X\", GUILayout.Width(20))) { var dropTable = zoneLootItems.dropTables.FirstOrDefault(dt => dt == table); if (dropTable != null) { zoneLootItems.dropTables.Remove(dropTable); } return; } EditorGUILayout.EndHorizontal(); } EditorGUILayout.Space(); EditorGUILayout.Space(); } } EditorGUILayout.EndVertical(); } _selectedZone = (CratesSystem.Zone)EditorGUILayout.EnumPopup(\"Zone\", _selectedZone); // Add new item button if (GUILayout.Button(\"Add New Item\")) { var LootItems = lootDropDefinition.LootItemsList.FirstOrDefault(li => li.zone == _selectedZone); LootItems.dropTables.Add(new LootDropDefinition.DropTable() { dropType = LootDropDefinition.DropType.Weapon, item = CreateInstance<vItem>(), dropChance = 0.5f, min = 1, max = 1 }); } // Add new item button // if (GUILayout.Button(\"Add New Item\")) // { // var newItem = new LootDropDefinition.LootItems(); // newItem.zone = _selectedZone; // default value // newItem.dropTables.Add(new LootDropDefinition.DropTable() // { // dropType = LootDropDefinition.DropType.Weapon, // item = ScriptableObject.CreateInstance<vItem>(), // dropChance = 0.5f, // min = 1, // max = 1 // }); // // lootDropDefinition.LootItemsList.Add(newItem); // } if (GUILayout.Button(\"Export\")) { lootDropDefinition.ExportToJson(); } if (GUILayout.Button(\"Save\")) { // Save changes to asset EditorUtility.SetDirty(lootDropDefinition); AssetDatabase.SaveAssets(); // Refresh asset database AssetDatabase.Refresh(); } serializedObject.ApplyModifiedProperties(); } private static void AddLabel(string txt, int width) { GUILayout.Label(txt, EditorStyles.boldLabel, GUILayout.Width(width)); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LootDropDefinitionEditor",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootDropDefinitionEditor",
          "content": "using System.Collections.Generic; using System.Linq; using Invector.vItemManager; using UnityEngine; using UnityEditor; namespace InRoomSystems { [CustomEditor(typeof(LootDropDefinition))] public class LootDropDefinitionEditor : Editor { private LootDropDefinition lootDropDefinition; private static CratesSystem.Zone _selectedZone; private Dictionary<CratesSystem.Zone, bool> showZones = new Dictionary<CratesSystem.Zone, bool>(); private void OnEnable() { lootDropDefinition = (LootDropDefinition)target; foreach (var item in lootDropDefinition.LootItemsList) { if (!showZones.ContainsKey(item.zone)) { showZones[item.zone] = true; } } } public override void OnInspectorGUI() { serializedObject.Update(); // Display item list field //EditorGUILayout.PropertyField(serializedObject.FindProperty(\"_itemList\")); // Display list of loot items EditorGUILayout.LabelField(\"Loot Items\", EditorStyles.boldLabel); // Group loot items by zone var groupedItems = lootDropDefinition.LootItemsList.GroupBy(item => item.zone); foreach (var group in groupedItems) { EditorGUILayout.BeginVertical(GUI.skin.box); // Display zone name and add show/hide toggle EditorGUILayout.BeginHorizontal(); showZones[group.Key] = EditorGUILayout.ToggleLeft(group.Key.ToString(), showZones[group.Key], GUILayout.ExpandWidth(false)); EditorGUILayout.EndHorizontal(); // Only display items in zones that are set to show if (showZones[group.Key]) { // Create table header EditorGUILayout.BeginHorizontal(); AddLabel(\"Name\", 100); AddLabel(\"Type\", 80); AddLabel(\"Icon\", 50); AddLabel(\"Chance\", 50); AddLabel(\"Min\", 25); AddLabel(\"Max\", 25); AddLabel(\"vItem\", 60); AddLabel(\"\", 20); EditorGUILayout.EndHorizontal(); // Display each drop table in the group foreach (var zoneLootItems in group) { foreach (LootDropDefinition.DropTable table in zoneLootItems.dropTables) { EditorGUILayout.BeginHorizontal(); // Display item name if (table.item == null) continue; AddLabel(table.item.name, 100); //edit drop type table.dropType = (LootDropDefinition.DropType)EditorGUILayout.EnumPopup(table.dropType, GUILayout.Width(80)); // Display icon field table.item.icon = (Sprite)EditorGUILayout.ObjectField(GUIContent.none, table.item.icon, typeof(Sprite), false, GUILayout.Width(50), GUILayout.Height(50)); // Display chance, min, and max fields table.dropChance = EditorGUILayout.FloatField(table.dropChance, GUILayout.Width(50)); table.min = EditorGUILayout.IntField(table.min, GUILayout.Width(25)); table.max = EditorGUILayout.IntField(table.max, GUILayout.Width(25)); //show vItem link table.item = (vItem)EditorGUILayout.ObjectField(GUIContent.none, table.item, typeof(vItem), false, GUILayout.Width(60)); // Add delete button for each drop table if (GUILayout.Button(\"X\", GUILayout.Width(20))) { var dropTable = zoneLootItems.dropTables.FirstOrDefault(dt => dt == table); if (dropTable != null) { zoneLootItems.dropTables.Remove(dropTable); } return; } EditorGUILayout.EndHorizontal(); } EditorGUILayout.Space(); EditorGUILayout.Space(); } } EditorGUILayout.EndVertical(); } _selectedZone = (CratesSystem.Zone)EditorGUILayout.EnumPopup(\"Zone\", _selectedZone); // Add new item button if (GUILayout.Button(\"Add New Item\")) { var LootItems = lootDropDefinition.LootItemsList.FirstOrDefault(li => li.zone == _selectedZone); LootItems.dropTables.Add(new LootDropDefinition.DropTable() { dropType = LootDropDefinition.DropType.Weapon, item = CreateInstance<vItem>(), dropChance = 0.5f, min = 1, max = 1 }); } // Add new item button // if (GUILayout.Button(\"Add New Item\")) // { // var newItem = new LootDropDefinition.LootItems(); // newItem.zone = _selectedZone; // default value // newItem.dropTables.Add(new LootDropDefinition.DropTable() // { // dropType = LootDropDefinition.DropType.Weapon, // item = ScriptableObject.CreateInstance<vItem>(), // dropChance = 0.5f, // min = 1, // max = 1 // }); // // lootDropDefinition.LootItemsList.Add(newItem); //  ",
          "content_tokens": 1169,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootDropDefinitionEditor",
          "content": "if (GUILayout.Button(\"Export\")) { lootDropDefinition.ExportToJson();  if (GUILayout.Button(\"Save\")) { // Save changes to asset EditorUtility.SetDirty(lootDropDefinition); AssetDatabase.SaveAssets(); // Refresh asset database AssetDatabase.Refresh(); } serializedObject.ApplyModifiedProperties(); } private static void AddLabel(string txt, int width) { GUILayout.Label(txt, EditorStyles.boldLabel, GUILayout.Width(width)); } } }",
          "content_tokens": 123,
          "embedding": []
        }
      ],
      "length": 4342
    },
    {
      "filename": "PuzzleControllerEditor",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; [CustomEditor(typeof(PuzzleController))] public class PuzzleControllerEditor : Editor { //run AssignPuzzleMovablesIfNeed on PuzzleController public override void OnInspectorGUI() { // Draw the default inspector DrawDefaultInspector(); PuzzleController myScript = (PuzzleController)target; myScript.AssignPuzzleMovablesIfNeed(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PuzzleControllerEditor",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; [CustomEditor(typeof(PuzzleController))] public class PuzzleControllerEditor : Editor { //run AssignPuzzleMovablesIfNeed on PuzzleController public override void OnInspectorGUI() { // Draw the default inspector DrawDefaultInspector(); PuzzleController myScript = (PuzzleController)target; myScript.AssignPuzzleMovablesIfNeed(); } }",
          "content_tokens": 104,
          "embedding": []
        }
      ],
      "length": 430
    },
    {
      "filename": "RoomEnterTriggerDetectorEditor",
      "content": "using UnityEngine; using UnityEditor; #if UNITY_EDITOR [CustomEditor(typeof(RoomEnterTriggerDetector))] public class RoomEnterTriggerDetectorEditor : Editor { //automatically find single PuzzleController in children and call SetupRoomEnterTriggerDetector this private bool _isAssigned; public override void OnInspectorGUI() { // Draw the default inspector DrawDefaultInspector(); RoomEnterTriggerDetector myScript = (RoomEnterTriggerDetector)target; if (!_isAssigned) { PuzzleController puzzleController = myScript.GetComponentInChildren<PuzzleController>(); if (puzzleController != null) { puzzleController.SetupRoomEnterTriggerDetector(myScript); Debug.Log($\"RoomEnterTriggerDetector was assigned to {puzzleController.name}\", puzzleController); _isAssigned = true; } } } } #endif",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RoomEnterTriggerDetectorEditor",
          "content": "using UnityEngine; using UnityEditor; #if UNITY_EDITOR [CustomEditor(typeof(RoomEnterTriggerDetector))] public class RoomEnterTriggerDetectorEditor : Editor { //automatically find single PuzzleController in children and call SetupRoomEnterTriggerDetector this private bool _isAssigned; public override void OnInspectorGUI() { // Draw the default inspector DrawDefaultInspector(); RoomEnterTriggerDetector myScript = (RoomEnterTriggerDetector)target; if (!_isAssigned) { PuzzleController puzzleController = myScript.GetComponentInChildren<PuzzleController>(); if (puzzleController != null) { puzzleController.SetupRoomEnterTriggerDetector(myScript); Debug.Log($\"RoomEnterTriggerDetector was assigned to {puzzleController.name}\", puzzleController); _isAssigned = true; } } } } #endif",
          "content_tokens": 189,
          "embedding": []
        }
      ],
      "length": 781
    },
    {
      "filename": "EnemiesWithinSightNotifier",
      "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Object; using UnityEngine; public class EnemiesWithinSightNotifier : NetworkBehaviour { public string[] Obstacles = new[] {\"Obstacle\", \"Default\"}; [SerializeField] private bool _isDebug; private List<NetworkObject> _enemiesWithinSight = new List<NetworkObject>(); public override void OnStartClient() { base.OnStartClient(); StartCoroutine(TimedStartDetection()); } private void OnDisable() { //InstanceFinder.TimeManager.OnTick -= OnTick; } private IEnumerator TimedStartDetection() { yield return new WaitForSeconds(4f); //InstanceFinder.TimeManager.OnTick += OnTick; } private void OnTick() { var aiNobs = GameplayManager.LocalPlayer.GetAliveAIControlledNobs(); if (aiNobs == null) return; foreach (var aiNob in aiNobs) { //TODO replace GetComponent with pre-cached values AIUnit aiUnit = aiNob.GetComponent<AIUnit>(); Vector3 targetPos = aiUnit.Head.transform.position; Vector3 myPos = transform.position + Vector3.up; // Raise the position by 1f var direction = targetPos - myPos; float distance; Ray rayToTarget = RayToTarget(aiUnit.Head.transform, myPos, direction, out distance); if (distance > aiUnit.EnemyDefinition.ViewDistance) { if (aiUnit.PlayersWithinSight.Contains(NetworkObject.ObjectId)) { RemoveFromEnemiesWithinSight(aiUnit.NetworkObject); aiUnit.CmdRemoveTargetFromWithinSight(NetworkObject.ObjectId); } DebugWrite.Log($\"[WithinSight] {aiNob.name} is too far away [{distance.ToString(\"F0\")}]\", gameObject, _isDebug); continue; } RaycastHit hit; bool isHitObstacle = Physics.Raycast(rayToTarget, out hit, Mathf.Min(distance, aiNob.GetComponent<AIUnit>().EnemyDefinition.ViewDistance), LayerMask.GetMask(Obstacles)); if (isHitObstacle) { if (aiUnit.PlayersWithinSight.Contains(NetworkObject.ObjectId)) { RemoveFromEnemiesWithinSight(aiUnit.NetworkObject); aiUnit.CmdRemoveTargetFromWithinSight(NetworkObject.ObjectId); } DebugWrite.Log($\"[WithinSight] {aiNob.name} is behind obstacle [{hit.collider.gameObject.name}]\", gameObject, _isDebug); continue; } DebugWrite.Log($\"[WithinSight] {aiNob.name} is within view distance [{distance.ToString(\"F0\")}] of [{gameObject.name}]\", gameObject, _isDebug); if (!aiUnit.PlayersWithinSight.Contains(NetworkObject.ObjectId)) { AddToEnemiesWithinSight(aiUnit.NetworkObject); aiUnit.CmdAddTargetToWithinSight(NetworkObject.ObjectId); } } } private void AddToEnemiesWithinSight(NetworkObject networkObject) { if (_enemiesWithinSight.Contains(networkObject)) return; _enemiesWithinSight.Add(networkObject); } private void RemoveFromEnemiesWithinSight(NetworkObject networkObject) { if (!_enemiesWithinSight.Contains(networkObject)) return; _enemiesWithinSight.Remove(networkObject); } private Ray RayToTarget(Transform target, Vector3 startRayPos, Vector3 direction, out float distance) { distance = direction.magnitude; Ray ray = new Ray(startRayPos, direction); ray = new Ray(startRayPos, direction); Debug.DrawRay(startRayPos, direction, Color.red); return ray; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "EnemiesWithinSightNotifier",
          "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Object; using UnityEngine; public class EnemiesWithinSightNotifier : NetworkBehaviour { public string[] Obstacles = new[] {\"Obstacle\", \"Default\"}; [SerializeField] private bool _isDebug; private List<NetworkObject> _enemiesWithinSight = new List<NetworkObject>(); public override void OnStartClient() { base.OnStartClient(); StartCoroutine(TimedStartDetection());  ",
          "content_tokens": 151,
          "embedding": []
        },
        {
          "cs_scriptfile": "EnemiesWithinSightNotifier",
          "content": "private void OnDisable() { //InstanceFinder.TimeManager.OnTick -= OnTick; } private IEnumerator TimedStartDetection() { yield return new WaitForSeconds(4f); //InstanceFinder.TimeManager.OnTick += OnTick;  ",
          "content_tokens": 64,
          "embedding": []
        },
        {
          "cs_scriptfile": "EnemiesWithinSightNotifier",
          "content": "private void OnTick() { var aiNobs = GameplayManager.LocalPlayer.GetAliveAIControlledNobs(); if (aiNobs == null) return; foreach (var aiNob in aiNobs) { //TODO replace GetComponent with pre-cached values AIUnit aiUnit = aiNob.GetComponent<AIUnit>(); Vector3 targetPos = aiUnit.Head.transform.position; Vector3 myPos = transform.position + Vector3.up; // Raise the position by 1f var direction = targetPos - myPos; float distance; Ray rayToTarget = RayToTarget(aiUnit.Head.transform, myPos, direction, out distance); if (distance > aiUnit.EnemyDefinition.ViewDistance) { if (aiUnit.PlayersWithinSight.Contains(NetworkObject.ObjectId)) { RemoveFromEnemiesWithinSight(aiUnit.NetworkObject); aiUnit.CmdRemoveTargetFromWithinSight(NetworkObject.ObjectId); } DebugWrite.Log($\"[WithinSight] {aiNob.name} is too far away [{distance.ToString(\"F0\")}]\", gameObject, _isDebug); continue; } RaycastHit hit; bool isHitObstacle = Physics.Raycast(rayToTarget, out hit, Mathf.Min(distance, aiNob.GetComponent<AIUnit>().EnemyDefinition.ViewDistance), LayerMask.GetMask(Obstacles)); if (isHitObstacle) { if (aiUnit.PlayersWithinSight.Contains(NetworkObject.ObjectId)) { RemoveFromEnemiesWithinSight(aiUnit.NetworkObject); aiUnit.CmdRemoveTargetFromWithinSight(NetworkObject.ObjectId); } DebugWrite.Log($\"[WithinSight] {aiNob.name} is behind obstacle [{hit.collider.gameObject.name}]\", gameObject, _isDebug); continue; } DebugWrite.Log($\"[WithinSight] {aiNob.name} is within view distance [{distance.ToString(\"F0\")}] of [{gameObject.name}]\", gameObject, _isDebug); if (!aiUnit.PlayersWithinSight.Contains(NetworkObject.ObjectId)) { AddToEnemiesWithinSight(aiUnit.NetworkObject); aiUnit.CmdAddTargetToWithinSight(NetworkObject.ObjectId); } }  ",
          "content_tokens": 537,
          "embedding": []
        },
        {
          "cs_scriptfile": "EnemiesWithinSightNotifier",
          "content": "private void AddToEnemiesWithinSight(NetworkObject networkObject) { if (_enemiesWithinSight.Contains(networkObject)) return; _enemiesWithinSight.Add(networkObject);  private void RemoveFromEnemiesWithinSight(NetworkObject networkObject) { if (!_enemiesWithinSight.Contains(networkObject)) return; _enemiesWithinSight.Remove(networkObject); } private Ray RayToTarget(Transform target, Vector3 startRayPos, Vector3 direction, out float distance) { distance = direction.magnitude; Ray ray = new Ray(startRayPos, direction); ray = new Ray(startRayPos, direction); Debug.DrawRay(startRayPos, direction, Color.red); return ray; } }",
          "content_tokens": 166,
          "embedding": []
        }
      ],
      "length": 3128
    },
    {
      "filename": "FishnetClearServerFromClientOnlyGOs",
      "content": "using FishNet.Object; using UnityEngine; public class FishnetClearServerFromClientOnlyGOs : NetworkBehaviour { public override void OnStartServer() { base.OnStartServer(); var objsToDel = GameObject.FindGameObjectsWithTag(\"RemoveFromServer\"); foreach (var go in objsToDel) { Destroy(go); } RemoveThisObject(); } private void RemoveThisObject() { DestroyImmediate(this); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "FishnetClearServerFromClientOnlyGOs",
          "content": "using FishNet.Object; using UnityEngine; public class FishnetClearServerFromClientOnlyGOs : NetworkBehaviour { public override void OnStartServer() { base.OnStartServer(); var objsToDel = GameObject.FindGameObjectsWithTag(\"RemoveFromServer\"); foreach (var go in objsToDel) { Destroy(go); } RemoveThisObject(); } private void RemoveThisObject() { DestroyImmediate(this); } }",
          "content_tokens": 97,
          "embedding": []
        }
      ],
      "length": 374
    },
    {
      "filename": "BookExpController",
      "content": "using System.Collections; using System.Collections.Generic; using System.Linq; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Connection; using FishNet.Object; using FishnetInvector; using Invector.vItemManager; using UnityEngine; namespace InRoomSystems { public class BookExpController : InteractableObjectController { [SerializeField] private int _itemId = 0; [SerializeField] private float _ExpAmount = 100f; [SerializeField] private GameObject _ExpFx; [SerializeField] private GameObject _visualFX; private bool _isUsed = false; private bool isHaveItem = true; public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { OnPlayerFinishedInteracting += ConsumeBook; } } [Client] public void OnPlayerActionInput() { CmdPlayerEnteredSphere(); } [ServerRpc(RequireOwnership = false)] private void CmdPlayerEnteredSphere(NetworkConnection conn = null) { ConsumeBook(conn); } [Server] private void ConsumeBook(NetworkConnection conn) { if (_isUsed || !isHaveItem) return; isHaveItem = false; _isUsed = true; _triggerGenericAction.enabled = false; StringBuilder sb = new StringBuilder(); sb.Append($\"[BookExpController] Player {conn.ClientId} consumed a Book Exp!\"); UnitComponents unit = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); var playerItemManager = unit.ItemManager; var item = FishnetInvectorItemManager.LocalPlayer.ItemManager.GetAllItems().Where(x => x.id == _itemId).First(); playerItemManager.ServerAddListItemReferences(new List<ItemReference> { item.ToItemReference() }); DebugWrite.Log($\"{ClassName} received item #{item.id} {unit.ItemManager.gameObject.name} \", gameObject, _isDebug); //Despawn(NetworkObject); // sb.Append($\" Before Level: {unit.XpController.CurrentLevel}; \"); //// sb.Append($\" Before Stats: {unit.StatsController.get}; \"); // unit.XpController.AddXp(_ExpAmount); // var stats = unit.StatsController.GetStats(); // foreach(var stat in stats) // { // unit.StatsController.AddChanges(stat.StatType, CombatEntityStat.From.Bonus, 2); // } // sb.Append($\" After Exp: {unit.XpController.CurrentLevel}\"); // DebugWrite.Log($\"{sb}\", gameObject, _isDebug); #region Resilience Globules //byte abilityId = PassiveResilienceGlobules.ABILITY_ID; //if (unit.AbilityController.IsAbilityLearned(abilityId)) //{ // Ability ability = AbilityManager.Instance.GetAbility(abilityId); // ability.ServerAddStack(unit.AbilityController, 1); //} #endregion ObserversSpawnExpFx(unit.XpController.ObjectId); StartCoroutine(DespawnAfterTime()); } [Server] private IEnumerator DespawnAfterTime() { yield return new WaitForSeconds(3f); InstanceFinder.ServerManager.Despawn(gameObject); } [ObserversRpc] private void ObserversSpawnExpFx(int unitId) { _visualFX.SetActive(false); Transform target = GameplayManager.Instance.GetTargetTransformServerAndClient(unitId); StartCoroutine(ExpFX(target)); } [Client] private IEnumerator ExpFX(Transform target) { GameObject fx = Instantiate(_ExpFx, target.position, Quaternion.identity); fx.transform.SetParent(target); DebugWrite.Log($\"[BookExpController] Spawned exp fx for {target.name}\", gameObject, _isDebug); yield return new WaitForSeconds(2.0f); DebugWrite.Log($\"[BookExpController] Destroyed exp fx for {target.name}\", gameObject, _isDebug); Destroy(fx); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BookExpController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "BookExpController",
          "content": "using System.Collections; using System.Collections.Generic; using System.Linq; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Connection; using FishNet.Object; using FishnetInvector; using Invector.vItemManager; using UnityEngine; namespace InRoomSystems { public class BookExpController : InteractableObjectController { [SerializeField] private int _itemId = 0; [SerializeField] private float _ExpAmount = 100f; [SerializeField] private GameObject _ExpFx; [SerializeField] private GameObject _visualFX; private bool _isUsed = false; private bool isHaveItem = true; public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { OnPlayerFinishedInteracting += ConsumeBook; } } [Client] public void OnPlayerActionInput() { CmdPlayerEnteredSphere(); } [ServerRpc(RequireOwnership = false)] private void CmdPlayerEnteredSphere(NetworkConnection conn = null) { ConsumeBook(conn); } [Server] private void ConsumeBook(NetworkConnection conn) { if (_isUsed || !isHaveItem) return; isHaveItem = false; _isUsed = true; _triggerGenericAction.enabled = false; StringBuilder sb = new StringBuilder(); sb.Append($\"[BookExpController] Player {conn.ClientId} consumed a Book Exp!\"); UnitComponents unit = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); var playerItemManager = unit.ItemManager; var item = FishnetInvectorItemManager.LocalPlayer.ItemManager.GetAllItems().Where(x => x.id == _itemId).First(); playerItemManager.ServerAddListItemReferences(new List<ItemReference> { item.ToItemReference() }); DebugWrite.Log($\"{ClassName} received item #{item.id} {unit.ItemManager.gameObject.name} \", gameObject, _isDebug); //Despawn(NetworkObject); // sb.Append($\" Before Level: {unit.XpController.CurrentLevel}; \"); //// sb.Append($\" Before Stats: {unit.StatsController.get}; \"); // unit.XpController.AddXp(_ExpAmount); // var stats = unit.StatsController.GetStats(); // foreach(var stat in stats) // { // unit.StatsController.AddChanges(stat.StatType, CombatEntityStat.From.Bonus, 2); // } // sb.Append($\" After Exp: {unit.XpController.CurrentLevel}\"); // DebugWrite.Log($\"{sb}\", gameObject, _isDebug); #region Resilience Globules //byte abilityId = PassiveResilienceGlobules.ABILITY_ID; //if (unit.AbilityController.IsAbilityLearned(abilityId)) //{ // Ability ability = AbilityManager.Instance.GetAbility(abilityId); // ability.ServerAddStack(unit.AbilityController, 1); //} #endregion ObserversSpawnExpFx(unit.XpController.ObjectId); StartCoroutine(DespawnAfterTime()); } [Server] private IEnumerator DespawnAfterTime() { yield return new WaitForSeconds(3f); InstanceFinder.ServerManager.Despawn(gameObject); } [ObserversRpc] private void ObserversSpawnExpFx(int unitId) { _visualFX.SetActive(false); Transform target = GameplayManager.Instance.GetTargetTransformServerAndClient(unitId); StartCoroutine(ExpFX(target)); } [Client] private IEnumerator ExpFX(Transform target) { GameObject fx = Instantiate(_ExpFx, target.position, Quaternion.identity); fx.transform.SetParent(target); DebugWrite.Log($\"[BookExpController] Spawned exp fx for {target.name}\", gameObject, _isDebug); yield return new WaitForSeconds(2.0f); DebugWrite.Log($\"[BookExpController] Destroyed exp fx for {target.name}\", gameObject, _isDebug); Destroy(fx); } } }",
          "content_tokens": 964,
          "embedding": []
        }
      ],
      "length": 3378
    },
    {
      "filename": "BossLocationNotifier",
      "content": " using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; namespace InRoomSystems { public class BossLocationNotifier : ObjectLocationNotifier { [SerializeField] private RespawnManager _respawnManager; protected void Awake() { base.Awake(); } public void InitServer() { _respawnManager.OnBossSpawnPointsPopulated += UpdatePoints; } public void TeleportAllPlayersToBoss() { foreach (var unit in GameplayManager.GetAllPlayersHeroes()) { var unitComps = GameplayManager.Instance.GetUnitComponents(unit); unitComps.InvectorManager.ServerTeleportPlayer(_myCollection[0] + Vector3.up * 8); } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "BossLocationNotifier",
          "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; namespace InRoomSystems { public class BossLocationNotifier : ObjectLocationNotifier { [SerializeField] private RespawnManager _respawnManager; protected void Awake() { base.Awake(); } public void InitServer() { _respawnManager.OnBossSpawnPointsPopulated += UpdatePoints; } public void TeleportAllPlayersToBoss() { foreach (var unit in GameplayManager.GetAllPlayersHeroes()) { var unitComps = GameplayManager.Instance.GetUnitComponents(unit); unitComps.InvectorManager.ServerTeleportPlayer(_myCollection[0] + Vector3.up * 8); } } } }",
          "content_tokens": 175,
          "embedding": []
        }
      ],
      "length": 643
    },
    {
      "filename": "ChestController",
      "content": " using System.Collections; using System.Collections.Generic; using System.Text; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using FishnetInvector; using Invector.vItemManager; using SingletonsExtension; using UnityEngine; using UnityEngine.Events; using Zomb.Creatures.Helpers; namespace InRoomSystems { public class ChestController: InteractableObjectController { [SyncVar(OnChange = nameof(OnChestIsLooted))] private bool _isLooted; [SerializeField] private LootDropDefinition _lootDropDefinition; [SerializeField] private CratesSystem.Zone _zone; [SerializeField] private Transform _head; [SerializeField] private GameObject _openActionText; [SerializeField] private EnemyDefinition.PossibleItemRanges[] _itemRanges; [SerializeField] private int _itemsCount = 2; [SerializeField] private float _chanceMod = .1f; [SerializeField] private float _goldDropChance = .5f; [SerializeField] private Vector2Int _minMaxGoldDrops = new Vector2Int(10, 15); [SerializeField] private AnimatorDecorator animatorDecorator; [SerializeField] private NetworkedActionsAnimator networkedActionsAnimator; private static float ONE_ITEM_SPAWN_CHANCE = 1.0f; private static float TWO_ITEMS_SPAWN_CHANCE = .1f; private static float THREE_ITEMS_SPAWN_CHANCE = .03f; private List<ItemReference> _items; [SerializeField] private UnityEvent OnChestOpened; /// <summary> /// int clientId, opening coroutine /// </summary> private Dictionary<int, Coroutine> chestOpeningCoroutines = new (); public override void OnStartServer() { base.OnStartServer(); OnPlayerStartedInteracting += ServerStartPlayerAnimation; OnPlayerFinishedInteracting += ServerOpenChest; OnInitialized += PopulateChestWithItems; } protected override void PlayerFinishedInteracting() { } [Server] private void ServerStartPlayerAnimation(NetworkConnection conn) { UnitComponents player = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); NetworkedActionsAnimator networkedActionsAnimator = player.InvectorManager.NetworkedActionsAnimator; networkedActionsAnimator.PlayChestOpeningAnimation(_triggerGenericAction.buttonTimer); StartOpeningTimerForPlayer(conn); } private void StartOpeningTimerForPlayer(NetworkConnection conn) { if (!chestOpeningCoroutines.ContainsKey(conn.ClientId)) { chestOpeningCoroutines.Add(conn.ClientId, StartCoroutine(OpenChest(conn, _triggerGenericAction.buttonTimer))); } else { if (chestOpeningCoroutines[conn.ClientId] != null) StopCoroutine(chestOpeningCoroutines[conn.ClientId]); chestOpeningCoroutines[conn.ClientId] = StartCoroutine(OpenChest(conn, _triggerGenericAction.buttonTimer)); } } [Server] private IEnumerator OpenChest(NetworkConnection conn, float buttonTimer) { yield return new WaitForSeconds(buttonTimer); OnPlayerFinishedInteracting?.Invoke(conn); } protected override void OnValidate() { base.OnValidate(); } public override void OnStartClient() { base.OnStartClient(); OnPlayerStartedInteracting += ClientStartInteracting; OnPlayerCanceledInteracting += ClientCancelInteracting; } private void ClientStartInteracting(NetworkConnection owner) { FishnetInvectorManager.LocalPlayer.NetworkedActionsAnimator.PlayChestOpeningForLocalPlayer(_triggerGenericAction.buttonTimer); } private void ClientCancelInteracting(NetworkConnection myConn) { FishnetInvectorManager.LocalPlayer.NetworkedActionsAnimator.BreakChestOpeningForLocalPlayer(); FishnetInvectorManager.LocalPlayer.NetworkedActionsAnimator.CmdBreakChestOpening(); CmdClearChestOpeningCoroutine(myConn); } [ServerRpc(RequireOwnership = false)] private void CmdClearChestOpeningCoroutine(NetworkConnection conn) { if (chestOpeningCoroutines.ContainsKey(conn.ClientId)) { if (chestOpeningCoroutines[conn.ClientId] != null) StopCoroutine(chestOpeningCoroutines[conn.ClientId]); chestOpeningCoroutines[conn.ClientId] = null; } } [Server] private void ServerOpenChest(NetworkConnection conn) { _isLooted = true; DebugLog($\"{ClassName} ServerOpenChest() called by {conn.ClientId}\"); var playerComps = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); //var playerItemManager = playerComps.ItemManager; GameplayManager.Instance.LootDropSystem.DropLootItems(_items, transform.position + Vector3.up); //playerItemManager.ServerAddListItemReferences(_items); DebugLog($\"{ClassName} Player {conn.ClientId} received {_items.Count} items from chest.\"); _openActionText.SetActive(false); } private void OnChestIsLooted(bool prev, bool next, bool asServer) { Vector3 rotationNext = next ? new Vector3(-130.0f, .0f, .0f) : Vector3.zero; Vector3 rotationPrev = prev ? new Vector3(-130.0f, .0f, .0f) : Vector3.zero; if (asServer) { if (animatorDecorator == null) SetObjectRotation(_head, rotationNext); else { animatorDecorator.SetBool(\"IsOpened\", true); } } else { OnChestOpened?.Invoke(); ChestOpened(); if (animatorDecorator == null) StartCoroutine(RotateObject(_head, rotationPrev, rotationNext)); } } private void ChestOpened() { animatorDecorator.SetBool(\"IsOpened\", false); } [Server] private void PopulateChestWithItems() { List<ItemReference> items = GameplayManager.Instance.LootDropSystem.GenerateLoot(_itemRanges, _itemsCount, _chanceMod); List<ItemReference> itemsBackup = new List<ItemReference>(items); StringBuilder sb = new StringBuilder($\"{ClassName} PopulateChestWithItems: \"); if (GameplayManager.Instance.LootDropSystem.AddGoldDrop(_goldDropChance, _minMaxGoldDrops.x, _minMaxGoldDrops.y, ref items)) { sb.Append($\"Gold: {items[items.Count-1].amount}; \"); } _items = items; if (_items[0]==null) { Debug.LogError($\"{ClassName} PopulateChestWithItems: itemsBackup[0] != null && _items[0]==null\"); } if (_isDebug) { foreach (ItemReference itemRef in _items) { if (itemRef == null) { Debug.LogError($\"{ClassName} PopulateChestWithItems: itemRef == null\"); } sb.Append($\"itemRef.id: {itemRef.id}\"); vItem vitem = MasterManager.Instance.ItemListData.items.Find(item => item.id == itemRef.id); sb.Append($\"{vitem.Name}, \"); } DebugLog($\"{ClassName} Chest populated with {_items.Count} items: {sb}\"); } } public override void ShowOpenActionText() { if (_isLooted) return; base.ShowOpenActionText(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ChestController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChestController",
          "content": " using System.Collections; using System.Collections.Generic; using System.Text; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using FishnetInvector; using Invector.vItemManager; using SingletonsExtension; using UnityEngine; using UnityEngine.Events; using Zomb.Creatures.Helpers; namespace InRoomSystems { public class ChestController: InteractableObjectController { [SyncVar(OnChange = nameof(OnChestIsLooted))] private bool _isLooted; [SerializeField] private LootDropDefinition _lootDropDefinition; [SerializeField] private CratesSystem.Zone _zone; [SerializeField] private Transform _head; [SerializeField] private GameObject _openActionText; [SerializeField] private EnemyDefinition.PossibleItemRanges[] _itemRanges; [SerializeField] private int _itemsCount = 2; [SerializeField] private float _chanceMod = .1f; [SerializeField] private float _goldDropChance = .5f; [SerializeField] private Vector2Int _minMaxGoldDrops = new Vector2Int(10, 15); [SerializeField] private AnimatorDecorator animatorDecorator; [SerializeField] private NetworkedActionsAnimator networkedActionsAnimator; private static float ONE_ITEM_SPAWN_CHANCE = 1.0f; private static float TWO_ITEMS_SPAWN_CHANCE = .1f; private static float THREE_ITEMS_SPAWN_CHANCE = .03f; private List<ItemReference> _items; [SerializeField] private UnityEvent OnChestOpened; /// <summary> /// int clientId, opening coroutine /// </summary> private Dictionary<int, Coroutine> chestOpeningCoroutines = new (); public override void OnStartServer() { base.OnStartServer(); OnPlayerStartedInteracting += ServerStartPlayerAnimation; OnPlayerFinishedInteracting += ServerOpenChest; OnInitialized += PopulateChestWithItems; } protected override void PlayerFinishedInteracting() { } [Server] private void ServerStartPlayerAnimation(NetworkConnection conn) { UnitComponents player = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); NetworkedActionsAnimator networkedActionsAnimator = player.InvectorManager.NetworkedActionsAnimator; networkedActionsAnimator.PlayChestOpeningAnimation(_triggerGenericAction.buttonTimer); StartOpeningTimerForPlayer(conn);  ",
          "content_tokens": 594,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChestController",
          "content": "private void StartOpeningTimerForPlayer(NetworkConnection conn) { if (!chestOpeningCoroutines.ContainsKey(conn.ClientId)) { chestOpeningCoroutines.Add(conn.ClientId, StartCoroutine(OpenChest(conn, _triggerGenericAction.buttonTimer))); } else { if (chestOpeningCoroutines[conn.ClientId] != null) StopCoroutine(chestOpeningCoroutines[conn.ClientId]); chestOpeningCoroutines[conn.ClientId] = StartCoroutine(OpenChest(conn, _triggerGenericAction.buttonTimer)); } } [Server] private IEnumerator OpenChest(NetworkConnection conn, float buttonTimer) { yield return new WaitForSeconds(buttonTimer); OnPlayerFinishedInteracting?.Invoke(conn); } protected override void OnValidate() { base.OnValidate(); } public override void OnStartClient() { base.OnStartClient(); OnPlayerStartedInteracting += ClientStartInteracting; OnPlayerCanceledInteracting += ClientCancelInteracting;  ",
          "content_tokens": 229,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChestController",
          "content": "private void ClientStartInteracting(NetworkConnection owner) { FishnetInvectorManager.LocalPlayer.NetworkedActionsAnimator.PlayChestOpeningForLocalPlayer(_triggerGenericAction.buttonTimer);  ",
          "content_tokens": 44,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChestController",
          "content": "private void ClientCancelInteracting(NetworkConnection myConn) { FishnetInvectorManager.LocalPlayer.NetworkedActionsAnimator.BreakChestOpeningForLocalPlayer(); FishnetInvectorManager.LocalPlayer.NetworkedActionsAnimator.CmdBreakChestOpening(); CmdClearChestOpeningCoroutine(myConn); } [ServerRpc(RequireOwnership = false)] private void CmdClearChestOpeningCoroutine(NetworkConnection conn) { if (chestOpeningCoroutines.ContainsKey(conn.ClientId)) { if (chestOpeningCoroutines[conn.ClientId] != null) StopCoroutine(chestOpeningCoroutines[conn.ClientId]); chestOpeningCoroutines[conn.ClientId] = null; } } [Server] private void ServerOpenChest(NetworkConnection conn) { _isLooted = true; DebugLog($\"{ClassName}",
          "content_tokens": 192,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChestController",
          "content": "ServerOpenChest() called by {conn.ClientId}\"); var playerComps = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); //var playerItemManager = playerComps.ItemManager; GameplayManager.Instance.LootDropSystem.DropLootItems(_items, transform.position + Vector3.up); //playerItemManager.ServerAddListItemReferences(_items); DebugLog($\"{ClassName} Player {conn.ClientId} received {_items.Count} items from chest.\"); _openActionText.SetActive(false);  ",
          "content_tokens": 127,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChestController",
          "content": "private void OnChestIsLooted(bool prev, bool next, bool asServer) { Vector3 rotationNext = next ? new Vector3(-130.0f, .0f, .0f) : Vector3.zero; Vector3 rotationPrev = prev ? new Vector3(-130.0f, .0f, .0f) : Vector3.zero; if (asServer) { if (animatorDecorator == null) SetObjectRotation(_head, rotationNext); else { animatorDecorator.SetBool(\"IsOpened\", true); } } else { OnChestOpened?.Invoke(); ChestOpened(); if (animatorDecorator == null) StartCoroutine(RotateObject(_head, rotationPrev, rotationNext)); }  ",
          "content_tokens": 170,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChestController",
          "content": "private void ChestOpened() { animatorDecorator.SetBool(\"IsOpened\", false); } [Server] private void PopulateChestWithItems() { List<ItemReference> items = GameplayManager.Instance.LootDropSystem.GenerateLoot(_itemRanges, _itemsCount, _chanceMod); List<ItemReference> itemsBackup = new List<ItemReference>(items); StringBuilder sb = new StringBuilder($\"{ClassName} PopulateChestWithItems: \"); if (GameplayManager.Instance.LootDropSystem.AddGoldDrop(_goldDropChance, _minMaxGoldDrops.x, _minMaxGoldDrops.y, ref items)) { sb.Append($\"Gold: {items[items.Count-1].amount}; \"); } _items = items; if (_items[0]==null) { Debug.LogError($\"{ClassName} PopulateChestWithItems: itemsBackup[0] != null && _items[0]==null\");  ",
          "content_tokens": 225,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChestController",
          "content": "if (_isDebug) { foreach (ItemReference itemRef in _items) { if (itemRef == null) { Debug.LogError($\"{ClassName} PopulateChestWithItems: itemRef == null\"); } sb.Append($\"itemRef.id: {itemRef.id}\"); vItem vitem = MasterManager.Instance.ItemListData.items.Find(item => item.id == itemRef.id); sb.Append($\"{vitem.Name}, \");  DebugLog($\"{ClassName} Chest populated with {_items.Count} items: {sb}\"); } } public override void ShowOpenActionText() { if (_isLooted) return; base.ShowOpenActionText(); } } }",
          "content_tokens": 165,
          "embedding": []
        }
      ],
      "length": 6212
    },
    {
      "filename": "CratesSystem",
      "content": "using System; using System.Collections; using System.Collections.Generic; using System.Text; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Connection; using FishNet.Object; using FishnetInvector; using UnityEngine; using Random = UnityEngine.Random; namespace InRoomSystems{ public class CratesSystem : RoomManager { private const string CHEST_TAG = \"Chest\"; private float CRATES_SPAWN_CHANCE = 1.0f; private int MAXIMUM_CRATE_POINTS = 100; protected string OBJECT_TAG = \"Chest\"; public Dictionary<int, List<CratePoint>> PlayerCratesPositions => _playerCratesPositions; [SerializeField] private FNvItemCollection _crateTriggerPrefab; [SerializeField] private List<CratePoint> _allCratePositions = new List<CratePoint>(); private Dictionary<int, List<CratePoint>> _playerCratesPositions = new Dictionary<int, List<CratePoint>>(); [SerializeField] private LootDropDefinition _lootDropDefinition; [SerializeField] private CratePositionsTable _cratePositionsTable; public override void OnStartNetwork() { base.OnStartNetwork(); try { if (IsServer) { //GameplayManager.OnPlayerJoinedRoom += GameplayManager_OnPlayerJoinedRoom; //InitCrateLoots(); } }catch (Exception e) { Debug.LogError($\"{ClassAndRoomName} OnStartNetwork: {e}\"); } } private void InitCrateLoots() { LoadDataTables(); if (_allCratePositions.Count == 0) { return; } for (int i = 0; i < _allCratePositions.Count; i++) { _allCratePositions[i].Items = GenerateLootForCrate(_allCratePositions[i]); } } private void GeneratePossiblePositions() { GameObject[] roomDoors = GameObject.FindGameObjectsWithTag(CHEST_TAG); } public void LoadDataTables() { _lootDropDefinition = Resources.Load<LootDropDefinition>(\"LootDropDefinitionSO\"); //TODO: Remove this _cratePositionsTable = Resources.Load<CratePositionsTable>(\"CratePositionsTableSO\"); } private List<CrateItem> GenerateLootForCrate(CratePoint cratePoint) { var cratePointZone = cratePoint.Zone; var possibleLoot = _lootDropDefinition.GetLoot(cratePointZone); List<CrateItem> items = new List<CrateItem>(); GenerateItems(items, possibleLoot); GenerateMoney(items, possibleLoot); return items; } private List<CrateItem> GenerateLootForCrate() { var cratePointZone = (Zone)0; var possibleLoot = _lootDropDefinition.GetLoot(cratePointZone); List<CrateItem> items = new List<CrateItem>(); GenerateItems(items, possibleLoot); GenerateMoney(items, possibleLoot); return items; } private static void GenerateMoney(List<CrateItem> items, LootDropDefinition.LootItems possibleLoot) { bool isOnlyOneTypeOfMoney = true; foreach (var table in possibleLoot.dropTables) { bool isNotMoney = table.dropType != LootDropDefinition.DropType.Coins; if (isNotMoney) { continue; } float chance = Random.Range(0.0f, 1.0f); if (chance <= table.dropChance) { int amount = table.max == 1 ? 1 : Random.Range(table.min, table.max); CrateItem crateItem = new CrateItem(table.item.id, amount, (int)table.item.equipArea); items.Add(crateItem); if (isOnlyOneTypeOfMoney) break; } } } private static void GenerateItems(List<CrateItem> items, LootDropDefinition.LootItems possibleLoot) { bool isOnlyOneTypeOfItem = true; foreach (var table in possibleLoot.dropTables) { bool isMoney = table.dropType == LootDropDefinition.DropType.Coins; if (isMoney) { continue; } float chance = Random.Range(0.0f, 1.0f); if (chance <= table.dropChance) { int amount = table.max == 1 ? 1 : Random.Range(table.min, table.max); CrateItem crateItem = new CrateItem(table.item.id, amount, (int)table.item.equipArea); items.Add(crateItem); if (isOnlyOneTypeOfItem) break; } } } public override void OnStartServer() { base.OnStartServer(); try { StartCoroutine(CheckPlayers()); }catch (Exception e) { Debug.LogError($\"{ClassAndRoomName} OnStartServer: {e}\"); } } [Server] private void GameplayManager_OnPlayerJoinedRoom(NetworkObject playerCharacter) { InitCratesForPlayer(playerCharacter); } [Server] private void InitCratesForPlayer(NetworkObject playerCharacter) { StringBuilder sb = new StringBuilder($\"{ClassAndRoomName}[InitCratesForPlayer] Player #{playerCharacter.ObjectId}\"); for (int i = 0; i < _allCratePositions.Count; i++) { if (Random.Range(0.0f, 1.0f) <= CRATES_SPAWN_CHANCE) { CratePoint cratePoint = new CratePoint(); cratePoint.Id = (ushort)i; cratePoint.Position = _allCratePositions[i].Position; cratePoint.Rotation = _allCratePositions[i].Rotation; cratePoint.Zone = _allCratePositions[i].Zone; cratePoint.Items = _allCratePositions[i].Items; AddCratePointToPlayer(playerCharacter.ObjectId, cratePoint); sb.Append($\" #{cratePoint.Id}: {cratePoint.Position},\"); } } Debug.Log($\"{sb}\"); if (PlayerCratesPositions.ContainsKey(playerCharacter.ObjectId)) { Debug.Log($\"{ClassAndRoomName}[InitCratesForPlayer] Player #{playerCharacter.ObjectId} has {PlayerCratesPositions[playerCharacter.ObjectId].Count} possible crates\"); } else { Debug.LogError($\"[InitCratesForPlayer] Player #{playerCharacter.ObjectId} has no crates\"); } } [Server] private IEnumerator CheckPlayers() { //TODO optimize using chunks var time = new WaitForSeconds(5f); while (true) { foreach (var kv in PlayerCratesPositions) { int playerObjectId = kv.Key; if (!InstanceFinder.ServerManager.Objects.Spawned.ContainsKey(playerObjectId)) { Debug.Log($\"{ClassAndRoomName}[CheckPlayers] Player #{playerObjectId} has left the room\"); continue; } StringBuilder sb = new StringBuilder(); sb.Append($\"{ClassAndRoomName}[CheckPlayers] Check Player #{playerObjectId}'s position against crates: \"); NetworkObject playerCharacter = InstanceFinder.ServerManager.Objects.Spawned[playerObjectId]; Vector3 playerPos = playerCharacter.transform.position; for (int i = 0; i < kv.Value.Count; i++) { sb.Append($\"{kv.Value[i].Id}\"); CratePoint cratePoint = kv.Value[i]; if (cratePoint.isLooted) { continue; } //Debug.Log($\"{ClassAndRoomName}[CheckPlayers] Player #{playerObjectId}({playerPos.x};{playerPos.z})/({cratePos.x};{cratePos.z}) is {distance} units away from crate #{kv.Value[i].Id}\"); if (CommonMath.Math.IsWithinRange(playerPos, cratePoint.Position, 10.0f)) { RemoveCratePointFromPlayer(playerObjectId, cratePoint.Id); SpawnCrateForPlayer(playerCharacter.Owner,cratePoint.Id); sb.Append($\" (spawned), \"); } else { sb.Append($\",\"); } } Debug.Log(sb.ToString()); } yield return time; } } [TargetRpc] private void SpawnCrateForPlayer(NetworkConnection conn, ushort crateId) { Debug.Log($\"{ClassAndRoomName}[SpawnCrateForPlayer] Spawn crate #{crateId} for this player\"); Quaternion rotation = Quaternion.Euler(_allCratePositions[crateId].Rotation); FNvItemCollection crate = Instantiate(_crateTriggerPrefab, _allCratePositions[crateId].Position, rotation); List<CrateItem> newItems = GenerateLootForCrate(); crate.Init(crateId, this, newItems); Debug.Log($\"{ClassAndRoomName}[SpawnCrateForPlayer] Crate #{crateId} {crate.name} spawned\", crate); } private CratePoint GetLootAtCratePoint(ushort crateId) => _allCratePositions[crateId]; [Server] private void AddCratePointToPlayer(int playerId, CratePoint cratePoint) { var tempCratePointList = new List<CratePoint>(); bool isNeedToAddNewPlayerId = !PlayerCratesPositions.ContainsKey(playerId); if (isNeedToAddNewPlayerId) { tempCratePointList.Add(cratePoint); }else{ tempCratePointList = PlayerCratesPositions[playerId]; tempCratePointList.Add(cratePoint); } _playerCratesPositions[playerId] = tempCratePointList; } [Server] private void RemoveCratePointFromPlayer(int playerId, ushort id) { if (!PlayerCratesPositions.ContainsKey(playerId)) { return; } foreach (var point in PlayerCratesPositions[playerId]) { if (point.Id == id) { _playerCratesPositions[playerId].Remove(point); return; } } } [Client] public void OnCrateLooted(ushort crateId) { Debug.Log($\"[OnCrateLooted] {crateId}\"); if (IsServer) { return; } CmdReportCrateLooted(crateId); } [ServerRpc(RequireOwnership = false)] private void CmdReportCrateLooted(ushort crateId, NetworkConnection conn = null) { Debug.Log($\"[CmdReportCrateLooted] {crateId}\"); foreach (var playerChar in GameplayManager.GetAllPlayersHeroes()) { if (playerChar.Owner == conn) { RemoveCratePointFromPlayer(playerChar.ObjectId, crateId); AddLootedCrateToPlayer(playerChar.ObjectId, crateId, out int[] itemIds, out int[] itemAmounts); RpcReportToPlayerAboutloot(conn, itemIds, itemAmounts); Debug.Log($\"{ClassAndRoomName}[CmdReportCrateLooted] Player #{playerChar.ObjectId} looted crate #{crateId}\"); return; } } } private void AddLootedCrateToPlayer(int playerCharObjectId, ushort crateId, out int[] itemIds, out int[] itemAmounts) { ///TODO give loot to player on server throw new System.NotImplementedException(); } [TargetRpc] private void RpcReportToPlayerAboutloot(NetworkConnection conn, int[] itemIds, int[] amounts) { Debug.Log($\"[RpcReportToPlayerAboutloot] {itemIds.Length} items\"); ///TODO give player his loot locally } #region HelperClasses public enum Zone { level1, level2, level3, Boss } [Serializable] public class CratePoint { public ushort Id; public Zone Zone; public bool isLooted; public Vector3 Position; public Vector3 Rotation; public List<CrateItem> Items; } [Serializable] public class CrateItem { public int ItemId; public int Amount; public ushort Ammo; public int indexArea; public CrateItem(int itemId, int amount, int indexArea, ushort ammo = 0) { ItemId = itemId; Amount = amount; Ammo = ammo; indexArea = indexArea; } } #endregion } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CratesSystem",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "CratesSystem",
          "content": "using System; using System.Collections; using System.Collections.Generic; using System.Text; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Connection; using FishNet.Object; using FishnetInvector; using UnityEngine; using Random = UnityEngine.Random; namespace InRoomSystems{ public class CratesSystem : RoomManager { private const string CHEST_TAG = \"Chest\"; private float CRATES_SPAWN_CHANCE = 1.0f; private int MAXIMUM_CRATE_POINTS = 100; protected string OBJECT_TAG = \"Chest\"; public Dictionary<int, List<CratePoint>> PlayerCratesPositions => _playerCratesPositions; [SerializeField] private FNvItemCollection _crateTriggerPrefab; [SerializeField] private List<CratePoint> _allCratePositions = new List<CratePoint>(); private Dictionary<int, List<CratePoint>> _playerCratesPositions = new Dictionary<int, List<CratePoint>>(); [SerializeField] private LootDropDefinition _lootDropDefinition; [SerializeField] private CratePositionsTable _cratePositionsTable; public override void OnStartNetwork() { base.OnStartNetwork(); try { if (IsServer) { //GameplayManager.OnPlayerJoinedRoom += GameplayManager_OnPlayerJoinedRoom; //InitCrateLoots(); }  ",
          "content_tokens": 322,
          "embedding": []
        },
        {
          "cs_scriptfile": "CratesSystem",
          "content": "catch (Exception e) { Debug.LogError($\"{ClassAndRoomName} OnStartNetwork: {e}\"); }  private void InitCrateLoots() { LoadDataTables(); if (_allCratePositions.Count == 0) { return;  for (int i = 0; i < _allCratePositions.Count; i++) { _allCratePositions[i].Items = GenerateLootForCrate(_allCratePositions[i]); }  private void GeneratePossiblePositions() { GameObject[] roomDoors = GameObject.FindGameObjectsWithTag(CHEST_TAG);  ",
          "content_tokens": 142,
          "embedding": []
        },
        {
          "cs_scriptfile": "CratesSystem",
          "content": "public void LoadDataTables() { _lootDropDefinition = Resources.Load<LootDropDefinition>(\"LootDropDefinitionSO\"); //TODO: Remove this _cratePositionsTable = Resources.Load<CratePositionsTable>(\"CratePositionsTableSO\"); } private List<CrateItem> GenerateLootForCrate(CratePoint cratePoint) { var cratePointZone = cratePoint.Zone; var possibleLoot = _lootDropDefinition.GetLoot(cratePointZone); List<CrateItem> items = new List<CrateItem>(); GenerateItems(items, possibleLoot); GenerateMoney(items, possibleLoot); return items; } private List<CrateItem> GenerateLootForCrate() { var cratePointZone = (Zone)0; var possibleLoot = _lootDropDefinition.GetLoot(cratePointZone); List<CrateItem> items = new List<CrateItem>(); GenerateItems(items, possibleLoot); GenerateMoney(items, possibleLoot); return items; } private static void GenerateMoney(List<CrateItem> items, LootDropDefinition.LootItems possibleLoot) { bool isOnlyOneTypeOfMoney = true; foreach (var table in possibleLoot.dropTables) { bool isNotMoney = table.dropType != LootDropDefinition.DropType.Coins; if (isNotMoney) { continue; } float chance = Random.Range(0.0f, 1.0f); if (chance <= table.dropChance) { int amount = table.max == 1 ? 1 : Random.Range(table.min, table.max); CrateItem crateItem = new CrateItem(table.item.id, amount, (int)table.item.equipArea); items.Add(crateItem); if (isOnlyOneTypeOfMoney) break; } } } private static void GenerateItems(List<CrateItem> items, LootDropDefinition.LootItems possibleLoot) { bool isOnlyOneTypeOfItem = true; foreach (var table in possibleLoot.dropTables) { bool isMoney = table.dropType == LootDropDefinition.DropType.Coins; if (isMoney) { continue; } float chance = Random.Range(0.0f, 1.0f); if (chance <= table.dropChance) { int amount = table.max == 1 ? 1 : Random.Range(table.min, table.max); CrateItem crateItem = new CrateItem(table.item.id, amount, (int)table.item.equipArea); items.Add(crateItem); if (isOnlyOneTypeOfItem) break; } } } public override void OnStartServer() { base.OnStartServer(); try { StartCoroutine(CheckPlayers());  ",
          "content_tokens": 628,
          "embedding": []
        },
        {
          "cs_scriptfile": "CratesSystem",
          "content": "catch (Exception e) { Debug.LogError($\"{ClassAndRoomName} OnStartServer: {e}\"); } } [Server] private void GameplayManager_OnPlayerJoinedRoom(NetworkObject playerCharacter) { InitCratesForPlayer(playerCharacter); } [Server] private void InitCratesForPlayer(NetworkObject playerCharacter) { StringBuilder sb = new StringBuilder($\"{ClassAndRoomName}[InitCratesForPlayer] Player #{playerCharacter.ObjectId}\"); for (int i = 0; i < _allCratePositions.Count; i++) { if (Random.Range(0.0f, 1.0f) <= CRATES_SPAWN_CHANCE) { CratePoint cratePoint = new CratePoint(); cratePoint.Id = (ushort)i; cratePoint.Position = _allCratePositions[i].Position; cratePoint.Rotation = _allCratePositions[i].Rotation; cratePoint.Zone = _allCratePositions[i].Zone; cratePoint.Items = _allCratePositions[i].Items; AddCratePointToPlayer(playerCharacter.ObjectId, cratePoint); sb.Append($\" #{cratePoint.Id}: {cratePoint.Position},\"); } } Debug.Log($\"{sb}\"); if (PlayerCratesPositions.ContainsKey(playerCharacter.ObjectId)) { Debug.Log($\"{ClassAndRoomName}[InitCratesForPlayer] Player #{playerCharacter.ObjectId} has {PlayerCratesPositions[playerCharacter.ObjectId].Count} possible crates\"); } else { Debug.LogError($\"[InitCratesForPlayer] Player #{playerCharacter.ObjectId} has no crates\"); } } [Server] private IEnumerator CheckPlayers() { //TODO optimize using chunks var time = new WaitForSeconds(5f); while (true) { foreach (var kv in PlayerCratesPositions) { int playerObjectId = kv.Key; if (!InstanceFinder.ServerManager.Objects.Spawned.ContainsKey(playerObjectId)) { Debug.Log($\"{ClassAndRoomName}[CheckPlayers] Player #{playerObjectId} has left the room\"); continue; } StringBuilder sb = new StringBuilder(); sb.Append($\"{ClassAndRoomName}[CheckPlayers] Check Player #{playerObjectId}'s position against crates: \"); NetworkObject playerCharacter = InstanceFinder.ServerManager.Objects.Spawned[playerObjectId]; Vector3 playerPos = playerCharacter.transform.position; for (int i = 0; i < kv.Value.Count; i++) { sb.Append($\"{kv.Value[i].Id}\"); CratePoint cratePoint = kv.Value[i]; if (cratePoint.isLooted) { continue; } //Debug.Log($\"{ClassAndRoomName}[CheckPlayers] Player #{playerObjectId}({playerPos.x};{playerPos.z})/({cratePos.x};{cratePos.z}) is {distance} units away from crate #{kv.Value[i].Id}\"); if (CommonMath.Math.IsWithinRange(playerPos, cratePoint.Position, 10.0f)) { RemoveCratePointFromPlayer(playerObjectId, cratePoint.Id); SpawnCrateForPlayer(playerCharacter.Owner,cratePoint.Id); sb.Append($\" (spawned), \"); } else { sb.Append($\",\"); } } Debug.Log(sb.ToString()); } yield return time; } } [TargetRpc] private void SpawnCrateForPlayer(NetworkConnection conn, ushort crateId) { Debug.Log($\"{ClassAndRoomName}[SpawnCrateForPlayer] Spawn crate #{crateId} for this player\"); Quaternion rotation = Quaternion.Euler(_allCratePositions[crateId].Rotation); FNvItemCollection crate = Instantiate(_crateTriggerPrefab, _allCratePositions[crateId].Position, rotation); List<CrateItem> newItems = GenerateLootForCrate(); crate.Init(crateId, this, newItems); Debug.Log($\"{ClassAndRoomName}[SpawnCrateForPlayer] Crate #{crateId} {crate.name} spawned\", crate); } private CratePoint GetLootAtCratePoint(ushort crateId) => _allCratePositions[crateId]; [Server] private void AddCratePointToPlayer(int playerId, CratePoint cratePoint) { var tempCratePointList = new List<CratePoint>(); bool isNeedToAddNewPlayerId = !PlayerCratesPositions.ContainsKey(playerId); if (isNeedToAddNewPlayerId) { tempCratePointList.Add(cratePoint); }else{ tempCratePointList = PlayerCratesPositions[playerId]; tempCratePointList.Add(cratePoint); } _playerCratesPositions[playerId] = tempCratePointList; } [Server] private void RemoveCratePointFromPlayer(int playerId, ushort id) { if (!PlayerCratesPositions.ContainsKey(playerId)) { return;  ",
          "content_tokens": 1190,
          "embedding": []
        },
        {
          "cs_scriptfile": "CratesSystem",
          "content": "foreach (var point in PlayerCratesPositions[playerId]) { if (point.Id == id) { _playerCratesPositions[playerId].Remove(point); return; } } } [Client] public void OnCrateLooted(ushort crateId) { Debug.Log($\"[OnCrateLooted] {crateId}\"); if (IsServer) { return;  ",
          "content_tokens": 90,
          "embedding": []
        },
        {
          "cs_scriptfile": "CratesSystem",
          "content": "CmdReportCrateLooted(crateId); } [ServerRpc(RequireOwnership = false)] private void CmdReportCrateLooted(ushort crateId, NetworkConnection conn = null) { Debug.Log($\"[CmdReportCrateLooted] {crateId}\"); foreach (var playerChar in GameplayManager.GetAllPlayersHeroes()) { if (playerChar.Owner == conn) { RemoveCratePointFromPlayer(playerChar.ObjectId, crateId); AddLootedCrateToPlayer(playerChar.ObjectId, crateId, out int[] itemIds, out int[] itemAmounts); RpcReportToPlayerAboutloot(conn, itemIds, itemAmounts); Debug.Log($\"{ClassAndRoomName}[CmdReportCrateLooted] Player #{playerChar.ObjectId} looted crate #{crateId}\"); return; } }  ",
          "content_tokens": 206,
          "embedding": []
        },
        {
          "cs_scriptfile": "CratesSystem",
          "content": "private void AddLootedCrateToPlayer(int playerCharObjectId, ushort crateId, out int[] itemIds, out int[] itemAmounts) { ///TODO give loot to player on server throw new System.NotImplementedException(); } [TargetRpc] private void RpcReportToPlayerAboutloot(NetworkConnection conn, int[] itemIds, int[] amounts) { Debug.Log($\"[RpcReportToPlayerAboutloot] {itemIds.Length} items\"); ///TODO give player his loot locally } #region HelperClasses public enum Zone { level1, level2, level3, Boss } [Serializable] public class CratePoint { public ushort Id; public Zone Zone; public bool isLooted; public Vector3 Position; public Vector3 Rotation; public List<CrateItem> Items; } [Serializable] public class CrateItem { public int ItemId; public int Amount; public ushort Ammo; public int indexArea; public CrateItem(int itemId, int amount, int indexArea, ushort ammo = 0) { ItemId = itemId; Amount = amount; Ammo = ammo; indexArea = indexArea; } } #endregion } }",
          "content_tokens": 270,
          "embedding": []
        }
      ],
      "length": 9314
    },
    {
      "filename": "DamagingCollider",
      "content": "using System; using System.Collections; using System.Collections.Generic; using System.Reflection; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishnetInvector; using Invector; using UnityEngine; using UnityEngine.Rendering; using UnityEngine.Rendering.Universal; using Zomb.Creatures.Helpers; public class DamagingCollider : MonoBehaviour { [SerializeField] private Collider _collider; [SerializeField] private vDamage _damagePerTick = new vDamage(); [SerializeField] private float _damageTickRate = 1.0f; [SerializeField] private Transform _fxPrefab; [SerializeField] private AttachmentPoints.Point _fxSpawnPoint; [SerializeField] private string screenEffectPropertyName = \"_VignetteIntensity\"; [Header(\"OnScreenEffect\")] [SerializeField] private string screenEffectName = \"LavaEffect\"; [SerializeField] private FullScreenFX fullScreenFX; private int _voronoiIntensity = Shader.PropertyToID(\"_VoronoiIntensity\"); private int _vignetteIntensity = Shader.PropertyToID(\"_VignetteIntensity\"); private const float VIGNETTE_INTENSITY_START_AMOUNT = 0.6f; private const float VORONOI_INTENSITY_START_AMOUNT = 1.0f; [Header(\"Time Stats\")] [SerializeField] private float _hurtDisplayTime = 1.5f; [SerializeField] private float _hurtFadeOutTime = .5f; private Dictionary<FishnetInvectorHealthController, Coroutine> _damageTimer = new (); private ObjectsPool<Transform> _fxPool; [SerializeField] private AnimatorDecorator _animatorDecorator; private void OnValidate() { AssignComponentsIfRequired(); } private void AssignComponentsIfRequired() { _collider ??= GetComponent<Collider>(); _animatorDecorator ??= GetComponent<AnimatorDecorator>(); } private void Awake() { if (_fxPrefab != null) _fxPool = new ObjectsPool<Transform>(transform, _fxPrefab, 3); AssignComponentsIfRequired(); } private void OnDisable() { HideScreenFXIfRequired(); } private void Start() { _collider.isTrigger = true; } private void OnTriggerEnter(Collider other) { if (!enabled) return; if (!GameplayManager.IsOwningPlayer(other)) return; if (_animatorDecorator != null) _animatorDecorator.SetTrigger(\"DoActivate\"); StartDamagingIfRequired(other); } private void OnTriggerStay(Collider other) { if (!enabled) return; if (!GameplayManager.IsOwningPlayer(other)) return; if (_animatorDecorator != null) _animatorDecorator.SetTrigger(\"DoActivate\"); StartDamagingIfRequired(other); } private void StartDamagingIfRequired(Collider other) { FishnetInvectorHealthController hc = GameplayManager.Instance.GetHealthController(other); if (_damageTimer.ContainsKey(hc)) return; Debug.Log($\"[DamagingCollider] StartDamagingIfRequired room: {gameObject.name}; player: {other.name}\"); Vector3 closestPoint = other.ClosestPoint(transform.position); SetupAndDealDamage(hc, closestPoint); _damageTimer.Add(hc, StartCoroutine(DamagingCoroutine())); } private void OnTriggerExit(Collider other) { if (!GameplayManager.IsOwningPlayer(other)) return; Debug.Log($\"[DamagingCollider] OnTriggerExit room: {gameObject.name}; player: {other.name}\"); FishnetInvectorHealthController hc = GameplayManager.Instance.GetHealthController(other); if (!_damageTimer.ContainsKey(hc)) return; StopCoroutine(_damageTimer[hc]); _damageTimer.Remove(hc); } private IEnumerator DamagingCoroutine() { while (true) { yield return new WaitForSeconds(_damageTickRate); foreach (var kv in _damageTimer) { SetupAndDealDamage(kv.Key, kv.Key.transform.position); } } } private IEnumerator Hurt(float hurtDisplayTime) { Debug.Log($\"[DamagingCollider] Hurt room: {gameObject.name}\"); ShowFullScreenEffect(); yield return new WaitForSeconds(hurtDisplayTime); float elapsedTime = 0; while (elapsedTime < _hurtFadeOutTime) { elapsedTime += Time.deltaTime; float lerpedVoronoi = Mathf.Lerp(VORONOI_INTENSITY_START_AMOUNT, 0f, elapsedTime / _hurtFadeOutTime); float lerpedVignette = Mathf.Lerp(VIGNETTE_INTENSITY_START_AMOUNT, 0f, elapsedTime / _hurtFadeOutTime); fullScreenFX.screenEffectMaterial.SetFloat(_voronoiIntensity, lerpedVoronoi); fullScreenFX.screenEffectMaterial.SetFloat(_vignetteIntensity, lerpedVignette); yield return null; } } private void ShowFullScreenEffect() { ExtractScriptableRendererData(); foreach ( var renderObjSetting in _scriptableRendererData.rendererFeatures) { if (renderObjSetting.name == screenEffectName) { renderObjSetting.SetActive(true); } } } private ScriptableRendererData _scriptableRendererData; private void ExtractScriptableRendererData() { var pipeline = ((UniversalRenderPipelineAsset)GraphicsSettings.renderPipelineAsset); FieldInfo propertyInfo = pipeline.GetType( ).GetField( \"m_RendererDataList\", BindingFlags.Instance | BindingFlags.NonPublic ); _scriptableRendererData = ((ScriptableRendererData[]) propertyInfo?.GetValue( pipeline ))?[0]; } private void HideFullScreenEffect() { ExtractScriptableRendererData(); foreach ( var renderObjSetting in _scriptableRendererData.rendererFeatures) { if (renderObjSetting.name == screenEffectName) { renderObjSetting.SetActive(false); } } //StartCoroutine(Hurt(.0f)); } public void ShowScreenFXIfRequired() { if (screenEffectName == string.Empty) return; ShowFullScreenEffect(); } public void HideScreenFXIfRequired() { if (screenEffectName == string.Empty) return; HideFullScreenEffect(); } private void SetupAndDealDamage(FishnetInvectorHealthController hc, Vector3 closestPoint) { _damagePerTick.senderNetworkObjectID = hc.ObjectId; _damagePerTick.receiver = hc.transform; _damagePerTick.hitPosition = closestPoint; _damagePerTick.type = vDamage.DamageType.Trap; FNvDamage fNvDamage = _damagePerTick.ToFNvDamage(); hc.CmdDealMeDamagePlease(fNvDamage); var unitComps = hc.UnitComponents; unitComps.AttachmentPoints.GetAttachmentPoint(_fxSpawnPoint); //itween allocate _fxPool.Allocate() and deallocate _fxPool.Deallocate() after 1 sec if (_fxPrefab != null) { var fx = _fxPool.Allocate(); fx.position = unitComps.AttachmentPoints.GetAttachmentPoint(_fxSpawnPoint).position; fx.rotation = unitComps.AttachmentPoints.GetAttachmentPoint(_fxSpawnPoint).rotation; StartCoroutine(DestroyFX(fx)); } } private IEnumerator DestroyFX(Transform fx) { yield return new WaitForSeconds(1f); _fxPool.Deallocate(fx); } [Serializable] public struct FullScreenFX { public ScriptableRendererFeature[] renderFeatures; public Material screenEffectMaterial; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DamagingCollider",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "DamagingCollider",
          "content": "using System; using System.Collections; using System.Collections.Generic; using System.Reflection; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishnetInvector; using Invector; using UnityEngine; using UnityEngine.Rendering; using UnityEngine.Rendering.Universal; using Zomb.Creatures.Helpers; public class DamagingCollider : MonoBehaviour { [SerializeField] private Collider _collider; [SerializeField] private vDamage _damagePerTick = new vDamage(); [SerializeField] private float _damageTickRate = 1.0f; [SerializeField] private Transform _fxPrefab; [SerializeField] private AttachmentPoints.Point _fxSpawnPoint; [SerializeField] private string screenEffectPropertyName = \"_VignetteIntensity\"; [Header(\"OnScreenEffect\")] [SerializeField] private string screenEffectName = \"LavaEffect\"; [SerializeField] private FullScreenFX fullScreenFX; private int _voronoiIntensity = Shader.PropertyToID(\"_VoronoiIntensity\"); private int _vignetteIntensity = Shader.PropertyToID(\"_VignetteIntensity\"); private const float VIGNETTE_INTENSITY_START_AMOUNT = 0.6f; private const float VORONOI_INTENSITY_START_AMOUNT = 1.0f; [Header(\"Time Stats\")] [SerializeField] private float _hurtDisplayTime = 1.5f; [SerializeField] private float _hurtFadeOutTime = .5f; private Dictionary<FishnetInvectorHealthController, Coroutine> _damageTimer = new (); private ObjectsPool<Transform> _fxPool; [SerializeField] private AnimatorDecorator _animatorDecorator; private void OnValidate() { AssignComponentsIfRequired();  ",
          "content_tokens": 438,
          "embedding": []
        },
        {
          "cs_scriptfile": "DamagingCollider",
          "content": "private void AssignComponentsIfRequired() { _collider ??= GetComponent<Collider>(); _animatorDecorator ??= GetComponent<AnimatorDecorator>();  private void Awake() { if (_fxPrefab != null) _fxPool = new ObjectsPool<Transform>(transform, _fxPrefab, 3); AssignComponentsIfRequired();  private void OnDisable() { HideScreenFXIfRequired();  private void Start() { _collider.isTrigger = true;  private void OnTriggerEnter(Collider other) { if (!enabled) return; if (!GameplayManager.IsOwningPlayer(other)) return; if (_animatorDecorator != null) _animatorDecorator.SetTrigger(\"DoActivate\"); StartDamagingIfRequired(other);  ",
          "content_tokens": 175,
          "embedding": []
        },
        {
          "cs_scriptfile": "DamagingCollider",
          "content": "private void OnTriggerStay(Collider other) { if (!enabled) return; if (!GameplayManager.IsOwningPlayer(other)) return; if (_animatorDecorator != null) _animatorDecorator.SetTrigger(\"DoActivate\"); StartDamagingIfRequired(other);  private void StartDamagingIfRequired(Collider other) { FishnetInvectorHealthController hc = GameplayManager.Instance.GetHealthController(other); if (_damageTimer.ContainsKey(hc)) return; Debug.Log($\"[DamagingCollider] StartDamagingIfRequired room: {gameObject.name}; player: {other.name}\"); Vector3 closestPoint = other.ClosestPoint(transform.position); SetupAndDealDamage(hc, closestPoint); _damageTimer.Add(hc, StartCoroutine(DamagingCoroutine()));  ",
          "content_tokens": 191,
          "embedding": []
        },
        {
          "cs_scriptfile": "DamagingCollider",
          "content": "private void OnTriggerExit(Collider other) { if (!GameplayManager.IsOwningPlayer(other)) return; Debug.Log($\"[DamagingCollider] OnTriggerExit room: {gameObject.name}; player: {other.name}\"); FishnetInvectorHealthController hc = GameplayManager.Instance.GetHealthController(other); if (!_damageTimer.ContainsKey(hc)) return; StopCoroutine(_damageTimer[hc]); _damageTimer.Remove(hc); } private IEnumerator DamagingCoroutine() { while (true) { yield return new WaitForSeconds(_damageTickRate); foreach (var kv in _damageTimer) { SetupAndDealDamage(kv.Key, kv.Key.transform.position); } } } private IEnumerator Hurt(float hurtDisplayTime) { Debug.Log($\"[DamagingCollider] Hurt room: {gameObject.name}\"); ShowFullScreenEffect(); yield return new WaitForSeconds(hurtDisplayTime); float elapsedTime = 0; while (elapsedTime < _hurtFadeOutTime) { elapsedTime += Time.deltaTime; float lerpedVoronoi = Mathf.Lerp(VORONOI_INTENSITY_START_AMOUNT, 0f, elapsedTime / _hurtFadeOutTime); float lerpedVignette = Mathf.Lerp(VIGNETTE_INTENSITY_START_AMOUNT, 0f, elapsedTime / _hurtFadeOutTime); fullScreenFX.screenEffectMaterial.SetFloat(_voronoiIntensity, lerpedVoronoi); fullScreenFX.screenEffectMaterial.SetFloat(_vignetteIntensity, lerpedVignette); yield return null; }  ",
          "content_tokens": 400,
          "embedding": []
        },
        {
          "cs_scriptfile": "DamagingCollider",
          "content": "private void ShowFullScreenEffect() { ExtractScriptableRendererData(); foreach ( var renderObjSetting in _scriptableRendererData.rendererFeatures) { if (renderObjSetting.name == screenEffectName) { renderObjSetting.SetActive(true); } } } private ScriptableRendererData _scriptableRendererData; private void ExtractScriptableRendererData() { var pipeline = ((UniversalRenderPipelineAsset)GraphicsSettings.renderPipelineAsset); FieldInfo propertyInfo = pipeline.GetType( ).GetField( \"m_RendererDataList\", BindingFlags.Instance | BindingFlags.NonPublic ); _scriptableRendererData = ((ScriptableRendererData[]) propertyInfo?.GetValue( pipeline ))?[0];  ",
          "content_tokens": 174,
          "embedding": []
        },
        {
          "cs_scriptfile": "DamagingCollider",
          "content": "private void HideFullScreenEffect() { ExtractScriptableRendererData(); foreach ( var renderObjSetting in _scriptableRendererData.rendererFeatures) { if (renderObjSetting.name == screenEffectName) { renderObjSetting.SetActive(false); } } //StartCoroutine(Hurt(.0f));  public void ShowScreenFXIfRequired() { if (screenEffectName == string.Empty) return; ShowFullScreenEffect();  public void HideScreenFXIfRequired() { if (screenEffectName == string.Empty) return; HideFullScreenEffect();  ",
          "content_tokens": 129,
          "embedding": []
        },
        {
          "cs_scriptfile": "DamagingCollider",
          "content": "private void SetupAndDealDamage(FishnetInvectorHealthController hc, Vector3 closestPoint) { _damagePerTick.senderNetworkObjectID = hc.ObjectId; _damagePerTick.receiver = hc.transform; _damagePerTick.hitPosition = closestPoint; _damagePerTick.type = vDamage.DamageType.Trap; FNvDamage fNvDamage = _damagePerTick.ToFNvDamage(); hc.CmdDealMeDamagePlease(fNvDamage); var unitComps = hc.UnitComponents; unitComps.AttachmentPoints.GetAttachmentPoint(_fxSpawnPoint); //itween allocate _fxPool.Allocate() and deallocate _fxPool.Deallocate() after 1 sec if (_fxPrefab != null) { var fx = _fxPool.Allocate(); fx.position = unitComps.AttachmentPoints.GetAttachmentPoint(_fxSpawnPoint).position; fx.rotation = unitComps.AttachmentPoints.GetAttachmentPoint(_fxSpawnPoint).rotation; StartCoroutine(DestroyFX(fx)); } } private IEnumerator DestroyFX(Transform fx) { yield return new WaitForSeconds(1f); _fxPool.Deallocate(fx); } [Serializable] public struct FullScreenFX { public ScriptableRendererFeature[] renderFeatures; public Material screenEffectMaterial; } }",
          "content_tokens": 316,
          "embedding": []
        }
      ],
      "length": 6296
    },
    {
      "filename": "DoorController",
      "content": "using System; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using NGS.AdvancedCullingSystem.Dynamic; using UnityEngine; namespace InRoomSystems { public class DoorController : InteractableObjectController { [SyncVar(OnChange = nameof(OnDoorOpen))] protected bool _isDoorOpened = false; protected const float DOOR_OPEN_ANGLE = 90f; [SerializeField] protected bool _isDoubleDoor; [SerializeField] protected Transform _leftDoor; [SerializeField] protected Transform _rightDoor; protected Vector3 _startingRotationRightDoor = Vector3.zero; public Action<Transform, bool> OnDoorOpened; public Action<Transform, bool> OnDoorClosed; [SyncVar] private NetworkObject _interactingAgent; public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { OnPlayerFinishedInteracting += OpenDoor; } } protected override void InitClient() { TurnOnClientOnlyComponents(); AddTimedActionListeners(); _gameplayManager = GameplayManager.LocalPlayer; gameObject.name = $\"{tag} #{NetworkObject.ObjectId}\"; #if UNITY_EDITOR if (ObjectsRoomManager == null) ObjectsRoomManager = FindObjectOfType<ObjectsRoomManager>(); transform.parent = ObjectsRoomManager.transform; #endif for (int i = 0; i < _meshRenderers.Length; i++) { DC_Controller.Instance.AddObjectForCulling(_meshRenderers[i]); } } [Server] protected void OpenDoor(NetworkConnection senderConn) { _interactingAgent = GameplayManager.Instance.GetPlayerNob(senderConn); _isDoorOpened = !_isDoorOpened; DeallocateObjectInteractingAction(senderConn.ClientId); } protected void OnDoorOpen(bool prev, bool next, bool asServer) { DebugWrite.Log($\"[DoorController] OnDoorOpen() called for {gameObject.name} with _isDoorOpened {next} _isStartingRotationNotSet {_isStartingRotationNotSet}\", gameObject, _isDebug); if (next) { OnDoorOpened?.Invoke(_interactingAgent.transform, asServer); } else { OnDoorClosed?.Invoke(_interactingAgent.transform, asServer); } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DoorController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "DoorController",
          "content": "using System; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using NGS.AdvancedCullingSystem.Dynamic; using UnityEngine; namespace InRoomSystems { public class DoorController : InteractableObjectController { [SyncVar(OnChange = nameof(OnDoorOpen))] protected bool _isDoorOpened = false; protected const float DOOR_OPEN_ANGLE = 90f; [SerializeField] protected bool _isDoubleDoor; [SerializeField] protected Transform _leftDoor; [SerializeField] protected Transform _rightDoor; protected Vector3 _startingRotationRightDoor = Vector3.zero; public Action<Transform, bool> OnDoorOpened; public Action<Transform, bool> OnDoorClosed; [SyncVar] private NetworkObject _interactingAgent; public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { OnPlayerFinishedInteracting += OpenDoor; } } protected override void InitClient() { TurnOnClientOnlyComponents(); AddTimedActionListeners(); _gameplayManager = GameplayManager.LocalPlayer; gameObject.name = $\"{tag} #{NetworkObject.ObjectId}\"; #if UNITY_EDITOR if (ObjectsRoomManager == null) ObjectsRoomManager = FindObjectOfType<ObjectsRoomManager>(); transform.parent = ObjectsRoomManager.transform; #endif for (int i = 0; i < _meshRenderers.Length; i++) { DC_Controller.Instance.AddObjectForCulling(_meshRenderers[i]); } } [Server] protected void OpenDoor(NetworkConnection senderConn) { _interactingAgent = GameplayManager.Instance.GetPlayerNob(senderConn); _isDoorOpened = !_isDoorOpened; DeallocateObjectInteractingAction(senderConn.ClientId);  ",
          "content_tokens": 465,
          "embedding": []
        },
        {
          "cs_scriptfile": "DoorController",
          "content": "protected void OnDoorOpen(bool prev, bool next, bool asServer) { DebugWrite.Log($\"[DoorController] OnDoorOpen() called for {gameObject.name} with _isDoorOpened {next} _isStartingRotationNotSet {_isStartingRotationNotSet}\", gameObject, _isDebug); if (next) { OnDoorOpened?.Invoke(_interactingAgent.transform, asServer); } else { OnDoorClosed?.Invoke(_interactingAgent.transform, asServer); } } } }",
          "content_tokens": 125,
          "embedding": []
        }
      ],
      "length": 2059
    },
    {
      "filename": "DoorsManager",
      "content": "using FishNet.Object; using InRoomSystems; using UnityEngine; public class DoorsManager : ObjectsRoomManager { private static string DOOR_TAG = \"Door\"; [SerializeField] private NetworkObject _doorPrefab; Vector3[] _doorPositions; float[] _doorRotations; Transform[] _doorParentTransforms; public void StoreAndRemoveDoorsInfos() { GameObject[] roomDoors = FindAllDoors(); _doorPositions = new Vector3[roomDoors.Length]; _doorRotations = new float[roomDoors.Length]; _doorParentTransforms = new Transform[roomDoors.Length]; for (int i = 0; i < roomDoors.Length; i++) { Transform doorTransform = roomDoors[i].transform; _doorPositions[i] = doorTransform.position; if (doorTransform.parent.parent == null) { Debug.LogError(\"Door parent parent is null\", doorTransform); continue; } _doorRotations[i] = doorTransform.parent.parent.rotation.eulerAngles.y; _doorParentTransforms[i] = doorTransform.parent; Destroy(roomDoors[i]); } Debug.Log($\"{ClassAndRoomName} Doors destroyed\"); } public override void OnStartServer() { base.OnStartServer(); GenerateObjects(); } [Server] public void SpawnDoors() { Debug.Log($\"{ClassAndRoomName} Starting...\"); ObserverRemoveDoor(); for (int i = 0; i < _doorPositions.Length; i++) { Vector3 rotation = new Vector3(.0f, _doorRotations[i], .0f); var rotationQuaternion = Quaternion.Euler(rotation); NetworkObject nob = Instantiate<NetworkObject>(_doorPrefab, _doorPositions[i], rotationQuaternion, transform); base.Spawn(nob); nob.GetComponent<DoorController>().InitServer(GameplayManager, DOOR_TAG, _doorPositions[i], rotation); } Debug.Log($\"{ClassAndRoomName} Doors Spawned\"); } [ObserversRpc] private void ObserverRemoveDoor() { GameObject[] roomDoors = FindAllDoors(); for (int i = 0; i < roomDoors.Length; i++) { Destroy(roomDoors[i]); } } private GameObject[] FindAllDoors() { return GameObject.FindGameObjectsWithTag(DOOR_TAG); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DoorsManager",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "DoorsManager",
          "content": "using FishNet.Object; using InRoomSystems; using UnityEngine; public class DoorsManager : ObjectsRoomManager { private static string DOOR_TAG = \"Door\"; [SerializeField] private NetworkObject _doorPrefab; Vector3[] _doorPositions; float[] _doorRotations; Transform[] _doorParentTransforms; public void StoreAndRemoveDoorsInfos() { GameObject[] roomDoors = FindAllDoors(); _doorPositions = new Vector3[roomDoors.Length]; _doorRotations = new float[roomDoors.Length]; _doorParentTransforms = new Transform[roomDoors.Length]; for (int i = 0; i < roomDoors.Length; i++) { Transform doorTransform = roomDoors[i].transform; _doorPositions[i] = doorTransform.position; if (doorTransform.parent.parent == null) { Debug.LogError(\"Door parent parent is null\", doorTransform); continue; } _doorRotations[i] = doorTransform.parent.parent.rotation.eulerAngles.y; _doorParentTransforms[i] = doorTransform.parent; Destroy(roomDoors[i]); } Debug.Log($\"{ClassAndRoomName} Doors destroyed\"); } public override void OnStartServer() { base.OnStartServer(); GenerateObjects(); } [Server] public void SpawnDoors() { Debug.Log($\"{ClassAndRoomName} Starting...\"); ObserverRemoveDoor(); for (int i = 0; i < _doorPositions.Length; i++) { Vector3 rotation = new Vector3(.0f, _doorRotations[i], .0f); var rotationQuaternion = Quaternion.Euler(rotation); NetworkObject nob = Instantiate<NetworkObject>(_doorPrefab, _doorPositions[i], rotationQuaternion, transform); base.Spawn(nob); nob.GetComponent<DoorController>().InitServer(GameplayManager, DOOR_TAG, _doorPositions[i], rotation); } Debug.Log($\"{ClassAndRoomName} Doors Spawned\"); } [ObserversRpc] private void ObserverRemoveDoor() { GameObject[] roomDoors = FindAllDoors(); for (int i = 0; i < roomDoors.Length; i++) { Destroy(roomDoors[i]); } } private GameObject[] FindAllDoors() { return GameObject.FindGameObjectsWithTag(DOOR_TAG); } }",
          "content_tokens": 548,
          "embedding": []
        }
      ],
      "length": 1866
    },
    {
      "filename": "SingleDoorEditor",
      "content": "using UnityEditor; using UnityEngine; [CustomEditor(typeof(SingleDoor))] public class SingleDoorEditor : Editor { private SingleDoor _myScript; private void OnEnable() { _myScript = (SingleDoor)target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); SingleDoor door = (SingleDoor)target; if (GUILayout.Button(\"Open Door\")) { door.OnDoorOpened(_myScript.transform, true); } if (GUILayout.Button(\"Close Door\")) { door.OnDoorClosed(_myScript.transform, true); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SingleDoorEditor",
          "content": "using UnityEditor; using UnityEngine; [CustomEditor(typeof(SingleDoor))] public class SingleDoorEditor : Editor { private SingleDoor _myScript; private void OnEnable() { _myScript = (SingleDoor)target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); SingleDoor door = (SingleDoor)target; if (GUILayout.Button(\"Open Door\")) { door.OnDoorOpened(_myScript.transform, true); } if (GUILayout.Button(\"Close Door\")) { door.OnDoorClosed(_myScript.transform, true); } } }",
          "content_tokens": 145,
          "embedding": []
        }
      ],
      "length": 479
    },
    {
      "filename": "EscapeCitySource",
      "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; public class EscapeCitySource : NetworkBehaviour { private GameplayManager _gameplayManager; public void Init(GameplayManager gameplayManager) => _gameplayManager = gameplayManager; //[Client] public void PlayerInteractWithEscapeSource() => GameplayManager.Instance.RpcWinForPlayer(); }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "EscapeCitySource",
          "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; public class EscapeCitySource : NetworkBehaviour { private GameplayManager _gameplayManager; public void Init(GameplayManager gameplayManager) => _gameplayManager = gameplayManager; //[Client] public void PlayerInteractWithEscapeSource() => GameplayManager.Instance.RpcWinForPlayer(); }",
          "content_tokens": 100,
          "embedding": []
        }
      ],
      "length": 398
    },
    {
      "filename": "EscapePortalController",
      "content": " using System; using System.Linq; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Clients; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Connection; using FishNet.Object; namespace InRoomSystems { public class EscapePortalController : InteractableObjectController { public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { OnPlayerFinishedInteracting += PlayerEscape; } } [Server] private void PlayerEscape(NetworkConnection conn) { DebugWrite.Log($\"[EscapePortalController] Player #{conn.ClientId} escaped!\", gameObject, _isDebug); ClientInstance clientInstance = conn.FirstObject.GetComponent<ClientInstance>(); PlayerSettings playerSettings = clientInstance.PlayerSettings; string playerToken = playerSettings.Token; UnitComponents unitComponents = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); FNAbilityController abilityController = unitComponents.AbilityController; AbilityInfo[] learnedAbilities = abilityController.LearnedAbilityDict.Values.ToArray(); Action<int> callback = (result) => { }; BackendReadWrites.SetAbilityStacks(playerToken, learnedAbilities, callback); GameplayManager.Instance.RpcWinForPlayer(conn); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "EscapePortalController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "EscapePortalController",
          "content": "using System; using System.Linq; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Clients; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Connection; using FishNet.Object; namespace InRoomSystems { public class EscapePortalController : InteractableObjectController { public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { OnPlayerFinishedInteracting += PlayerEscape; } } [Server] private void PlayerEscape(NetworkConnection conn) { DebugWrite.Log($\"[EscapePortalController] Player #{conn.ClientId} escaped!\", gameObject, _isDebug); ClientInstance clientInstance = conn.FirstObject.GetComponent<ClientInstance>(); PlayerSettings playerSettings = clientInstance.PlayerSettings; string playerToken = playerSettings.Token; UnitComponents unitComponents = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); FNAbilityController abilityController = unitComponents.AbilityController; AbilityInfo[] learnedAbilities = abilityController.LearnedAbilityDict.Values.ToArray(); Action<int> callback = (result) => { }; BackendReadWrites.SetAbilityStacks(playerToken, learnedAbilities, callback); GameplayManager.Instance.RpcWinForPlayer(conn); } } }",
          "content_tokens": 315,
          "embedding": []
        }
      ],
      "length": 1264
    },
    {
      "filename": "EscapePortalNotifier",
      "content": "using System.Collections; using FishNet.Object; using FishnetInvector; using InRoomSystems; using UnityEngine; public class EscapePortalNotifier : NetworkBehaviour { [SerializeField] protected float DISTANCE_TO_HIDE_ICON = 20.0f; [SerializeField] protected GameObject _iconPrefab; public static ObjectLocationNotifier Instance { get; private set; } private Vector3 _lastPosition; private Transform localPlayer; private float _sqrtDistanceToHide = 400f; private GameObject _iconGo; private TMProDecorator _distanceText; public override void OnStartClient() { base.OnStartClient(); _sqrtDistanceToHide = DISTANCE_TO_HIDE_ICON * DISTANCE_TO_HIDE_ICON; localPlayer = FishnetInvectorManager.LocalPlayer.transform; _lastPosition = localPlayer.position; _iconGo = Instantiate(_iconPrefab, transform.position, Quaternion.identity); UICanvasGroupDecorator iconCanvas = _iconGo.GetComponentInChildren<UICanvasGroupDecorator>(); _distanceText = _iconGo.GetComponentInChildren<TMProDecorator>(); StartCoroutine(DistanceUpdater()); } private IEnumerator DistanceUpdater() { var time = new WaitForSeconds(1.0f); while (true) { yield return time; if (Mathf.Approximately(localPlayer.position.x, _lastPosition.x) && Mathf.Approximately(localPlayer.position.y, _lastPosition.y) && Mathf.Approximately(localPlayer.position.z, _lastPosition.z)) { continue; } _lastPosition = localPlayer.position; var sqrtDist = Vector3.SqrMagnitude(localPlayer.position - transform.position); if (sqrtDist > _sqrtDistanceToHide) { _iconGo.SetActive(true); float distance = Mathf.Sqrt(sqrtDist); _distanceText.SetText($\"{distance:0.0}m\"); } else { _iconGo.SetActive(false); } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "EscapePortalNotifier",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "EscapePortalNotifier",
          "content": "using System.Collections; using FishNet.Object; using FishnetInvector; using InRoomSystems; using UnityEngine; public class EscapePortalNotifier : NetworkBehaviour { [SerializeField] protected float DISTANCE_TO_HIDE_ICON = 20.0f; [SerializeField] protected GameObject _iconPrefab; public static ObjectLocationNotifier Instance { get; private set; } private Vector3 _lastPosition; private Transform localPlayer; private float _sqrtDistanceToHide = 400f; private GameObject _iconGo; private TMProDecorator _distanceText; public override void OnStartClient() { base.OnStartClient(); _sqrtDistanceToHide = DISTANCE_TO_HIDE_ICON * DISTANCE_TO_HIDE_ICON; localPlayer = FishnetInvectorManager.LocalPlayer.transform; _lastPosition = localPlayer.position; _iconGo = Instantiate(_iconPrefab, transform.position, Quaternion.identity); UICanvasGroupDecorator iconCanvas = _iconGo.GetComponentInChildren<UICanvasGroupDecorator>(); _distanceText = _iconGo.GetComponentInChildren<TMProDecorator>(); StartCoroutine(DistanceUpdater()); } private IEnumerator DistanceUpdater() { var time = new WaitForSeconds(1.0f); while (true) { yield return time; if (Mathf.Approximately(localPlayer.position.x, _lastPosition.x) && Mathf.Approximately(localPlayer.position.y, _lastPosition.y) && Mathf.Approximately(localPlayer.position.z, _lastPosition.z)) { continue; } _lastPosition = localPlayer.position; var sqrtDist = Vector3.SqrMagnitude(localPlayer.position - transform.position); if (sqrtDist > _sqrtDistanceToHide) { _iconGo.SetActive(true); float distance = Mathf.Sqrt(sqrtDist); _distanceText.SetText($\"{distance:0.0}m\"); } else { _iconGo.SetActive(false); } } } }",
          "content_tokens": 485,
          "embedding": []
        }
      ],
      "length": 1645
    },
    {
      "filename": "HealthSphereController",
      "content": " using System.Collections; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Connection; using FishNet.Object; using FishnetInvector; using UnityEngine; namespace InRoomSystems { public class HealthSphereController : InteractableObjectController { [SerializeField] private float _healAmount = 25f; [SerializeField] private GameObject _healFx; [SerializeField] private GameObject _visualFX; private bool _isUsed = false; public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { OnPlayerFinishedInteracting += ConsumeSphere; } } [Client] public void OnPlayerEnterTrigger() { CmdPlayerEnteredSphere(); } [ServerRpc(RequireOwnership = false)] private void CmdPlayerEnteredSphere(NetworkConnection conn = null) { ConsumeSphere(conn); } [Server] private void ConsumeSphere(NetworkConnection conn) { if (_isUsed) return; _isUsed = true; StringBuilder sb = new StringBuilder(); sb.Append($\"[HealthSphereController] Player {conn.ClientId} consumed a health sphere!\"); UnitComponents unit = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); sb.Append($\" Before health: {unit.HealthController.CurrentHealth}; \"); _triggerGenericAction.enabled = false; var healData = new FishnetInvectorHealthController.HealData(); healData.amount = _healAmount; unit.HealthController.Heal(healData); sb.Append($\" After health: {unit.HealthController.CurrentHealth}\"); DebugWrite.Log($\"{sb}\", gameObject, _isDebug); #region Resilience Globules byte abilityId = PassiveResilienceGlobules.ABILITY_ID; if (unit.AbilityController.IsAbilityLearned(abilityId)) { Ability ability = AbilityManager.Instance.GetAbility(abilityId); ability.ServerAddStack(unit.AbilityController, 1); } #endregion ObserversSpawnHealFx(unit.HealthController.ObjectId); StartCoroutine(DespawnAfterTime()); } [Server] private IEnumerator DespawnAfterTime() { yield return new WaitForSeconds(3f); InstanceFinder.ServerManager.Despawn(gameObject); } [ObserversRpc] private void ObserversSpawnHealFx(int unitId) { _visualFX.SetActive(false); Transform target = GameplayManager.Instance.GetTargetTransformServerAndClient(unitId); StartCoroutine(HealFX(target)); } [Client] private IEnumerator HealFX(Transform target) { GameObject fx = Instantiate(_healFx, target.position, Quaternion.identity); fx.transform.SetParent(target); DebugWrite.Log($\"[HealthSphereController] Spawned heal fx for {target.name}\", gameObject, _isDebug); yield return new WaitForSeconds(2.0f); DebugWrite.Log($\"[HealthSphereController] Destroyed heal fx for {target.name}\", gameObject, _isDebug); Destroy(fx); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "HealthSphereController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "HealthSphereController",
          "content": "using System.Collections; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Connection; using FishNet.Object; using FishnetInvector; using UnityEngine; namespace InRoomSystems { public class HealthSphereController : InteractableObjectController { [SerializeField] private float _healAmount = 25f; [SerializeField] private GameObject _healFx; [SerializeField] private GameObject _visualFX; private bool _isUsed = false; public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { OnPlayerFinishedInteracting += ConsumeSphere; } } [Client] public void OnPlayerEnterTrigger() { CmdPlayerEnteredSphere(); } [ServerRpc(RequireOwnership = false)] private void CmdPlayerEnteredSphere(NetworkConnection conn = null) { ConsumeSphere(conn); } [Server] private void ConsumeSphere(NetworkConnection conn) { if (_isUsed) return; _isUsed = true; StringBuilder sb = new StringBuilder(); sb.Append($\"[HealthSphereController] Player {conn.ClientId} consumed a health sphere!\"); UnitComponents unit = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); sb.Append($\" Before health: {unit.HealthController.CurrentHealth}; \"); _triggerGenericAction.enabled = false; var healData = new FishnetInvectorHealthController.HealData(); healData.amount = _healAmount; unit.HealthController.Heal(healData); sb.Append($\" After health: {unit.HealthController.CurrentHealth}\"); DebugWrite.Log($\"{sb}\", gameObject, _isDebug); #region Resilience Globules byte abilityId = PassiveResilienceGlobules.ABILITY_ID; if (unit.AbilityController.IsAbilityLearned(abilityId)) { Ability ability = AbilityManager.Instance.GetAbility(abilityId); ability.ServerAddStack(unit.AbilityController, 1); } #endregion ObserversSpawnHealFx(unit.HealthController.ObjectId); StartCoroutine(DespawnAfterTime()); } [Server] private IEnumerator DespawnAfterTime() { yield return new WaitForSeconds(3f); InstanceFinder.ServerManager.Despawn(gameObject); } [ObserversRpc] private void ObserversSpawnHealFx(int unitId) { _visualFX.SetActive(false); Transform target = GameplayManager.Instance.GetTargetTransformServerAndClient(unitId); StartCoroutine(HealFX(target)); } [Client] private IEnumerator HealFX(Transform target) { GameObject fx = Instantiate(_healFx, target.position, Quaternion.identity); fx.transform.SetParent(target); DebugWrite.Log($\"[HealthSphereController] Spawned heal fx for {target.name}\", gameObject, _isDebug); yield return new WaitForSeconds(2.0f); DebugWrite.Log($\"[HealthSphereController] Destroyed heal fx for {target.name}\", gameObject, _isDebug); Destroy(fx); } } }",
          "content_tokens": 744,
          "embedding": []
        }
      ],
      "length": 2684
    },
    {
      "filename": "InteractableObjectController",
      "content": " using System; using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DG.Tweening; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using UnityEngine; using DungeonScrollerCore; using FishNet; using FishNet.Observing; using Invector.vCharacterController.vActions; using NGS.AdvancedCullingSystem.Dynamic; namespace InRoomSystems { [RequireComponent(typeof(NetworkObserver))] public class InteractableObjectController : NetworkBehaviour { [SyncVar(OnChange = nameof(OnObjectRotationChanged))] protected Vector3 _objectRotation = Vector3.zero; protected Dictionary<int, ObjectAction> _playerInteractingCoroutines = new Dictionary<int, ObjectAction>(); [SerializeField] protected GameplayManager _gameplayManager; [SerializeField] protected SoundSource[] _soundSources = new SoundSource[0]; [SerializeField] protected GameObjectDispatcher _visualModel; [SerializeField] protected AudioSource _audioSource; [SerializeField] protected GameObject vOpenActionText; protected bool _isStartingRotationNotSet = true; protected Vector3 _startingRotation = Vector3.zero; protected string _tag; [SerializeField] public float OBJECT_ROTATION_DURATION = 0.4f; public Action<NetworkConnection> OnLocalPlayerFinishedInteracting; public Action<NetworkConnection> OnPlayerFinishedInteracting; public Action<NetworkConnection> OnPlayerStartedInteracting; public Action<NetworkConnection> OnPlayerCanceledInteracting; public Action<NetworkConnection> OnPlayerActivatedObject; public Action OnInitialized; [SerializeField] protected bool _isDebug = true; [SerializeField] protected vTriggerGenericAction _triggerGenericAction; public static ObjectsRoomManager ObjectsRoomManager; [SerializeField] protected MeshRenderer[] _meshRenderers; public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); protected string _className; protected virtual void OnValidate() { AssignComponentsIfRequired(); } protected virtual void Awake() { AssignComponentsIfRequired(); } protected void AssignComponentsIfRequired() { if (_meshRenderers ==null || _meshRenderers.Length == 0) { _meshRenderers = GetComponentsInChildren<MeshRenderer>(); } _audioSource ??= GetComponentInChildren<AudioSource>(); if (_triggerGenericAction == null) _triggerGenericAction = GetComponentInChildren<vTriggerGenericAction>(); if (_audioSource == null) _audioSource = GetComponentInChildren<AudioSource>(); } protected virtual void InitClient() { TurnOnClientOnlyComponents(); AddTimedActionListeners(); DebugWrite.Log($\"{ClassName} {gameObject.name} transform.rotation {transform.rotation.eulerAngles}, _objectRotation {_objectRotation}\", gameObject, _isDebug); if (transform.rotation.eulerAngles != _objectRotation) { SetObjectRotation(transform, _objectRotation); } _gameplayManager = GameplayManager.LocalPlayer; gameObject.name = $\"{tag} #{NetworkObject.ObjectId}\"; #if UNITY_EDITOR if (ObjectsRoomManager == null) ObjectsRoomManager = FindObjectOfType<ObjectsRoomManager>(); transform.parent = ObjectsRoomManager.transform; #endif for (int i = 0; i < _meshRenderers.Length; i++) { DC_Controller.Instance.AddObjectForCulling(_meshRenderers[i]); } } public override void OnStartClient() { base.OnStartClient(); InitClient(); } protected void TurnOnClientOnlyComponents() { _triggerGenericAction.gameObject.SetActive(true); if (_audioSource != null) { _audioSource.gameObject.SetActive(true); } else { if (_soundSources.Length > 0) Debug.LogError($\"{ClassName} _audioSource is null for {gameObject.name}\"); } if (_visualModel != null) _visualModel.Activate(); } public override void OnStartServer() { base.OnStartServer(); SetupName(); } private void OnDisable() { //DebugLog($\"{ClassName} OnDisable() called for {gameObject.name}\"); } public override void OnStopClient() { base.OnStopClient(); RemoveTimedActionListeners(); } protected void AddTimedActionListeners() { _triggerGenericAction.OnPressActionInput.AddListener(PlayerStartedInteracting); _triggerGenericAction.OnFinishActionInput.AddListener(PlayerFinishedInteracting); _triggerGenericAction.OnCancelActionInput.AddListener(PlayerCanceledInteracting); } private void PlayerActivateObject() { DebugLog($\"{ClassName} OnPlayerActivatedObject Player started interacting with {gameObject.name}.\"); OnPlayerActivatedObject?.Invoke(InstanceFinder.ClientManager.Connection); } protected void RemoveTimedActionListeners() { _triggerGenericAction.OnPressActionInput.RemoveAllListeners(); _triggerGenericAction.OnFinishActionInput.RemoveAllListeners(); _triggerGenericAction.OnCancelActionInput.RemoveAllListeners(); } protected void PlayerStartedInteracting() { DebugLog($\"{ClassName} Player started interacting with {gameObject.name}.\"); if (_triggerGenericAction.inputType == vTriggerGenericAction.InputType.GetButtonDown) { PlayerFinishedInteracting(); }else if (_triggerGenericAction.inputType == vTriggerGenericAction.InputType.GetButtonTimer) { LoadingBarLogic.Instance.StartLoading(_triggerGenericAction.buttonTimer); OnPlayerStartedInteracting?.Invoke(InstanceFinder.ClientManager.Connection); CmdPlayerStartedInteracting(); } } protected virtual void PlayerFinishedInteracting() { DebugLog($\"{ClassName} Player finished interacting with {gameObject.name}.\"); OnLocalPlayerFinishedInteracting?.Invoke(InstanceFinder.ClientManager.Connection); CmdPlayerFinishedInteracting(); } protected void PlayerCanceledInteracting() { LoadingBarLogic.Instance.CancelLoading(); DebugLog($\"{ClassName} Player canceled interacting with {gameObject.name}.\"); OnPlayerCanceledInteracting?.Invoke(InstanceFinder.ClientManager.Connection); InternalStopAudio(); CmdPlayerCanceledInteracting(); } [ServerRpc(RequireOwnership = false)] protected virtual void CmdPlayerStartedInteracting(NetworkConnection senderConn = null) { DebugLog($\"{ClassName} Player {senderConn.ClientId} started interacting with {gameObject.name}.\"); AllocateObjectInteractingAction(senderConn.ClientId); PlayAudio(SoundSource.Type.Interacting); OnPlayerStartedInteracting?.Invoke(senderConn); } [ServerRpc(RequireOwnership = false)] protected void CmdPlayerFinishedInteracting(NetworkConnection senderConn = null) { int clientId = senderConn.ClientId; DebugLog($\"{ClassName}[Server] Player {clientId} finished interacting with {gameObject.name}.\"); if (_triggerGenericAction.inputType == vTriggerGenericAction.InputType.GetButtonTimer) { if (_playerInteractingCoroutines.ContainsKey(clientId)) { if (_playerInteractingCoroutines[clientId].IsEligibleToInteract) { DebugLog($\"{ClassName} Player {clientId} finished interacting with {gameObject.name} and was eligible to do so.\"); OnPlayerFinishedInteracting?.Invoke(senderConn); } else { DeallocateObjectInteractingAction(clientId); DebugLog($\"{ClassName} Player {clientId} raised finishing of interacting with {gameObject.name}, but was not eligible to do so.\"); } } else { DebugLog($\"{ClassName} Player {clientId} raised finishing of interacting with {gameObject.name}, but no coroutine was found.\"); return; } } else { DebugLog($\"{ClassName} Player {clientId} finished interacting with {gameObject.name} and was eligible to do so.\"); OnPlayerFinishedInteracting?.Invoke(senderConn); } } [ServerRpc(RequireOwnership = false)] protected void CmdPlayerCanceledInteracting(NetworkConnection senderConn = null) { DebugLog($\"{ClassName} Player {senderConn.ClientId} canceled interacting with {gameObject.name}.\"); DeallocateObjectInteractingAction(senderConn.ClientId); foreach (NetworkConnection observer in NetworkObject.Observers) { if (observer == senderConn) continue; TargetsStopAudio(observer); } OnPlayerCanceledInteracting?.Invoke(senderConn); } [Server] protected void AllocateObjectInteractingAction(int clientId) { if (_playerInteractingCoroutines.ContainsKey(clientId)) { DeallocateObjectInteractingAction(clientId); } ObjectAction objectAction = new ObjectAction(StartCoroutine(ObjectInteractingEligibilitySwither(clientId))); _playerInteractingCoroutines.Add(clientId, objectAction); } [Server] protected void DeallocateObjectInteractingAction(int clientId) { if (_playerInteractingCoroutines.ContainsKey(clientId)) { Coroutine coroutine = _playerInteractingCoroutines[clientId].ActionCoroutine; _playerInteractingCoroutines.Remove(clientId); StopCoroutine(coroutine); } } [Server] protected IEnumerator ObjectInteractingEligibilitySwither(int clientId) { yield return new WaitForSeconds(_triggerGenericAction.buttonTimer * .85f); _playerInteractingCoroutines[clientId].IsEligibleToInteract = true; yield return new WaitForSeconds(1f); DeallocateObjectInteractingAction(clientId); } public static void SetObjectRotation(Transform which, Vector3 angle) { //DebugWrite.Log($\"{ClassName} SetObjectRotation() called for {gameObject.name} with angle {angle}\", gameObject, _isDebug); which.localRotation = Quaternion.Euler(angle); } protected virtual void OnObjectRotationChanged(Vector3 prev, Vector3 next, bool asServer) { DebugWrite.Log($\"{ClassName} OnObjectRotationChanged() called for {gameObject.name} with angle {next} _isStartingRotationNotSet {_isStartingRotationNotSet}\", gameObject, _isDebug); if (_isStartingRotationNotSet) { _startingRotation = next; _isStartingRotationNotSet = false; } if (asServer) { SetObjectRotation(transform, next); } else { StartCoroutine(RotateObject(transform, prev, next)); } } public static void RotateObject(Transform trans, Quaternion prev, Quaternion next, float time, Ease ease = Ease.OutSine) { DOTween.Init(); // Reset the rotation to the previous value before starting the tween trans.rotation = prev; // Start a new tween to rotate the object to the next value trans.DORotateQuaternion(next, time) .SetEase(ease); } public static void RotateObject(Transform trans, Vector3 prev, Vector3 next, float time, Ease ease = Ease.OutSine) { DOTween.Init(); // Reset the rotation to the previous value before starting the tween trans.rotation = Quaternion.Euler(prev); // Start a new tween to rotate the object to the next value trans.DORotate(next, time, RotateMode.FastBeyond360) .SetEase(ease); } public IEnumerator RotateObject(Transform trans, Vector3 prev, Vector3 next) { float elapsedTime = 0f; if (prev != next) { DebugWrite.Log($\"{ClassName} RotateObject() called for {gameObject.name} {prev} -> {next}\", gameObject, _isDebug); } while (elapsedTime < OBJECT_ROTATION_DURATION) { elapsedTime += Time.deltaTime; float t = elapsedTime / OBJECT_ROTATION_DURATION; //lerp angle between prev and next var angle = Vector3.Lerp(prev, next, t); SetObjectRotation(trans, angle); prev = angle; yield return null; } } [Server] public virtual void InitServer(GameplayManager gpm, string tag, Vector3 pos, Vector3 rot, float newTime = 0f, bool overrideTime = false) { _tag = tag; _objectRotation = rot; _gameplayManager = gpm; DebugWrite.Log($\"{ClassName} {_tag} {gameObject.name} initialized. _objectRotation: {_objectRotation}\", gameObject, _isDebug); if (_gameplayManager == null) { DebugWrite.Log($\"{ClassName} GameplayManager is null.\", gameObject, _isDebug); } SetupName(); ObserversPlaceObject(pos, rot); if (overrideTime) { if (!Mathf.Approximately(_triggerGenericAction.buttonTimer, newTime)) { _triggerGenericAction.buttonTimer = newTime; ObserversUpdateTime(newTime); } } OnInitialized?.Invoke(); } [ObserversRpc] protected void ObserversPlaceObject(Vector3 pos, Vector3 rot) { DebugWrite.Log($\"{ClassName} Object {gameObject.name} placed.\", gameObject,_isDebug); transform.position = pos; SetObjectRotation(transform, rot); } [ObserversRpc(RunLocally = true)] protected void ObserversUpdateTime(float newTime) { DebugWrite.Log($\"{ClassName} Object {gameObject.name} updated time to {newTime}.\", gameObject,_isDebug); _triggerGenericAction.buttonTimer = newTime; if (newTime < Mathf.Epsilon) { _triggerGenericAction.inputType = vTriggerGenericAction.InputType.GetButtonDown; } } protected virtual void SetupName() { gameObject.name = $\"{_tag} #{NetworkObject.ObjectId}\"; } public class ObjectAction { public Coroutine ActionCoroutine; public bool IsEligibleToInteract; public ObjectAction(Coroutine actionCoroutine) { ActionCoroutine = actionCoroutine; IsEligibleToInteract = false; } } [ObserversRpc] protected void PlayAudio(SoundSource.Type whichType) { InternalPlayAudio(whichType); } protected void InternalPlayAudio(SoundSource.Type whichType) { SoundSource soundSource = null; for (int i = 0; i < _soundSources.Length; i++) { if (_soundSources[i].TypeOfSound == whichType) { soundSource = _soundSources[i]; break; } } if (_audioSource == null) { return; } if (soundSource != null) { _audioSource.volume = soundSource.Volume; if (soundSource.IsLooping) { _audioSource.clip = soundSource.Clip; _audioSource.loop = true; _audioSource.Play(); }else { _audioSource.PlayOneShot(soundSource.Clip); } } } [TargetRpc] protected void TargetsStopAudio(NetworkConnection conn) { //DebugLog($\"{ClassName} StopAudio() called for {gameObject.name}\"); InternalStopAudio(); } protected void InternalStopAudio() { //Debug.Log($\"{ClassName} InternalStopAudio() called for {gameObject.name}\"); if (_audioSource == null) return; if (_audioSource.clip != null) _audioSource.Stop(); } protected void DebugLog(string message) { DebugWrite.Log(message, gameObject, _isDebug); } public virtual void ShowOpenActionText() => vOpenActionText.SetActive(true); public virtual void HideOpenActionText() => vOpenActionText.SetActive(false); [Serializable] public class SoundSource { public AudioClip Clip; [Range(0f, 1f)] public float Volume = 1f; public bool IsLooping; public Type TypeOfSound; public enum Type {Interacting, Activated, Deactivated} } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "InteractableObjectController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "InteractableObjectController",
          "content": " using System; using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DG.Tweening; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using UnityEngine; using DungeonScrollerCore; using FishNet; using FishNet.Observing; using Invector.vCharacterController.vActions; using NGS.AdvancedCullingSystem.Dynamic; namespace InRoomSystems { [RequireComponent(typeof(NetworkObserver))] public class InteractableObjectController : NetworkBehaviour { [SyncVar(OnChange = nameof(OnObjectRotationChanged))] protected Vector3 _objectRotation = Vector3.zero; protected Dictionary<int, ObjectAction> _playerInteractingCoroutines = new Dictionary<int, ObjectAction>(); [SerializeField] protected GameplayManager _gameplayManager; [SerializeField] protected SoundSource[] _soundSources = new SoundSource[0]; [SerializeField] protected GameObjectDispatcher _visualModel; [SerializeField] protected AudioSource _audioSource; [SerializeField] protected GameObject vOpenActionText; protected bool _isStartingRotationNotSet = true; protected Vector3 _startingRotation = Vector3.zero; protected string _tag; [SerializeField] public float OBJECT_ROTATION_DURATION = 0.4f; public Action<NetworkConnection> OnLocalPlayerFinishedInteracting; public Action<NetworkConnection> OnPlayerFinishedInteracting; public Action<NetworkConnection> OnPlayerStartedInteracting; public Action<NetworkConnection> OnPlayerCanceledInteracting; public Action<NetworkConnection> OnPlayerActivatedObject; public Action OnInitialized; [SerializeField] protected bool _isDebug = true; [SerializeField] protected vTriggerGenericAction _triggerGenericAction; public static ObjectsRoomManager ObjectsRoomManager; [SerializeField] protected MeshRenderer[] _meshRenderers; public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); protected string _className; protected virtual void OnValidate() { AssignComponentsIfRequired(); } protected virtual void Awake() { AssignComponentsIfRequired();  ",
          "content_tokens": 522,
          "embedding": []
        },
        {
          "cs_scriptfile": "InteractableObjectController",
          "content": "protected void AssignComponentsIfRequired() { if (_meshRenderers ==null || _meshRenderers.Length == 0) { _meshRenderers = GetComponentsInChildren<MeshRenderer>(); } _audioSource ??= GetComponentInChildren<AudioSource>(); if (_triggerGenericAction == null) _triggerGenericAction = GetComponentInChildren<vTriggerGenericAction>(); if (_audioSource == null) _audioSource = GetComponentInChildren<AudioSource>(); } protected virtual void InitClient() { TurnOnClientOnlyComponents(); AddTimedActionListeners(); DebugWrite.Log($\"{ClassName} {gameObject.name} transform.rotation {transform.rotation.eulerAngles}, _objectRotation {_objectRotation}\", gameObject, _isDebug); if (transform.rotation.eulerAngles != _objectRotation) { SetObjectRotation(transform, _objectRotation); } _gameplayManager = GameplayManager.LocalPlayer; gameObject.name = $\"{tag} #{NetworkObject.ObjectId}\"; #if UNITY_EDITOR if (ObjectsRoomManager == null) ObjectsRoomManager = FindObjectOfType<ObjectsRoomManager>(); transform.parent = ObjectsRoomManager.transform; #endif for (int i = 0; i < _meshRenderers.Length; i++) { DC_Controller.Instance.AddObjectForCulling(_meshRenderers[i]); } } public override void OnStartClient() { base.OnStartClient(); InitClient();  ",
          "content_tokens": 349,
          "embedding": []
        },
        {
          "cs_scriptfile": "InteractableObjectController",
          "content": "protected void TurnOnClientOnlyComponents() { _triggerGenericAction.gameObject.SetActive(true); if (_audioSource != null) { _audioSource.gameObject.SetActive(true); } else { if (_soundSources.Length > 0) Debug.LogError($\"{ClassName} _audioSource is null for {gameObject.name}\");  if (_visualModel != null) _visualModel.Activate(); } public override void OnStartServer() { base.OnStartServer(); SetupName();  private void OnDisable() { //DebugLog($\"{ClassName}OnDisable() called for {gameObject.name}\"); } public override void OnStopClient() { base.OnStopClient(); RemoveTimedActionListeners();  ",
          "content_tokens": 163,
          "embedding": []
        },
        {
          "cs_scriptfile": "InteractableObjectController",
          "content": "protected void AddTimedActionListeners() { _triggerGenericAction.OnPressActionInput.AddListener(PlayerStartedInteracting); _triggerGenericAction.OnFinishActionInput.AddListener(PlayerFinishedInteracting); _triggerGenericAction.OnCancelActionInput.AddListener(PlayerCanceledInteracting);  private void PlayerActivateObject() { DebugLog($\"{ClassName} OnPlayerActivatedObject Player started interacting with {gameObject.name}.\"); OnPlayerActivatedObject?.Invoke(InstanceFinder.ClientManager.Connection);  protected void RemoveTimedActionListeners() { _triggerGenericAction.OnPressActionInput.RemoveAllListeners(); _triggerGenericAction.OnFinishActionInput.RemoveAllListeners(); _triggerGenericAction.OnCancelActionInput.RemoveAllListeners();  ",
          "content_tokens": 181,
          "embedding": []
        },
        {
          "cs_scriptfile": "InteractableObjectController",
          "content": "protected void PlayerStartedInteracting() { DebugLog($\"{ClassName} Player started interacting with {gameObject.name}.\"); if (_triggerGenericAction.inputType == vTriggerGenericAction.InputType.GetButtonDown) { PlayerFinishedInteracting(); }else if (_triggerGenericAction.inputType == vTriggerGenericAction.InputType.GetButtonTimer) { LoadingBarLogic.Instance.StartLoading(_triggerGenericAction.buttonTimer); OnPlayerStartedInteracting?.Invoke(InstanceFinder.ClientManager.Connection); CmdPlayerStartedInteracting(); } } protected virtual void PlayerFinishedInteracting() { DebugLog($\"{ClassName} Player finished interacting with {gameObject.name}.\"); OnLocalPlayerFinishedInteracting?.Invoke(InstanceFinder.ClientManager.Connection); CmdPlayerFinishedInteracting();  ",
          "content_tokens": 189,
          "embedding": []
        },
        {
          "cs_scriptfile": "InteractableObjectController",
          "content": "protected void PlayerCanceledInteracting() { LoadingBarLogic.Instance.CancelLoading(); DebugLog($\"{ClassName} Player canceled interacting with {gameObject.name}.\"); OnPlayerCanceledInteracting?.Invoke(InstanceFinder.ClientManager.Connection); InternalStopAudio(); CmdPlayerCanceledInteracting(); } [ServerRpc(RequireOwnership = false)] protected virtual void CmdPlayerStartedInteracting(NetworkConnection senderConn = null) { DebugLog($\"{ClassName} Player {senderConn.ClientId} started interacting with {gameObject.name}.\"); AllocateObjectInteractingAction(senderConn.ClientId); PlayAudio(SoundSource.Type.Interacting); OnPlayerStartedInteracting?.Invoke(senderConn); } [ServerRpc(RequireOwnership = false)] protected void CmdPlayerFinishedInteracting(NetworkConnection senderConn = null) { int clientId = senderConn.ClientId; DebugLog($\"{ClassName}[Server] Player {clientId} finished interacting with {gameObject.name}.\"); if (_triggerGenericAction.inputType == vTriggerGenericAction.InputType.GetButtonTimer) { if (_playerInteractingCoroutines.ContainsKey(clientId)) { if (_playerInteractingCoroutines[clientId].IsEligibleToInteract) { DebugLog($\"{ClassName} Player {clientId} finished interacting with {gameObject.name} and was eligible to do so.\"); OnPlayerFinishedInteracting?.Invoke(senderConn); } else { DeallocateObjectInteractingAction(clientId); DebugLog($\"{ClassName} Player {clientId} raised finishing of interacting with {gameObject.name}, but was not eligible to do so.\"); } } else { DebugLog($\"{ClassName} Player {clientId} raised finishing of interacting with {gameObject.name}, but no coroutine was found.\"); return; } } else { DebugLog($\"{ClassName} Player {clientId} finished interacting with {gameObject.name} and was eligible to do so.\"); OnPlayerFinishedInteracting?.Invoke(senderConn); } } [ServerRpc(RequireOwnership = false)] protected void CmdPlayerCanceledInteracting(NetworkConnection senderConn = null) { DebugLog($\"{ClassName} Player {senderConn.ClientId} canceled interacting with {gameObject.name}.\"); DeallocateObjectInteractingAction(senderConn.ClientId); foreach (NetworkConnection observer in NetworkObject.Observers) { if (observer == senderConn) continue; TargetsStopAudio(observer); } OnPlayerCanceledInteracting?.Invoke(senderConn); } [Server] protected void AllocateObjectInteractingAction(int clientId) { if (_playerInteractingCoroutines.ContainsKey(clientId)) { DeallocateObjectInteractingAction(clientId); } ObjectAction objectAction = new ObjectAction(StartCoroutine(ObjectInteractingEligibilitySwither(clientId))); _playerInteractingCoroutines.Add(clientId, objectAction); } [Server] protected void DeallocateObjectInteractingAction(int clientId) { if (_playerInteractingCoroutines.ContainsKey(clientId)) { Coroutine coroutine = _playerInteractingCoroutines[clientId].ActionCoroutine; _playerInteractingCoroutines.Remove(clientId); StopCoroutine(coroutine); } } [Server] protected IEnumerator ObjectInteractingEligibilitySwither(int clientId) { yield return new WaitForSeconds(_triggerGenericAction.buttonTimer * .85f); _playerInteractingCoroutines[clientId].IsEligibleToInteract = true; yield return new WaitForSeconds(1f); DeallocateObjectInteractingAction(clientId); } public static void SetObjectRotation(Transform which, Vector3 angle) { //DebugWrite.Log($\"{ClassName}",
          "content_tokens": 887,
          "embedding": []
        },
        {
          "cs_scriptfile": "InteractableObjectController",
          "content": "SetObjectRotation() called for {gameObject.name} with angle {angle}\", gameObject, _isDebug); which.localRotation = Quaternion.Euler(angle); } protected virtual void OnObjectRotationChanged(Vector3 prev, Vector3 next, bool asServer) { DebugWrite.Log($\"{ClassName}OnObjectRotationChanged() called for {gameObject.name} with angle {next} _isStartingRotationNotSet {_isStartingRotationNotSet}\", gameObject, _isDebug); if (_isStartingRotationNotSet) { _startingRotation = next; _isStartingRotationNotSet = false;  ",
          "content_tokens": 146,
          "embedding": []
        },
        {
          "cs_scriptfile": "InteractableObjectController",
          "content": "if (asServer) { SetObjectRotation(transform, next); } else { StartCoroutine(RotateObject(transform, prev, next)); } } public static void RotateObject(Transform trans, Quaternion prev, Quaternion next, float time, Ease ease = Ease.OutSine) { DOTween.Init(); // Reset the rotation to the previous value before starting the tween trans.rotation = prev; // Start a new tween to rotate the object to the next value trans.DORotateQuaternion(next, time) .SetEase(ease); } public static void RotateObject(Transform trans, Vector3 prev, Vector3 next, float time, Ease ease = Ease.OutSine) { DOTween.Init(); // Reset the rotation to the previous value before starting the tween trans.rotation = Quaternion.Euler(prev); // Start a new tween to rotate the object to the next value trans.DORotate(next, time, RotateMode.FastBeyond360) .SetEase(ease); } public IEnumerator RotateObject(Transform trans, Vector3 prev, Vector3 next) { float elapsedTime = 0f; if (prev != next) { DebugWrite.Log($\"{ClassName}",
          "content_tokens": 283,
          "embedding": []
        },
        {
          "cs_scriptfile": "InteractableObjectController",
          "content": "RotateObject() called for {gameObject.name} {prev} -> {next}\", gameObject, _isDebug);  ",
          "content_tokens": 29,
          "embedding": []
        },
        {
          "cs_scriptfile": "InteractableObjectController",
          "content": "while (elapsedTime < OBJECT_ROTATION_DURATION) { elapsedTime += Time.deltaTime; float t = elapsedTime / OBJECT_ROTATION_DURATION; //lerp angle between prev and next var angle = Vector3.Lerp(prev, next, t); SetObjectRotation(trans, angle); prev = angle; yield return null; } } [Server] public virtual void InitServer(GameplayManager gpm, string tag, Vector3 pos, Vector3 rot, float newTime = 0f, bool overrideTime = false) { _tag = tag; _objectRotation = rot; _gameplayManager = gpm; DebugWrite.Log($\"{ClassName} {_tag} {gameObject.name} initialized. _objectRotation: {_objectRotation}\", gameObject, _isDebug); if (_gameplayManager == null) { DebugWrite.Log($\"{ClassName} GameplayManager is null.\", gameObject, _isDebug);  ",
          "content_tokens": 221,
          "embedding": []
        },
        {
          "cs_scriptfile": "InteractableObjectController",
          "content": "SetupName(); ObserversPlaceObject(pos, rot); if (overrideTime) { if (!Mathf.Approximately(_triggerGenericAction.buttonTimer, newTime)) { _triggerGenericAction.buttonTimer = newTime; ObserversUpdateTime(newTime); } } OnInitialized?.Invoke(); } [ObserversRpc] protected void ObserversPlaceObject(Vector3 pos, Vector3 rot) { DebugWrite.Log($\"{ClassName} Object {gameObject.name} placed.\", gameObject,_isDebug); transform.position = pos; SetObjectRotation(transform, rot); } [ObserversRpc(RunLocally = true)] protected void ObserversUpdateTime(float newTime) { DebugWrite.Log($\"{ClassName} Object {gameObject.name} updated time to {newTime}.\", gameObject,_isDebug); _triggerGenericAction.buttonTimer = newTime; if (newTime < Mathf.Epsilon) { _triggerGenericAction.inputType = vTriggerGenericAction.InputType.GetButtonDown; } } protected virtual void SetupName() { gameObject.name = $\"{_tag} #{NetworkObject.ObjectId}\"; } public class ObjectAction { public Coroutine ActionCoroutine; public bool IsEligibleToInteract; public ObjectAction(Coroutine actionCoroutine) { ActionCoroutine = actionCoroutine; IsEligibleToInteract = false; } } [ObserversRpc] protected void PlayAudio(SoundSource.Type whichType) { InternalPlayAudio(whichType);  ",
          "content_tokens": 349,
          "embedding": []
        },
        {
          "cs_scriptfile": "InteractableObjectController",
          "content": "protected void InternalPlayAudio(SoundSource.Type whichType) { SoundSource soundSource = null; for (int i = 0; i < _soundSources.Length; i++) { if (_soundSources[i].TypeOfSound == whichType) { soundSource = _soundSources[i]; break; }  if (_audioSource == null) { return;  if (soundSource != null) { _audioSource.volume = soundSource.Volume; if (soundSource.IsLooping) { _audioSource.clip = soundSource.Clip; _audioSource.loop = true; _audioSource.Play(); }else { _audioSource.PlayOneShot(soundSource.Clip); } } } [TargetRpc] protected void TargetsStopAudio(NetworkConnection conn) { //DebugLog($\"{ClassName}StopAudio() called for {gameObject.name}\"); InternalStopAudio();  ",
          "content_tokens": 197,
          "embedding": []
        },
        {
          "cs_scriptfile": "InteractableObjectController",
          "content": "protected void InternalStopAudio() { //Debug.Log($\"{ClassName}InternalStopAudio() called for {gameObject.name}\"); if (_audioSource == null) return; if (_audioSource.clip != null) _audioSource.Stop();  protected void DebugLog(string message) { DebugWrite.Log(message, gameObject, _isDebug); } public virtual void ShowOpenActionText() => vOpenActionText.SetActive(true); public virtual void HideOpenActionText() => vOpenActionText.SetActive(false); [Serializable] public class SoundSource { public AudioClip Clip; [Range(0f, 1f)] public float Volume = 1f; public bool IsLooping; public Type TypeOfSound; public enum Type {Interacting, Activated, Deactivated} } } }",
          "content_tokens": 176,
          "embedding": []
        }
      ],
      "length": 13657
    },
    {
      "filename": "LootBagController",
      "content": "using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FishNet.Connection; using FishNet.Object; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using Invector.vItemManager; namespace InRoomSystems { public class LootBagController : InteractableObjectController { private List<ItemReference> _items; public override void OnStartServer() { base.OnStartServer(); OnPlayerFinishedInteracting += OpenLootBag; } [Server] public void CustomInit(List<ItemReference> itemReferences) { _items = itemReferences; } [Server] private void OpenLootBag(NetworkConnection conn) { var playerComps = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); var playerItemManager = playerComps.ItemManager; playerItemManager.ServerAddListItemReferences(_items); DebugWrite.Log($\"[LootBagController] Player {conn.ClientId} received {_items.Count} items from loot bag.\", gameObject, _isDebug); Despawn(NetworkObject); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LootBagController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootBagController",
          "content": "using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FishNet.Connection; using FishNet.Object; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using Invector.vItemManager; namespace InRoomSystems { public class LootBagController : InteractableObjectController { private List<ItemReference> _items; public override void OnStartServer() { base.OnStartServer(); OnPlayerFinishedInteracting += OpenLootBag; } [Server] public void CustomInit(List<ItemReference> itemReferences) { _items = itemReferences; } [Server] private void OpenLootBag(NetworkConnection conn) { var playerComps = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); var playerItemManager = playerComps.ItemManager; playerItemManager.ServerAddListItemReferences(_items); DebugWrite.Log($\"[LootBagController] Player {conn.ClientId} received {_items.Count} items from loot bag.\", gameObject, _isDebug); Despawn(NetworkObject); } } }",
          "content_tokens": 254,
          "embedding": []
        }
      ],
      "length": 970
    },
    {
      "filename": "LootItemController",
      "content": "using System; using System.Collections.Generic; using System.Threading.Tasks; using _ZombieRoyale.Scripts.Core; using DuloGames.UI; using FishNet.Connection; using FishNet.Object; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object.Synchronizing; using Invector.vItemManager; using SingletonsExtension; using Sirenix.OdinInspector; using UnityEngine; using UnityEngine.UI; using Random = UnityEngine.Random; namespace InRoomSystems { public class LootItemController : InteractableObjectController { [SyncObject] private readonly SyncList<ItemReferenceNetworked> _storedItems = new (); [SerializeField] private GameObject canvasUI; [SerializeField] private GameObject hotkeyInfo; [SerializeField] private GameObject iconGroup; [SerializeField] private Image imgIcon; [SerializeField] private Image imgBackground; [SerializeField] private Image imgFrame; [SerializeField] private TMProDecorator textAmount; [Header(\"Physics\")] [SerializeField] private Rigidbody rb; [SerializeField] private float minLaunchForce = 5f; // Minimum launch force [SerializeField] private float maxLaunchForce = 10f; // Maximum launch force [SerializeField] private float maxRandomAngle = 45f; // Maximum angle for random direction #region Item Tooltip [Header(\"Item Tooltip\")] [SerializeField] private GameObject tooltipHolder; [SerializeField] private TMProDecorator itemName; [SerializeField] private TMProDecorator itemType; [SerializeField] private TMProDecorator statPrefab; [SerializeField] private Color colorArmor; [SerializeField] private Color colorDescription; [SerializeField] private Color colorStatPositive; [SerializeField] private Color colorStatNegative; [SerializeField] private UIHeightSetter heightSetter; #endregion [Header(\"Particles\")] [SerializeField] private GameObject particleGroup; [SerializeField] private ParticleSystem[] particleSystems; private bool isHaveItem = true; private bool isInitialized; private void OnDisable() { particleGroup.SetActive(false); iconGroup.SetActive(false); _storedItems.OnChange -= storedItems_OnChange; OnPlayerFinishedInteracting -= GiveItem; } protected override void Awake() { base.Awake(); _storedItems.OnChange += storedItems_OnChange; } public override void OnStartServer() { base.OnStartServer(); OnPlayerFinishedInteracting += GiveItem; } [Server] public void CustomInit(List<ItemReference> itemReferences) { for (int i = 0; i < itemReferences.Count; i++) { ItemReference itemRef = itemReferences[i]; ItemReferenceNetworked itemRefNet = itemRef.ToNetworked(); _storedItems.Add(itemRefNet); if (itemRef.id == 0) { Debug.Log($\"{ClassName} CustomInit: itemRef.id == 0\"); } } } private void storedItems_OnChange(SyncListOperation op, int index, ItemReferenceNetworked oldItem, ItemReferenceNetworked newItem, bool asServer) { if (asServer) return; switch (op) { case SyncListOperation.Add: Debug.Log($\"{ClassName} storedItems_OnChange: {op} item id #{newItem.id}x{newItem.amount} at index {index}\"); UpdateVisualUI(newItem.id, newItem.amount); break; case SyncListOperation.RemoveAt: break; case SyncListOperation.Insert: break; case SyncListOperation.Set: break; case SyncListOperation.Clear: break; case SyncListOperation.Complete: break; } } /// <summary> /// Activates by _triggerGenericAction /// </summary> public void OnPlayerEnterToInteractingZone() { var item = _storedItems[0]; OnTooltip(item.id, item.amount, true); hotkeyInfo.SetActive(true); } /// <summary> /// Activates by _triggerGenericAction /// </summary> public void OnPlayerExitFromInteractingZone() { OnTooltip(2, 0, false); hotkeyInfo.SetActive(false); } [Server] private void GiveItem(NetworkConnection conn) { if (!isHaveItem) return; isHaveItem = false; var playerComps = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); var playerItemManager = playerComps.ItemManager; List<ItemReference> _items = new List<ItemReference>(); foreach (var itemRefNet in _storedItems) { ItemReference itemRef = itemRefNet.ToNonNetworked(); _items.Add(itemRef); } playerItemManager.ServerAddListItemReferences(_items); DebugWrite.Log($\"{ClassName} received item #{_items[0].id} {playerComps.ItemManager.gameObject.name} \", gameObject, _isDebug); Despawn(NetworkObject); } public void UpdateVisualUI(int itemId, int amount) { if (itemId < 0) return; if (amount < 1) return; vItem item = MasterManager.GetVItem(itemId); item.amount = amount; string colorHex = vItem.GetRarityHexColorCode(item.rarity); UpdateColors(colorHex.Substring(1)); imgIcon.sprite = item.icon; if (amount > 1) textAmount.SetText(amount.ToString()); particleGroup.SetActive(true); iconGroup.SetActive(true); LaunchItem(); } public void LaunchItem() { // Calculate a random direction within the maximum angle float randomX = Random.Range(-maxRandomAngle, maxRandomAngle); float randomY = Random.Range(0f, 360f); float randomZ = Random.Range(-maxRandomAngle, maxRandomAngle); Debug.Log($\"Random angles: {randomX}, {randomY}, {randomZ}\"); Vector3 randomDirection = Quaternion.Euler(-35f, randomY, 35f) * transform.forward; // Calculate a random launch force within the specified range float launchForce = Random.Range(minLaunchForce, maxLaunchForce); // Apply the launch force to the item in the random direction rb.gameObject.SetActive(true); rb.AddForce(randomDirection * launchForce, ForceMode.Impulse); TurnOffRigidbody(); } async Task TurnOffRigidbody() { await Task.Delay(500); rb.isKinematic = true; } private void OnTooltip(int itemId, int amount, bool show) { if (itemId < 1) return; if (show) { GenerateTooltipIfRequired(itemId, amount); heightSetter.gameObject.SetActive(true); tooltipHolder.SetActive(true); } else { heightSetter.gameObject.SetActive(false); tooltipHolder.SetActive(false); } } private void GenerateTooltipIfRequired(int itemId, int amount) { if (isInitialized) return; vItem item = MasterManager.GetVItem(itemId); item.amount = amount; itemName.SetText($\"<color={vItem.GetRarityHexColorCode(item.rarity)}>{item.Name}</color>\"); itemType.SetText(item.type.ToString()); int lastSiblingIndex = 0; foreach (vItemAttribute attr in item.attributes) { TMProDecorator stat = Instantiate(statPrefab, tooltipHolder.transform); stat.SetText(attr.GetTextForTooltip()); stat.SetColor(attr.value > float.Epsilon ? colorStatPositive : colorStatNegative); if (attr.Type == AttributeTypes.Armor) { stat.SetColor(colorArmor); } } TMProDecorator desc = Instantiate(statPrefab, tooltipHolder.transform); desc.SetText(item.description); desc.SetColor(colorDescription); SetDescriptionHeightBasedOnTextLength(desc); heightSetter.UpdateHeight(); isInitialized = true; } private void SetDescriptionHeightBasedOnTextLength(TMProDecorator desc) { int textLength = desc.GetText().Length; int additionalLines = textLength / 66; int lineHeight = 40; desc.GetComponent<RectTransform>().sizeDelta = new Vector2(desc.GetComponent<RectTransform>().sizeDelta.x, desc.GetComponent<RectTransform>().sizeDelta.y + lineHeight * additionalLines); } private void UpdateColors(string colorHex) { //set color alpha to 30% colorHex += \"4D\"; UpgradeUIColors(colorHex); UpdateParticlesColors(colorHex); } private void UpgradeUIColors(string colorHex) { imgBackground.color = CommonColorBuffer.HexToColor(colorHex); imgFrame.color = CommonColorBuffer.HexToColor(colorHex); } private void UpdateParticlesColors(string colorHex) { foreach (var ps in particleSystems) { var main = ps.main; main.startColor = CommonColorBuffer.HexToColor(colorHex); } } protected override void SetupName() { gameObject.name = $\"LootItem #{NetworkObject.ObjectId}\"; } private void ActivateUI() { canvasUI.SetActive(true); } private void DeactivateUI() { canvasUI.SetActive(false); } #region Test [Button(ButtonSizes.Medium)] public void TestShowDescription() { UpdateVisualUI(215, 1); OnTooltip(215, 1, true); hotkeyInfo.SetActive(true); } [Button(ButtonSizes.Medium)] public void TestHideDescription() { OnTooltip(215, 1, false); hotkeyInfo.SetActive(false); } [Button(ButtonSizes.Medium)] private void EditorShowElements() { #if UNITY_EDITOR rb.gameObject.SetActive(true); iconGroup.SetActive(true); tooltipHolder.SetActive(true); hotkeyInfo.SetActive(true); heightSetter.gameObject.SetActive(true); particleGroup.SetActive(true); #endif } [Button(ButtonSizes.Medium)] private void EditorHideElements() { #if UNITY_EDITOR rb.gameObject.SetActive(false); iconGroup.SetActive(false); tooltipHolder.SetActive(false); hotkeyInfo.SetActive(false); heightSetter.gameObject.SetActive(false); particleGroup.SetActive(false); #endif } #endregion } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LootItemController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootItemController",
          "content": "using System; using System.Collections.Generic; using System.Threading.Tasks; using _ZombieRoyale.Scripts.Core; using DuloGames.UI; using FishNet.Connection; using FishNet.Object; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object.Synchronizing; using Invector.vItemManager; using SingletonsExtension; using Sirenix.OdinInspector; using UnityEngine; using UnityEngine.UI; using Random = UnityEngine.Random; namespace InRoomSystems { public class LootItemController : InteractableObjectController { [SyncObject] private readonly SyncList<ItemReferenceNetworked> _storedItems = new (); [SerializeField] private GameObject canvasUI; [SerializeField] private GameObject hotkeyInfo; [SerializeField] private GameObject iconGroup; [SerializeField] private Image imgIcon; [SerializeField] private Image imgBackground; [SerializeField] private Image imgFrame; [SerializeField] private TMProDecorator textAmount; [Header(\"Physics\")] [SerializeField] private Rigidbody rb; [SerializeField] private float minLaunchForce = 5f; // Minimum launch force [SerializeField] private float maxLaunchForce = 10f; // Maximum launch force [SerializeField] private float maxRandomAngle = 45f; // Maximum angle for random direction #region Item Tooltip [Header(\"Item Tooltip\")] [SerializeField] private GameObject tooltipHolder; [SerializeField] private TMProDecorator itemName; [SerializeField] private TMProDecorator itemType; [SerializeField] private TMProDecorator statPrefab; [SerializeField] private Color colorArmor; [SerializeField] private Color colorDescription; [SerializeField] private Color colorStatPositive; [SerializeField] private Color colorStatNegative; [SerializeField] private UIHeightSetter heightSetter; #endregion [Header(\"Particles\")] [SerializeField] private GameObject particleGroup; [SerializeField] private ParticleSystem[] particleSystems; private bool isHaveItem = true; private bool isInitialized; private void OnDisable() { particleGroup.SetActive(false); iconGroup.SetActive(false); _storedItems.OnChange -= storedItems_OnChange; OnPlayerFinishedInteracting -= GiveItem; } protected override void Awake() { base.Awake(); _storedItems.OnChange += storedItems_OnChange; } public override void OnStartServer() { base.OnStartServer(); OnPlayerFinishedInteracting += GiveItem; } [Server] public void CustomInit(List<ItemReference> itemReferences) { for (int i = 0; i < itemReferences.Count; i++) { ItemReference itemRef = itemReferences[i]; ItemReferenceNetworked itemRefNet = itemRef.ToNetworked(); _storedItems.Add(itemRefNet); if (itemRef.id == 0) { Debug.Log($\"{ClassName} CustomInit: itemRef.id == 0\"); } }  ",
          "content_tokens": 698,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootItemController",
          "content": "private void storedItems_OnChange(SyncListOperation op, int index, ItemReferenceNetworked oldItem, ItemReferenceNetworked newItem, bool asServer) { if (asServer) return; switch (op) { case SyncListOperation.Add: Debug.Log($\"{ClassName} storedItems_OnChange: {op} item id #{newItem.id}x{newItem.amount} at index {index}\"); UpdateVisualUI(newItem.id, newItem.amount); break; case SyncListOperation.RemoveAt: break; case SyncListOperation.Insert: break; case SyncListOperation.Set: break; case SyncListOperation.Clear: break; case SyncListOperation.Complete: break; } } /// <summary> /// Activates by _triggerGenericAction /// </summary> public void OnPlayerEnterToInteractingZone() { var item = _storedItems[0]; OnTooltip(item.id, item.amount, true); hotkeyInfo.SetActive(true); } /// <summary> /// Activates by _triggerGenericAction /// </summary> public void OnPlayerExitFromInteractingZone() { OnTooltip(2, 0, false); hotkeyInfo.SetActive(false); } [Server] private void GiveItem(NetworkConnection conn) { if (!isHaveItem) return; isHaveItem = false; var playerComps = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); var playerItemManager = playerComps.ItemManager; List<ItemReference> _items = new List<ItemReference>(); foreach (var itemRefNet in _storedItems) { ItemReference itemRef = itemRefNet.ToNonNetworked(); _items.Add(itemRef); } playerItemManager.ServerAddListItemReferences(_items); DebugWrite.Log($\"{ClassName} received item #{_items[0].id} {playerComps.ItemManager.gameObject.name} \", gameObject, _isDebug); Despawn(NetworkObject);  ",
          "content_tokens": 442,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootItemController",
          "content": "public void UpdateVisualUI(int itemId, int amount) { if (itemId < 0) return; if (amount < 1) return; vItem item = MasterManager.GetVItem(itemId); item.amount = amount; string colorHex = vItem.GetRarityHexColorCode(item.rarity); UpdateColors(colorHex.Substring(1)); imgIcon.sprite = item.icon; if (amount > 1) textAmount.SetText(amount.ToString()); particleGroup.SetActive(true); iconGroup.SetActive(true); LaunchItem();  ",
          "content_tokens": 133,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootItemController",
          "content": "public void LaunchItem() { // Calculate a random direction within the maximum angle float randomX = Random.Range(-maxRandomAngle, maxRandomAngle); float randomY = Random.Range(0f, 360f); float randomZ = Random.Range(-maxRandomAngle, maxRandomAngle); Debug.Log($\"Random angles: {randomX}, {randomY}, {randomZ}\"); Vector3 randomDirection = Quaternion.Euler(-35f, randomY, 35f) * transform.forward; // Calculate a random launch force within the specified range float launchForce = Random.Range(minLaunchForce, maxLaunchForce); // Apply the launch force to the item in the random direction rb.gameObject.SetActive(true); rb.AddForce(randomDirection * launchForce, ForceMode.Impulse); TurnOffRigidbody(); } async Task TurnOffRigidbody() { await Task.Delay(500); rb.isKinematic = true;  ",
          "content_tokens": 221,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootItemController",
          "content": "private void OnTooltip(int itemId, int amount, bool show) { if (itemId < 1) return; if (show) { GenerateTooltipIfRequired(itemId, amount); heightSetter.gameObject.SetActive(true); tooltipHolder.SetActive(true); } else { heightSetter.gameObject.SetActive(false); tooltipHolder.SetActive(false); }  ",
          "content_tokens": 91,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootItemController",
          "content": "private void GenerateTooltipIfRequired(int itemId, int amount) { if (isInitialized) return; vItem item = MasterManager.GetVItem(itemId); item.amount = amount; itemName.SetText($\"<color={vItem.GetRarityHexColorCode(item.rarity)}>{item.Name}</color>\"); itemType.SetText(item.type.ToString()); int lastSiblingIndex = 0; foreach (vItemAttribute attr in item.attributes) { TMProDecorator stat = Instantiate(statPrefab, tooltipHolder.transform); stat.SetText(attr.GetTextForTooltip()); stat.SetColor(attr.value > float.Epsilon ? colorStatPositive : colorStatNegative); if (attr.Type == AttributeTypes.Armor) { stat.SetColor(colorArmor); } } TMProDecorator desc = Instantiate(statPrefab, tooltipHolder.transform); desc.SetText(item.description); desc.SetColor(colorDescription); SetDescriptionHeightBasedOnTextLength(desc); heightSetter.UpdateHeight(); isInitialized = true;  ",
          "content_tokens": 258,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootItemController",
          "content": "private void SetDescriptionHeightBasedOnTextLength(TMProDecorator desc) { int textLength = desc.GetText().Length; int additionalLines = textLength / 66; int lineHeight = 40; desc.GetComponent<RectTransform>().sizeDelta = new Vector2(desc.GetComponent<RectTransform>().sizeDelta.x, desc.GetComponent<RectTransform>().sizeDelta.y + lineHeight * additionalLines);  private void UpdateColors(string colorHex) { //set color alpha to 30% colorHex += \"4D\"; UpgradeUIColors(colorHex); UpdateParticlesColors(colorHex);  private void UpgradeUIColors(string colorHex) { imgBackground.color = CommonColorBuffer.HexToColor(colorHex); imgFrame.color = CommonColorBuffer.HexToColor(colorHex);  ",
          "content_tokens": 197,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootItemController",
          "content": "private void UpdateParticlesColors(string colorHex) { foreach (var ps in particleSystems) { var main = ps.main; main.startColor = CommonColorBuffer.HexToColor(colorHex); } } protected override void SetupName() { gameObject.name = $\"LootItem #{NetworkObject.ObjectId}\";  private void ActivateUI() { canvasUI.SetActive(true);  ",
          "content_tokens": 95,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootItemController",
          "content": "private void DeactivateUI() { canvasUI.SetActive(false); } #region Test [Button(ButtonSizes.Medium)] public void TestShowDescription() { UpdateVisualUI(215, 1); OnTooltip(215, 1, true); hotkeyInfo.SetActive(true); } [Button(ButtonSizes.Medium)] public void TestHideDescription() { OnTooltip(215, 1, false); hotkeyInfo.SetActive(false); } [Button(ButtonSizes.Medium)] private void EditorShowElements() { #if UNITY_EDITOR rb.gameObject.SetActive(true); iconGroup.SetActive(true); tooltipHolder.SetActive(true); hotkeyInfo.SetActive(true); heightSetter.gameObject.SetActive(true); particleGroup.SetActive(true); #endif } [Button(ButtonSizes.Medium)] private void EditorHideElements() { #if UNITY_EDITOR rb.gameObject.SetActive(false); iconGroup.SetActive(false); tooltipHolder.SetActive(false); hotkeyInfo.SetActive(false); heightSetter.gameObject.SetActive(false); particleGroup.SetActive(false); #endif } #endregion } }",
          "content_tokens": 272,
          "embedding": []
        }
      ],
      "length": 8543
    },
    {
      "filename": "ObjectLocationNotifier",
      "content": " using System; using System.Collections; using System.Collections.Generic; using DungeonScrollerCore; using FishNet.Object; using FishNet.Object.Synchronizing; using FishnetInvector; using UnityEngine; using UnityEngine.Serialization; namespace InRoomSystems { public class ObjectLocationNotifier : RoomManager { [SerializeField] protected float START_REPORT_AFTER_SECS = 20.0f; [SerializeField] protected float DISTANCE_TO_HIDE_ICON = 15.0f; [SerializeField] protected GameObject _iconPrefab; [SyncObject] protected readonly SyncList<Vector3> _myCollection = new SyncList<Vector3>(); [SerializeField] protected bool _isDebug; public ObjectLocationNotifier Instance { get; private set; } #region Local Player Fields protected Coroutine _notificationTimerCoroutine; protected Stack<ObjectIconContainer> _usedList; protected Stack<ObjectIconContainer> _unusedList; #endregion protected virtual void Awake() { Instance = this; _myCollection.OnChange += _myCollection_OnChange; } protected void _myCollection_OnChange(SyncListOperation op, int index, Vector3 oldItem, Vector3 newItem, bool asServer) { switch (op) { /* An object was added to the list. Index * will be where it was added, which will be the end * of the list, while newItem is the value added. */ case SyncListOperation.Add: if (!asServer) NotifyPlayers(); break; /* An object was removed from the list. Index * is from where the object was removed. oldItem * will contain the removed item. */ case SyncListOperation.RemoveAt: if (!asServer) NotifyPlayers(); break; /* An object was inserted into the list. Index * is where the obejct was inserted. newItem * contains the item inserted. */ case SyncListOperation.Insert: if (!asServer) NotifyPlayers(); break; /* An object replaced another. Index * is where the object was replaced. oldItem * is the item that was replaced, while * newItem is the item which now has it's place. */ case SyncListOperation.Set: if (!asServer) NotifyPlayers(); break; /* All objects have been cleared. Index, oldValue, * and newValue are default. */ case SyncListOperation.Clear: if (!asServer) NotifyPlayers(); break; /* When complete calls all changes have been * made to the collection. You may use this * to refresh information in relation to * the list changes, rather than doing so * after every entry change. Like Clear * Index, oldItem, and newItem are all default. */ case SyncListOperation.Complete: break; } } public override void OnStartClient() { base.OnStartClient(); _usedList = new Stack<ObjectIconContainer>(); _unusedList = new Stack<ObjectIconContainer>(); } [Server] public void UpdatePoints(List<Vector3> pointsList) { StartCoroutine(NotificationTimer(pointsList)); } [Server] protected virtual IEnumerator NotificationTimer(List<Vector3> pointsList) { yield return new WaitForSeconds(START_REPORT_AFTER_SECS); _myCollection.AddRange(pointsList); //if (pointsList.Count > 0) NotifyPlayers(pointsList); //Debug.Log($\"[ObjectLocationNotifier] Notifying players\"); } [Client] public void NotifyPlayers() { DebugWrite.Log($\"[ObjectLocationNotifier] Notifying players\", gameObject, _isDebug); if (_notificationTimerCoroutine != null) StopCoroutine(_notificationTimerCoroutine); _notificationTimerCoroutine = StartCoroutine(LocalPlayerNotifierSpam(_myCollection)); } [Client] protected IEnumerator LocalPlayerNotifierSpam(SyncList<Vector3> positions) { var time = new WaitForSeconds(.5f); while (true) { yield return time; if (FishnetInvectorManager.LocalPlayer == null) { //Debug.LogError($\"[ObjectLocationNotifier] Local player hero is null!\"); continue; } SpawnOrUpdateForEachPoint(positions); } } [Client] protected void SpawnOrUpdateForEachPoint(SyncList<Vector3> positions) { DeallocateAllPoints(); DebugWrite.Log($\"[ObjectLocationNotifier] Spawning {positions.Count} points\", gameObject, _isDebug); foreach (var point in positions) { var localPlayer = FishnetInvectorManager.LocalPlayer; float distance = Vector3.Distance(localPlayer.transform.position, point); if (distance > DISTANCE_TO_HIDE_ICON) { var newIcon = AllocatePoint(point); newIcon.SetDistance(distance); } } } protected ObjectIconContainer AllocatePoint(Vector3 position) { DebugWrite.Log($\"[ObjectLocationNotifier] Allocating point at {position}\", gameObject, _isDebug); ObjectIconContainer objectIconContainer = null; if (_unusedList.Count > 0) { objectIconContainer = _unusedList.Pop(); _usedList.Push(objectIconContainer); objectIconContainer.Show(); return objectIconContainer; } var iconGo = Instantiate(_iconPrefab, position, Quaternion.identity); UICanvasGroupDecorator iconCanvas = iconGo.GetComponentInChildren<UICanvasGroupDecorator>(); TMProDecorator distanceText = iconGo.GetComponentInChildren<TMProDecorator>(); objectIconContainer = new ObjectIconContainer(iconGo, iconCanvas, distanceText); _usedList.Push(objectIconContainer); return objectIconContainer; } protected void DeallocatePoint(Vector3 atPosition) { foreach (var objectIcon in _usedList) { if (objectIcon.Parent.transform.position == atPosition) { _usedList.Pop(); _unusedList.Push(objectIcon); objectIcon.Hide(); } } } protected void DeallocatePoints(List<Vector3> atPositions) { foreach (var objectIcon in _usedList) { var objectPos = objectIcon.Parent.transform.position; if (atPositions.Contains(objectPos)) { _usedList.Pop(); _unusedList.Push(objectIcon); objectIcon.Hide(); } } } protected void DeallocateAllPoints() { DebugWrite.Log($\"[ObjectLocationNotifier] Deallocating all points\", gameObject, _isDebug); while (_usedList.Count > 0) { var objectIcon = _usedList.Pop(); _unusedList.Push(objectIcon); objectIcon.Hide(); } } } [Serializable] public class ObjectIconContainer { public GameObject Parent; [FormerlySerializedAs(\"Icon\")] public UICanvasGroupDecorator IconCanvasGroupDecorator; public TMProDecorator DistanceText; public ObjectIconContainer(GameObject parent, UICanvasGroupDecorator iconCanvasGroupDecorator, TMProDecorator distanceText) { Parent = parent; IconCanvasGroupDecorator = iconCanvasGroupDecorator; DistanceText = distanceText; } public void Show() => IconCanvasGroupDecorator.Show(true); public void Hide() { if (IconCanvasGroupDecorator != null) { IconCanvasGroupDecorator.Hide(); } } public void SetDistance(float distance) { DistanceText.SetText(distance.ToString(\"F0\") + \"m\"); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ObjectLocationNotifier",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "ObjectLocationNotifier",
          "content": " using System; using System.Collections; using System.Collections.Generic; using DungeonScrollerCore; using FishNet.Object; using FishNet.Object.Synchronizing; using FishnetInvector; using UnityEngine; using UnityEngine.Serialization; namespace InRoomSystems { public class ObjectLocationNotifier : RoomManager { [SerializeField] protected float START_REPORT_AFTER_SECS = 20.0f; [SerializeField] protected float DISTANCE_TO_HIDE_ICON = 15.0f; [SerializeField] protected GameObject _iconPrefab; [SyncObject] protected readonly SyncList<Vector3> _myCollection = new SyncList<Vector3>(); [SerializeField] protected bool _isDebug; public ObjectLocationNotifier Instance { get; private set; } #region Local Player Fields protected Coroutine _notificationTimerCoroutine; protected Stack<ObjectIconContainer> _usedList; protected Stack<ObjectIconContainer> _unusedList; #endregion protected virtual void Awake() { Instance = this; _myCollection.OnChange += _myCollection_OnChange;  ",
          "content_tokens": 251,
          "embedding": []
        },
        {
          "cs_scriptfile": "ObjectLocationNotifier",
          "content": "protected void _myCollection_OnChange(SyncListOperation op, int index, Vector3 oldItem, Vector3 newItem, bool asServer) { switch (op) { /* An object was added to the list. Index * will be where it was added, which will be the end * of the list, while newItem is the value added. */ case SyncListOperation.Add: if (!asServer) NotifyPlayers(); break; /* An object was removed from the list. Index * is from where the object was removed. oldItem * will contain the removed item. */ case SyncListOperation.RemoveAt: if (!asServer) NotifyPlayers(); break; /* An object was inserted into the list. Index * is where the obejct was inserted. newItem * contains the item inserted. */ case SyncListOperation.Insert: if (!asServer) NotifyPlayers(); break; /* An object replaced another. Index * is where the object was replaced. oldItem * is the item that was replaced, while * newItem is the item which now has it's place. */ case SyncListOperation.Set: if (!asServer) NotifyPlayers(); break; /* All objects have been cleared. Index, oldValue, * and newValue are default. */ case SyncListOperation.Clear: if (!asServer) NotifyPlayers(); break; /* When complete calls all changes have been * made to the collection. You may use this * to refresh information in relation to * the list changes, rather than doing so * after every entry change. Like Clear * Index, oldItem, and newItem are all default. */ case SyncListOperation.Complete: break; } } public override void OnStartClient() { base.OnStartClient(); _usedList = new Stack<ObjectIconContainer>(); _unusedList = new Stack<ObjectIconContainer>(); } [Server] public void UpdatePoints(List<Vector3> pointsList) { StartCoroutine(NotificationTimer(pointsList)); } [Server] protected virtual IEnumerator NotificationTimer(List<Vector3> pointsList) { yield return new WaitForSeconds(START_REPORT_AFTER_SECS); _myCollection.AddRange(pointsList); //if (pointsList.Count > 0) NotifyPlayers(pointsList); //Debug.Log($\"[ObjectLocationNotifier] Notifying players\"); } [Client] public void NotifyPlayers() { DebugWrite.Log($\"[ObjectLocationNotifier] Notifying players\", gameObject, _isDebug); if (_notificationTimerCoroutine != null) StopCoroutine(_notificationTimerCoroutine); _notificationTimerCoroutine = StartCoroutine(LocalPlayerNotifierSpam(_myCollection)); } [Client] protected IEnumerator LocalPlayerNotifierSpam(SyncList<Vector3> positions) { var time = new WaitForSeconds(.5f); while (true) { yield return time; if (FishnetInvectorManager.LocalPlayer == null) { //Debug.LogError($\"[ObjectLocationNotifier] Local player hero is null!\"); continue;  ",
          "content_tokens": 660,
          "embedding": []
        },
        {
          "cs_scriptfile": "ObjectLocationNotifier",
          "content": "SpawnOrUpdateForEachPoint(positions); } } [Client] protected void SpawnOrUpdateForEachPoint(SyncList<Vector3> positions) { DeallocateAllPoints(); DebugWrite.Log($\"[ObjectLocationNotifier] Spawning {positions.Count} points\", gameObject, _isDebug); foreach (var point in positions) { var localPlayer = FishnetInvectorManager.LocalPlayer; float distance = Vector3.Distance(localPlayer.transform.position, point); if (distance > DISTANCE_TO_HIDE_ICON) { var newIcon = AllocatePoint(point); newIcon.SetDistance(distance); } } } protected ObjectIconContainer AllocatePoint(Vector3 position) { DebugWrite.Log($\"[ObjectLocationNotifier] Allocating point at {position}\", gameObject, _isDebug); ObjectIconContainer objectIconContainer = null; if (_unusedList.Count > 0) { objectIconContainer = _unusedList.Pop(); _usedList.Push(objectIconContainer); objectIconContainer.Show(); return objectIconContainer; } var iconGo = Instantiate(_iconPrefab, position, Quaternion.identity); UICanvasGroupDecorator iconCanvas = iconGo.GetComponentInChildren<UICanvasGroupDecorator>(); TMProDecorator distanceText = iconGo.GetComponentInChildren<TMProDecorator>(); objectIconContainer = new ObjectIconContainer(iconGo, iconCanvas, distanceText); _usedList.Push(objectIconContainer); return objectIconContainer;  ",
          "content_tokens": 345,
          "embedding": []
        },
        {
          "cs_scriptfile": "ObjectLocationNotifier",
          "content": "protected void DeallocatePoint(Vector3 atPosition) { foreach (var objectIcon in _usedList) { if (objectIcon.Parent.transform.position == atPosition) { _usedList.Pop(); _unusedList.Push(objectIcon); objectIcon.Hide(); } }  protected void DeallocatePoints(List<Vector3> atPositions) { foreach (var objectIcon in _usedList) { var objectPos = objectIcon.Parent.transform.position; if (atPositions.Contains(objectPos)) { _usedList.Pop(); _unusedList.Push(objectIcon); objectIcon.Hide(); } }  ",
          "content_tokens": 144,
          "embedding": []
        },
        {
          "cs_scriptfile": "ObjectLocationNotifier",
          "content": "protected void DeallocateAllPoints() { DebugWrite.Log($\"[ObjectLocationNotifier] Deallocating all points\", gameObject, _isDebug); while (_usedList.Count > 0) { var objectIcon = _usedList.Pop(); _unusedList.Push(objectIcon); objectIcon.Hide(); } } } [Serializable] public class ObjectIconContainer { public GameObject Parent; [FormerlySerializedAs(\"Icon\")] public UICanvasGroupDecorator IconCanvasGroupDecorator; public TMProDecorator DistanceText; public ObjectIconContainer(GameObject parent, UICanvasGroupDecorator iconCanvasGroupDecorator, TMProDecorator distanceText) { Parent = parent; IconCanvasGroupDecorator = iconCanvasGroupDecorator; DistanceText = distanceText;  ",
          "content_tokens": 184,
          "embedding": []
        },
        {
          "cs_scriptfile": "ObjectLocationNotifier",
          "content": "public void Show() => IconCanvasGroupDecorator.Show(true); public void Hide() { if (IconCanvasGroupDecorator != null) { IconCanvasGroupDecorator.Hide(); }  public void SetDistance(float distance) { DistanceText.SetText(distance.ToString(\"F0\") + \"m\"); } } }",
          "content_tokens": 77,
          "embedding": []
        }
      ],
      "length": 6274
    },
    {
      "filename": "ObjectsRoomManager",
      "content": " using System; using System.Collections; using System.Collections.Generic; using System.Text; using DungeonScrollerCore; using FishNet.Object; using FishNet.Object.Synchronizing; using UnityEngine; namespace InRoomSystems { public class ObjectsRoomManager : RoomManager { public bool IsNonNetworkedObjectsRemoved { get; private set; } private ObjectTempData[] _objectTempData; public static string[] OBJECT_TAGS => Instance._tagsToReplace; [SerializeField] private bool _isDebug; [SerializeField] private string[] _tagsToReplace = new[] { \"Door\", \"Chest\", \"WallTorch\", \"ReplaceableObject\", \"LavaFloor\" }; public bool IsObjectsSpawned => _isObjectsSpawned; [SyncVar] private bool _isObjectsSpawned; public static ObjectsRoomManager Instance { get; private set; } private void Awake() { Instance = this; _objectTempData = new ObjectTempData[_tagsToReplace.Length]; } public override void OnStartClient() { base.OnStartClient(); } public void RemoveNonNetworkedObjectsClient() { StartCoroutine(RemoveNonNetworkedObjects()); } private IEnumerator RemoveNonNetworkedObjects() { yield return new WaitForSeconds(1f); for (int i = 0; i < _tagsToReplace.Length; i++) { StringBuilder sb = new StringBuilder(); List<GameObject> roomObjects = new List<GameObject>(GameObject.FindGameObjectsWithTag(_tagsToReplace[i])); sb.Append($\"[{ClassAndRoomName}] Removing {roomObjects.Count} {_tagsToReplace[i]} objects: \"); for (int j = 0; j < roomObjects.Count; j++) { if (roomObjects[j].GetComponent<NetworkObject>() != null) continue; sb.Append($\"{roomObjects[j].name}, \"); Destroy(roomObjects[j]); } DebugWrite.Log($\"{sb}\", gameObject, _isDebug); } yield return null; IsNonNetworkedObjectsRemoved = true; } public void StoreAndRemoveObjectsInfos() { for (int i = 0; i < _tagsToReplace.Length; i++) { Debug.Log($\"{ClassAndRoomName} Working on {_tagsToReplace[i]}...\", gameObject); StoreAndRemoveObjectsInfos(i); } } public void SpawnObjects() { StartCoroutine(ObjectsSpawningRoutine()); } private IEnumerator ObjectsSpawningRoutine() { StoreAndRemoveObjectsInfos(); for (int i = 0; i < _tagsToReplace.Length; i++) { if (_isDebug) { Debug.Log($\"{ClassAndRoomName} Working on {_tagsToReplace[i]}...\"); } SpawnObjects(i); yield return null; } _isObjectsSpawned = true; } /// <summary> /// Generates objects by first storing and removing existing GameObjects with a specified tag, before finally spawning new objects from prefabs. /// </summary> public void GenerateObjects() { DebugWrite.Log($\"{ClassAndRoomName} Starting {_tagsToReplace.Length} amount...\", isShowLog:_isDebug); for (int i = 0; i < _tagsToReplace.Length; i++) { if (_isDebug) { Debug.Log($\"{ClassAndRoomName} Working on {_tagsToReplace[i]}...\"); } StoreAndRemoveObjectsInfos(i); SpawnObjects(i); } DebugWrite.Log($\"{ClassAndRoomName} Finished\", isShowLog:_isDebug); } protected void StoreAndRemoveObjectsInfos(int index) { string tag = _tagsToReplace[index]; List<GameObject> inRoomObjects = new List<GameObject>(GameObject.FindGameObjectsWithTag(_tagsToReplace[index])); _objectTempData[index] = new ObjectTempData(inRoomObjects.Count); for (int i = 0; i < inRoomObjects.Count; i++) { Transform objectTransform = inRoomObjects[i].transform; _objectTempData[index].ObjectPositions[i] = objectTransform.position; if (index == 0) { if (objectTransform.parent?.parent == null) { Debug.LogError($\"{tag}'s parent parent is null\", objectTransform); continue; } _objectTempData[index].ObjectRotations[i] = objectTransform.parent.parent.rotation.eulerAngles; } else { _objectTempData[index].ObjectRotations[i] = objectTransform.rotation.eulerAngles; } _objectTempData[index].Prefabs[i] = objectTransform.GetComponent<ReplaceableObject>().Prefab; if (_objectTempData[index].Prefabs[i] == null) { _objectTempData[index].ObjectReplaceable[i] = objectTransform.GetComponent<ReplaceableObject>().InteractableObjectControllerPrefab; objectTransform.gameObject.name = $\"{tag} #{i} (replaced)\"; Debug.Log($\"{ClassAndRoomName} Destroy {objectTransform.name}\", objectTransform.gameObject); Destroy(objectTransform.gameObject); } else { //Movable Networked Walls _objectTempData[index].ObjectParentTransforms[i] = inRoomObjects[i].transform; var child = inRoomObjects[i].transform.GetChild(0); if (child != null) Destroy(child.gameObject); Debug.Log($\"{ClassAndRoomName} {inRoomObjects[i].name} #{i} worldPos: {inRoomObjects[i].transform.position}; localPos: {inRoomObjects[i].transform.localPosition}\"); } } Debug.Log($\"{ClassAndRoomName} all '{_tagsToReplace[index]}'x{_objectTempData[index].ObjectPositions.Length} objects was saved and their GOs destroyed\", gameObject); } [Server] protected void SpawnObjects(int index) { string tag = _tagsToReplace[index]; DebugWrite.Log($\"{ClassAndRoomName} Starting...\", isShowLog:_isDebug); //ObserverRemoveObject(index); GameObject folder = new GameObject(tag); folder.transform.SetParent(transform); ObjectTempData currentData = _objectTempData[index]; for (int i = 0; i < currentData.ObjectPositions.Length; i++) { InteractableObjectController prefab = currentData.ObjectReplaceable[i]; bool isNotMovingWalls = prefab != null; if (isNotMovingWalls) { InteractableObjectController nob = Instantiate(prefab, currentData.ObjectPositions[i], Quaternion.Euler(currentData.ObjectRotations[i]), folder.transform); Spawn(nob.gameObject); nob.InitServer(GameplayManager, tag, currentData.ObjectPositions[i], currentData.ObjectRotations[i]); } else { GameObject nob = Instantiate(currentData.Prefabs[i], currentData.ObjectPositions[i], Quaternion.Euler(currentData.ObjectRotations[i]), folder.transform); //Destroy(currentData.ObjectParentTransforms[i]); //GameObject nob = Instantiate(currentData.Prefabs[i], currentData.ObjectPositions[i], Quaternion.Euler(currentData.ObjectRotations[i]), currentData.ObjectParentTransforms[i]); //nob.transform.localPosition = Vector3.zero; // nob.transform.position = currentData.ObjectPositions[i]; // nob.transform.SetParent(currentData.ObjectParentTransforms[i]); Spawn(nob); Debug.Log($\"[ObjectsRoomManager] {nob.name} #{i} worldPos: {nob.transform.position}; localPos: {nob.transform.localPosition}\"); //Vector3 shiftedPositionWithoutParent = currentData.ObjectPositions[i] - currentData.ObjectParentTransforms[i].position; //nob.GetComponent<MovableNetworked>().CorrectNetPosition(nob.transform.position); } } DebugWrite.Log($\"{ClassAndRoomName} all {currentData.ObjectPositions.Length}x'{tag}' objects was spawned\", isShowLog:_isDebug); currentData = null; } [ObserversRpc] private void TargetsCorrectPosition(Transform trans, Vector3 newPos) { trans.position = newPos; Debug.Log($\"[ObjectsRoomManager] {trans.name} worldPos: {trans.position}; localPos: {trans.localPosition}\"); } [ObserversRpc(ExcludeServer = true, ExcludeOwner = true)] private void ObserverRemoveObject(int index) { StringBuilder sb = new StringBuilder(); List<GameObject> roomObjects = new List<GameObject>(GameObject.FindGameObjectsWithTag(_tagsToReplace[index])); sb.Append($\"[{ClassAndRoomName}] Removing {roomObjects.Count} {_tagsToReplace[index]} objects: \"); for (int i = 0; i < roomObjects.Count; i++) { sb.Append($\"{roomObjects[i]}, \"); Destroy(roomObjects[i]); } DebugWrite.Log($\"{sb}\", gameObject, _isDebug); } [Serializable] public class ObjectTempData { public Vector3[] ObjectPositions; public Vector3[] ObjectRotations; public InteractableObjectController[] ObjectReplaceable; public GameObject[] Prefabs; // Used only for Rotating Walls in Dynamic Labyrinth public Transform[] ObjectParentTransforms; public ObjectTempData(int length) { ObjectPositions = new Vector3[length]; ObjectRotations = new Vector3[length]; ObjectParentTransforms = new Transform[length]; ObjectReplaceable = new InteractableObjectController[length]; Prefabs = new GameObject[length]; } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ObjectsRoomManager",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "ObjectsRoomManager",
          "content": " using System; using System.Collections; using System.Collections.Generic; using System.Text; using DungeonScrollerCore; using FishNet.Object; using FishNet.Object.Synchronizing; using UnityEngine; namespace InRoomSystems { public class ObjectsRoomManager : RoomManager { public bool IsNonNetworkedObjectsRemoved { get; private set; } private ObjectTempData[] _objectTempData; public static string[] OBJECT_TAGS => Instance._tagsToReplace; [SerializeField] private bool _isDebug; [SerializeField] private string[] _tagsToReplace = new[] { \"Door\", \"Chest\", \"WallTorch\", \"ReplaceableObject\", \"LavaFloor\" }; public bool IsObjectsSpawned => _isObjectsSpawned; [SyncVar] private bool _isObjectsSpawned; public static ObjectsRoomManager Instance { get; private set;  ",
          "content_tokens": 203,
          "embedding": []
        },
        {
          "cs_scriptfile": "ObjectsRoomManager",
          "content": "private void Awake() { Instance = this; _objectTempData = new ObjectTempData[_tagsToReplace.Length]; } public override void OnStartClient() { base.OnStartClient();  ",
          "content_tokens": 45,
          "embedding": []
        },
        {
          "cs_scriptfile": "ObjectsRoomManager",
          "content": "public void RemoveNonNetworkedObjectsClient() { StartCoroutine(RemoveNonNetworkedObjects()); } private IEnumerator RemoveNonNetworkedObjects() { yield return new WaitForSeconds(1f); for (int i = 0; i < _tagsToReplace.Length; i++) { StringBuilder sb = new StringBuilder(); List<GameObject> roomObjects = new List<GameObject>(GameObject.FindGameObjectsWithTag(_tagsToReplace[i])); sb.Append($\"[{ClassAndRoomName}] Removing {roomObjects.Count} {_tagsToReplace[i]} objects: \"); for (int j = 0; j < roomObjects.Count; j++) { if (roomObjects[j].GetComponent<NetworkObject>() != null) continue; sb.Append($\"{roomObjects[j].name}, \"); Destroy(roomObjects[j]); } DebugWrite.Log($\"{sb}\", gameObject, _isDebug); } yield return null; IsNonNetworkedObjectsRemoved = true;  ",
          "content_tokens": 244,
          "embedding": []
        },
        {
          "cs_scriptfile": "ObjectsRoomManager",
          "content": "public void StoreAndRemoveObjectsInfos() { for (int i = 0; i < _tagsToReplace.Length; i++) { Debug.Log($\"{ClassAndRoomName} Working on {_tagsToReplace[i]}...\", gameObject); StoreAndRemoveObjectsInfos(i); }  public void SpawnObjects() { StartCoroutine(ObjectsSpawningRoutine()); } private IEnumerator ObjectsSpawningRoutine() { StoreAndRemoveObjectsInfos(); for (int i = 0; i < _tagsToReplace.Length; i++) { if (_isDebug) { Debug.Log($\"{ClassAndRoomName} Working on {_tagsToReplace[i]}...\");  ",
          "content_tokens": 161,
          "embedding": []
        },
        {
          "cs_scriptfile": "ObjectsRoomManager",
          "content": "SpawnObjects(i); yield return null; } _isObjectsSpawned = true; } /// <summary> /// Generates objects by first storing and removing existing GameObjects with a specified tag, before finally spawning new objects from prefabs. /// </summary> public void GenerateObjects() { DebugWrite.Log($\"{ClassAndRoomName} Starting {_tagsToReplace.Length} amount...\", isShowLog:_isDebug); for (int i = 0; i < _tagsToReplace.Length; i++) { if (_isDebug) { Debug.Log($\"{ClassAndRoomName} Working on {_tagsToReplace[i]}...\");  StoreAndRemoveObjectsInfos(i); SpawnObjects(i); } DebugWrite.Log($\"{ClassAndRoomName} Finished\", isShowLog:_isDebug);  ",
          "content_tokens": 189,
          "embedding": []
        },
        {
          "cs_scriptfile": "ObjectsRoomManager",
          "content": "protected void StoreAndRemoveObjectsInfos(int index) { string tag = _tagsToReplace[index]; List<GameObject> inRoomObjects = new List<GameObject>(GameObject.FindGameObjectsWithTag(_tagsToReplace[index])); _objectTempData[index] = new ObjectTempData(inRoomObjects.Count); for (int i = 0; i < inRoomObjects.Count; i++) { Transform objectTransform = inRoomObjects[i].transform; _objectTempData[index].ObjectPositions[i] = objectTransform.position; if (index == 0) { if (objectTransform.parent?.parent == null) { Debug.LogError($\"{tag}'s parent parent is null\", objectTransform); continue; } _objectTempData[index].ObjectRotations[i] = objectTransform.parent.parent.rotation.eulerAngles; } else { _objectTempData[index].ObjectRotations[i] = objectTransform.rotation.eulerAngles; } _objectTempData[index].Prefabs[i] = objectTransform.GetComponent<ReplaceableObject>().Prefab; if (_objectTempData[index].Prefabs[i] == null) { _objectTempData[index].ObjectReplaceable[i] = objectTransform.GetComponent<ReplaceableObject>().InteractableObjectControllerPrefab; objectTransform.gameObject.name = $\"{tag} #{i} (replaced)\"; Debug.Log($\"{ClassAndRoomName} Destroy {objectTransform.name}\", objectTransform.gameObject); Destroy(objectTransform.gameObject); } else { //Movable Networked Walls _objectTempData[index].ObjectParentTransforms[i] = inRoomObjects[i].transform; var child = inRoomObjects[i].transform.GetChild(0); if (child != null) Destroy(child.gameObject); Debug.Log($\"{ClassAndRoomName} {inRoomObjects[i].name} #{i} worldPos: {inRoomObjects[i].transform.position}; localPos: {inRoomObjects[i].transform.localPosition}\"); } } Debug.Log($\"{ClassAndRoomName} all '{_tagsToReplace[index]}'x{_objectTempData[index].ObjectPositions.Length} objects was saved and their GOs destroyed\", gameObject); } [Server] protected void SpawnObjects(int index) { string tag = _tagsToReplace[index]; DebugWrite.Log($\"{ClassAndRoomName} Starting...\", isShowLog:_isDebug); //ObserverRemoveObject(index); GameObject folder = new GameObject(tag); folder.transform.SetParent(transform); ObjectTempData currentData = _objectTempData[index]; for (int i = 0; i < currentData.ObjectPositions.Length; i++) { InteractableObjectController prefab = currentData.ObjectReplaceable[i]; bool isNotMovingWalls = prefab != null; if (isNotMovingWalls) { InteractableObjectController nob = Instantiate(prefab, currentData.ObjectPositions[i], Quaternion.Euler(currentData.ObjectRotations[i]), folder.transform); Spawn(nob.gameObject); nob.InitServer(GameplayManager, tag, currentData.ObjectPositions[i], currentData.ObjectRotations[i]); } else { GameObject nob = Instantiate(currentData.Prefabs[i], currentData.ObjectPositions[i], Quaternion.Euler(currentData.ObjectRotations[i]), folder.transform); //Destroy(currentData.ObjectParentTransforms[i]); //GameObject nob = Instantiate(currentData.Prefabs[i], currentData.ObjectPositions[i], Quaternion.Euler(currentData.ObjectRotations[i]), currentData.ObjectParentTransforms[i]); //nob.transform.localPosition = Vector3.zero; // nob.transform.position = currentData.ObjectPositions[i]; // nob.transform.SetParent(currentData.ObjectParentTransforms[i]); Spawn(nob); Debug.Log($\"[ObjectsRoomManager] {nob.name} #{i} worldPos: {nob.transform.position}; localPos: {nob.transform.localPosition}\"); //Vector3 shiftedPositionWithoutParent = currentData.ObjectPositions[i] - currentData.ObjectParentTransforms[i].position; //nob.GetComponent<MovableNetworked>().CorrectNetPosition(nob.transform.position); } } DebugWrite.Log($\"{ClassAndRoomName} all {currentData.ObjectPositions.Length}x'{tag}' objects was spawned\", isShowLog:_isDebug); currentData = null; } [ObserversRpc] private void TargetsCorrectPosition(Transform trans, Vector3 newPos) { trans.position = newPos; Debug.Log($\"[ObjectsRoomManager] {trans.name} worldPos: {trans.position}; localPos: {trans.localPosition}\"); } [ObserversRpc(ExcludeServer = true, ExcludeOwner = true)] private void ObserverRemoveObject(int index) { StringBuilder sb = new StringBuilder(); List<GameObject> roomObjects = new List<GameObject>(GameObject.FindGameObjectsWithTag(_tagsToReplace[index])); sb.Append($\"[{ClassAndRoomName}] Removing {roomObjects.Count} {_tagsToReplace[index]} objects: \"); for (int i = 0; i < roomObjects.Count; i++) { sb.Append($\"{roomObjects[i]}, \"); Destroy(roomObjects[i]); } DebugWrite.Log($\"{sb}\", gameObject, _isDebug); } [Serializable] public class ObjectTempData { public Vector3[] ObjectPositions; public Vector3[] ObjectRotations; public InteractableObjectController[] ObjectReplaceable; public GameObject[] Prefabs; // Used only for Rotating Walls in Dynamic Labyrinth public Transform[] ObjectParentTransforms; public ObjectTempData(int length) { ObjectPositions = new Vector3[length]; ObjectRotations = new Vector3[length]; ObjectParentTransforms = new Transform[length]; ObjectReplaceable = new InteractableObjectController[length]; Prefabs = new GameObject[length]; } } } }",
          "content_tokens": 1428,
          "embedding": []
        }
      ],
      "length": 7759
    },
    {
      "filename": "OtherPlayersLocationNotifier",
      "content": " using System.Collections; using System.Collections.Generic; using System.Linq; using UnityEngine; namespace InRoomSystems { public class OtherPlayersLocationNotifier : ObjectLocationNotifier { protected override IEnumerator NotificationTimer(List<Vector3> pointsList) { yield return new WaitForSeconds(START_REPORT_AFTER_SECS); _myCollection.AddRange(GameplayManager.PlayerPositions.Values); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "OtherPlayersLocationNotifier",
          "content": "using System.Collections; using System.Collections.Generic; using System.Linq; using UnityEngine; namespace InRoomSystems { public class OtherPlayersLocationNotifier : ObjectLocationNotifier { protected override IEnumerator NotificationTimer(List<Vector3> pointsList) { yield return new WaitForSeconds(START_REPORT_AFTER_SECS); _myCollection.AddRange(GameplayManager.PlayerPositions.Values); } } }",
          "content_tokens": 100,
          "embedding": []
        }
      ],
      "length": 398
    },
    {
      "filename": "RespawnManager",
      "content": "using System; using System.Collections; using System.Collections.Generic; using System.Text; using DungeonScrollerCore; using FishNet.Object; using Pathfinding; using Unity.Collections; using Unity.Jobs; using UnityEngine; using Zomb.Creatures.Module; namespace InRoomSystems { public struct SearchNearestCreaturesToEachPlayerJob : IJob { //Unmanaged types: //sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, or bool, Any enum type, Any pointer type //NativeStream example: https://github.com/Unity-Technologies/SimpleUIDemo/blob/master/Tiny3D/Library/PackageCache/com.unity.collections%400.3.0-preview.0/Unity.Collections.Tests/NativeStreamTests.cs private static readonly float DISTANCE_TO_SPAWN_AI_SQUARED = 200f;//14.1f private static readonly float DISTANCE_TO_DESPAWN_AI_SQUARED = 1600f;//40f private static readonly float DISTANCE_TO_BLOCK_POINTS_SQUARED = 225f; // Jobs declare all data that will be accessed in the job // By declaring it as read only, multiple jobs are allowed to access the data in parallel [ReadOnly] public NativeArray<SpawnPointForJob> JSpawnPointsArray; public NativeArray<Vector3> PlayersPosArray; public NativeList<ushort> ResultPointsToSpawn; public NativeList<ushort> ResultPointsToDespawn; public bool IsSpawnBasedOnPlayers; public void Execute() { for (int j = 0; j < JSpawnPointsArray.Length; j++) { var spawnPoint = JSpawnPointsArray[j]; if (spawnPoint.isUsed) { byte playerNearby = 0; for (int i = 0; i < PlayersPosArray.Length; i++) { var playerPos = PlayersPosArray[i]; float distSquared = (playerPos - spawnPoint.position).sqrMagnitude; if (distSquared < DISTANCE_TO_DESPAWN_AI_SQUARED) playerNearby++; } if (playerNearby > 0) continue; ResultPointsToDespawn.Add(spawnPoint.id); } else { for (int i = 0; i < PlayersPosArray.Length; i++) { var playerPos = PlayersPosArray[i]; float distSquared = (playerPos - spawnPoint.position).sqrMagnitude; if (distSquared > DISTANCE_TO_SPAWN_AI_SQUARED) continue; ResultPointsToSpawn.Add(spawnPoint.id); break; } } } //TODO check and insert this logic // if (IsSpawnBasedOnPlayers) // { // for (int i = 0; i < JSpawnPointsArray.Length; i++) // { // var spawnPoint = JSpawnPointsArray[i]; // if (spawnPoint.isUsed) // continue; // // if (spawnPoint.IsUsedAsNeighbourToOtherPoint) // continue; // // byte playerNearby = 0; // for (int j = 0; j < PlayersPosArray.Length; j++) // { // var playerPos = PlayersPosArray[j]; // float distSquared = (playerPos - spawnPoint.position).sqrMagnitude; // if (distSquared > DISTANCE_TO_BLOCK_POINTS_SQUARED) // continue; // playerNearby++; // spawnPoint.closestPlayerDistance = distSquared; // } // if (playerNearby <= 0) // continue; // ResultPointsToSpawn.Add(spawnPoint.id); // for (int j = 0; j < JSpawnPointsArray.Length; j++) // { // if (i == j) // continue; // var point = JSpawnPointsArray[j]; // if (point.isUsed) // { // continue; // } // float distance = (spawnPoint.position - point.position).sqrMagnitude; // if (distance > DISTANCE_TO_BLOCK_POINTS_SQUARED) // { // continue; // } // point.IsUsedAsNeighbourToOtherPoint = true; // } // } // } } } [ExecuteInEditMode] public class RespawnManager : RoomManager { protected const float DEFAULT_MONSTER_RESPAWN_TIME = 600f; public static string TAG_PORTAL_SPAWN_POINT = \"EscapePortalPoint\"; public static string TAG_MONSTER_SPAWN_POINT = \"MonsterSpawnPoint\"; public static string TAG_BOSS_SPAWN_POINT = \"BossSpawnPoint\"; protected static float DISTANCE_TO_SPAWN_AI = 20f; protected static float DISTANCE_TO_DESPAWN_AI = 40f; protected static float DISTANCE_TO_BLOCK_POINTS = 15f; [SerializeField] protected List<SpawnPoint> _spawnPoints = new List<SpawnPoint>(); protected NativeArray<SpawnPointForJob> SpawnPointsArray; [SerializeField] protected EnemyDefinitionsHolderSO _enemyDefinitionsHolderSO; [SerializeField] protected bool _isSpawnBasedOnPlayers; protected CreaturesFactory _creaturesFactory; protected bool _isActivated = true; protected ushort _startingFromIndex = 0; public Action<List<Vector3>> OnBossSpawnPointsPopulated; [field: SerializeField] public List<Vector3> PortalPoints { get; protected set; } = new (); protected bool _isDebug = true; protected bool _isSpawnPointsInitialized; public static RespawnManager Instance { get; protected set; } protected void OnDisable() { Debug.Log($\"[RespawnManager] OnDisable\"); } protected void OnEnable() { Debug.Log($\"[RespawnManager] OnEnable\"); } private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } } public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer || IsHost) { _creaturesFactory = GetComponent<CreaturesFactory>(); } } public override void OnStopNetwork() { base.OnStopNetwork(); if (IsServer || IsHost) { if (SpawnPointsArray.IsCreated) SpawnPointsArray.Dispose(); } } protected IEnumerator CorUpdate() { var time = new WaitForSeconds(1f); while (true) { if (!_isActivated) yield return null; // StartCoroutine(SpawnCreaturesIfRequired()); // StartCoroutine(DespawnCreaturesIfRequired()); CheckPlayers(); yield return time; } } private void CheckPlayers() { if (GameplayManager.SpawnedPlayerHeroes.Count == 0) return; var playerPosArray = new NativeArray<Vector3>(GameplayManager.SpawnedPlayerHeroes.Count, Allocator.TempJob); for (int i = 0; i < GameplayManager.SpawnedPlayerHeroes.Count; i++) { playerPosArray[i] = GameplayManager.SpawnedPlayerHeroes[i].transform.position; } NativeList<ushort> resultPointsToSpawn = new NativeList<ushort>(Allocator.TempJob); NativeList<ushort> resultPointsToDespawn = new NativeList<ushort>(Allocator.TempJob); var job = new SearchNearestCreaturesToEachPlayerJob { JSpawnPointsArray = SpawnPointsArray, PlayersPosArray = playerPosArray, ResultPointsToSpawn = resultPointsToSpawn, ResultPointsToDespawn = resultPointsToDespawn, IsSpawnBasedOnPlayers = _isSpawnBasedOnPlayers }; job.Schedule().Complete(); StringBuilder result = new StringBuilder(\"[RespawnManager] CheckPlayers \"); if (resultPointsToSpawn.Length > 0) { result.Append($\"Spawn(resultPointsToSpawn.Length): \"); for (int i = 0; i < resultPointsToSpawn.Length; i++) { result.Append($\"{resultPointsToSpawn[i]}, \"); } } if (resultPointsToDespawn.Length > 0) { result.Append($\". Despawn(resultPointsToDespawn.Length): \"); for (int i = 0; i < resultPointsToDespawn.Length; i++) { result.Append($\"{resultPointsToDespawn[i]}, \"); } } //Debug.Log($\"{result}\"); foreach (var pointId in resultPointsToDespawn) { SpawnPoint point = _spawnPoints[pointId]; point.UpdateClosestPlayerDistance(DISTANCE_TO_DESPAWN_AI+1f); _creaturesFactory.DeallocateCreature(point.SpawnedAI); point.RemoveAIUnit(); point.SetUsedAs(false); SpawnPointsArray[pointId] = new SpawnPointForJob() { id = point.Id, type = point.GetCreatureType(), position = point.Position, isUsed = false, spawnedAIObjectId = -1, IsUsedAsNeighbourToOtherPoint = false }; Debug.Log($\"{ClassAndRoomName} despawned point {pointId}\"); } foreach (var pointId in resultPointsToSpawn) { SpawnPoint point = _spawnPoints[pointId]; ushort creatureType = point.GetCreatureType(); var creature = SpawnCreatureAtPoint(point.Position, creatureType); _spawnPoints[pointId].SetUsedAs(true); _spawnPoints[pointId].StoreAIUnit(creature.Controller); SpawnPointsArray[pointId] = new SpawnPointForJob() { id = point.Id, type = creatureType, position = point.Position, isUsed = true, spawnedAIObjectId = creature.Controller.ObjectId, IsUsedAsNeighbourToOtherPoint = false }; creature.Controller.OnHideCreature += Controller_OnHideCreature; } resultPointsToSpawn.Dispose(); resultPointsToDespawn.Dispose(); playerPosArray.Dispose(); } protected bool IsThereAnySpawnPointsToDespawn(out HashSet<int> pointsToDespawn) { pointsToDespawn = new HashSet<int>(); for (int i = 0; i < _spawnPoints.Count; i++) { var spawnPoint = _spawnPoints[i]; if (!spawnPoint.IsUsed) continue; if (spawnPoint.IsUsedAsNeighbourToOtherPoint) { continue; } int playersNearby = 0; foreach (var playerNob in GameplayManager.GetAllPlayersHeroes()) { var playerPosition = playerNob.transform.position; float distance = Vector3.Distance(spawnPoint.Position, playerPosition); if (distance < DISTANCE_TO_DESPAWN_AI) playersNearby++; } if (playersNearby > 0) continue; pointsToDespawn.Add(spawnPoint.Id); } if (pointsToDespawn.Count == 0) return false; return true; } protected bool IsThereAnySpawnPointsToSpawn(out HashSet<int> pointsToSpawn) { //TODO optimize from O(n2) -> O(nlogn) using chunks pointsToSpawn = new HashSet<int>(); for (int i = 0; i < _spawnPoints.Count; i++) { var spawnPoint = _spawnPoints[i]; if (spawnPoint.IsUsed) { continue; } if (spawnPoint.IsUsedAsNeighbourToOtherPoint) { continue; } int playersNearby = 0; foreach (var playerNob in GameplayManager.SpawnedPlayerHeroes) { var playerPosition = playerNob.transform.position; float distance = Vector3.Distance(spawnPoint.Position, playerPosition); if (distance > DISTANCE_TO_SPAWN_AI) { continue; } playersNearby++; spawnPoint.UpdateClosestPlayerDistance(distance); } if (playersNearby <= 0) continue; pointsToSpawn.Add(spawnPoint.Id); SpawnFilterBasedOnPlayersCountIfRequired(i, spawnPoint, playersNearby); } //Debug.Log($\"{ClassAndRoomName} need to spawn {_pointsToSpawn.Count} points\"); if (pointsToSpawn.Count == 0) return false; return true; } protected void SpawnFilterBasedOnPlayersCountIfRequired(int i, SpawnPoint spawnPoint, int playersNearby) { if (!_isSpawnBasedOnPlayers) return; List<SpawnPoint> pointsNearby = new List<SpawnPoint>(); //near each point should be only players*points active points for (int j = 0; j < _spawnPoints.Count; j++) { if (i == j) continue; var point = _spawnPoints[j]; if (point.IsUsed) { continue; } float distance = Vector3.Distance(spawnPoint.Position, point.Position); if (distance > DISTANCE_TO_BLOCK_POINTS) { continue; } pointsNearby.Add(point); } foreach (var pointNear in pointsNearby) { if (playersNearby > 0) { playersNearby--; pointNear.IsUsedAsNeighbourToOtherPoint = true; continue; } else { pointNear.SetUsedAs(true); } } } public CreaturesFactory.PooledCreature SpawnCreatureAtPoint(Vector3 pos, ushort creatureType) { NNInfo astarPoint = GameplayManager.AstarPath.GetNearest(pos); CreaturesFactory.PooledCreature creature = _creaturesFactory.AllocateCreature(creatureType, astarPoint.position, GameplayManager); return creature; } protected void Controller_OnHideCreature(AIUnit controller) { //TODO spawn point id not setting properly ushort pointId = controller.SpawnPointId; SpawnPoint point = SpawnPointsGetFromId(pointId); point.SetUsedAs(false); } protected SpawnPoint SpawnPointsGetFromId(ushort id) { return _spawnPoints[id]; } [Server] public void MonsterSpawnPointsPopulate() { ushort index = 0; PopulateMonsterSpots(EnemyDefinition.Type.Monster); PopulateMonsterSpots(EnemyDefinition.Type.Boss); Debug.Log($\"[RespawnManager] SpawnPointsPopulate: {_spawnPoints.Count}\"); _isSpawnPointsInitialized = true; } public void InitIfAllRequirementsMet() { StartCoroutine(LateInit()); } protected IEnumerator LateInit() { if (!IsHost) { yield return new WaitUntil(() => GameplayManager.IsAllPlayersSpawned); } DebugWrite.Log($\"[RespawnManager] Init\", gameObject, _isDebug); StartCoroutine(CorUpdate()); } public void RemovePortalSpawnPoints() { GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_PORTAL_SPAWN_POINT); for (int j = 0; j < spawnPointHolders.Length; j++) { Destroy(spawnPointHolders[j]); } } public void RemoveMonsterSpawnPoints() { StringBuilder sb = new StringBuilder($\"{ClassAndRoomName} RemoveMonsterSpawnPoints \"); GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_MONSTER_SPAWN_POINT); sb.Append($\"[RespawnManager] RemoveMonsterSpawnPoints {TAG_MONSTER_SPAWN_POINT}: {spawnPointHolders.Length}\"); for (int j = 0; j < spawnPointHolders.Length; j++) { Destroy(spawnPointHolders[j]); } spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_BOSS_SPAWN_POINT); sb.Append($\"[RespawnManager] RemoveMonsterSpawnPoints {TAG_BOSS_SPAWN_POINT}: {spawnPointHolders.Length}\"); for (int j = 0; j < spawnPointHolders.Length; j++) { Destroy(spawnPointHolders[j]); } DebugWrite.Log($\"{sb}\", gameObject, _isDebug); if (!IsHost) Destroy(this.gameObject); } [Server] public void PopulatePortalPoints() { GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_PORTAL_SPAWN_POINT); for (int j = 0; j < spawnPointHolders.Length; j++) { PortalPoints.Add(spawnPointHolders[j].transform.position); Destroy(spawnPointHolders[j]); } } [Server] protected void PopulateMonsterSpots(EnemyDefinition.Type type) { StringBuilder sb = new StringBuilder(); string tag = \"\"; float respawnTime = DEFAULT_MONSTER_RESPAWN_TIME; switch (type) { case EnemyDefinition.Type.Monster: tag = TAG_MONSTER_SPAWN_POINT; break; case EnemyDefinition.Type.Boss: tag = TAG_BOSS_SPAWN_POINT; respawnTime = 999999f; break; } sb.Append($\"[RespawnManager] PopulateMonsterSpots of type: {tag}. \"); GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(tag); sb.Append($\"Found {spawnPointHolders.Length} points. \"); List<Transform> spawnPointHoldersCleared = new List<Transform>(); //Clear from those that dont have children, because in unity calling FindGameObjectsWithTag gives results with gameobjects that are not tagged with that tag, but they are children of game objects with that tag for (int i = 0; i < spawnPointHolders.Length; i++) { if (spawnPointHolders[i].transform.childCount > 0) { spawnPointHoldersCleared.Add(spawnPointHolders[i].transform); } } sb.Append($\"generate enemies: \"); foreach (var holderGo in spawnPointHoldersCleared) { List<Transform> spawnPoints = new List<Transform>(); int childCount = holderGo.childCount; byte[] randomEnemies = new byte[childCount]; for (int i = 0; i < childCount; i++) { spawnPoints.Add(holderGo.GetChild(i)); randomEnemies[i] = _enemyDefinitionsHolderSO.GetRandomEnemyId(type); sb.Append($\"id: {randomEnemies[i]}, \"); } PopulateSpawnPointsWith(randomEnemies, spawnPoints, respawnTime); } DebugWrite.Log($\"[RespawnManager] {sb}\", gameObject, _isDebug); if (type == EnemyDefinition.Type.Boss) AddBossPoints(spawnPointHoldersCleared); for (int j = 0; j < spawnPointHolders.Length; j++) { Destroy(spawnPointHolders[j]); } } [Server] protected void AddBossPoints(List<Transform> spawnPointHoldersCleared) { List<Vector3> positions = new List<Vector3>(); foreach (var holderGo in spawnPointHoldersCleared) { positions.Add(holderGo.position); } Debug.Log($\"[RespawnManager] Added {positions.Count} BossPoints\"); OnBossSpawnPointsPopulated?.Invoke(positions); } protected void PopulateSpawnPointsWith(byte[] randomEnemies, List<Transform> spawnPoints, float respawnTime) { foreach (var trans in spawnPoints) { byte randomEnemy = randomEnemies[spawnPoints.IndexOf(trans)]; SpawnPoint spawnPoint = new SpawnPoint(_startingFromIndex, randomEnemy, trans.position, respawnTime); Debug.Log($\"[RespawnManager] Added spawnPoint #{_startingFromIndex} with enemyId {randomEnemy}, at {trans.position} with respawnTime {respawnTime}\", gameObject); _spawnPoints.Add(spawnPoint); _startingFromIndex++; } SpawnPointsArray = new NativeArray<SpawnPointForJob>(_spawnPoints.Count, Allocator.Persistent); for (int i = 0; i < _spawnPoints.Count; i++) { SpawnPointsArray[i] = new SpawnPointForJob() { id = _spawnPoints[i].Id, type = _spawnPoints[i].GetCreatureType(), position = _spawnPoints[i].Position, isUsed = _spawnPoints[i].IsUsed, spawnedAIObjectId = -1, IsUsedAsNeighbourToOtherPoint = false }; } } #if UNITY_EDITOR protected void OnDrawGizmos() { //draw spheres if (_spawnPoints == null) return; for (int i = 0; i < _spawnPoints.Count; i++) { var spawnPoint = _spawnPoints[i]; if (spawnPoint.IsUsed) { Gizmos.color = Color.red; } else { Gizmos.color = Color.green; } Gizmos.DrawSphere(spawnPoint.Position, 1f); } } #endif } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RespawnManager",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "using System; using System.Collections; using System.Collections.Generic; using System.Text; using DungeonScrollerCore; using FishNet.Object; using Pathfinding; using Unity.Collections; using Unity.Jobs; using UnityEngine; using Zomb.Creatures.Module; namespace InRoomSystems { public struct SearchNearestCreaturesToEachPlayerJob : IJob { //Unmanaged types: //sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, or bool, Any enum type, Any pointer type //NativeStream example: https://github.com/Unity-Technologies/SimpleUIDemo/blob/master/Tiny3D/Library/PackageCache/com.unity.collections%400.3.0-preview.0/Unity.Collections.Tests/NativeStreamTests.cs private static readonly float DISTANCE_TO_SPAWN_AI_SQUARED = 200f;//14.1f private static readonly float DISTANCE_TO_DESPAWN_AI_SQUARED = 1600f;//40f private static readonly float DISTANCE_TO_BLOCK_POINTS_SQUARED = 225f; // Jobs declare all data that will be accessed in the job // By declaring it as read only, multiple jobs are allowed to access the data in parallel [ReadOnly] public NativeArray<SpawnPointForJob> JSpawnPointsArray; public NativeArray<Vector3> PlayersPosArray; public NativeList<ushort> ResultPointsToSpawn; public NativeList<ushort> ResultPointsToDespawn; public bool IsSpawnBasedOnPlayers; public void Execute() { for (int j = 0; j < JSpawnPointsArray.Length; j++) { var spawnPoint = JSpawnPointsArray[j]; if (spawnPoint.isUsed) { byte playerNearby = 0; for (int i = 0; i < PlayersPosArray.Length; i++) { var playerPos = PlayersPosArray[i]; float distSquared = (playerPos - spawnPoint.position).sqrMagnitude; if (distSquared < DISTANCE_TO_DESPAWN_AI_SQUARED) playerNearby++;  ",
          "content_tokens": 500,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "if (playerNearby > 0) continue; ResultPointsToDespawn.Add(spawnPoint.id); } else { for (int i = 0; i < PlayersPosArray.Length; i++) { var playerPos = PlayersPosArray[i]; float distSquared = (playerPos - spawnPoint.position).sqrMagnitude; if (distSquared > DISTANCE_TO_SPAWN_AI_SQUARED) continue; ResultPointsToSpawn.Add(spawnPoint.id); break; } } } //TODO check and insert this logic // if (IsSpawnBasedOnPlayers) // { // for (int i = 0; i < JSpawnPointsArray.Length; i++) // { // var spawnPoint = JSpawnPointsArray[i]; // if (spawnPoint.isUsed) // continue; // // if (spawnPoint.IsUsedAsNeighbourToOtherPoint) // continue; // // byte playerNearby = 0; // for (int j = 0; j < PlayersPosArray.Length; j++) // { // var playerPos = PlayersPosArray[j]; // float distSquared = (playerPos - spawnPoint.position).sqrMagnitude; // if (distSquared > DISTANCE_TO_BLOCK_POINTS_SQUARED) // continue; // playerNearby++; // spawnPoint.closestPlayerDistance = distSquared; // } // if (playerNearby <= 0) // continue; // ResultPointsToSpawn.Add(spawnPoint.id); // for (int j = 0; j < JSpawnPointsArray.Length; j++) // { // if (i == j) // continue; // var point = JSpawnPointsArray[j]; // if (point.isUsed) // { // continue; // } // float distance = (spawnPoint.position - point.position).sqrMagnitude; // if (distance > DISTANCE_TO_BLOCK_POINTS_SQUARED) // { // continue; // } // point.IsUsedAsNeighbourToOtherPoint = true; // } // } // } } } [ExecuteInEditMode] public class RespawnManager : RoomManager { protected const float DEFAULT_MONSTER_RESPAWN_TIME = 600f; public static string TAG_PORTAL_SPAWN_POINT = \"EscapePortalPoint\"; public static string TAG_MONSTER_SPAWN_POINT = \"MonsterSpawnPoint\"; public static string TAG_BOSS_SPAWN_POINT = \"BossSpawnPoint\"; protected static float DISTANCE_TO_SPAWN_AI = 20f; protected static float DISTANCE_TO_DESPAWN_AI = 40f; protected static float DISTANCE_TO_BLOCK_POINTS = 15f; [SerializeField] protected List<SpawnPoint> _spawnPoints = new List<SpawnPoint>(); protected NativeArray<SpawnPointForJob> SpawnPointsArray; [SerializeField] protected EnemyDefinitionsHolderSO _enemyDefinitionsHolderSO; [SerializeField] protected bool _isSpawnBasedOnPlayers; protected CreaturesFactory _creaturesFactory; protected bool _isActivated = true; protected ushort _startingFromIndex = 0; public Action<List<Vector3>> OnBossSpawnPointsPopulated; [field: SerializeField] public List<Vector3> PortalPoints { get; protected set; } = new (); protected bool _isDebug = true; protected bool _isSpawnPointsInitialized; public static RespawnManager Instance { get; protected set;  ",
          "content_tokens": 781,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "protected void OnDisable() { Debug.Log($\"[RespawnManager] OnDisable\");  protected void OnEnable() { Debug.Log($\"[RespawnManager] OnEnable\");  ",
          "content_tokens": 39,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } } public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer || IsHost) { _creaturesFactory = GetComponent<CreaturesFactory>(); } } public override void OnStopNetwork() { base.OnStopNetwork(); if (IsServer || IsHost) { if (SpawnPointsArray.IsCreated) SpawnPointsArray.Dispose(); } } protected IEnumerator CorUpdate() { var time = new WaitForSeconds(1f); while (true) { if (!_isActivated) yield return null; // StartCoroutine(SpawnCreaturesIfRequired()); // StartCoroutine(DespawnCreaturesIfRequired()); CheckPlayers(); yield return time; }  ",
          "content_tokens": 177,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "private void CheckPlayers() { if (GameplayManager.SpawnedPlayerHeroes.Count == 0) return; var playerPosArray = new NativeArray<Vector3>(GameplayManager.SpawnedPlayerHeroes.Count, Allocator.TempJob); for (int i = 0; i < GameplayManager.SpawnedPlayerHeroes.Count; i++) { playerPosArray[i] = GameplayManager.SpawnedPlayerHeroes[i].transform.position; } NativeList<ushort> resultPointsToSpawn = new NativeList<ushort>(Allocator.TempJob); NativeList<ushort> resultPointsToDespawn = new NativeList<ushort>(Allocator.TempJob); var job = new SearchNearestCreaturesToEachPlayerJob { JSpawnPointsArray = SpawnPointsArray, PlayersPosArray = playerPosArray, ResultPointsToSpawn = resultPointsToSpawn, ResultPointsToDespawn = resultPointsToDespawn, IsSpawnBasedOnPlayers = _isSpawnBasedOnPlayers }; job.Schedule().Complete(); StringBuilder result = new StringBuilder(\"[RespawnManager] CheckPlayers \"); if (resultPointsToSpawn.Length > 0) { result.Append($\"Spawn(resultPointsToSpawn.Length): \"); for (int i = 0; i < resultPointsToSpawn.Length; i++) { result.Append($\"{resultPointsToSpawn[i]}, \"); }  ",
          "content_tokens": 313,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "if (resultPointsToDespawn.Length > 0) { result.Append($\". Despawn(resultPointsToDespawn.Length): \"); for (int i = 0; i < resultPointsToDespawn.Length; i++) { result.Append($\"{resultPointsToDespawn[i]}, \"); } } //Debug.Log($\"{result}\"); foreach (var pointId in resultPointsToDespawn) { SpawnPoint point = _spawnPoints[pointId]; point.UpdateClosestPlayerDistance(DISTANCE_TO_DESPAWN_AI+1f); _creaturesFactory.DeallocateCreature(point.SpawnedAI); point.RemoveAIUnit(); point.SetUsedAs(false); SpawnPointsArray[pointId] = new SpawnPointForJob() { id = point.Id, type = point.GetCreatureType(), position = point.Position, isUsed = false, spawnedAIObjectId = -1, IsUsedAsNeighbourToOtherPoint = false }; Debug.Log($\"{ClassAndRoomName} despawned point {pointId}\");  ",
          "content_tokens": 250,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "foreach (var pointId in resultPointsToSpawn) { SpawnPoint point = _spawnPoints[pointId]; ushort creatureType = point.GetCreatureType(); var creature = SpawnCreatureAtPoint(point.Position, creatureType); _spawnPoints[pointId].SetUsedAs(true); _spawnPoints[pointId].StoreAIUnit(creature.Controller); SpawnPointsArray[pointId] = new SpawnPointForJob() { id = point.Id, type = creatureType, position = point.Position, isUsed = true, spawnedAIObjectId = creature.Controller.ObjectId, IsUsedAsNeighbourToOtherPoint = false }; creature.Controller.OnHideCreature += Controller_OnHideCreature; } resultPointsToSpawn.Dispose(); resultPointsToDespawn.Dispose(); playerPosArray.Dispose();  ",
          "content_tokens": 186,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "protected bool IsThereAnySpawnPointsToDespawn(out HashSet<int> pointsToDespawn) { pointsToDespawn = new HashSet<int>(); for (int i = 0; i < _spawnPoints.Count; i++) { var spawnPoint = _spawnPoints[i]; if (!spawnPoint.IsUsed) continue; if (spawnPoint.IsUsedAsNeighbourToOtherPoint) { continue; } int playersNearby = 0; foreach (var playerNob in GameplayManager.GetAllPlayersHeroes()) { var playerPosition = playerNob.transform.position; float distance = Vector3.Distance(spawnPoint.Position, playerPosition); if (distance < DISTANCE_TO_DESPAWN_AI) playersNearby++;  if (playersNearby > 0) continue; pointsToDespawn.Add(spawnPoint.Id);  ",
          "content_tokens": 192,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "if (pointsToDespawn.Count == 0) return false; return true;  protected bool IsThereAnySpawnPointsToSpawn(out HashSet<int> pointsToSpawn) { //TODO optimize from O(n2) -> O(nlogn) using chunks pointsToSpawn = new HashSet<int>(); for (int i = 0; i < _spawnPoints.Count; i++) { var spawnPoint = _spawnPoints[i]; if (spawnPoint.IsUsed) { continue;  ",
          "content_tokens": 111,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "if (spawnPoint.IsUsedAsNeighbourToOtherPoint) { continue; } int playersNearby = 0; foreach (var playerNob in GameplayManager.SpawnedPlayerHeroes) { var playerPosition = playerNob.transform.position; float distance = Vector3.Distance(spawnPoint.Position, playerPosition); if (distance > DISTANCE_TO_SPAWN_AI) { continue; } playersNearby++; spawnPoint.UpdateClosestPlayerDistance(distance);  if (playersNearby <= 0) continue; pointsToSpawn.Add(spawnPoint.Id); SpawnFilterBasedOnPlayersCountIfRequired(i, spawnPoint, playersNearby); } //Debug.Log($\"{ClassAndRoomName} need to spawn {_pointsToSpawn.Count} points\"); if (pointsToSpawn.Count == 0) return false; return true;  ",
          "content_tokens": 190,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "protected void SpawnFilterBasedOnPlayersCountIfRequired(int i, SpawnPoint spawnPoint, int playersNearby) { if (!_isSpawnBasedOnPlayers) return; List<SpawnPoint> pointsNearby = new List<SpawnPoint>(); //near each point should be only players*points active points for (int j = 0; j < _spawnPoints.Count; j++) { if (i == j) continue; var point = _spawnPoints[j]; if (point.IsUsed) { continue; } float distance = Vector3.Distance(spawnPoint.Position, point.Position); if (distance > DISTANCE_TO_BLOCK_POINTS) { continue; } pointsNearby.Add(point);  ",
          "content_tokens": 158,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "foreach (var pointNear in pointsNearby) { if (playersNearby > 0) { playersNearby--; pointNear.IsUsedAsNeighbourToOtherPoint = true; continue; } else { pointNear.SetUsedAs(true); } } } public CreaturesFactory.PooledCreature SpawnCreatureAtPoint(Vector3 pos, ushort creatureType) { NNInfo astarPoint = GameplayManager.AstarPath.GetNearest(pos); CreaturesFactory.PooledCreature creature = _creaturesFactory.AllocateCreature(creatureType, astarPoint.position, GameplayManager); return creature;  ",
          "content_tokens": 141,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "protected void Controller_OnHideCreature(AIUnit controller) { //TODO spawn point id not setting properly ushort pointId = controller.SpawnPointId; SpawnPoint point = SpawnPointsGetFromId(pointId); point.SetUsedAs(false); } protected SpawnPoint SpawnPointsGetFromId(ushort id) { return _spawnPoints[id]; } [Server] public void MonsterSpawnPointsPopulate() { ushort index = 0; PopulateMonsterSpots(EnemyDefinition.Type.Monster); PopulateMonsterSpots(EnemyDefinition.Type.Boss); Debug.Log($\"[RespawnManager] SpawnPointsPopulate: {_spawnPoints.Count}\"); _isSpawnPointsInitialized = true;  ",
          "content_tokens": 159,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "public void InitIfAllRequirementsMet() { StartCoroutine(LateInit()); } protected IEnumerator LateInit() { if (!IsHost) { yield return new WaitUntil(() => GameplayManager.IsAllPlayersSpawned); } DebugWrite.Log($\"[RespawnManager] Init\", gameObject, _isDebug); StartCoroutine(CorUpdate());  public void RemovePortalSpawnPoints() { GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_PORTAL_SPAWN_POINT); for (int j = 0; j < spawnPointHolders.Length; j++) { Destroy(spawnPointHolders[j]); }  ",
          "content_tokens": 148,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "public void RemoveMonsterSpawnPoints() { StringBuilder sb = new StringBuilder($\"{ClassAndRoomName} RemoveMonsterSpawnPoints \"); GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_MONSTER_SPAWN_POINT); sb.Append($\"[RespawnManager] RemoveMonsterSpawnPoints {TAG_MONSTER_SPAWN_POINT}: {spawnPointHolders.Length}\"); for (int j = 0; j < spawnPointHolders.Length; j++) { Destroy(spawnPointHolders[j]); } spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_BOSS_SPAWN_POINT); sb.Append($\"[RespawnManager] RemoveMonsterSpawnPoints {TAG_BOSS_SPAWN_POINT}: {spawnPointHolders.Length}\"); for (int j = 0; j < spawnPointHolders.Length; j++) { Destroy(spawnPointHolders[j]); } DebugWrite.Log($\"{sb}\", gameObject, _isDebug); if (!IsHost) Destroy(this.gameObject); } [Server] public void PopulatePortalPoints() { GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(TAG_PORTAL_SPAWN_POINT); for (int j = 0; j < spawnPointHolders.Length; j++) { PortalPoints.Add(spawnPointHolders[j].transform.position); Destroy(spawnPointHolders[j]); } } [Server] protected void PopulateMonsterSpots(EnemyDefinition.Type type) { StringBuilder sb = new StringBuilder(); string tag = \"\"; float respawnTime = DEFAULT_MONSTER_RESPAWN_TIME; switch (type) { case EnemyDefinition.Type.Monster: tag = TAG_MONSTER_SPAWN_POINT; break; case EnemyDefinition.Type.Boss: tag = TAG_BOSS_SPAWN_POINT; respawnTime = 999999f; break; } sb.Append($\"[RespawnManager] PopulateMonsterSpots of type: {tag}. \"); GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(tag); sb.Append($\"Found {spawnPointHolders.Length} points. \"); List<Transform> spawnPointHoldersCleared = new List<Transform>(); //Clear from those that dont have children, because in unity calling FindGameObjectsWithTag gives results with gameobjects that are not tagged with that tag, but they are children of game objects with that tag for (int i = 0; i < spawnPointHolders.Length; i++) { if (spawnPointHolders[i].transform.childCount > 0) { spawnPointHoldersCleared.Add(spawnPointHolders[i].transform); } } sb.Append($\"generate enemies: \"); foreach (var holderGo in spawnPointHoldersCleared) { List<Transform> spawnPoints = new List<Transform>(); int childCount = holderGo.childCount; byte[] randomEnemies = new byte[childCount]; for (int i = 0; i < childCount; i++) { spawnPoints.Add(holderGo.GetChild(i)); randomEnemies[i] = _enemyDefinitionsHolderSO.GetRandomEnemyId(type); sb.Append($\"id: {randomEnemies[i]}, \");  ",
          "content_tokens": 761,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "PopulateSpawnPointsWith(randomEnemies, spawnPoints, respawnTime); } DebugWrite.Log($\"[RespawnManager] {sb}\", gameObject, _isDebug); if (type == EnemyDefinition.Type.Boss) AddBossPoints(spawnPointHoldersCleared); for (int j = 0; j < spawnPointHolders.Length; j++) { Destroy(spawnPointHolders[j]); } } [Server] protected void AddBossPoints(List<Transform> spawnPointHoldersCleared) { List<Vector3> positions = new List<Vector3>(); foreach (var holderGo in spawnPointHoldersCleared) { positions.Add(holderGo.position); } Debug.Log($\"[RespawnManager] Added {positions.Count} BossPoints\"); OnBossSpawnPointsPopulated?.Invoke(positions);  ",
          "content_tokens": 185,
          "embedding": []
        },
        {
          "cs_scriptfile": "RespawnManager",
          "content": "protected void PopulateSpawnPointsWith(byte[] randomEnemies, List<Transform> spawnPoints, float respawnTime) { foreach (var trans in spawnPoints) { byte randomEnemy = randomEnemies[spawnPoints.IndexOf(trans)]; SpawnPoint spawnPoint = new SpawnPoint(_startingFromIndex, randomEnemy, trans.position, respawnTime); Debug.Log($\"[RespawnManager] Added spawnPoint #{_startingFromIndex} with enemyId {randomEnemy}, at {trans.position} with respawnTime {respawnTime}\", gameObject); _spawnPoints.Add(spawnPoint); _startingFromIndex++; } SpawnPointsArray = new NativeArray<SpawnPointForJob>(_spawnPoints.Count, Allocator.Persistent); for (int i = 0; i < _spawnPoints.Count; i++) { SpawnPointsArray[i] = new SpawnPointForJob() { id = _spawnPoints[i].Id, type = _spawnPoints[i].GetCreatureType(), position = _spawnPoints[i].Position, isUsed = _spawnPoints[i].IsUsed, spawnedAIObjectId = -1, IsUsedAsNeighbourToOtherPoint = false }; } } #if UNITY_EDITOR protected void OnDrawGizmos() { //draw spheres if (_spawnPoints == null) return; for (int i = 0; i < _spawnPoints.Count; i++) { var spawnPoint = _spawnPoints[i]; if (spawnPoint.IsUsed) { Gizmos.color = Color.red; } else { Gizmos.color = Color.green; } Gizmos.DrawSphere(spawnPoint.Position, 1f); } } #endif } }",
          "content_tokens": 372,
          "embedding": []
        }
      ],
      "length": 15747
    },
    {
      "filename": "RespawnManagerBossBattle",
      "content": "using InRoomSystems; public class RespawnManagerBossBattle : RespawnManager { public static RespawnManagerBossBattle GetInstance => Instance as RespawnManagerBossBattle; }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RespawnManagerBossBattle",
          "content": "using InRoomSystems; public class RespawnManagerBossBattle : RespawnManager { public static RespawnManagerBossBattle GetInstance => Instance as RespawnManagerBossBattle; }",
          "content_tokens": 38,
          "embedding": []
        }
      ],
      "length": 171
    },
    {
      "filename": "SingleDoor",
      "content": "using InRoomSystems; using Pathfinding; using UnityEngine; using System.Threading; using System.Threading.Tasks; public class SingleDoor : MonoBehaviour { [SerializeField] DoorController doorController; [SerializeField] NavmeshCut navMeshCut; [SerializeField] private Vector3 closedRotation = Vector3.zero; [SerializeField] private Vector3 closedScale = Vector3.one; [SerializeField] private Vector3 openedRotation = Vector3.zero; [SerializeField] private Vector3 openedScale = Vector3.one; private void OnValidate() { AssignComponentsIfRequired(); } private void Awake() { AssignComponentsIfRequired(); doorController.OnInitialized += () => { closedRotation = transform.localRotation.eulerAngles; closedScale = transform.localScale; openedRotation = closedRotation + new Vector3(0, -90, 0); }; doorController.OnDoorOpened += OnDoorOpened; doorController.OnDoorClosed += OnDoorClosed; // Initialize door to closed state transform.localRotation = Quaternion.Euler(closedRotation); transform.localScale = closedScale; } private void OnDestroy() { // Unsubscribe to avoid memory leaks if (doorController != null) { doorController.OnDoorOpened -= OnDoorOpened; doorController.OnDoorClosed -= OnDoorClosed; } } public void SetClosedRotation(Quaternion rotation) { closedRotation = rotation.eulerAngles; } public void SetClosedPosition(Vector3 position) { } public void OnDoorClosed(Transform closingAgentPosition, bool asServer) { if (asServer) { if (!doorController.IsHost) { transform.rotation = Quaternion.Euler(closedRotation); } SwitchNavMeshCutTimed(doorController.OBJECT_ROTATION_DURATION * .5f, false); } else { StartCoroutine(doorController.RotateObject(transform, openedRotation, closedRotation)); } } async Task SwitchNavMeshCutTimed(float delay, bool isOn) { await new WaitForSeconds(delay); navMeshCut.enabled = isOn; // Schedule a graph update as soon as possible AstarPath.active.navmeshUpdates.ForceUpdate(); // Immediatelly process all work items to make sure the navmesh is actually updated AstarPath.active.FlushWorkItems(); } public void OnDoorOpened(Transform openingAgentPosition, bool asServer) { if (asServer) { if (!doorController.IsHost) { transform.rotation = Quaternion.Euler(openedRotation); } SwitchNavMeshCutTimed(doorController.OBJECT_ROTATION_DURATION * .5f, true); } else { StartCoroutine(doorController.RotateObject(transform, closedRotation, openedRotation)); } } private void AssignComponentsIfRequired() { doorController ??= GetComponentInParent<DoorController>(); navMeshCut ??= GetComponent<NavmeshCut>(); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SingleDoor",
          "content": "using InRoomSystems; using Pathfinding; using UnityEngine; using System.Threading; using System.Threading.Tasks; public class SingleDoor : MonoBehaviour { [SerializeField] DoorController doorController; [SerializeField] NavmeshCut navMeshCut; [SerializeField] private Vector3 closedRotation = Vector3.zero; [SerializeField] private Vector3 closedScale = Vector3.one; [SerializeField] private Vector3 openedRotation = Vector3.zero; [SerializeField] private Vector3 openedScale = Vector3.one; private void OnValidate() { AssignComponentsIfRequired();  ",
          "content_tokens": 144,
          "embedding": []
        },
        {
          "cs_scriptfile": "SingleDoor",
          "content": "private void Awake() { AssignComponentsIfRequired(); doorController.OnInitialized += () => { closedRotation = transform.localRotation.eulerAngles; closedScale = transform.localScale; openedRotation = closedRotation + new Vector3(0, -90, 0); }; doorController.OnDoorOpened += OnDoorOpened; doorController.OnDoorClosed += OnDoorClosed; // Initialize door to closed state transform.localRotation = Quaternion.Euler(closedRotation); transform.localScale = closedScale;  private void OnDestroy() { // Unsubscribe to avoid memory leaks if (doorController != null) { doorController.OnDoorOpened -= OnDoorOpened; doorController.OnDoorClosed -= OnDoorClosed; }  ",
          "content_tokens": 183,
          "embedding": []
        },
        {
          "cs_scriptfile": "SingleDoor",
          "content": "public void SetClosedRotation(Quaternion rotation) { closedRotation = rotation.eulerAngles;  public void SetClosedPosition(Vector3 position) {  public void OnDoorClosed(Transform closingAgentPosition, bool asServer) { if (asServer) { if (!doorController.IsHost) { transform.rotation = Quaternion.Euler(closedRotation);  ",
          "content_tokens": 90,
          "embedding": []
        },
        {
          "cs_scriptfile": "SingleDoor",
          "content": "SwitchNavMeshCutTimed(doorController.OBJECT_ROTATION_DURATION * .5f, false); } else { StartCoroutine(doorController.RotateObject(transform, openedRotation, closedRotation)); } } async Task SwitchNavMeshCutTimed(float delay, bool isOn) { await new WaitForSeconds(delay); navMeshCut.enabled = isOn; // Schedule a graph update as soon as possible AstarPath.active.navmeshUpdates.ForceUpdate(); // Immediatelly process all work items to make sure the navmesh is actually updated AstarPath.active.FlushWorkItems();  public void OnDoorOpened(Transform openingAgentPosition, bool asServer) { if (asServer) { if (!doorController.IsHost) { transform.rotation = Quaternion.Euler(openedRotation);  ",
          "content_tokens": 194,
          "embedding": []
        },
        {
          "cs_scriptfile": "SingleDoor",
          "content": "SwitchNavMeshCutTimed(doorController.OBJECT_ROTATION_DURATION * .5f, true); } else { StartCoroutine(doorController.RotateObject(transform, closedRotation, openedRotation)); }  private void AssignComponentsIfRequired() { doorController ??= GetComponentInParent<DoorController>(); navMeshCut ??= GetComponent<NavmeshCut>(); } }",
          "content_tokens": 93,
          "embedding": []
        }
      ],
      "length": 2544
    },
    {
      "filename": "TorchController",
      "content": "using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using NGS.AdvancedCullingSystem.Dynamic; using UnityEngine; using core.client.mechanics; namespace InRoomSystems { public class TorchController : InteractableObjectController { [SyncVar(OnChange = nameof(OnLightSwitched))] protected bool _isLightOn = true; [SerializeField] private GameObject _lightFx; [SerializeField] private VfxGraphController _vfxFire; public override void OnStartServer() { base.OnStartServer(); OnPlayerFinishedInteracting += SwitchLight; } public override void OnStartClient() { base.OnStartClient(); InternalPlayAudio(SoundSource.Type.Activated); _lightFx.SetActive(true); //TODO implement this feature //DC_Controller.Instance.AddObjectForCulling(_vfxFire); //Debug.Log($\"[TorchController] Activate go {_lightFx}\"); } [Server] private void SwitchLight(NetworkConnection conn) { _isLightOn = !_isLightOn; if (_isLightOn) { PlayAudio(SoundSource.Type.Activated); } } protected void OnLightSwitched(bool prev, bool next, bool asServer) { if (IsHost || !asServer) { SwitchLight(next); } } private void SwitchLight(bool isOn) { Debug.Log($\"[TorchController] SwitchLight {gameObject} {isOn}\", gameObject); _isLightOn = isOn; _lightFx.SetActive(isOn); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "TorchController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "TorchController",
          "content": "using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using NGS.AdvancedCullingSystem.Dynamic; using UnityEngine; using core.client.mechanics; namespace InRoomSystems { public class TorchController : InteractableObjectController { [SyncVar(OnChange = nameof(OnLightSwitched))] protected bool _isLightOn = true; [SerializeField] private GameObject _lightFx; [SerializeField] private VfxGraphController _vfxFire; public override void OnStartServer() { base.OnStartServer(); OnPlayerFinishedInteracting += SwitchLight; } public override void OnStartClient() { base.OnStartClient(); InternalPlayAudio(SoundSource.Type.Activated); _lightFx.SetActive(true); //TODO implement this feature //DC_Controller.Instance.AddObjectForCulling(_vfxFire); //Debug.Log($\"[TorchController] Activate go {_lightFx}\"); } [Server] private void SwitchLight(NetworkConnection conn) { _isLightOn = !_isLightOn; if (_isLightOn) { PlayAudio(SoundSource.Type.Activated); }  ",
          "content_tokens": 268,
          "embedding": []
        },
        {
          "cs_scriptfile": "TorchController",
          "content": "protected void OnLightSwitched(bool prev, bool next, bool asServer) { if (IsHost || !asServer) { SwitchLight(next); }  private void SwitchLight(bool isOn) { Debug.Log($\"[TorchController] SwitchLight {gameObject} {isOn}\", gameObject); _isLightOn = isOn; _lightFx.SetActive(isOn); } } }",
          "content_tokens": 90,
          "embedding": []
        }
      ],
      "length": 1260
    },
    {
      "filename": "TradingPostController",
      "content": " using System; using System.Collections; using System.Collections.Generic; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using FishnetInvector; using Invector.vItemManager; using SingletonsExtension; using TMPro; using UnityEngine; namespace InRoomSystems { public class TradingPostController : InteractableObjectController { [SerializeField] private EnemyDefinition.PossibleItemRanges[] _itemRanges; [SerializeField] private TextMeshProUGUI itemNameText; [SerializeField] private TextMeshProUGUI itemDescriptionText; [SyncVar] [SerializeField] private int itemId; [field:SerializeField] public vItem targetItem { get; private set; } [field:SerializeField] public GameObject uiItemInfo { get; private set; } [field:SerializeField] public Transform targetItemHolder { get; private set; } [field:SerializeField] public SphereCollider collider { get; private set; } private vItemListData _itemList => MasterManager.Instance.ItemListData; [SerializeField] private GameObject _healFx; [SerializeField] private GameObject _visualFX; private bool _isUsed = false; protected override void Awake() { base.Awake(); uiItemInfo.SetActive(false); } public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { InitRandomItem(); OnPlayerFinishedInteracting += TryToBuyItem; } } public override void OnStartClient() { base.OnStartClient(); UpdateItemDescription(); collider.isTrigger = true; } [Server] public void InitRandomItem() { List<ItemReference> items = GameplayManager.Instance.LootDropSystem.GenerateLoot(_itemRanges, 1, .0f); itemId = items[0].id; targetItem = _itemList.items.Find(item => item.id == itemId); Debug.Log($\"[TradingPostController] {gameObject.name} InitRandomItem: {targetItem.Name} #{itemId}\"); } [Client] private void UpdateItemDescription() { targetItem = _itemList.items.Find(item => item.id == itemId); itemNameText.text = $\"{targetItem.Name} - <color = yellow>{targetItem.Price}</color> gold\"; itemDescriptionText.text = targetItem.description; } [Client] private void OnTriggerEnter(Collider other) { if (!IsServer) return; if (other.CompareTag(\"Player\")) { FishnetInvectorHealthController healthController = GameplayManager.Instance.GetHealthController(other); if (healthController.IsDead) return; if (!healthController.IsOwner) return; uiItemInfo.SetActive(true); } } [Client] private void OnTriggerExit(Collider other) { if (!IsServer) return; if (other.CompareTag(\"Player\")) { FishnetInvectorHealthController healthController = GameplayManager.Instance.GetHealthController(other); if (!healthController.IsOwner) return; uiItemInfo.SetActive(false); } } private bool IsGoldEnough(bool asServer = false) { int currentGold = FishnetInvectorItemManager.LocalPlayer.GetGoldAmount(); if (targetItem.Price > currentGold) { Debug.Log($\"[TradingPostController] {FishnetInvectorItemManager.LocalPlayer.name} doesn't have enough gold to buy {targetItem.Name}\"); return false; } return true; } [Server] private void RemoveItemFromTradingPost() { } [Server] private void TryToBuyItem(NetworkConnection conn) { if (!IsGoldEnough(true)) return; if (_isUsed) return; _isUsed = true; StringBuilder sb = new StringBuilder(); sb.Append($\"[TradingPostController] Player {conn.ClientId} interacted with {gameObject.name} and bought {targetItem.Name} for {targetItem.Price} gold. \"); UnitComponents unit = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); _triggerGenericAction.enabled = false; unit.ItemManager.ChangeGoldAmount(-targetItem.Price); unit.ItemManager.ServerAddItemReference(targetItem.ToItemReference()); RemoveItemFromTradingPost(); DebugWrite.Log($\"{sb}\", gameObject, _isDebug); //ObserversSpawnHealFx(unit.HealthController.ObjectId); //StartCoroutine(DespawnAfterTime()); } [Server] private IEnumerator DespawnAfterTime() { yield return new WaitForSeconds(3f); InstanceFinder.ServerManager.Despawn(gameObject); } [ObserversRpc] private void ObserversSpawnHealFx(int unitId) { _visualFX.SetActive(false); Transform target = GameplayManager.Instance.GetTargetTransformServerAndClient(unitId); StartCoroutine(HealFX(target)); } [Client] private IEnumerator HealFX(Transform target) { GameObject fx = Instantiate(_healFx, target.position, Quaternion.identity); fx.transform.SetParent(target); DebugWrite.Log($\"[HealthSphereController] Spawned heal fx for {target.name}\", gameObject, _isDebug); yield return new WaitForSeconds(2.0f); DebugWrite.Log($\"[HealthSphereController] Destroyed heal fx for {target.name}\", gameObject, _isDebug); Destroy(fx); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "TradingPostController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "TradingPostController",
          "content": " using System; using System.Collections; using System.Collections.Generic; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using FishnetInvector; using Invector.vItemManager; using SingletonsExtension; using TMPro; using UnityEngine; namespace InRoomSystems { public class TradingPostController : InteractableObjectController { [SerializeField] private EnemyDefinition.PossibleItemRanges[] _itemRanges; [SerializeField] private TextMeshProUGUI itemNameText; [SerializeField] private TextMeshProUGUI itemDescriptionText; [SyncVar] [SerializeField] private int itemId; [field:SerializeField] public vItem targetItem { get; private set; } [field:SerializeField] public GameObject uiItemInfo { get; private set; } [field:SerializeField] public Transform targetItemHolder { get; private set; } [field:SerializeField] public SphereCollider collider { get; private set; } private vItemListData _itemList => MasterManager.Instance.ItemListData; [SerializeField] private GameObject _healFx; [SerializeField] private GameObject _visualFX; private bool _isUsed = false; protected override void Awake() { base.Awake(); uiItemInfo.SetActive(false); } public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { InitRandomItem(); OnPlayerFinishedInteracting += TryToBuyItem; } } public override void OnStartClient() { base.OnStartClient(); UpdateItemDescription(); collider.isTrigger = true; } [Server] public void InitRandomItem() { List<ItemReference> items = GameplayManager.Instance.LootDropSystem.GenerateLoot(_itemRanges, 1, .0f); itemId = items[0].id; targetItem = _itemList.items.Find(item => item.id == itemId); Debug.Log($\"[TradingPostController] {gameObject.name} InitRandomItem: {targetItem.Name} #{itemId}\"); } [Client] private void UpdateItemDescription() { targetItem = _itemList.items.Find(item => item.id == itemId); itemNameText.text = $\"{targetItem.Name} - <color = yellow>{targetItem.Price}</color> gold\"; itemDescriptionText.text = targetItem.description; } [Client] private void OnTriggerEnter(Collider other) { if (!IsServer) return; if (other.CompareTag(\"Player\")) { FishnetInvectorHealthController healthController = GameplayManager.Instance.GetHealthController(other); if (healthController.IsDead) return; if (!healthController.IsOwner) return; uiItemInfo.SetActive(true); } } [Client] private void OnTriggerExit(Collider other) { if (!IsServer) return; if (other.CompareTag(\"Player\")) { FishnetInvectorHealthController healthController = GameplayManager.Instance.GetHealthController(other); if (!healthController.IsOwner) return; uiItemInfo.SetActive(false); }  ",
          "content_tokens": 752,
          "embedding": []
        },
        {
          "cs_scriptfile": "TradingPostController",
          "content": "private bool IsGoldEnough(bool asServer = false) { int currentGold = FishnetInvectorItemManager.LocalPlayer.GetGoldAmount(); if (targetItem.Price > currentGold) { Debug.Log($\"[TradingPostController] {FishnetInvectorItemManager.LocalPlayer.name} doesn't have enough gold to buy {targetItem.Name}\"); return false; } return true; } [Server] private void RemoveItemFromTradingPost() { } [Server] private void TryToBuyItem(NetworkConnection conn) { if (!IsGoldEnough(true)) return; if (_isUsed) return; _isUsed = true; StringBuilder sb = new StringBuilder(); sb.Append($\"[TradingPostController] Player {conn.ClientId} interacted with {gameObject.name} and bought {targetItem.Name} for {targetItem.Price} gold. \"); UnitComponents unit = GameplayManager.Instance.GetPlayerHeroComponentsServerAndClient(conn); _triggerGenericAction.enabled = false; unit.ItemManager.ChangeGoldAmount(-targetItem.Price); unit.ItemManager.ServerAddItemReference(targetItem.ToItemReference()); RemoveItemFromTradingPost(); DebugWrite.Log($\"{sb}\", gameObject, _isDebug); //ObserversSpawnHealFx(unit.HealthController.ObjectId); //StartCoroutine(DespawnAfterTime()); } [Server] private IEnumerator DespawnAfterTime() { yield return new WaitForSeconds(3f); InstanceFinder.ServerManager.Despawn(gameObject); } [ObserversRpc] private void ObserversSpawnHealFx(int unitId) { _visualFX.SetActive(false); Transform target = GameplayManager.Instance.GetTargetTransformServerAndClient(unitId); StartCoroutine(HealFX(target)); } [Client] private IEnumerator HealFX(Transform target) { GameObject fx = Instantiate(_healFx, target.position, Quaternion.identity); fx.transform.SetParent(target); DebugWrite.Log($\"[HealthSphereController] Spawned heal fx for {target.name}\", gameObject, _isDebug); yield return new WaitForSeconds(2.0f); DebugWrite.Log($\"[HealthSphereController] Destroyed heal fx for {target.name}\", gameObject, _isDebug); Destroy(fx); } } }",
          "content_tokens": 541,
          "embedding": []
        }
      ],
      "length": 4696
    },
    {
      "filename": "TrapController",
      "content": "using System.Collections; using System.Collections.Generic; using InRoomSystems; using UnityEngine; [RequireComponent(typeof(BehavioursSwitcherUtility))] public class TrapController : InteractableObjectController { } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "TrapController",
          "content": "using System.Collections; using System.Collections.Generic; using InRoomSystems; using UnityEngine; [RequireComponent(typeof(BehavioursSwitcherUtility))] public class TrapController : InteractableObjectController { }",
          "content_tokens": 53,
          "embedding": []
        }
      ],
      "length": 217
    },
    {
      "filename": "WallButtonController",
      "content": "using System; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using Invector.vItemManager; using NGS.AdvancedCullingSystem.Dynamic; using UnityEngine; namespace InRoomSystems { public class WallButtonController : InteractableObjectController { [SyncVar(OnChange = nameof(OnWallButton))] protected bool _wallButtonPressed = false; [SerializeField] private DamagingCollider _trap; [SerializeField] private EnemyDefinition.PossibleItemRanges[] _itemRanges; [SerializeField] private int _itemsCount = 2; [SerializeField] private float _chanceMod = .1f; [SerializeField][Range(0,100)] private int _chanceLoot = 25; public Action<Transform, bool> OnWallButtonPressed; [SyncVar] private NetworkObject _interactingAgent; public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { OnPlayerFinishedInteracting += WallButton; } } protected override void InitClient() { TurnOnClientOnlyComponents(); AddTimedActionListeners(); _gameplayManager = GameplayManager.LocalPlayer; gameObject.name = $\"{tag} #{NetworkObject.ObjectId}\"; #if UNITY_EDITOR if (ObjectsRoomManager == null) ObjectsRoomManager = FindObjectOfType<ObjectsRoomManager>(); transform.parent = ObjectsRoomManager.transform; #endif for (int i = 0; i < _meshRenderers.Length; i++) { DC_Controller.Instance.AddObjectForCulling(_meshRenderers[i]); } } [Server] protected void WallButton(NetworkConnection senderConn) { _interactingAgent = GameplayManager.Instance.GetPlayerNob(senderConn); _wallButtonPressed = !_wallButtonPressed; DeallocateObjectInteractingAction(senderConn.ClientId); } protected void OnWallButton(bool prev, bool next, bool asServer) { if (IsGetLoot()) { List<ItemReference> items = GameplayManager.Instance.LootDropSystem.GenerateLoot(_itemRanges, _itemsCount, _chanceMod); GameplayManager.Instance.LootDropSystem.DropLootItems(items, transform.position + Vector3.up); } else if(_trap != null) { _trap.enabled = true; } DebugWrite.Log($\"[WallButtonController] OnWallButton() called for {gameObject.name} with _wallButtonPressed {next} _isStartingRotationNotSet {_isStartingRotationNotSet}\", gameObject, _isDebug); if (next) { OnWallButtonPressed?.Invoke(_interactingAgent.transform, asServer); } } private bool IsGetLoot() { int rnd = UnityEngine.Random.Range(0, 100); if(rnd <= _chanceLoot) return true; return false; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "WallButtonController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "WallButtonController",
          "content": "using System; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using Invector.vItemManager; using NGS.AdvancedCullingSystem.Dynamic; using UnityEngine; namespace InRoomSystems { public class WallButtonController : InteractableObjectController { [SyncVar(OnChange = nameof(OnWallButton))] protected bool _wallButtonPressed = false; [SerializeField] private DamagingCollider _trap; [SerializeField] private EnemyDefinition.PossibleItemRanges[] _itemRanges; [SerializeField] private int _itemsCount = 2; [SerializeField] private float _chanceMod = .1f; [SerializeField][Range(0,100)] private int _chanceLoot = 25; public Action<Transform, bool> OnWallButtonPressed; [SyncVar] private NetworkObject _interactingAgent; public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { OnPlayerFinishedInteracting += WallButton; } } protected override void InitClient() { TurnOnClientOnlyComponents(); AddTimedActionListeners(); _gameplayManager = GameplayManager.LocalPlayer; gameObject.name = $\"{tag} #{NetworkObject.ObjectId}\"; #if UNITY_EDITOR if (ObjectsRoomManager == null) ObjectsRoomManager = FindObjectOfType<ObjectsRoomManager>(); transform.parent = ObjectsRoomManager.transform; #endif for (int i = 0; i < _meshRenderers.Length; i++) { DC_Controller.Instance.AddObjectForCulling(_meshRenderers[i]); } } [Server] protected void WallButton(NetworkConnection senderConn) { _interactingAgent = GameplayManager.Instance.GetPlayerNob(senderConn); _wallButtonPressed = !_wallButtonPressed; DeallocateObjectInteractingAction(senderConn.ClientId);  ",
          "content_tokens": 476,
          "embedding": []
        },
        {
          "cs_scriptfile": "WallButtonController",
          "content": "protected void OnWallButton(bool prev, bool next, bool asServer) { if (IsGetLoot()) { List<ItemReference> items = GameplayManager.Instance.LootDropSystem.GenerateLoot(_itemRanges, _itemsCount, _chanceMod); GameplayManager.Instance.LootDropSystem.DropLootItems(items, transform.position + Vector3.up); } else if(_trap != null) { _trap.enabled = true; } DebugWrite.Log($\"[WallButtonController] OnWallButton() called for {gameObject.name} with _wallButtonPressed {next} _isStartingRotationNotSet {_isStartingRotationNotSet}\", gameObject, _isDebug); if (next) { OnWallButtonPressed?.Invoke(_interactingAgent.transform, asServer); }  ",
          "content_tokens": 186,
          "embedding": []
        },
        {
          "cs_scriptfile": "WallButtonController",
          "content": "private bool IsGetLoot() { int rnd = UnityEngine.Random.Range(0, 100); if(rnd <= _chanceLoot) return true; return false; } } }",
          "content_tokens": 42,
          "embedding": []
        }
      ],
      "length": 2501
    },
    {
      "filename": "GoActivatorForPlayer",
      "content": "using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishnetInvector; using UnityEngine; public class GoActivatorForPlayer : MonoBehaviour { [SerializeField] private GameObjectDispatcher _light; [SerializeField] private bool _isActiveAtStart = false; [SerializeField] private List<Collider> playersInside = new (); [SerializeField] private List<Collider> collidersInside = new (); private void Start() { if (!_isActiveAtStart) _light.Deactivate(); } private void OnTriggerEnter(Collider other) { collidersInside.Add(other); if (other.CompareTag(\"Player\")) { var healthController = GameplayManager.Instance.GetHealthController(other); if (!IsLocalPlayer(healthController)) return; playersInside.Add(other); _light.Activate(); } } private void OnTriggerExit(Collider other) { if (other.CompareTag(\"Player\")) { var healthController = GameplayManager.Instance.GetHealthController(other); if (!IsLocalPlayer(healthController)) return; _light.Deactivate(); if (playersInside.Contains(other)) playersInside.Remove(other); } if (collidersInside.Contains(other)) collidersInside.Remove(other); } private bool IsLocalPlayer(FishnetInvectorHealthController healthController) { if (healthController.UnitComponents.MeleeManager.IsOwner) return true; return false; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "GoActivatorForPlayer",
          "content": "using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishnetInvector; using UnityEngine; public class GoActivatorForPlayer : MonoBehaviour { [SerializeField] private GameObjectDispatcher _light; [SerializeField] private bool _isActiveAtStart = false; [SerializeField] private List<Collider> playersInside = new (); [SerializeField] private List<Collider> collidersInside = new (); private void Start() { if (!_isActiveAtStart) _light.Deactivate();  ",
          "content_tokens": 143,
          "embedding": []
        },
        {
          "cs_scriptfile": "GoActivatorForPlayer",
          "content": "private void OnTriggerEnter(Collider other) { collidersInside.Add(other); if (other.CompareTag(\"Player\")) { var healthController = GameplayManager.Instance.GetHealthController(other); if (!IsLocalPlayer(healthController)) return; playersInside.Add(other); _light.Activate(); }  private void OnTriggerExit(Collider other) { if (other.CompareTag(\"Player\")) { var healthController = GameplayManager.Instance.GetHealthController(other); if (!IsLocalPlayer(healthController)) return; _light.Deactivate(); if (playersInside.Contains(other)) playersInside.Remove(other);  if (collidersInside.Contains(other)) collidersInside.Remove(other);  ",
          "content_tokens": 164,
          "embedding": []
        },
        {
          "cs_scriptfile": "GoActivatorForPlayer",
          "content": "private bool IsLocalPlayer(FishnetInvectorHealthController healthController) { if (healthController.UnitComponents.MeleeManager.IsOwner) return true; return false; } }",
          "content_tokens": 40,
          "embedding": []
        }
      ],
      "length": 1332
    },
    {
      "filename": "ICorrectNetPosition",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public interface ICorrectNetPosition { public void CorrectNetPosition(Vector3 newPos); } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ICorrectNetPosition",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public interface ICorrectNetPosition { public void CorrectNetPosition(Vector3 newPos); }",
          "content_tokens": 37,
          "embedding": []
        }
      ],
      "length": 168
    },
    {
      "filename": "LootItemButton",
      "content": "using System; using Invector.vItemManager; using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.UI; public class LootItemButton : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler { private int _id; [SerializeField] private Image _itemIcon; [SerializeField] private TMProDecorator _itemNameTextDecorator; public Action<int> OnMouseHoverEnter; public Action OnMouseHoverExit; public void Init(LootWindow lootWindow, int id, vItem item) { _id = id; _itemIcon.sprite = item.icon; _itemNameTextDecorator.SetText(item.name); } public void OnPointerEnter(PointerEventData eventData) { OnMouseHoverEnter?.Invoke(_id); Debug.Log(\"Mouse is over the button.\"); } public void OnPointerExit(PointerEventData eventData) { OnMouseHoverExit?.Invoke(); Debug.Log(\"Mouse left the button.\"); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LootItemButton",
          "content": "using System; using Invector.vItemManager; using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.UI; public class LootItemButton : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler { private int _id; [SerializeField] private Image _itemIcon; [SerializeField] private TMProDecorator _itemNameTextDecorator; public Action<int> OnMouseHoverEnter; public Action OnMouseHoverExit; public void Init(LootWindow lootWindow, int id, vItem item) { _id = id; _itemIcon.sprite = item.icon; _itemNameTextDecorator.SetText(item.name);  public void OnPointerEnter(PointerEventData eventData) { OnMouseHoverEnter?.Invoke(_id); Debug.Log(\"Mouse is over the button.\");  ",
          "content_tokens": 195,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootItemButton",
          "content": "public void OnPointerExit(PointerEventData eventData) { OnMouseHoverExit?.Invoke(); Debug.Log(\"Mouse left the button.\"); } }",
          "content_tokens": 37,
          "embedding": []
        }
      ],
      "length": 801
    },
    {
      "filename": "LootItemInfo",
      "content": "using Invector.vItemManager; using UnityEngine; using UnityEngine.UI; public class LootItemInfo : MonoBehaviour { [SerializeField] private Image _itemIcon; [SerializeField] private TMProDecorator _itemNameTextDecorator; [SerializeField] private TMProDecorator _itemDescriptionTextDecorator; private UICanvasGroupDecorator _canvasGroupDecorator; private void Awake() => _canvasGroupDecorator = GetComponent<UICanvasGroupDecorator>(); public void Show(vItem item) { LoadItem(item); _canvasGroupDecorator.Show(); } public void Hide() => _canvasGroupDecorator.Hide(); private void LoadItem(vItem item) { _itemIcon.sprite = item.icon; _itemNameTextDecorator.SetText(item.name); string attributes = item.GetItemAttributesText(); _itemDescriptionTextDecorator.SetText($\"{attributes}\\n{item.description}\"); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LootItemInfo",
          "content": "using Invector.vItemManager; using UnityEngine; using UnityEngine.UI; public class LootItemInfo : MonoBehaviour { [SerializeField] private Image _itemIcon; [SerializeField] private TMProDecorator _itemNameTextDecorator; [SerializeField] private TMProDecorator _itemDescriptionTextDecorator; private UICanvasGroupDecorator _canvasGroupDecorator; private void Awake() => _canvasGroupDecorator = GetComponent<UICanvasGroupDecorator>(); public void Show(vItem item) { LoadItem(item); _canvasGroupDecorator.Show();  ",
          "content_tokens": 147,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootItemInfo",
          "content": "public void Hide() => _canvasGroupDecorator.Hide(); private void LoadItem(vItem item) { _itemIcon.sprite = item.icon; _itemNameTextDecorator.SetText(item.name); string attributes = item.GetItemAttributesText(); _itemDescriptionTextDecorator.SetText($\"{attributes}\\n{item.description}\"); } }",
          "content_tokens": 86,
          "embedding": []
        }
      ],
      "length": 803
    },
    {
      "filename": "LootWindow",
      "content": "using System.Collections.Generic; using Invector.vItemManager; using UnityEngine; public class LootWindow : MonoBehaviour { private UICanvasGroupDecorator _canvasGroupDecorator; [SerializeField] private LootItemInfo _lootItemInfo; [SerializeField] private LootItemButton _lootItemButtonPrefab; private List<LootItemButton> _lootItemButtons = new List<LootItemButton>(); private List<vItem> _currentLootItems = new List<vItem>(); private void Awake() => _canvasGroupDecorator = GetComponent<UICanvasGroupDecorator>(); public void LoadItems(List<vItem> items) { _currentLootItems = items; for (int i = 0; i < _lootItemButtons.Count; i++) { Destroy(_lootItemButtons[i].gameObject); } for (int i = 0; i < items.Count; i++) { var lootItemButton = Instantiate(_lootItemButtonPrefab, transform); _lootItemButtons.Add(lootItemButton); lootItemButton.Init(this, i, items[i]); lootItemButton.OnMouseHoverEnter += OnMouseHoverEnter; lootItemButton.OnMouseHoverExit += OnMouseHoverExit; } _canvasGroupDecorator.Show(); } public void Hide() => _canvasGroupDecorator.Hide(); private void OnMouseHoverEnter(int itemId) { _lootItemInfo.Show(_currentLootItems[itemId]); } private void OnMouseHoverExit() { _lootItemInfo.Hide(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LootWindow",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootWindow",
          "content": "using System.Collections.Generic; using Invector.vItemManager; using UnityEngine; public class LootWindow : MonoBehaviour { private UICanvasGroupDecorator _canvasGroupDecorator; [SerializeField] private LootItemInfo _lootItemInfo; [SerializeField] private LootItemButton _lootItemButtonPrefab; private List<LootItemButton> _lootItemButtons = new List<LootItemButton>(); private List<vItem> _currentLootItems = new List<vItem>(); private void Awake() => _canvasGroupDecorator = GetComponent<UICanvasGroupDecorator>(); public void LoadItems(List<vItem> items) { _currentLootItems = items; for (int i = 0; i < _lootItemButtons.Count; i++) { Destroy(_lootItemButtons[i].gameObject);  ",
          "content_tokens": 205,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootWindow",
          "content": "for (int i = 0; i < items.Count; i++) { var lootItemButton = Instantiate(_lootItemButtonPrefab, transform); _lootItemButtons.Add(lootItemButton); lootItemButton.Init(this, i, items[i]); lootItemButton.OnMouseHoverEnter += OnMouseHoverEnter; lootItemButton.OnMouseHoverExit += OnMouseHoverExit; } _canvasGroupDecorator.Show();  public void Hide() => _canvasGroupDecorator.Hide(); private void OnMouseHoverEnter(int itemId) { _lootItemInfo.Show(_currentLootItems[itemId]);  private void OnMouseHoverExit() { _lootItemInfo.Hide(); } }",
          "content_tokens": 169,
          "embedding": []
        }
      ],
      "length": 1215
    },
    {
      "filename": "LootDropDefinition",
      "content": "using System; using System.Collections.Generic; using System.IO; using Invector.vItemManager; using UnityEditor; using UnityEngine; using Newtonsoft.Json; namespace InRoomSystems { [CreateAssetMenu(fileName = \"LootDropDefinitionSO\", menuName = \"ScriptableObjects/LootDropDefinition\")] public class LootDropDefinition : ScriptableObject { [SerializeField] private vItemListData _itemList; [SerializeField] private List<LootItems> _lootItems = new List<LootItems>(); private static string JSON_FILE_NAME = \"LootDrop.json\"; public List<LootItems> LootItemsList => _lootItems; public void AddLootItem(LootItems lootItem) { _lootItems.Add(lootItem); } public void RemoveLootItem(LootItems lootItem) { _lootItems.Remove(lootItem); } public LootItems GetLoot(CratesSystem.Zone zone){ foreach (var lootItem in _lootItems) { if (lootItem.zone == zone) { return lootItem; } } Debug.LogError(\"No loot items found for zone: \" + zone); return null; } public void ExportToJson() { var json = new Dictionary<string, object>(); var itemList = new List<Dictionary<string, object>>(); foreach (var item in LootItemsList) { var itemDict = new Dictionary<string, object>(); itemDict.Add(\"Zone\", item.zone.ToString()); var dropTables = new List<Dictionary<string, object>>(); foreach (var table in item.dropTables) { var tableDict = new Dictionary<string, object>(); tableDict.Add(\"Type\", table.dropType.ToString()); tableDict.Add(\"Chance\", table.dropChance); tableDict.Add(\"Min\", table.min); tableDict.Add(\"Max\", table.max); tableDict.Add(\"vItemID\", table.item.id); dropTables.Add(tableDict); } itemDict.Add(\"DropTables\", dropTables); itemList.Add(itemDict); } json.Add(\"ItemList\", itemList); var jsonStr = Newtonsoft.Json.JsonConvert.SerializeObject(json, Newtonsoft.Json.Formatting.Indented); //string jsonStr = JsonUtility.ToJson(json, true); var path = \"Assets/Resources/\" + JSON_FILE_NAME; System.IO.File.WriteAllText(path, jsonStr); Debug.Log(\"Exported to: \" + path); } public void ImportFromJson() { string path = \"Assets/Resources/\" + JSON_FILE_NAME; if (!File.Exists(path)) { Debug.LogError(\"File does not exist: \" + path); return; } string jsonStr = File.ReadAllText(path); var json = JsonConvert.DeserializeObject(jsonStr, typeof(Dictionary<string, object>)) as Dictionary<string, object>; //JsonUtility.FromJson<Dictionary<string, object>>(jsonStr); if (json.ContainsKey(\"ItemList\")) { var itemList = json[\"ItemList\"] as List<object>; foreach (var itemData in itemList) { var itemDict = itemData as Dictionary<string, object>; if (itemDict.ContainsKey(\"Zone\") && itemDict.ContainsKey(\"DropTables\")) { var item = new LootItems(); item.zone = (CratesSystem.Zone)Enum.Parse(typeof(CratesSystem.Zone), itemDict[\"Zone\"].ToString()); var dropTablesData = itemDict[\"DropTables\"] as List<object>; foreach (var tableData in dropTablesData) { var tableDict = tableData as Dictionary<string, object>; if (tableDict.ContainsKey(\"Type\") && tableDict.ContainsKey(\"Chance\") && tableDict.ContainsKey(\"Min\") && tableDict.ContainsKey(\"Max\") && tableDict.ContainsKey(\"vItemID\")) { var table = new LootDropDefinition.DropTable(); table.dropType = (LootDropDefinition.DropType)Enum.Parse(typeof(LootDropDefinition.DropType), tableDict[\"Type\"].ToString()); int vItemId = Convert.ToInt32(tableDict[\"vItemID\"]); table.item = _itemList.items.Find(x => x.id == vItemId); table.dropChance = Convert.ToSingle(tableDict[\"Chance\"]); table.min = Convert.ToInt32(tableDict[\"Min\"]); table.max = Convert.ToInt32(tableDict[\"Max\"]); item.dropTables.Add(table); } } LootItemsList.Add(item); } } #if UNITY_EDITOR EditorUtility.SetDirty(this); #endif } } #region HelperClasses public enum DropType { Weapon, Armor, Ammo, Consumable, Misc, Coins } [Serializable] public class LootItems { public CratesSystem.Zone zone; public List<DropTable> dropTables = new List<DropTable>(); } [Serializable] public class DropTable { public DropType dropType; public vItem item; public float dropChance; public int min = 1; public int max = 1; } #endregion } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LootDropDefinition",
          "content": "using System; using System.Collections.Generic; using System.IO; using Invector.vItemManager; using UnityEditor; using UnityEngine; using Newtonsoft.Json; namespace InRoomSystems { [CreateAssetMenu(fileName = \"LootDropDefinitionSO\", menuName = \"ScriptableObjects/LootDropDefinition\")] public class LootDropDefinition : ScriptableObject { [SerializeField] private vItemListData _itemList; [SerializeField] private List<LootItems> _lootItems = new List<LootItems>(); private static string JSON_FILE_NAME = \"LootDrop.json\"; public List<LootItems> LootItemsList => _lootItems; public void AddLootItem(LootItems lootItem) { _lootItems.Add(lootItem);  ",
          "content_tokens": 183,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootDropDefinition",
          "content": "public void RemoveLootItem(LootItems lootItem) { _lootItems.Remove(lootItem); } public LootItems GetLoot(CratesSystem.Zone zone){ foreach (var lootItem in _lootItems) { if (lootItem.zone == zone) { return lootItem; } } Debug.LogError(\"No loot items found for zone: \" + zone); return null;  ",
          "content_tokens": 91,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootDropDefinition",
          "content": "public void ExportToJson() { var json = new Dictionary<string, object>(); var itemList = new List<Dictionary<string, object>>(); foreach (var item in LootItemsList) { var itemDict = new Dictionary<string, object>(); itemDict.Add(\"Zone\", item.zone.ToString()); var dropTables = new List<Dictionary<string, object>>(); foreach (var table in item.dropTables) { var tableDict = new Dictionary<string, object>(); tableDict.Add(\"Type\", table.dropType.ToString()); tableDict.Add(\"Chance\", table.dropChance); tableDict.Add(\"Min\", table.min); tableDict.Add(\"Max\", table.max); tableDict.Add(\"vItemID\", table.item.id); dropTables.Add(tableDict); } itemDict.Add(\"DropTables\", dropTables); itemList.Add(itemDict); } json.Add(\"ItemList\", itemList); var jsonStr = Newtonsoft.Json.JsonConvert.SerializeObject(json, Newtonsoft.Json.Formatting.Indented); //string jsonStr = JsonUtility.ToJson(json, true); var path = \"Assets/Resources/\" + JSON_FILE_NAME; System.IO.File.WriteAllText(path, jsonStr); Debug.Log(\"Exported to: \" + path);  ",
          "content_tokens": 325,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootDropDefinition",
          "content": "public void ImportFromJson() { string path = \"Assets/Resources/\" + JSON_FILE_NAME; if (!File.Exists(path)) { Debug.LogError(\"File does not exist: \" + path); return; } string jsonStr = File.ReadAllText(path); var json = JsonConvert.DeserializeObject(jsonStr, typeof(Dictionary<string, object>)) as Dictionary<string, object>; //JsonUtility.FromJson<Dictionary<string, object>>(jsonStr); if (json.ContainsKey(\"ItemList\")) { var itemList = json[\"ItemList\"] as List<object>; foreach (var itemData in itemList) { var itemDict = itemData as Dictionary<string, object>; if (itemDict.ContainsKey(\"Zone\") && itemDict.ContainsKey(\"DropTables\")) { var item = new LootItems(); item.zone = (CratesSystem.Zone)Enum.Parse(typeof(CratesSystem.Zone), itemDict[\"Zone\"].ToString()); var dropTablesData = itemDict[\"DropTables\"] as List<object>; foreach (var tableData in dropTablesData) { var tableDict = tableData as Dictionary<string, object>; if (tableDict.ContainsKey(\"Type\") && tableDict.ContainsKey(\"Chance\") && tableDict.ContainsKey(\"Min\") && tableDict.ContainsKey(\"Max\") && tableDict.ContainsKey(\"vItemID\")) { var table = new LootDropDefinition.DropTable(); table.dropType = (LootDropDefinition.DropType)Enum.Parse(typeof(LootDropDefinition.DropType), tableDict[\"Type\"].ToString()); int vItemId = Convert.ToInt32(tableDict[\"vItemID\"]); table.item = _itemList.items.Find(x => x.id == vItemId); table.dropChance = Convert.ToSingle(tableDict[\"Chance\"]); table.min = Convert.ToInt32(tableDict[\"Min\"]); table.max = Convert.ToInt32(tableDict[\"Max\"]); item.dropTables.Add(table); } } LootItemsList.Add(item); } } #if UNITY_EDITOR EditorUtility.SetDirty(this); #endif } } #region HelperClasses public enum DropType { Weapon, Armor, Ammo, Consumable, Misc, Coins } [Serializable] public class LootItems { public CratesSystem.Zone zone; public List<DropTable> dropTables = new List<DropTable>(); } [Serializable] public class DropTable { public DropType dropType; public vItem item; public float dropChance; public int min = 1; public int max = 1; } #endregion } }",
          "content_tokens": 639,
          "embedding": []
        }
      ],
      "length": 3998
    },
    {
      "filename": "LootDropSystem",
      "content": "using System; using System.Collections.Generic; using System.Security.Cryptography; using System.Text; using DungeonScrollerCore; using FishNet.Object; using Invector.vItemManager; using SingletonsExtension; using UnityEngine; using Random = UnityEngine.Random; namespace InRoomSystems { public class LootDropSystem : RoomManager { public static int GOLD_ITEM_ID { get; private set; } = 0; [SerializeField] private LootBagController _lootBagPrefab; [SerializeField] private LootItemController _lootItemPrefab; private LootDropDefinition _lootDropDefinition; protected bool _isDebug = true; public override void OnStartServer() { base.OnStartServer(); try { LoadDataTables(); }catch (Exception e) { Debug.LogError($\"{ClassAndRoomName} OnStartServer: {e}\"); } } /// <summary> /// Called from UnitAI when unit dies through gameplayManager /// </summary> /// <param name=\"pos\"></param> /// <param name=\"chanceModifier\"></param> /// <param name=\"zone\"></param> [Server] public void DropLootBag(List<ItemReference> items, Vector3 pos, float chanceModifier, CratesSystem.Zone zone, int itemsCount) { DebugWrite.Log($\"{ClassAndRoomName} DropLootBag at {pos} with chanceMod {chanceModifier} and itemsCount {itemsCount}\", gameObject, _isDebug); LootBagController lootBag = Instantiate(_lootBagPrefab, pos, Quaternion.identity); items.ForEach(item => item.amount = 1); Spawn(lootBag.gameObject); lootBag.InitServer(GameplayManager, \"LootBag\", pos, Vector3.zero); lootBag.CustomInit(items); } [Server] public void DropLootBag(Vector3 pos, List<ItemReference> items, float interactionTime) { DebugWrite.Log($\"{ClassAndRoomName} DropLootBag: {items.Count} items\", gameObject, _isDebug); LootBagController lootBag = Instantiate(_lootBagPrefab, pos, Quaternion.identity); Spawn(lootBag.gameObject); lootBag.InitServer(GameplayManager, \"LootBag\", pos, Vector3.zero, interactionTime, true); lootBag.CustomInit(items); } [Server] public void DropLootItems(List<ItemReference> items, Vector3 pos) { DebugWrite.Log($\"{ClassAndRoomName} DropLootItems: {items.Count} items\", gameObject, _isDebug); foreach (ItemReference item in items) { if (item.id == 0) { Debug.Log($\"{ClassAndRoomName} DropLootItems: item.id == 0\"); } LootItemController lootItem = Instantiate(_lootItemPrefab, pos, Quaternion.identity); Spawn(lootItem.gameObject); lootItem.CustomInit(new List<ItemReference> {item}); } } [Server] public void LoadDataTables() { _lootDropDefinition = Resources.Load<LootDropDefinition>(\"LootDropDefinitionSO\"); } [Server] public void TestDropNLootbagsNearPlayers(int howMany) { var allPlayers = GameplayManager.GetAllPlayersHeroes(); foreach (var player in allPlayers) { for (int i = 0; i < howMany; i++) { Vector3 randomPos = player.transform.position + new Vector3(Random.Range(-1, 1), 0, Random.Range(-1, 1)); EnemyDefinition.PossibleItemRanges[] possibleItemRanges = new EnemyDefinition.PossibleItemRanges[] { new EnemyDefinition.PossibleItemRanges(1, 10000) }; List<ItemReference> loot = GenerateLoot(possibleItemRanges, 1, .0f); DropLootBag(loot, randomPos, 0, CratesSystem.Zone.level1, 3); } } } [Server] public List<ItemReference> GenerateLoot(EnemyDefinition.PossibleItemRanges[] itemRange, int itemsCount, float chanceMod) { List<ItemReference> items = new List<ItemReference>(); int iterationsCount = 0; for (int j = 0; j < itemsCount; j++) { bool isItemFound = false; byte roll = GameplayManager.GetRandomByte(); float chance = roll / 255f; float chanceSum = Mathf.Max(0f, chance - chanceMod); Debug.Log($\"{ClassAndRoomName} GenerateLoot roll: {roll} chance: {chance} chanceSum: {chanceSum}\"); vItem.Rarity rarity = vItem.Rarity.Trash; List<int> possibleItems = MasterManager.Instance.ItemListData.GetPossibleItemsForChance(chanceSum, out rarity); ItemReference itemToAdd = null; while (itemToAdd == null) { for (int i = 0; i < itemRange.Length; i++) { if (isItemFound) break; List<int> possibleItemsCopy = new List<int>(possibleItems); int minItemId = itemRange[i].FromId; int maxItemId = itemRange[i].ToId; StringBuilder sb = new StringBuilder(); for (int k = 0; k < possibleItems.Count; k++) { sb.Append($\"{possibleItems[k]}, \"); } while (possibleItemsCopy.Count > 0) { System.Random rnd = new System.Random(); long seed = rnd.Next(); int rollItem; byte[] seedBytes = BitConverter.GetBytes(seed); using (SHA256 sha256 = SHA256.Create()) { byte[] hashBytes = sha256.ComputeHash(seedBytes); int randomNumber = BitConverter.ToInt32(hashBytes, 0); rollItem = Math.Abs(randomNumber % possibleItemsCopy.Count); } Debug.Log($\"[LootDropSystem] possibleItems {possibleItems.Count}: possibleItemsCopy {possibleItemsCopy.Count}: {sb}; rollItem: {rollItem} minItemId: {minItemId} maxItemId: {maxItemId}. ISPossibleItemsCopy.Count: {possibleItemsCopy.Count > 100}.\"); if (possibleItemsCopy[rollItem] >= minItemId && possibleItemsCopy[rollItem] <= maxItemId) { var item = MasterManager.Instance.ItemListData.GetItem(possibleItemsCopy[rollItem]); itemToAdd = item.ToItemReference(); Debug.Log($\"[LootDropSystem] GenerateLoot added {itemToAdd?.name} ({item.rarity}); iterations: {iterationsCount}\"); isItemFound = true; break; }else { possibleItemsCopy.Remove(possibleItemsCopy[rollItem]); iterationsCount++; } } } if (isItemFound) break; var nextRarity = rarity + 1; if (nextRarity > vItem.Rarity.Legendary) { Debug.LogError($\"[LootDropSystem] GenerateLoot upperRarity > vItem.Rarity.Legendary\"); break; } possibleItems = MasterManager.Instance.ItemListData.GetPossibleItemsForRarity(nextRarity); } if (!isItemFound) { Debug.LogError($\"[LootDropSystem] GenerateLoot itemToAdd == null\"); if (possibleItems[0] == null) { itemToAdd = MasterManager.Instance.ItemListData.GetItem(GOLD_ITEM_ID).ToItemReference(); itemToAdd.amount = 1; } itemToAdd = MasterManager.Instance.ItemListData.GetItem(possibleItems[0]).ToItemReference(); } if (itemToAdd == null) { Debug.LogError($\"[LootDropSystem] GenerateLoot itemToAdd == null\"); } items.Add(itemToAdd); } return items; } [Server] public List<ItemReference> GenerateLoot(CratesSystem.Zone cratePointZone, float chanceMod, int itemsCount) { LootDropDefinition.LootItems possibleZoneLoot = _lootDropDefinition.GetLoot(cratePointZone); List<LootDropDefinition.DropTable> possibleItems = possibleZoneLoot.dropTables; List<LootDropDefinition.DropTable> itemsToDrop = new List<LootDropDefinition.DropTable>(); //shuffle possibleItems for (int i = 0; i < possibleItems.Count; i++) { int randomIndex = Random.Range(i, possibleItems.Count); LootDropDefinition.DropTable temp = possibleItems[randomIndex]; possibleItems[randomIndex] = possibleItems[i]; possibleItems[i] = temp; } for (int i = 0; i < itemsCount; i++) { LootDropDefinition.DropTable itemWithHighestChance = possibleItems[0]; foreach (var lootItem in possibleItems) { if (itemsToDrop.Contains(lootItem)) { continue; } float random = Random.value; float totalChance = lootItem.dropChance + chanceMod; if (itemWithHighestChance.dropChance + chanceMod > totalChance) { itemWithHighestChance = lootItem; } if (random <= totalChance ) { itemsToDrop.Add(lootItem); break; } } if (itemsToDrop.Count == i) { itemsToDrop.Add(itemWithHighestChance); } } List<ItemReference> items = new List<ItemReference>(); foreach (var dropTable in itemsToDrop) { ItemReference it = dropTable.item.ToItemReference(); items.Add(it); } DebugWrite.Log($\"[LootDropSystem] Generated {items.Count} items for zone {cratePointZone}\"); return items; } public bool AddGoldDrop(float goldDropChance, int minGoldDrop, int MaxGoldDrop, ref List<ItemReference> items) { float roll = GameplayManager.GetRandomFloat(0f, 1f); if (roll < goldDropChance) { int goldAmount = GameplayManager.GetRandomInt(minGoldDrop, MaxGoldDrop); var item = MasterManager.Instance.ItemListData.GetItem(GOLD_ITEM_ID); item.amount = goldAmount; items.Add(item.ToItemReference()); return true; } return false; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LootDropSystem",
          "content": "using System; using System.Collections.Generic; using System.Security.Cryptography; using System.Text; using DungeonScrollerCore; using FishNet.Object; using Invector.vItemManager; using SingletonsExtension; using UnityEngine; using Random = UnityEngine.Random; namespace InRoomSystems { public class LootDropSystem : RoomManager { public static int GOLD_ITEM_ID { get; private set; } = 0; [SerializeField] private LootBagController _lootBagPrefab; [SerializeField] private LootItemController _lootItemPrefab; private LootDropDefinition _lootDropDefinition; protected bool _isDebug = true; public override void OnStartServer() { base.OnStartServer(); try { LoadDataTables();  ",
          "content_tokens": 172,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootDropSystem",
          "content": "catch (Exception e) { Debug.LogError($\"{ClassAndRoomName} OnStartServer: {e}\"); } } /// <summary> /// Called from UnitAI when unit dies through gameplayManager /// </summary> /// <param name=\"pos\"></param> /// <param name=\"chanceModifier\"></param> /// <param name=\"zone\"></param> [Server] public void DropLootBag(List<ItemReference> items, Vector3 pos, float chanceModifier, CratesSystem.Zone zone, int itemsCount) { DebugWrite.Log($\"{ClassAndRoomName} DropLootBag at {pos} with chanceMod {chanceModifier} and itemsCount {itemsCount}\", gameObject, _isDebug); LootBagController lootBag = Instantiate(_lootBagPrefab, pos, Quaternion.identity); items.ForEach(item => item.amount = 1); Spawn(lootBag.gameObject); lootBag.InitServer(GameplayManager, \"LootBag\", pos, Vector3.zero); lootBag.CustomInit(items); } [Server] public void DropLootBag(Vector3 pos, List<ItemReference> items, float interactionTime) { DebugWrite.Log($\"{ClassAndRoomName} DropLootBag: {items.Count} items\", gameObject, _isDebug); LootBagController lootBag = Instantiate(_lootBagPrefab, pos, Quaternion.identity); Spawn(lootBag.gameObject); lootBag.InitServer(GameplayManager, \"LootBag\", pos, Vector3.zero, interactionTime, true); lootBag.CustomInit(items); } [Server] public void DropLootItems(List<ItemReference> items, Vector3 pos) { DebugWrite.Log($\"{ClassAndRoomName} DropLootItems: {items.Count} items\", gameObject, _isDebug); foreach (ItemReference item in items) { if (item.id == 0) { Debug.Log($\"{ClassAndRoomName} DropLootItems: item.id == 0\"); } LootItemController lootItem = Instantiate(_lootItemPrefab, pos, Quaternion.identity); Spawn(lootItem.gameObject); lootItem.CustomInit(new List<ItemReference> {item}); } } [Server] public void LoadDataTables() { _lootDropDefinition = Resources.Load<LootDropDefinition>(\"LootDropDefinitionSO\"); } [Server] public void TestDropNLootbagsNearPlayers(int howMany) { var allPlayers = GameplayManager.GetAllPlayersHeroes(); foreach (var player in allPlayers) { for (int i = 0; i < howMany; i++) { Vector3 randomPos = player.transform.position + new Vector3(Random.Range(-1, 1), 0, Random.Range(-1, 1)); EnemyDefinition.PossibleItemRanges[] possibleItemRanges = new EnemyDefinition.PossibleItemRanges[] { new EnemyDefinition.PossibleItemRanges(1, 10000) }; List<ItemReference> loot = GenerateLoot(possibleItemRanges, 1, .0f); DropLootBag(loot, randomPos, 0, CratesSystem.Zone.level1, 3); } } } [Server] public List<ItemReference> GenerateLoot(EnemyDefinition.PossibleItemRanges[] itemRange, int itemsCount, float chanceMod) { List<ItemReference> items = new List<ItemReference>(); int iterationsCount = 0; for (int j = 0; j < itemsCount; j++) { bool isItemFound = false; byte roll = GameplayManager.GetRandomByte(); float chance = roll / 255f; float chanceSum = Mathf.Max(0f, chance - chanceMod); Debug.Log($\"{ClassAndRoomName} GenerateLoot roll: {roll} chance: {chance} chanceSum: {chanceSum}\"); vItem.Rarity rarity = vItem.Rarity.Trash; List<int> possibleItems = MasterManager.Instance.ItemListData.GetPossibleItemsForChance(chanceSum, out rarity); ItemReference itemToAdd = null; while (itemToAdd == null) { for (int i = 0; i < itemRange.Length; i++) { if (isItemFound) break; List<int> possibleItemsCopy = new List<int>(possibleItems); int minItemId = itemRange[i].FromId; int maxItemId = itemRange[i].ToId; StringBuilder sb = new StringBuilder(); for (int k = 0; k < possibleItems.Count; k++) { sb.Append($\"{possibleItems[k]}, \");  ",
          "content_tokens": 1059,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootDropSystem",
          "content": "while (possibleItemsCopy.Count > 0) { System.Random rnd = new System.Random(); long seed = rnd.Next(); int rollItem; byte[] seedBytes = BitConverter.GetBytes(seed); using (SHA256 sha256 = SHA256.Create()) { byte[] hashBytes = sha256.ComputeHash(seedBytes); int randomNumber = BitConverter.ToInt32(hashBytes, 0); rollItem = Math.Abs(randomNumber % possibleItemsCopy.Count); } Debug.Log($\"[LootDropSystem] possibleItems {possibleItems.Count}: possibleItemsCopy {possibleItemsCopy.Count}: {sb}; rollItem: {rollItem} minItemId: {minItemId} maxItemId: {maxItemId}. ISPossibleItemsCopy.Count: {possibleItemsCopy.Count > 100}.\"); if (possibleItemsCopy[rollItem] >= minItemId && possibleItemsCopy[rollItem] <= maxItemId) { var item = MasterManager.Instance.ItemListData.GetItem(possibleItemsCopy[rollItem]); itemToAdd = item.ToItemReference(); Debug.Log($\"[LootDropSystem] GenerateLoot added {itemToAdd?.name} ({item.rarity}); iterations: {iterationsCount}\"); isItemFound = true; break; }else { possibleItemsCopy.Remove(possibleItemsCopy[rollItem]); iterationsCount++; } }  ",
          "content_tokens": 322,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootDropSystem",
          "content": "if (isItemFound) break; var nextRarity = rarity + 1; if (nextRarity > vItem.Rarity.Legendary) { Debug.LogError($\"[LootDropSystem] GenerateLoot upperRarity > vItem.Rarity.Legendary\"); break; } possibleItems = MasterManager.Instance.ItemListData.GetPossibleItemsForRarity(nextRarity);  if (!isItemFound) { Debug.LogError($\"[LootDropSystem] GenerateLoot itemToAdd == null\"); if (possibleItems[0] == null) { itemToAdd = MasterManager.Instance.ItemListData.GetItem(GOLD_ITEM_ID).ToItemReference(); itemToAdd.amount = 1; } itemToAdd = MasterManager.Instance.ItemListData.GetItem(possibleItems[0]).ToItemReference();  ",
          "content_tokens": 192,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootDropSystem",
          "content": "if (itemToAdd == null) { Debug.LogError($\"[LootDropSystem] GenerateLoot itemToAdd == null\"); } items.Add(itemToAdd); } return items; } [Server] public List<ItemReference> GenerateLoot(CratesSystem.Zone cratePointZone, float chanceMod, int itemsCount) { LootDropDefinition.LootItems possibleZoneLoot = _lootDropDefinition.GetLoot(cratePointZone); List<LootDropDefinition.DropTable> possibleItems = possibleZoneLoot.dropTables; List<LootDropDefinition.DropTable> itemsToDrop = new List<LootDropDefinition.DropTable>(); //shuffle possibleItems for (int i = 0; i < possibleItems.Count; i++) { int randomIndex = Random.Range(i, possibleItems.Count); LootDropDefinition.DropTable temp = possibleItems[randomIndex]; possibleItems[randomIndex] = possibleItems[i]; possibleItems[i] = temp;  ",
          "content_tokens": 224,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootDropSystem",
          "content": "for (int i = 0; i < itemsCount; i++) { LootDropDefinition.DropTable itemWithHighestChance = possibleItems[0]; foreach (var lootItem in possibleItems) { if (itemsToDrop.Contains(lootItem)) { continue; } float random = Random.value; float totalChance = lootItem.dropChance + chanceMod; if (itemWithHighestChance.dropChance + chanceMod > totalChance) { itemWithHighestChance = lootItem;  if (random <= totalChance ) { itemsToDrop.Add(lootItem); break; }  ",
          "content_tokens": 131,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootDropSystem",
          "content": "if (itemsToDrop.Count == i) { itemsToDrop.Add(itemWithHighestChance); } } List<ItemReference> items = new List<ItemReference>(); foreach (var dropTable in itemsToDrop) { ItemReference it = dropTable.item.ToItemReference(); items.Add(it); } DebugWrite.Log($\"[LootDropSystem] Generated {items.Count} items for zone {cratePointZone}\"); return items;  ",
          "content_tokens": 104,
          "embedding": []
        },
        {
          "cs_scriptfile": "LootDropSystem",
          "content": "public bool AddGoldDrop(float goldDropChance, int minGoldDrop, int MaxGoldDrop, ref List<ItemReference> items) { float roll = GameplayManager.GetRandomFloat(0f, 1f); if (roll < goldDropChance) { int goldAmount = GameplayManager.GetRandomInt(minGoldDrop, MaxGoldDrop); var item = MasterManager.Instance.ItemListData.GetItem(GOLD_ITEM_ID); item.amount = goldAmount; items.Add(item.ToItemReference()); return true; } return false; } } }",
          "content_tokens": 126,
          "embedding": []
        }
      ],
      "length": 7827
    },
    {
      "filename": "Movable",
      "content": "using System.Collections; using DG.Tweening; using UnityEngine; public class Movable : MonoBehaviour { [SerializeField] protected iTween.EaseType _easeType = iTween.EaseType.easeInOutQuint; [SerializeField] protected Ease _easeTypeDOT = Ease.InOutQuint; #region Movement [SerializeField] protected Transform[] _positionPoint; protected Vector3[] _forwardPath; protected Vector3[] _backwardPath; protected float _timeToFinishOneWay; protected bool _isForwardMove = true; [Range(0f, 1f)] protected float _pathPosition; public bool IsNeedToMove => _positionPoint.Length > 0; #endregion #region Rotation protected Vector3 _endRotation = Vector3.zero; protected float _timeToRotateFullOneWay; protected bool _isForwardRotate = true; [SerializeField] protected Vector3[] _rotationPositions; // Now an array protected Vector3[] _rotationWays; // Now an array protected float _singleRotationTimeWithDelay; protected float _singleRotationTimeWithoutDelay; [SerializeField] protected bool _isCircularRotation = false; // Added protected int _nextRotationIndex = 0; // Added protected Vector3 _startRotation; protected float _sumRotationsXYZ; public bool IsNeedToRotate => _rotationPositions.Length > 0; #endregion [SerializeField] protected float _speed = 0f; [SerializeField] protected bool _isCustomDelay = false; [SerializeField] protected float _predefinedDelay = 0f; protected float _delayBetweenMoves; /// <summary> /// Called when need to launch the movement /// </summary> /// <param name=\"milisecondsPassedSinceStart\">To synchronize position state of moving platform</param> /// <param name=\"speed\">Movement speed of platform</param> public virtual void Init(float milisecondsPassedSinceStart, float speed, int delayBetweenMoves = 0) { StartCoroutine(InitCoroutine(milisecondsPassedSinceStart, speed, delayBetweenMoves)); } private IEnumerator InitCoroutine(float timeMilisecondsPassedSinceStart, float speed, int delayBetweenMoves) { if (_speed < Mathf.Epsilon) _speed = speed; if (_isCustomDelay) { _delayBetweenMoves = _predefinedDelay; } else { _delayBetweenMoves = delayBetweenMoves; } if (IsNeedToMove) { _forwardPath = new Vector3[_positionPoint.Length]; for (int i = 0; i < _positionPoint.Length; i++) { _forwardPath[i] = _positionPoint[i].position; Destroy(_positionPoint[i].gameObject); } _backwardPath = new Vector3[_positionPoint.Length]; for (int i = 0; i < _positionPoint.Length; i++) { _backwardPath[i] = _forwardPath[_positionPoint.Length - 1 - i]; } //calculate total time to finish the path float totalPathCalculated = 0; for (int i = 0; i < _forwardPath.Length - 1; i++) { totalPathCalculated += Vector3.Distance(_forwardPath[i], _forwardPath[i + 1]); } _timeToFinishOneWay = totalPathCalculated / _speed; var direction = (int) (timeMilisecondsPassedSinceStart / _timeToFinishOneWay) % 2; _isForwardMove = direction == 0; _pathPosition = (timeMilisecondsPassedSinceStart % _timeToFinishOneWay) / _timeToFinishOneWay; } Vector3 endRot = Vector3.zero; float currentIndexDelay = 0f; if (IsNeedToRotate) { float totalRotationCalculated = 0; if (_isCircularRotation) { SetupRotationOneWay(_rotationPositions.Length + 1); _timeToRotateFullOneWay = (_delayBetweenMoves * _rotationWays.Length) + 1f / _speed; } else { SetupRotationOneWay(_rotationPositions.Length * 2 + 1); for (int i = 0; i < _rotationPositions.Length - 1; i++) { _rotationWays[_rotationPositions.Length + 1 + i] = _rotationPositions[_rotationPositions.Length - 2 - i]; } _rotationWays[_rotationPositions.Length * 2] = _rotationWays[0]; _timeToRotateFullOneWay = (_delayBetweenMoves * _rotationWays.Length) + 2f / _speed; } _singleRotationTimeWithDelay = _timeToRotateFullOneWay / _rotationWays.Length; _singleRotationTimeWithoutDelay = _singleRotationTimeWithDelay - _delayBetweenMoves; //first we need to find current way if (gameObject.name == \"Wall1 (4)\") { Debug.Log(\"Wall1 (4)\"); } float currentTimeStatusWithDelay = (timeMilisecondsPassedSinceStart % _timeToRotateFullOneWay);//1.34 //float timePercentPassed = currentTimeStatusWithDelay / _timeToRotateFullOneWay;//.67 int currentIndex = (int)Mathf.Floor(currentTimeStatusWithDelay / _singleRotationTimeWithDelay);//1.34 / .66 float timePassedSinceCurrentIndexWithDelay = (currentTimeStatusWithDelay % _singleRotationTimeWithDelay);//1.34 % .66 = .02 //float currentIndexRotationTimePercentWithDelay = currentIndexTimePassedWithDelay / _singleRotationTimeWithDelay;//.02 / .66 = .03 Debug.Log($\"[Movable.Init] {gameObject.name} - currentTimeStatusWithDelay: {currentTimeStatusWithDelay} currentIndex: {currentIndex}, timePassedSinceCurrentIndexWithDelay: {timePassedSinceCurrentIndexWithDelay}\", gameObject); float currentIndexLocalPercent = 0f; if (timePassedSinceCurrentIndexWithDelay < _delayBetweenMoves) { currentIndexDelay = _delayBetweenMoves - timePassedSinceCurrentIndexWithDelay;//остаток задержки currentIndexLocalPercent = 0f; _nextRotationIndex = (currentIndex + 1) % _rotationPositions.Length; endRot = _rotationWays[currentIndex]; } else { currentIndexDelay = 0f; currentIndexLocalPercent = (timePassedSinceCurrentIndexWithDelay - _delayBetweenMoves) / _singleRotationTimeWithoutDelay; _nextRotationIndex = (currentIndex + 1) % _rotationPositions.Length; endRot = _rotationWays[_nextRotationIndex]; } transform.rotation = Quaternion.Euler(Vector3.Lerp(_rotationWays[currentIndex], endRot, currentIndexLocalPercent)); Debug.Log($\"[Movable.Init] {gameObject.name} - {transform.rotation} currentIndexDelay {currentIndexDelay}; currentIndexLocalPercent{currentIndexLocalPercent}; currentRotationStartIndex: {currentIndex}, currentRotationLocalPercent: {currentIndexLocalPercent}, endRot: {endRot}, milisecondsPassedSinceStart {timeMilisecondsPassedSinceStart}\", gameObject); } Launch(currentIndexDelay, endRot); yield return null; } protected void SetupRotationOneWay(int len) { _rotationWays = new Vector3[len]; _rotationWays[0] = transform.rotation.eulerAngles; for (int i = 0; i < _rotationPositions.Length; i++) { _rotationWays[i + 1] = _rotationPositions[i]; } } protected virtual void Launch(float delay, Vector3 endRot) { LaunchMove(); LaunchDOTRotation(delay, endRot); } protected void LaunchDOTRotation(float delay, Vector3 endRot) { Debug.Log($\"[Movable.LaunchDOTRotation] {gameObject.name} current: {_nextRotationIndex-1}; delay: {delay}; {transform.rotation}=>{endRot}\"); if (IsNeedToRotate) { //freeze axes that is 0f in endRot transform.DORotateQuaternion(Quaternion.Euler(endRot), _singleRotationTimeWithoutDelay) .SetEase(_easeTypeDOT) .SetDelay(delay) .OnUpdate(() => { }) .OnComplete(() => { _nextRotationIndex = (_nextRotationIndex + 1) % _rotationWays.Length; if (!_isCircularRotation) { if (_nextRotationIndex == _rotationWays.Length - 1) { _nextRotationIndex = 0; } } Vector3 endRot = _rotationWays[_nextRotationIndex]; LaunchDOTRotation(_delayBetweenMoves, endRot); }); } } // private void LaunchRotation() // { // if (IsNeedToRotate) // { // float currentSumRotationsXYZ = Mathf.Abs(_isForwardRotate ? _endRotation.x : _startRotation.x - _rotationPositions.x) // + Mathf.Abs(_isForwardRotate ? _endRotation.y : _startRotation.y - _rotationPositions.y) // + Mathf.Abs(_isForwardRotate ? _endRotation.z : _startRotation.z - _rotationPositions.z); // Debug.Log($\"[Movable.LaunchRotation] {gameObject} currentSumRotationsXYZ / _sumRotationsXYZ: {currentSumRotationsXYZ / _sumRotationsXYZ}\"); // iTween.ValueTo(gameObject, iTween.Hash( // \"from\", _rotationPositions, // \"to\", _isForwardRotate ? _endRotation : _startRotation, // \"time\", _timeToRotateFullOneWay * (currentSumRotationsXYZ / _sumRotationsXYZ), // \"onupdate\", \"UpdateRotationValue\", // \"oncomplete\", \"OnCompleteRotation\", // \"easetype\", _easeType // )); // } // } // // protected void UpdateRotationValue(Vector3 value) { // _rotationPositions[_nextRotationIndex] = value; // transform.rotation = Quaternion.Euler(value); // } // // protected void OnCompleteRotation() { // if (_isCircularRotation) // { // _nextRotationIndex = (_nextRotationIndex + 1) % _rotationPositions.Length; // } // else // { // if (_nextRotationIndex == 0 || _nextRotationIndex == _rotationPositions.Length - 1) // { // _isForwardRotate = !_isForwardRotate; // } // _nextRotationIndex += _isForwardRotate ? 1 : -1; // } // // LaunchRotation(); // } protected virtual void LaunchMove() { if (IsNeedToMove) { iTween.ValueTo(gameObject, iTween.Hash( \"from\", _pathPosition, \"to\", 1f, \"time\", _timeToFinishOneWay * (1 - _pathPosition), \"onupdate\", \"UpdatePathPosition\", \"oncomplete\", \"OnCompletePath\", \"easetype\", _easeType )); } } protected virtual void UpdatePathPosition(float value) { _pathPosition = value; iTween.PutOnPath(gameObject, _isForwardMove ? _forwardPath : _backwardPath, _pathPosition); } protected virtual void OnCompletePath() { _isForwardMove = !_isForwardMove; _pathPosition = 0f; LaunchMove(); } protected void OnDrawGizmos() { if (!Application.isPlaying) { iTween.DrawPath(_positionPoint, Color.green); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Movable",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "Movable",
          "content": "using System.Collections; using DG.Tweening; using UnityEngine; public class Movable : MonoBehaviour { [SerializeField] protected iTween.EaseType _easeType = iTween.EaseType.easeInOutQuint; [SerializeField] protected Ease _easeTypeDOT = Ease.InOutQuint; #region Movement [SerializeField] protected Transform[] _positionPoint; protected Vector3[] _forwardPath; protected Vector3[] _backwardPath; protected float _timeToFinishOneWay; protected bool _isForwardMove = true; [Range(0f, 1f)] protected float _pathPosition; public bool IsNeedToMove => _positionPoint.Length > 0; #endregion #region Rotation protected Vector3 _endRotation = Vector3.zero; protected float _timeToRotateFullOneWay; protected bool _isForwardRotate = true; [SerializeField] protected Vector3[] _rotationPositions; // Now an array protected Vector3[] _rotationWays; // Now an array protected float _singleRotationTimeWithDelay; protected float _singleRotationTimeWithoutDelay; [SerializeField] protected bool _isCircularRotation = false; // Added protected int _nextRotationIndex = 0; // Added protected Vector3 _startRotation; protected float _sumRotationsXYZ; public bool IsNeedToRotate => _rotationPositions.Length > 0; #endregion [SerializeField] protected float _speed = 0f; [SerializeField] protected bool _isCustomDelay = false; [SerializeField] protected float _predefinedDelay = 0f; protected float _delayBetweenMoves; /// <summary> /// Called when need to launch the movement /// </summary> /// <param name=\"milisecondsPassedSinceStart\">To synchronize position state of moving platform</param> /// <param name=\"speed\">Movement speed of platform</param> public virtual void Init(float milisecondsPassedSinceStart, float speed, int delayBetweenMoves = 0) { StartCoroutine(InitCoroutine(milisecondsPassedSinceStart, speed, delayBetweenMoves)); } private IEnumerator InitCoroutine(float timeMilisecondsPassedSinceStart, float speed, int delayBetweenMoves) { if (_speed < Mathf.Epsilon) _speed = speed; if (_isCustomDelay) { _delayBetweenMoves = _predefinedDelay; } else { _delayBetweenMoves = delayBetweenMoves;  ",
          "content_tokens": 562,
          "embedding": []
        },
        {
          "cs_scriptfile": "Movable",
          "content": "if (IsNeedToMove) { _forwardPath = new Vector3[_positionPoint.Length]; for (int i = 0; i < _positionPoint.Length; i++) { _forwardPath[i] = _positionPoint[i].position; Destroy(_positionPoint[i].gameObject); } _backwardPath = new Vector3[_positionPoint.Length]; for (int i = 0; i < _positionPoint.Length; i++) { _backwardPath[i] = _forwardPath[_positionPoint.Length - 1 - i]; } //calculate total time to finish the path float totalPathCalculated = 0; for (int i = 0; i < _forwardPath.Length - 1; i++) { totalPathCalculated += Vector3.Distance(_forwardPath[i], _forwardPath[i + 1]); } _timeToFinishOneWay = totalPathCalculated / _speed; var direction = (int) (timeMilisecondsPassedSinceStart / _timeToFinishOneWay) % 2; _isForwardMove = direction == 0; _pathPosition = (timeMilisecondsPassedSinceStart % _timeToFinishOneWay) / _timeToFinishOneWay; } Vector3 endRot = Vector3.zero; float currentIndexDelay = 0f; if (IsNeedToRotate) { float totalRotationCalculated = 0; if (_isCircularRotation) { SetupRotationOneWay(_rotationPositions.Length + 1); _timeToRotateFullOneWay = (_delayBetweenMoves * _rotationWays.Length) + 1f / _speed; } else { SetupRotationOneWay(_rotationPositions.Length * 2 + 1); for (int i = 0; i < _rotationPositions.Length - 1; i++) { _rotationWays[_rotationPositions.Length + 1 + i] = _rotationPositions[_rotationPositions.Length - 2 - i]; } _rotationWays[_rotationPositions.Length * 2] = _rotationWays[0]; _timeToRotateFullOneWay = (_delayBetweenMoves * _rotationWays.Length) + 2f / _speed; } _singleRotationTimeWithDelay = _timeToRotateFullOneWay / _rotationWays.Length; _singleRotationTimeWithoutDelay = _singleRotationTimeWithDelay - _delayBetweenMoves; //first we need to find current way if (gameObject.name == \"Wall1 (4)\") { Debug.Log(\"Wall1 (4)\"); } float currentTimeStatusWithDelay = (timeMilisecondsPassedSinceStart % _timeToRotateFullOneWay);//1.34 //float timePercentPassed = currentTimeStatusWithDelay / _timeToRotateFullOneWay;//.67 int currentIndex = (int)Mathf.Floor(currentTimeStatusWithDelay / _singleRotationTimeWithDelay);//1.34 / .66 float timePassedSinceCurrentIndexWithDelay = (currentTimeStatusWithDelay % _singleRotationTimeWithDelay);//1.34 % .66 = .02 //float currentIndexRotationTimePercentWithDelay = currentIndexTimePassedWithDelay / _singleRotationTimeWithDelay;//.02 / .66 = .03 Debug.Log($\"[Movable.Init] {gameObject.name} - currentTimeStatusWithDelay: {currentTimeStatusWithDelay} currentIndex: {currentIndex}, timePassedSinceCurrentIndexWithDelay: {timePassedSinceCurrentIndexWithDelay}\", gameObject); float currentIndexLocalPercent = 0f; if (timePassedSinceCurrentIndexWithDelay < _delayBetweenMoves) { currentIndexDelay = _delayBetweenMoves - timePassedSinceCurrentIndexWithDelay;//остаток задержки currentIndexLocalPercent = 0f; _nextRotationIndex = (currentIndex + 1) % _rotationPositions.Length; endRot = _rotationWays[currentIndex]; } else { currentIndexDelay = 0f; currentIndexLocalPercent = (timePassedSinceCurrentIndexWithDelay - _delayBetweenMoves) / _singleRotationTimeWithoutDelay; _nextRotationIndex = (currentIndex + 1) % _rotationPositions.Length; endRot = _rotationWays[_nextRotationIndex]; } transform.rotation = Quaternion.Euler(Vector3.Lerp(_rotationWays[currentIndex], endRot, currentIndexLocalPercent)); Debug.Log($\"[Movable.Init] {gameObject.name} - {transform.rotation} currentIndexDelay {currentIndexDelay}; currentIndexLocalPercent{currentIndexLocalPercent}; currentRotationStartIndex: {currentIndex}, currentRotationLocalPercent: {currentIndexLocalPercent}, endRot: {endRot}, milisecondsPassedSinceStart {timeMilisecondsPassedSinceStart}\", gameObject);  ",
          "content_tokens": 1120,
          "embedding": []
        },
        {
          "cs_scriptfile": "Movable",
          "content": "Launch(currentIndexDelay, endRot); yield return null;  protected void SetupRotationOneWay(int len) { _rotationWays = new Vector3[len]; _rotationWays[0] = transform.rotation.eulerAngles; for (int i = 0; i < _rotationPositions.Length; i++) { _rotationWays[i + 1] = _rotationPositions[i]; } } protected virtual void Launch(float delay, Vector3 endRot) { LaunchMove(); LaunchDOTRotation(delay, endRot);  ",
          "content_tokens": 129,
          "embedding": []
        },
        {
          "cs_scriptfile": "Movable",
          "content": "protected void LaunchDOTRotation(float delay, Vector3 endRot) { Debug.Log($\"[Movable.LaunchDOTRotation] {gameObject.name} current: {_nextRotationIndex-1}; delay: {delay}; {transform.rotation}=>{endRot}\"); if (IsNeedToRotate) { //freeze axes that is 0f in endRot transform.DORotateQuaternion(Quaternion.Euler(endRot), _singleRotationTimeWithoutDelay) .SetEase(_easeTypeDOT) .SetDelay(delay) .OnUpdate(() => { }) .OnComplete(() => { _nextRotationIndex = (_nextRotationIndex + 1) % _rotationWays.Length; if (!_isCircularRotation) { if (_nextRotationIndex == _rotationWays.Length - 1) { _nextRotationIndex = 0; } } Vector3 endRot = _rotationWays[_nextRotationIndex]; LaunchDOTRotation(_delayBetweenMoves, endRot); }); } } // private void LaunchRotation() // { // if (IsNeedToRotate) // { // float currentSumRotationsXYZ = Mathf.Abs(_isForwardRotate ? _endRotation.x : _startRotation.x - _rotationPositions.x) // + Mathf.Abs(_isForwardRotate ? _endRotation.y : _startRotation.y - _rotationPositions.y) // + Mathf.Abs(_isForwardRotate ? _endRotation.z : _startRotation.z - _rotationPositions.z); // Debug.Log($\"[Movable.LaunchRotation] {gameObject} currentSumRotationsXYZ / _sumRotationsXYZ: {currentSumRotationsXYZ / _sumRotationsXYZ}\"); // iTween.ValueTo(gameObject, iTween.Hash( // \"from\", _rotationPositions, // \"to\", _isForwardRotate ? _endRotation : _startRotation, // \"time\", _timeToRotateFullOneWay * (currentSumRotationsXYZ / _sumRotationsXYZ), // \"onupdate\", \"UpdateRotationValue\", // \"oncomplete\", \"OnCompleteRotation\", // \"easetype\", _easeType // )); // } // } // // protected void UpdateRotationValue(Vector3 value) { // _rotationPositions[_nextRotationIndex] = value; // transform.rotation = Quaternion.Euler(value); // } // // protected void OnCompleteRotation() { // if (_isCircularRotation) // { // _nextRotationIndex = (_nextRotationIndex + 1) % _rotationPositions.Length; // } // else // { // if (_nextRotationIndex == 0 || _nextRotationIndex == _rotationPositions.Length - 1) // { // _isForwardRotate = !_isForwardRotate; // } // _nextRotationIndex += _isForwardRotate ? 1 : -1; // } // // LaunchRotation(); // } protected virtual void LaunchMove() { if (IsNeedToMove) { iTween.ValueTo(gameObject, iTween.Hash( \"from\", _pathPosition, \"to\", 1f, \"time\", _timeToFinishOneWay * (1 - _pathPosition), \"onupdate\", \"UpdatePathPosition\", \"oncomplete\", \"OnCompletePath\", \"easetype\", _easeType )); } } protected virtual void UpdatePathPosition(float value) { _pathPosition = value; iTween.PutOnPath(gameObject, _isForwardMove ? _forwardPath : _backwardPath, _pathPosition); } protected virtual void OnCompletePath() { _isForwardMove = !_isForwardMove; _pathPosition = 0f; LaunchMove();  ",
          "content_tokens": 863,
          "embedding": []
        },
        {
          "cs_scriptfile": "Movable",
          "content": "protected void OnDrawGizmos() { if (!Application.isPlaying) { iTween.DrawPath(_positionPoint, Color.green); } } }",
          "content_tokens": 33,
          "embedding": []
        }
      ],
      "length": 8931
    },
    {
      "filename": "MovableNetworked",
      "content": "using System; using System.Collections; using DG.Tweening; using FishNet.Object; using FishNet.Object.Synchronizing; using FishNet.Observing; using NGS.AdvancedCullingSystem.Dynamic; using UnityEngine; [RequireComponent(typeof(NetworkObserver))] public class MovableNetworked : NetworkBehaviour { [SyncVar(OnChange = nameof(_worldPos_OnChange))] private Vector3 _worldPos; [SyncVar(OnChange = nameof(_pos_OnChange))] private Vector3 _pos; [SyncVar(OnChange = nameof(_rot_OnChange))] private Vector3 _rot; [SyncVar] protected float _speed = 0f; [SyncVar] protected float _delay; [SerializeField] private GameObjectDispatcher[] _visuals; [SerializeField] private Transform _triggeringTransform; private bool _isRotInitialized = false; [SerializeField] protected iTween.EaseType _easeType = iTween.EaseType.easeInOutQuint; [SerializeField] protected Ease _easeTypeDOT = Ease.InOutQuint; [SerializeField] protected MeshRenderer[] _meshRenderers; protected void OnValidate() { if (_meshRenderers ==null || _meshRenderers.Length == 0) { _meshRenderers = GetComponentsInChildren<MeshRenderer>(); } } #region Movement [SerializeField] protected Transform[] _positionPoint; protected Vector3[] _forwardPath; protected int _nextPositionIndex = 1; protected float _timeToFinishFullCycle; [SyncVar] protected float _timeToFinishSingleMove; public bool IsNeedToMove => _positionPoint.Length > 0; #endregion #region Rotation protected float _timeToRotateFullOneWay; [SerializeField] protected Vector3[] _rotationPositions; // Now an array protected Vector3[] _rotationWays; // Now an array protected float _singleRotationTimeWithDelay; [SyncVar] protected float _singleRotationTimeWithoutDelay; [SerializeField] protected bool _isCircularRotation = false; // Added protected int _nextRotationIndex = 1; // Added public bool IsNeedToRotate => _rotationPositions.Length > 0; #endregion [SerializeField] protected bool _isCustomDelay = false; [SerializeField] protected float _predefinedDelay = 0f; [Server] public void CorrectNetPosition(Vector3 newPos) { Debug.Log($\"[MovableNetworked] CorrectNetPosition on {gameObject.name} to {newPos}\", gameObject); _worldPos = newPos; } public override void OnStartNetwork() { base.OnStartNetwork(); gameObject.name = $\"{gameObject.name.Substring(0, gameObject.name.Length - 7)} #{base.ObjectId}\"; } public override void OnStopNetwork() { base.OnStopNetwork(); //Debug.Log($\"[MovableNetworked] OnStopNetwork on {gameObject.name}\", gameObject); } public override void OnStartClient() { base.OnStartClient(); for (int i = 0; i < _meshRenderers.Length; i++) { DC_Controller.Instance.AddObjectForCulling(_meshRenderers[i]); } } private void OnDestroy() { //Debug.Log($\"[MovableNetworked] OnDestroy on {gameObject.name}\", gameObject); } private void OnDisable() { //Debug.Log($\"[MovableNetworked] OnDisable on {gameObject.name}\", gameObject); } [Server] public void Launch() { //Debug.Log($\"[MovableNetworked] Launch on {gameObject.name}\", gameObject); if (!IsHost) { for (int i = 0; i < _visuals.Length; i++) { _visuals[i].Deactivate(); } } if (IsNeedToRotate) StartCoroutine(StartServerRotation()); if (IsNeedToMove) StartCoroutine(StartServerMoving()); } private IEnumerator StartServerRotation() { WaitForSeconds _delay = new WaitForSeconds(this._delay); WaitForSeconds _timeToRotate = new WaitForSeconds(_singleRotationTimeWithoutDelay); while (true) { yield return _delay; yield return _timeToRotate; _rot = _rotationWays[_nextRotationIndex]; _nextRotationIndex = (_nextRotationIndex + 1) % _rotationWays.Length; } } private IEnumerator StartServerMoving() { WaitForSeconds _delay = new WaitForSeconds(this._delay); WaitForSeconds _timeToSingleMove = new WaitForSeconds(_singleRotationTimeWithoutDelay); while (true) { yield return _delay; yield return _timeToSingleMove; _pos = _forwardPath[_nextPositionIndex]; _nextPositionIndex = (_nextPositionIndex + 1) % _forwardPath.Length; } } /// <summary> /// Called for client when he enters room, called for server Onstartnetwork when need to launch the movement /// </summary> /// <param name=\"milisecondsPassedSinceStart\">To synchronize position state of moving platform</param> /// <param name=\"speed\">Movement speed of platform</param> public virtual void InitParameters(float speed, int delayBetweenMoves = 0) { StartCoroutine(CalcParameters(speed, delayBetweenMoves)); } private IEnumerator CalcParameters(float speed, int delayBetweenMoves) { if (_speed < Mathf.Epsilon) _speed = speed; if (_isCustomDelay) { _delay = _predefinedDelay; } else { _delay = delayBetweenMoves; } if (IsNeedToMove) { _forwardPath = new Vector3[_positionPoint.Length * 2 + 1]; _forwardPath[0] = _triggeringTransform.position; _forwardPath[_positionPoint.Length * 2] = _forwardPath[0]; //0,1,2,1,0 //1,2,3,4,5 for (int i = 0; i < _positionPoint.Length; i++) { _forwardPath[i + 1] = _positionPoint[i].position; } for (int i = 0; i < _positionPoint.Length - 1; i++) { _forwardPath[_positionPoint.Length + 1 + i] = _positionPoint[_positionPoint.Length - 2 - i].position; } for (int i = 0; i < _positionPoint.Length; i++) { Destroy(_positionPoint[i].gameObject); } //calculate total time to finish the path float totalPathCalculated = 0; for (int i = 0; i < _forwardPath.Length - 1; i++) { totalPathCalculated += Vector3.Distance(_forwardPath[i], _forwardPath[i + 1]); } _timeToFinishFullCycle = totalPathCalculated / _speed; _timeToFinishSingleMove = _timeToFinishFullCycle / _forwardPath.Length; } if (IsNeedToRotate) { if (_isCircularRotation) { SetupRotationOneWay(_rotationPositions.Length + 1); _timeToRotateFullOneWay = (_delay * _rotationWays.Length) + 1f / _speed; } else { SetupRotationOneWay(_rotationPositions.Length * 2 + 1); for (int i = 0; i < _rotationPositions.Length - 1; i++) { _rotationWays[_rotationPositions.Length + 1 + i] = _rotationPositions[_rotationPositions.Length - 2 - i]; } _rotationWays[_rotationPositions.Length * 2] = _rotationWays[0]; _timeToRotateFullOneWay = (_delay * _rotationWays.Length) + 2f / _speed; } _singleRotationTimeWithDelay = _timeToRotateFullOneWay / _rotationWays.Length; _singleRotationTimeWithoutDelay = _singleRotationTimeWithDelay - _delay; } yield return null; } protected void SetupRotationOneWay(int len) { _rotationWays = new Vector3[len]; _rotationWays[0] = _triggeringTransform.localRotation.eulerAngles; for (int i = 0; i < _rotationPositions.Length; i++) { _rotationWays[i + 1] = _rotationPositions[i]; } } [Client] protected void LaunchDOTRotation(Quaternion endRot) { //Debug.Log($\"[Movable.LaunchDOTRotation] {gameObject.name} current: {_nextRotationIndex-1}; {_triggeringTransform.rotation}=>{endRot}\"); if (IsNeedToRotate) { //freeze axes that is 0f in endRot _triggeringTransform.DORotateQuaternion(endRot, _singleRotationTimeWithoutDelay).SetEase(_easeTypeDOT); } } [Client] protected void LaunchDOTMove(Vector3 endPos) { if (IsNeedToMove) { _triggeringTransform.DOMove(endPos, _timeToFinishSingleMove).SetEase(_easeTypeDOT); } } private void _rot_OnChange(Vector3 oldValue, Vector3 newValue, bool asServer) { if (asServer) return; if (!_isRotInitialized) { _triggeringTransform.rotation = Quaternion.Euler(newValue); _isRotInitialized = true; } else { LaunchDOTRotation(Quaternion.Euler(newValue)); } } private void _pos_OnChange(Vector3 oldValue, Vector3 newValue, bool asServer) { if (asServer) return; if (!_isRotInitialized) { _triggeringTransform.position = newValue; _isRotInitialized = true; } else { LaunchDOTMove(newValue); } } private void _worldPos_OnChange(Vector3 oldValue, Vector3 newValue, bool asServer) { if (asServer) return; transform.position = newValue; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MovableNetworked",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "MovableNetworked",
          "content": "using System; using System.Collections; using DG.Tweening; using FishNet.Object; using FishNet.Object.Synchronizing; using FishNet.Observing; using NGS.AdvancedCullingSystem.Dynamic; using UnityEngine; [RequireComponent(typeof(NetworkObserver))] public class MovableNetworked : NetworkBehaviour { [SyncVar(OnChange = nameof(_worldPos_OnChange))] private Vector3 _worldPos; [SyncVar(OnChange = nameof(_pos_OnChange))] private Vector3 _pos; [SyncVar(OnChange = nameof(_rot_OnChange))] private Vector3 _rot; [SyncVar] protected float _speed = 0f; [SyncVar] protected float _delay; [SerializeField] private GameObjectDispatcher[] _visuals; [SerializeField] private Transform _triggeringTransform; private bool _isRotInitialized = false; [SerializeField] protected iTween.EaseType _easeType = iTween.EaseType.easeInOutQuint; [SerializeField] protected Ease _easeTypeDOT = Ease.InOutQuint; [SerializeField] protected MeshRenderer[] _meshRenderers; protected void OnValidate() { if (_meshRenderers ==null || _meshRenderers.Length == 0) { _meshRenderers = GetComponentsInChildren<MeshRenderer>(); } } #region Movement [SerializeField] protected Transform[] _positionPoint; protected Vector3[] _forwardPath; protected int _nextPositionIndex = 1; protected float _timeToFinishFullCycle; [SyncVar] protected float _timeToFinishSingleMove; public bool IsNeedToMove => _positionPoint.Length > 0; #endregion #region Rotation protected float _timeToRotateFullOneWay; [SerializeField] protected Vector3[] _rotationPositions; // Now an array protected Vector3[] _rotationWays; // Now an array protected float _singleRotationTimeWithDelay; [SyncVar] protected float _singleRotationTimeWithoutDelay; [SerializeField] protected bool _isCircularRotation = false; // Added protected int _nextRotationIndex = 1; // Added public bool IsNeedToRotate => _rotationPositions.Length > 0; #endregion [SerializeField] protected bool _isCustomDelay = false; [SerializeField] protected float _predefinedDelay = 0f; [Server] public void CorrectNetPosition(Vector3 newPos) { Debug.Log($\"[MovableNetworked] CorrectNetPosition on {gameObject.name} to {newPos}\", gameObject); _worldPos = newPos; } public override void OnStartNetwork() { base.OnStartNetwork(); gameObject.name = $\"{gameObject.name.Substring(0, gameObject.name.Length - 7)} #{base.ObjectId}\"; } public override void OnStopNetwork() { base.OnStopNetwork(); //Debug.Log($\"[MovableNetworked] OnStopNetwork on {gameObject.name}\", gameObject); } public override void OnStartClient() { base.OnStartClient(); for (int i = 0; i < _meshRenderers.Length; i++) { DC_Controller.Instance.AddObjectForCulling(_meshRenderers[i]); }  ",
          "content_tokens": 757,
          "embedding": []
        },
        {
          "cs_scriptfile": "MovableNetworked",
          "content": "private void OnDestroy() { //Debug.Log($\"[MovableNetworked] OnDestroy on {gameObject.name}\", gameObject);  private void OnDisable() { //Debug.Log($\"[MovableNetworked] OnDisable on {gameObject.name}\", gameObject); } [Server] public void Launch() { //Debug.Log($\"[MovableNetworked] Launch on {gameObject.name}\", gameObject); if (!IsHost) { for (int i = 0; i < _visuals.Length; i++) { _visuals[i].Deactivate(); }  ",
          "content_tokens": 129,
          "embedding": []
        },
        {
          "cs_scriptfile": "MovableNetworked",
          "content": "if (IsNeedToRotate) StartCoroutine(StartServerRotation()); if (IsNeedToMove) StartCoroutine(StartServerMoving()); } private IEnumerator StartServerRotation() { WaitForSeconds _delay = new WaitForSeconds(this._delay); WaitForSeconds _timeToRotate = new WaitForSeconds(_singleRotationTimeWithoutDelay); while (true) { yield return _delay; yield return _timeToRotate; _rot = _rotationWays[_nextRotationIndex]; _nextRotationIndex = (_nextRotationIndex + 1) % _rotationWays.Length; } } private IEnumerator StartServerMoving() { WaitForSeconds _delay = new WaitForSeconds(this._delay); WaitForSeconds _timeToSingleMove = new WaitForSeconds(_singleRotationTimeWithoutDelay); while (true) { yield return _delay; yield return _timeToSingleMove; _pos = _forwardPath[_nextPositionIndex]; _nextPositionIndex = (_nextPositionIndex + 1) % _forwardPath.Length; } } /// <summary> /// Called for client when he enters room, called for server Onstartnetwork when need to launch the movement /// </summary> /// <param name=\"milisecondsPassedSinceStart\">To synchronize position state of moving platform</param> /// <param name=\"speed\">Movement speed of platform</param> public virtual void InitParameters(float speed, int delayBetweenMoves = 0) { StartCoroutine(CalcParameters(speed, delayBetweenMoves)); } private IEnumerator CalcParameters(float speed, int delayBetweenMoves) { if (_speed < Mathf.Epsilon) _speed = speed; if (_isCustomDelay) { _delay = _predefinedDelay; } else { _delay = delayBetweenMoves;  ",
          "content_tokens": 410,
          "embedding": []
        },
        {
          "cs_scriptfile": "MovableNetworked",
          "content": "if (IsNeedToMove) { _forwardPath = new Vector3[_positionPoint.Length * 2 + 1]; _forwardPath[0] = _triggeringTransform.position; _forwardPath[_positionPoint.Length * 2] = _forwardPath[0]; //0,1,2,1,0 //1,2,3,4,5 for (int i = 0; i < _positionPoint.Length; i++) { _forwardPath[i + 1] = _positionPoint[i].position;  for (int i = 0; i < _positionPoint.Length - 1; i++) { _forwardPath[_positionPoint.Length + 1 + i] = _positionPoint[_positionPoint.Length - 2 - i].position;  ",
          "content_tokens": 164,
          "embedding": []
        },
        {
          "cs_scriptfile": "MovableNetworked",
          "content": "for (int i = 0; i < _positionPoint.Length; i++) { Destroy(_positionPoint[i].gameObject); } //calculate total time to finish the path float totalPathCalculated = 0; for (int i = 0; i < _forwardPath.Length - 1; i++) { totalPathCalculated += Vector3.Distance(_forwardPath[i], _forwardPath[i + 1]); } _timeToFinishFullCycle = totalPathCalculated / _speed; _timeToFinishSingleMove = _timeToFinishFullCycle / _forwardPath.Length;  ",
          "content_tokens": 130,
          "embedding": []
        },
        {
          "cs_scriptfile": "MovableNetworked",
          "content": "if (IsNeedToRotate) { if (_isCircularRotation) { SetupRotationOneWay(_rotationPositions.Length + 1); _timeToRotateFullOneWay = (_delay * _rotationWays.Length) + 1f / _speed; } else { SetupRotationOneWay(_rotationPositions.Length * 2 + 1); for (int i = 0; i < _rotationPositions.Length - 1; i++) { _rotationWays[_rotationPositions.Length + 1 + i] = _rotationPositions[_rotationPositions.Length - 2 - i]; } _rotationWays[_rotationPositions.Length * 2] = _rotationWays[0]; _timeToRotateFullOneWay = (_delay * _rotationWays.Length) + 2f / _speed; } _singleRotationTimeWithDelay = _timeToRotateFullOneWay / _rotationWays.Length; _singleRotationTimeWithoutDelay = _singleRotationTimeWithDelay - _delay; } yield return null;  ",
          "content_tokens": 244,
          "embedding": []
        },
        {
          "cs_scriptfile": "MovableNetworked",
          "content": "protected void SetupRotationOneWay(int len) { _rotationWays = new Vector3[len]; _rotationWays[0] = _triggeringTransform.localRotation.eulerAngles; for (int i = 0; i < _rotationPositions.Length; i++) { _rotationWays[i + 1] = _rotationPositions[i]; } } [Client] protected void LaunchDOTRotation(Quaternion endRot) { //Debug.Log($\"[Movable.LaunchDOTRotation] {gameObject.name} current: {_nextRotationIndex-1}; {_triggeringTransform.rotation}=>{endRot}\"); if (IsNeedToRotate) { //freeze axes that is 0f in endRot _triggeringTransform.DORotateQuaternion(endRot, _singleRotationTimeWithoutDelay).SetEase(_easeTypeDOT); } } [Client] protected void LaunchDOTMove(Vector3 endPos) { if (IsNeedToMove) { _triggeringTransform.DOMove(endPos, _timeToFinishSingleMove).SetEase(_easeTypeDOT); }  ",
          "content_tokens": 265,
          "embedding": []
        },
        {
          "cs_scriptfile": "MovableNetworked",
          "content": "private void _rot_OnChange(Vector3 oldValue, Vector3 newValue, bool asServer) { if (asServer) return; if (!_isRotInitialized) { _triggeringTransform.rotation = Quaternion.Euler(newValue); _isRotInitialized = true; } else { LaunchDOTRotation(Quaternion.Euler(newValue)); }  private void _pos_OnChange(Vector3 oldValue, Vector3 newValue, bool asServer) { if (asServer) return; if (!_isRotInitialized) { _triggeringTransform.position = newValue; _isRotInitialized = true; } else { LaunchDOTMove(newValue); }  private void _worldPos_OnChange(Vector3 oldValue, Vector3 newValue, bool asServer) { if (asServer) return; transform.position = newValue; } }",
          "content_tokens": 192,
          "embedding": []
        }
      ],
      "length": 7600
    },
    {
      "filename": "MusicPlayer",
      "content": "using System; using System.Collections; using System.Collections.Generic; using FishNet.Object; using UnityEngine; using Random = UnityEngine.Random; public class MusicPlayer : NetworkBehaviour { [SerializeField] private List<AudioClip> _playlist = new List<AudioClip>(); [SerializeField] private List<AudioClip> _mainMenuPlaylist = new List<AudioClip>(); [SerializeField] private List<AudioClip> _successfullEscape = new List<AudioClip>(); private AudioSource audioSource; public static MusicPlayer Instance; private void Awake() { if (Instance == null) { Instance = this; audioSource = GetComponent<AudioSource>(); } } public override void OnStartClient() { base.OnStartClient(); PlayMainMenuMusic(); } public static void PlayInGameMusic() { Instance.StartCoroutine(Instance.PlayMusic(Instance._playlist)); } public static void PlayMainMenuMusic() { Instance.StartCoroutine(Instance.PlayMusic(Instance._mainMenuPlaylist)); } public static void PlaySuccessfullyEscapedMusic() { Instance.StartCoroutine(Instance.PlayMusic(Instance._successfullEscape)); } private List<AudioClip> ShufflePlaylist(List<AudioClip> playlist) { var shuffledPlaylist = new List<AudioClip>(playlist); for (int i = 0; i < shuffledPlaylist.Count; i++) { AudioClip temp = shuffledPlaylist[i]; int randomIndex = Random.Range(i, shuffledPlaylist.Count); shuffledPlaylist[i] = shuffledPlaylist[randomIndex]; shuffledPlaylist[randomIndex] = temp; } return shuffledPlaylist; } private IEnumerator PlayMusic(List<AudioClip> playList) { Debug.Log($\"Playing music from playlist\"); foreach (AudioClip clip in playList) { audioSource.clip = clip; audioSource.Play(); // Wait until the clip finishes playing before moving on to the next one yield return new WaitForSeconds(audioSource.clip.length); } // All clips have been played, reshuffle the playlist playList = ShufflePlaylist(playList); // Start the playlist over again StartCoroutine(PlayMusic(playList)); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MusicPlayer",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "MusicPlayer",
          "content": "using System; using System.Collections; using System.Collections.Generic; using FishNet.Object; using UnityEngine; using Random = UnityEngine.Random; public class MusicPlayer : NetworkBehaviour { [SerializeField] private List<AudioClip> _playlist = new List<AudioClip>(); [SerializeField] private List<AudioClip> _mainMenuPlaylist = new List<AudioClip>(); [SerializeField] private List<AudioClip> _successfullEscape = new List<AudioClip>(); private AudioSource audioSource; public static MusicPlayer Instance; private void Awake() { if (Instance == null) { Instance = this; audioSource = GetComponent<AudioSource>(); } } public override void OnStartClient() { base.OnStartClient(); PlayMainMenuMusic(); } public static void PlayInGameMusic() { Instance.StartCoroutine(Instance.PlayMusic(Instance._playlist)); } public static void PlayMainMenuMusic() { Instance.StartCoroutine(Instance.PlayMusic(Instance._mainMenuPlaylist)); } public static void PlaySuccessfullyEscapedMusic() { Instance.StartCoroutine(Instance.PlayMusic(Instance._successfullEscape)); } private List<AudioClip> ShufflePlaylist(List<AudioClip> playlist) { var shuffledPlaylist = new List<AudioClip>(playlist); for (int i = 0; i < shuffledPlaylist.Count; i++) { AudioClip temp = shuffledPlaylist[i]; int randomIndex = Random.Range(i, shuffledPlaylist.Count); shuffledPlaylist[i] = shuffledPlaylist[randomIndex]; shuffledPlaylist[randomIndex] = temp; } return shuffledPlaylist; } private IEnumerator PlayMusic(List<AudioClip> playList) { Debug.Log($\"Playing music from playlist\"); foreach (AudioClip clip in playList) { audioSource.clip = clip; audioSource.Play(); // Wait until the clip finishes playing before moving on to the next one yield return new WaitForSeconds(audioSource.clip.length); } // All clips have been played, reshuffle the playlist playList = ShufflePlaylist(playList); // Start the playlist over again StartCoroutine(PlayMusic(playList)); } }",
          "content_tokens": 512,
          "embedding": []
        }
      ],
      "length": 1928
    },
    {
      "filename": "OptimizeServerFromComponents",
      "content": "using System; using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using Unity.VisualScripting; using UnityEngine; public class OptimizeServerFromComponents : NetworkBehaviour { private NetworkObject[] FindAllNetworkObjectsInScene => FindObjectsOfType<NetworkObject>(); private GameplayManager gpm; private static string REMOVE_ON_SERVER_TAG = \"RmoveOnServer\"; private void Awake() { gpm = GetComponent<GameplayManager>(); } public void RemoveGameObjectsNotNeededForServer() { StartCoroutine(DelayedRemoveGOByTag()); } public void OptimizeLights() { StartCoroutine(LightsOptimizationCoroutine()); } private IEnumerator DelayedRemoveGOByTag() { var gos = GameObject.FindGameObjectsWithTag(REMOVE_ON_SERVER_TAG); for (int i = 0; i < gos.Length; i++) { Destroy(gos[i]); if (i % 5 == 0) yield return null; } Debug.Log($\"[OptimizeServerFromComponents] Removed {gos.Length} GOs with tag {REMOVE_ON_SERVER_TAG}\"); } private IEnumerator LightsOptimizationCoroutine() { int lightsDisabled = 0; var pointLightsToDisable = GameObject.FindGameObjectsWithTag(\"NetworkedLight\"); for (int j = 0; j < pointLightsToDisable.Length; j++) { pointLightsToDisable[j].SetActive(false); lightsDisabled++; } int lightsRemoved = 0; var allScenePointLights = GameObject.FindGameObjectsWithTag(\"ClientOnlyLight\"); for (int j = 0; j < allScenePointLights.Length; j++) { Destroy(allScenePointLights[j]); yield return null; lightsRemoved++; } float cpuSaved = (lightsRemoved) / 138f;//because 138 PointLights eats 1.0 ms time Debug.Log($\"[OptimizeServerFromComponents] disabled {lightsDisabled} lights; removed {lightsRemoved} lights; sum: {lightsDisabled + lightsRemoved}\"); Debug.Log($\"[OptimizeServerFromComponents] CPU saved: {cpuSaved}ms = FPS: {1f / cpuSaved}\"); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "OptimizeServerFromComponents",
          "content": "using System; using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using Unity.VisualScripting; using UnityEngine; public class OptimizeServerFromComponents : NetworkBehaviour { private NetworkObject[] FindAllNetworkObjectsInScene => FindObjectsOfType<NetworkObject>(); private GameplayManager gpm; private static string REMOVE_ON_SERVER_TAG = \"RmoveOnServer\"; private void Awake() { gpm = GetComponent<GameplayManager>();  public void RemoveGameObjectsNotNeededForServer() { StartCoroutine(DelayedRemoveGOByTag());  ",
          "content_tokens": 161,
          "embedding": []
        },
        {
          "cs_scriptfile": "OptimizeServerFromComponents",
          "content": "public void OptimizeLights() { StartCoroutine(LightsOptimizationCoroutine()); } private IEnumerator DelayedRemoveGOByTag() { var gos = GameObject.FindGameObjectsWithTag(REMOVE_ON_SERVER_TAG); for (int i = 0; i < gos.Length; i++) { Destroy(gos[i]); if (i % 5 == 0) yield return null; } Debug.Log($\"[OptimizeServerFromComponents] Removed {gos.Length} GOs with tag {REMOVE_ON_SERVER_TAG}\"); } private IEnumerator LightsOptimizationCoroutine() { int lightsDisabled = 0; var pointLightsToDisable = GameObject.FindGameObjectsWithTag(\"NetworkedLight\"); for (int j = 0; j < pointLightsToDisable.Length; j++) { pointLightsToDisable[j].SetActive(false); lightsDisabled++; } int lightsRemoved = 0; var allScenePointLights = GameObject.FindGameObjectsWithTag(\"ClientOnlyLight\"); for (int j = 0; j < allScenePointLights.Length; j++) { Destroy(allScenePointLights[j]); yield return null; lightsRemoved++; } float cpuSaved = (lightsRemoved) / 138f;//because 138 PointLights eats 1.0 ms time Debug.Log($\"[OptimizeServerFromComponents] disabled {lightsDisabled} lights; removed {lightsRemoved} lights; sum: {lightsDisabled + lightsRemoved}\"); Debug.Log($\"[OptimizeServerFromComponents] CPU saved: {cpuSaved}ms = FPS: {1f / cpuSaved}\"); } }",
          "content_tokens": 375,
          "embedding": []
        }
      ],
      "length": 1827
    },
    {
      "filename": "PhysicsSimulator",
      "content": "using FishNet; using FishNet.Managing.Timing; using UnityEngine; namespace My{ public class PhysicsSimulator : MonoBehaviour { /// <summary> /// PhysicsScene this object is in. Required for scene stacking. /// </summary> public PhysicsScene PhysicsScene => _physicsScene; private PhysicsScene _physicsScene; private float _stepTime; private bool _isInitialized = false; private TimeManager _tm; public void Init() { //Physics.autoSimulation = false; _tm = InstanceFinder.TimeManager; _tm.OnPrePhysicsSimulation += TimeManager_OnPhysicsSimulation; _physicsScene = gameObject.scene.GetPhysicsScene(); Physics.autoSimulation = false; } private void OnDestroy() { if (_tm != null) _tm.OnPrePhysicsSimulation -= TimeManager_OnPhysicsSimulation; } // private void Update() // { // if (!_isInitialized) // return; // // float fixedDeltaTime = Time.fixedDeltaTime; // _stepTime += Time.deltaTime; // while (_stepTime >= fixedDeltaTime) // { // _stepTime -= fixedDeltaTime; // _physicsScene.Simulate(fixedDeltaTime); // } // } private void TimeManager_OnPhysicsSimulation(float delta) { if (InstanceFinder.IsServer) _physicsScene.Simulate(delta); } // private void OnDisable() { // if (base.IsServer) // InstanceFinder.TimeManager.OnPrePhysicsSimulation -= TimeManager_OnPhysicsSimulation; // } // // private void TimeManager_OnPhysicsSimulation(float delta) // { // _physicsScene.Simulate(delta); // } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PhysicsSimulator",
          "content": "using FishNet; using FishNet.Managing.Timing; using UnityEngine; namespace My{ public class PhysicsSimulator : MonoBehaviour { /// <summary> /// PhysicsScene this object is in. Required for scene stacking. /// </summary> public PhysicsScene PhysicsScene => _physicsScene; private PhysicsScene _physicsScene; private float _stepTime; private bool _isInitialized = false; private TimeManager _tm; public void Init() { //Physics.autoSimulation = false; _tm = InstanceFinder.TimeManager; _tm.OnPrePhysicsSimulation += TimeManager_OnPhysicsSimulation; _physicsScene = gameObject.scene.GetPhysicsScene(); Physics.autoSimulation = false;  ",
          "content_tokens": 161,
          "embedding": []
        },
        {
          "cs_scriptfile": "PhysicsSimulator",
          "content": "private void OnDestroy() { if (_tm != null) _tm.OnPrePhysicsSimulation -= TimeManager_OnPhysicsSimulation; } // private void Update() // { // if (!_isInitialized) // return; // // float fixedDeltaTime = Time.fixedDeltaTime; // _stepTime += Time.deltaTime; // while (_stepTime >= fixedDeltaTime) // { // _stepTime -= fixedDeltaTime; // _physicsScene.Simulate(fixedDeltaTime); // } //  ",
          "content_tokens": 112,
          "embedding": []
        },
        {
          "cs_scriptfile": "PhysicsSimulator",
          "content": "private void TimeManager_OnPhysicsSimulation(float delta) { if (InstanceFinder.IsServer) _physicsScene.Simulate(delta); } // private void OnDisable() { // if (base.IsServer) // InstanceFinder.TimeManager.OnPrePhysicsSimulation -= TimeManager_OnPhysicsSimulation; // } // // private void TimeManager_OnPhysicsSimulation(float delta) // { // _physicsScene.Simulate(delta); // } } }",
          "content_tokens": 112,
          "embedding": []
        }
      ],
      "length": 1397
    },
    {
      "filename": "PuzzleController",
      "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; public class PuzzleController : MonoBehaviour { [SerializeField] private bool _isAutoLaunch; [SerializeField] private Movable[] _puzzleMovable; [SerializeField] private RoomEnterTriggerDetector _roomEnterTriggerDetector; private System.Random _random; #if UNITY_EDITOR public void SetupRoomEnterTriggerDetector(RoomEnterTriggerDetector roomEnterTriggerDetector) { _roomEnterTriggerDetector = roomEnterTriggerDetector; } #endif public void AssignPuzzleMovablesIfNeed() { var currentPuzzleMovable = GetComponentsInChildren<Movable>(); if (currentPuzzleMovable.Length != _puzzleMovable.Length) { Debug.Log(\"PuzzleController: AssignPuzzleMovables: currentPuzzleMovable.Length != puzzleMovable.Length\"); //find all PuzzleMovable inside his parent _puzzleMovable = transform.parent.GetComponentsInChildren<Movable>(); } } private void Awake() { Debug.Log($\"[PuzzleController] Awake on {gameObject}\"); if (!_isAutoLaunch) _roomEnterTriggerDetector.OnLocalPlayerEnter += OnLocalPlayerEnter; } private void OnLocalPlayerEnter() { SetupRandomIfNeed(); Launch(); } private void SetupRandomIfNeed() { _random ??= new System.Random(GameplayManager.Instance.Seed); } void Start() { if (_isAutoLaunch) { _random = new System.Random(); Launch(); } } private void Launch() { Debug.Log($\"[PuzzleController] Launch on {gameObject}\", gameObject); AssignPuzzleMovablesIfNeed();//somehow assigned from editor dont work for (int i = 0; i < _puzzleMovable.Length; i++) { //speed should be between .03f and .1f: float speed = (float)_random.NextDouble() * (.1f - .03f) + .03f; int delay = _random.Next(2, 10); float milSecondsPassedAfterStart = Time.time - GameplayManager.Instance.RoomStartTime; if (_isAutoLaunch) milSecondsPassedAfterStart = 1f; _puzzleMovable[i].Init(milSecondsPassedAfterStart, speed, delay); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PuzzleController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "PuzzleController",
          "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; public class PuzzleController : MonoBehaviour { [SerializeField] private bool _isAutoLaunch; [SerializeField] private Movable[] _puzzleMovable; [SerializeField] private RoomEnterTriggerDetector _roomEnterTriggerDetector; private System.Random _random; #if UNITY_EDITOR public void SetupRoomEnterTriggerDetector(RoomEnterTriggerDetector roomEnterTriggerDetector) { _roomEnterTriggerDetector = roomEnterTriggerDetector; } #endif public void AssignPuzzleMovablesIfNeed() { var currentPuzzleMovable = GetComponentsInChildren<Movable>(); if (currentPuzzleMovable.Length != _puzzleMovable.Length) { Debug.Log(\"PuzzleController: AssignPuzzleMovables: currentPuzzleMovable.Length != puzzleMovable.Length\"); //find all PuzzleMovable inside his parent _puzzleMovable = transform.parent.GetComponentsInChildren<Movable>(); }  ",
          "content_tokens": 250,
          "embedding": []
        },
        {
          "cs_scriptfile": "PuzzleController",
          "content": "private void Awake() { Debug.Log($\"[PuzzleController] Awake on {gameObject}\"); if (!_isAutoLaunch) _roomEnterTriggerDetector.OnLocalPlayerEnter += OnLocalPlayerEnter;  private void OnLocalPlayerEnter() { SetupRandomIfNeed(); Launch();  private void SetupRandomIfNeed() { _random ??= new System.Random(GameplayManager.Instance.Seed);  void Start() { if (_isAutoLaunch) { _random = new System.Random(); Launch(); }  ",
          "content_tokens": 114,
          "embedding": []
        },
        {
          "cs_scriptfile": "PuzzleController",
          "content": "private void Launch() { Debug.Log($\"[PuzzleController] Launch on {gameObject}\", gameObject); AssignPuzzleMovablesIfNeed();//somehow assigned from editor dont work for (int i = 0; i < _puzzleMovable.Length; i++) { //speed should be between .03f and .1f: float speed = (float)_random.NextDouble() * (.1f - .03f) + .03f; int delay = _random.Next(2, 10); float milSecondsPassedAfterStart = Time.time - GameplayManager.Instance.RoomStartTime; if (_isAutoLaunch) milSecondsPassedAfterStart = 1f; _puzzleMovable[i].Init(milSecondsPassedAfterStart, speed, delay); } } }",
          "content_tokens": 178,
          "embedding": []
        }
      ],
      "length": 1905
    },
    {
      "filename": "PuzzleControllerNetworked",
      "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Object; using InRoomSystems; using UnityEngine; public class PuzzleControllerNetworked : MonoBehaviour { [SerializeField] private bool _isAutoLaunch; private MovableNetworked[] _puzzleMovable = new MovableNetworked[0]; private System.Random _random; private bool _isParametersInitialized; private IEnumerator AssignPuzzleMovablesIfNeed() { yield return new WaitUntil(() => ObjectsRoomManager.Instance.IsObjectsSpawned); Debug.Log($\"[PuzzleController] AssignPuzzleMovablesIfNeed on {gameObject.name}\", gameObject); var movables = GameObject.FindGameObjectsWithTag(\"MovableNetworked\"); _puzzleMovable = new MovableNetworked[movables.Length]; for (int i = 0; i < movables.Length; i++) { _puzzleMovable[i] = movables[i].GetComponent<MovableNetworked>(); } } void Start() { if (_isAutoLaunch) { _random = new System.Random(); InitParameters(); } else { if (InstanceFinder.NetworkManager.IsServer) { Debug.Log($\"[PuzzleController] IsServer Launch on {gameObject}\", gameObject); StartCoroutine(SetupRandom()); StartCoroutine(AssignPuzzleMovablesIfNeed()); StartCoroutine(InitParameters()); StartCoroutine(LaunchAll()); } } } private IEnumerator SetupRandom() { yield return new WaitUntil(() => GameplayManager.Instance != null); _random ??= new System.Random(GameplayManager.Instance.Seed); } private IEnumerator InitParameters() { yield return new WaitUntil(() => _puzzleMovable.Length > 0); yield return new WaitUntil(() => _random != null); for (int i = 0; i < _puzzleMovable.Length; i++) { //speed should be between .03f and .1f: float speed = (float)_random.NextDouble() * (.1f - .03f) + .03f; int delay = _random.Next(2, 10); //Debug.Log($\"[PuzzleController] InitParameters on {_puzzleMovable[i].name}\", _puzzleMovable[i]); _puzzleMovable[i].InitParameters(speed, delay); } _isParametersInitialized = true; } [Server] private IEnumerator LaunchAll() { yield return new WaitUntil(() => _isParametersInitialized); for (int i = 0; i < _puzzleMovable.Length; i++) { _puzzleMovable[i].Launch(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PuzzleControllerNetworked",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "PuzzleControllerNetworked",
          "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Object; using InRoomSystems; using UnityEngine; public class PuzzleControllerNetworked : MonoBehaviour { [SerializeField] private bool _isAutoLaunch; private MovableNetworked[] _puzzleMovable = new MovableNetworked[0]; private System.Random _random; private bool _isParametersInitialized; private IEnumerator AssignPuzzleMovablesIfNeed() { yield return new WaitUntil(() => ObjectsRoomManager.Instance.IsObjectsSpawned); Debug.Log($\"[PuzzleController] AssignPuzzleMovablesIfNeed on {gameObject.name}\", gameObject); var movables = GameObject.FindGameObjectsWithTag(\"MovableNetworked\"); _puzzleMovable = new MovableNetworked[movables.Length]; for (int i = 0; i < movables.Length; i++) { _puzzleMovable[i] = movables[i].GetComponent<MovableNetworked>(); }  ",
          "content_tokens": 258,
          "embedding": []
        },
        {
          "cs_scriptfile": "PuzzleControllerNetworked",
          "content": "void Start() { if (_isAutoLaunch) { _random = new System.Random(); InitParameters(); } else { if (InstanceFinder.NetworkManager.IsServer) { Debug.Log($\"[PuzzleController] IsServer Launch on {gameObject}\", gameObject); StartCoroutine(SetupRandom()); StartCoroutine(AssignPuzzleMovablesIfNeed()); StartCoroutine(InitParameters()); StartCoroutine(LaunchAll()); } } } private IEnumerator SetupRandom() { yield return new WaitUntil(() => GameplayManager.Instance != null); _random ??= new System.Random(GameplayManager.Instance.Seed); } private IEnumerator InitParameters() { yield return new WaitUntil(() => _puzzleMovable.Length > 0); yield return new WaitUntil(() => _random != null); for (int i = 0; i < _puzzleMovable.Length; i++) { //speed should be between .03f and .1f: float speed = (float)_random.NextDouble() * (.1f - .03f) + .03f; int delay = _random.Next(2, 10); //Debug.Log($\"[PuzzleController] InitParameters on {_puzzleMovable[i].name}\", _puzzleMovable[i]); _puzzleMovable[i].InitParameters(speed, delay); } _isParametersInitialized = true; } [Server] private IEnumerator LaunchAll() { yield return new WaitUntil(() => _isParametersInitialized); for (int i = 0; i < _puzzleMovable.Length; i++) { _puzzleMovable[i].Launch(); } } }",
          "content_tokens": 366,
          "embedding": []
        }
      ],
      "length": 2139
    },
    {
      "filename": "PuzzleMovable",
      "content": "using UnityEngine; public class PuzzleMovable : Movable { } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PuzzleMovable",
          "content": "using UnityEngine; public class PuzzleMovable : Movable { }",
          "content_tokens": 14,
          "embedding": []
        }
      ],
      "length": 60
    },
    {
      "filename": "RewardAbilityManager",
      "content": "using System; using System.Collections; using System.Collections.Generic; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Clients; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Connection; using FishNet.Object; using UnityEngine; public class RewardAbilityManager : RoomManager { [SerializeField] private AbilityChoosingMenu _abilityChoosingMenu; [SerializeField] private AbilityDefinitionHolder _abilityDefinitionHolder; public static Action<byte> OnAbilityRewardSelected; public static RewardAbilityManager LocalPlayer { get; private set; } public static RewardAbilityManager Instance { get; private set; } public static Action OnRewardAbilityWindowOpened; private static readonly int MAX_ABILITIES_COUNT_TO_CHOOSE = 3; private static readonly int MAX_ACTIVE_ABILITIES_PLAYER_CAN_HAVE = 6; private static readonly int MAX_PASSIVE_ABILITIES_PLAYER_CAN_HAVE = 6; private static readonly int MAX_ABILITIES_PLAYER_CAN_HAVE = 4; private readonly byte[] _itemAbilitiesToExclude = new byte[] { 12 }; public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); private string _className; #region Server only fields. public Dictionary<int, int> PlayerAbilityPointsServerOnly => _playerAbilityPointsServerOnly; private Dictionary<int, int> _playerAbilityPointsServerOnly = new Dictionary<int, int>(); public Action<int, int> OnPlayerLearnedAbility_ServerOnly; #endregion public Dictionary<NetworkConnection, List<AbilityInfo>> PlayerLearnedAbilities => _playerLearnedAbilities; private Dictionary<NetworkConnection, List<AbilityInfo>> _playerLearnedAbilities = new Dictionary<NetworkConnection, List<AbilityInfo>>(); private bool _isDebug = true; private void Awake() { if (Instance != null) { Debug.LogWarning($\"{ClassAndRoomName} There is more than one instance of RewardAbilityManager in the scene.\"); return; } Instance = this; } public override void OnStartServer() { base.OnStartServer(); GameplayManager.Instance.OnPlayerHeroSpawned += GameplayManager_OnPlayerHeroSpawned; StartCoroutine(DelayedInit()); } private IEnumerator DelayedInit() { yield return new WaitForSeconds(2f); //Destroy(_abilityChoosingMenu.gameObject); } public override void OnStartClient() { base.OnStartClient(); LocalPlayer = this; StartCoroutine(AbilityChoosingMenuSearcher()); OnAbilityRewardSelected += This_OnAbilityRewardSelected; } private IEnumerator AbilityChoosingMenuSearcher() { while (_abilityChoosingMenu == null) { _abilityChoosingMenu = FindObjectOfType<AbilityChoosingMenu>(); yield return new WaitForSeconds(1f); } Debug.Log($\"{ClassName} AbilityChoosingMenu was setted up!\"); } #region Client available methods [Client] private void This_OnAbilityRewardSelected(byte abilityId) { _abilityChoosingMenu.HideAbilitiesMenu(); AbilityChosenByPlayer(abilityId); } [ServerRpc(RequireOwnership = false)] private void AbilityChosenByPlayer(byte abilityId, NetworkConnection conn = null) { //OLD: GameplayManager.Instance.GetUnitComponentsServerAndClient(conn).AbilityController.AddAbility(abilityId); var heroComps = GameplayManager.GetPlayerHeroComponentsServerAndClient(conn); int playerHeroObjectId = heroComps.HealthController.ObjectId; if (PlayerAbilityPointsServerOnly[playerHeroObjectId] >= 0) { DebugWrite.Log($\"[AbilityChosenByPlayer] {heroComps.HealthController} chose ability {abilityId}\", gameObject, _isDebug); AddAbilityToPlayer(conn, abilityId); ChangeUnlearnedPoint(heroComps.InvectorManager.ObjectId, -1); } else { DebugWrite.LogError($\"[AbilityChosenByPlayer] {heroComps.HealthController} tried to choose ability {abilityId} but has no unlearned points. Might be a cheater.\", gameObject, _isDebug); } } #endregion #region Server only calls [Server] public bool IsPlayerLearnedAbility(NetworkConnection conn, int abilityId) { return GetPlayerLearnedAbilities(conn).Exists(abilityInfo => abilityInfo.Id == abilityId); } [Server] public int GetPlayerLearnedAbilityRank(NetworkConnection conn, int abilityId) { return GetPlayerLearnedAbilities(conn).Find(abilityInfo => abilityInfo.Id == abilityId).Rank; } [Server] public void TestAddAbilitiesToAllPlayers(byte abilityId) { var allHeroes = GameplayManager.GetAllPlayersHeroes(); foreach (var hero in allHeroes) { AddAbilityToPlayer(hero.Owner, abilityId); } } [Server] public void SetRankToAbility(NetworkConnection conn, byte abilityId, uint rank) { var learnedAbilities = GetPlayerLearnedAbilities(conn); var abilityInfo = learnedAbilities.Find(info => info.Id == abilityId); if (abilityInfo != null) { abilityInfo.Rank++; abilityInfo.Stacks = 0; UnitComponents unitComponents = GameplayManager.GetPlayerHeroComponentsServerAndClient(conn); unitComponents.AbilityController.AddOrSetAbility(abilityInfo); Debug.Log($\"[SetRankToAbility] Client #{conn.ClientId} learned ability id #{abilityId} with rank: {abilityInfo.Rank}\"); } else { Debug.LogError($\"[AddRankToAbility] {conn} tried to add rank to ability {abilityId} but has not learned it yet.\"); } } [Server] private void AddAbilityToPlayer(NetworkConnection conn, byte abilityId) { ClientInstance ownerClientInstance = ClientInstance.ClientInstances[conn]; AbilityInfo defaultAbilityInfo = new(abilityId, 1, 0); Debug.Log($\"[AddAbilityToPlayer] {conn} learned {abilityId} with rank {defaultAbilityInfo.Rank}, stacks {defaultAbilityInfo.Stacks}\"); Ability ability = AbilityManager.Instance.GetAbility(abilityId); int rank = ability.CalculateRankBasedOnStacks(defaultAbilityInfo.Stacks); uint stacksLeft = defaultAbilityInfo.Stacks % ability.GetStacksForRank(); AbilityInfo calcAbilityInfo = new(abilityId, rank, stacksLeft); if (!PlayerLearnedAbilities.ContainsKey(conn)) { _playerLearnedAbilities.Add(conn, new List<AbilityInfo> {calcAbilityInfo} ); } _playerLearnedAbilities[conn].Add(calcAbilityInfo); UnitComponents unitComponents = GameplayManager.GetPlayerHeroComponentsServerAndClient(conn); unitComponents.AbilityController.AddOrSetAbility(calcAbilityInfo); OnPlayerLearnedAbility_ServerOnly?.Invoke(unitComponents.AbilityController.ObjectId, abilityId); try { BackendReadWrites.GetAbilityStacksForCharacter(ownerClientInstance.PlayerSettings.CharacterSkinData.Id, abilityId, abilityInfo => { if (abilityInfo.Stacks > 0) { int rank = ability.CalculateRankBasedOnStacks(defaultAbilityInfo.Stacks); uint stacksLeft = defaultAbilityInfo.Stacks % ability.GetStacksForRank(); AbilityInfo calcAbilityInfo = new(abilityId, rank, stacksLeft); unitComponents.AbilityController.AddOrSetAbility(calcAbilityInfo); } }); }catch (Exception e) { Debug.LogError($\"[AddAbilityToPlayer] {abilityId} stacks not found {e.Message}\"); } } [Server] private List<AbilityInfo> GetPlayerLearnedAbilities(NetworkConnection conn) { if (!PlayerLearnedAbilities.ContainsKey(conn)){ _playerLearnedAbilities.Add(conn, new List<AbilityInfo>()); } return _playerLearnedAbilities[conn]; } [Server] private void GameplayManager_OnPlayerHeroSpawned(int playerHeroObjectId) { var heroComps = GameplayManager.GetUnitComponentsServerAndClient(playerHeroObjectId); _playerAbilityPointsServerOnly.Add(playerHeroObjectId, 0); heroComps.XpController.OnNewLevelGained += XpController_OnNewLevelGained; } [Server] private void XpController_OnNewLevelGained(int playerHeroObjectId, int nextLevel) { NetworkConnection conn = InstanceFinder.ServerManager.Objects.Spawned[playerHeroObjectId].Owner; Debug.Log($\"[XpController_OnNewLevelGained] client #{conn.ClientId} gained a new level\"); ChangeUnlearnedPoint(playerHeroObjectId, 1); } [Server] private void ChangeUnlearnedPoint(int targetId, int amount) { if (!PlayerAbilityPointsServerOnly.ContainsKey(targetId)) { _playerAbilityPointsServerOnly.Add(targetId, 0); } if (amount < 0) { DebugWrite.Log($\"{ClassAndRoomName}[ChangeUnlearnedPoint] {targetId} lost {amount} unlearned points\", gameObject, _isDebug); } _playerAbilityPointsServerOnly[targetId] += amount; DebugWrite.Log($\"{ClassAndRoomName}[ChangeUnlearnedPoint] {targetId} has now {PlayerAbilityPointsServerOnly[targetId]} unlearned points\", gameObject, _isDebug); if (PlayerLearnedAbilities.Count >= MAX_ACTIVE_ABILITIES_PLAYER_CAN_HAVE + MAX_PASSIVE_ABILITIES_PLAYER_CAN_HAVE) return; if (PlayerAbilityPointsServerOnly[targetId] <= 0) return; NetworkConnection conn = GameplayManager.GetUnitComponentsServerAndClient(targetId).AbilityController.Owner; GenerateAndShowRandomAbilitiesForPlayer(conn); } [Server] private void GenerateAndShowRandomAbilitiesForPlayer(NetworkConnection conn) { List<AbilityDefinition> abilitiesToChoose = new List<AbilityDefinition>(_abilityDefinitionHolder.AbilityDefinitions); List<AbilityInfo> learnedAbilities = GetPlayerLearnedAbilities(conn); int activeAbilitiesCount = 0; RemoveItemAbilities(abilitiesToChoose); int playerLevel = GetPlayerLevel(conn); foreach (var abilityInfo in learnedAbilities) { var ability = _abilityDefinitionHolder.GetAbilityById(abilityInfo.Id); if (!ability.IsPassive) { activeAbilitiesCount++; } abilitiesToChoose.Remove(ability); } if (playerLevel < 4) { abilitiesToChoose.RemoveAll(ability => ability.IsPassive); } else { if (activeAbilitiesCount >= MAX_ACTIVE_ABILITIES_PLAYER_CAN_HAVE) { abilitiesToChoose.RemoveAll(ability => !ability.IsPassive); } } var abilitiesToShow = SelectRandomAbilities(abilitiesToChoose); Target_LoadRandomAbilities(conn, abilitiesToShow); } private int GetPlayerLevel(NetworkConnection conn) { ClientInstance clientInstance = ClientInstance.GetClientInstance(conn); var playerHero = clientInstance.PlayerHero; if (playerHero == null) { Debug.LogError($\"[GetPlayerLevel] {conn} has no player hero\"); return 0; } return playerHero.XpController.CurrentLevel; } private void RemoveItemAbilities(List<AbilityDefinition> abilitiesToChoose) { for (int i = 0; i < _itemAbilitiesToExclude.Length; i++) { foreach (var ability in abilitiesToChoose) { if (ability.Id == _itemAbilitiesToExclude[i]) { abilitiesToChoose.Remove(ability); break; } } } } [Server] private List<byte> SelectRandomAbilities(List<AbilityDefinition> abilities) { var rand = new System.Random(); var selectedAbilities = new List<byte>(); while (selectedAbilities.Count < MAX_ABILITIES_COUNT_TO_CHOOSE && abilities.Count > 0) { int randomAbilityIndex = rand.Next(abilities.Count); selectedAbilities.Add(abilities[randomAbilityIndex].Id); abilities.RemoveAt(randomAbilityIndex); } return selectedAbilities; } [TargetRpc] public void Target_LoadRandomAbilities(NetworkConnection conn, List<byte> abilitiesToShow) { _abilityChoosingMenu.ClientLoadRandomAbilities(abilitiesToShow); } #endregion private string AbilityReport(NetworkConnection conn) { StringBuilder sb = new StringBuilder(); sb.AppendLine($\"Player learned {PlayerLearnedAbilities[conn].Count} abilities: \"); foreach (var playerAbility in PlayerLearnedAbilities[conn]) { sb.AppendLine($\" {playerAbility}, \"); } return sb.ToString(); } [ServerRpc(RequireOwnership = false)] public void CmdReloadAbilities(NetworkConnection conn = null) { var unitComps = GameplayManager.GetPlayerHeroComponentsServerAndClient(conn); unitComps.XpController.RemoveXp(AbilityChoosingMenu.RELOAD_XP_COST); GenerateAndShowRandomAbilitiesForPlayer(conn); } } [Serializable] public class AbilityInfo { public byte Id; public int Rank = 1; public uint Stacks = 0; public AbilityInfo() { } public AbilityInfo(byte id, int rank, uint stacks) { Id = id; Rank = rank; Stacks = stacks; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RewardAbilityManager",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "RewardAbilityManager",
          "content": "using System; using System.Collections; using System.Collections.Generic; using System.Text; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Clients; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Connection; using FishNet.Object; using UnityEngine; public class RewardAbilityManager : RoomManager { [SerializeField] private AbilityChoosingMenu _abilityChoosingMenu; [SerializeField] private AbilityDefinitionHolder _abilityDefinitionHolder; public static Action<byte> OnAbilityRewardSelected; public static RewardAbilityManager LocalPlayer { get; private set; } public static RewardAbilityManager Instance { get; private set; } public static Action OnRewardAbilityWindowOpened; private static readonly int MAX_ABILITIES_COUNT_TO_CHOOSE = 3; private static readonly int MAX_ACTIVE_ABILITIES_PLAYER_CAN_HAVE = 6; private static readonly int MAX_PASSIVE_ABILITIES_PLAYER_CAN_HAVE = 6; private static readonly int MAX_ABILITIES_PLAYER_CAN_HAVE = 4; private readonly byte[] _itemAbilitiesToExclude = new byte[] { 12 }; public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); private string _className; #region Server only fields. public Dictionary<int, int> PlayerAbilityPointsServerOnly => _playerAbilityPointsServerOnly; private Dictionary<int, int> _playerAbilityPointsServerOnly = new Dictionary<int, int>(); public Action<int, int> OnPlayerLearnedAbility_ServerOnly; #endregion public Dictionary<NetworkConnection, List<AbilityInfo>> PlayerLearnedAbilities => _playerLearnedAbilities; private Dictionary<NetworkConnection, List<AbilityInfo>> _playerLearnedAbilities = new Dictionary<NetworkConnection, List<AbilityInfo>>(); private bool _isDebug = true; private void Awake() { if (Instance != null) { Debug.LogWarning($\"{ClassAndRoomName} There is more than one instance of RewardAbilityManager in the scene.\"); return; } Instance = this; } public override void OnStartServer() { base.OnStartServer(); GameplayManager.Instance.OnPlayerHeroSpawned += GameplayManager_OnPlayerHeroSpawned; StartCoroutine(DelayedInit()); } private IEnumerator DelayedInit() { yield return new WaitForSeconds(2f); //Destroy(_abilityChoosingMenu.gameObject); } public override void OnStartClient() { base.OnStartClient(); LocalPlayer = this; StartCoroutine(AbilityChoosingMenuSearcher()); OnAbilityRewardSelected += This_OnAbilityRewardSelected; } private IEnumerator AbilityChoosingMenuSearcher() { while (_abilityChoosingMenu == null) { _abilityChoosingMenu = FindObjectOfType<AbilityChoosingMenu>(); yield return new WaitForSeconds(1f); } Debug.Log($\"{ClassName} AbilityChoosingMenu was setted up!\"); } #region Client available methods [Client] private void This_OnAbilityRewardSelected(byte abilityId) { _abilityChoosingMenu.HideAbilitiesMenu(); AbilityChosenByPlayer(abilityId); } [ServerRpc(RequireOwnership = false)] private void AbilityChosenByPlayer(byte abilityId, NetworkConnection conn = null) { //OLD: GameplayManager.Instance.GetUnitComponentsServerAndClient(conn).AbilityController.AddAbility(abilityId); var heroComps = GameplayManager.GetPlayerHeroComponentsServerAndClient(conn); int playerHeroObjectId = heroComps.HealthController.ObjectId; if (PlayerAbilityPointsServerOnly[playerHeroObjectId] >= 0) { DebugWrite.Log($\"[AbilityChosenByPlayer] {heroComps.HealthController} chose ability {abilityId}\", gameObject, _isDebug); AddAbilityToPlayer(conn, abilityId); ChangeUnlearnedPoint(heroComps.InvectorManager.ObjectId, -1); } else { DebugWrite.LogError($\"[AbilityChosenByPlayer] {heroComps.HealthController} tried to choose ability {abilityId} but has no unlearned points. Might be a cheater.\", gameObject, _isDebug); } } #endregion #region Server only calls [Server] public bool IsPlayerLearnedAbility(NetworkConnection conn, int abilityId) { return GetPlayerLearnedAbilities(conn).Exists(abilityInfo => abilityInfo.Id == abilityId); } [Server] public int GetPlayerLearnedAbilityRank(NetworkConnection conn, int abilityId) { return GetPlayerLearnedAbilities(conn).Find(abilityInfo => abilityInfo.Id == abilityId).Rank; } [Server] public void TestAddAbilitiesToAllPlayers(byte abilityId) { var allHeroes = GameplayManager.GetAllPlayersHeroes(); foreach (var hero in allHeroes) { AddAbilityToPlayer(hero.Owner, abilityId); } } [Server] public void SetRankToAbility(NetworkConnection conn, byte abilityId, uint rank) { var learnedAbilities = GetPlayerLearnedAbilities(conn); var abilityInfo = learnedAbilities.Find(info => info.Id == abilityId); if (abilityInfo != null) { abilityInfo.Rank++; abilityInfo.Stacks = 0; UnitComponents unitComponents = GameplayManager.GetPlayerHeroComponentsServerAndClient(conn); unitComponents.AbilityController.AddOrSetAbility(abilityInfo); Debug.Log($\"[SetRankToAbility] Client #{conn.ClientId} learned ability id #{abilityId} with rank: {abilityInfo.Rank}\"); } else { Debug.LogError($\"[AddRankToAbility] {conn} tried to add rank to ability {abilityId} but has not learned it yet.\"); } } [Server] private void AddAbilityToPlayer(NetworkConnection conn, byte abilityId) { ClientInstance ownerClientInstance = ClientInstance.ClientInstances[conn]; AbilityInfo defaultAbilityInfo = new(abilityId, 1, 0); Debug.Log($\"[AddAbilityToPlayer] {conn} learned {abilityId} with rank {defaultAbilityInfo.Rank}, stacks {defaultAbilityInfo.Stacks}\"); Ability ability = AbilityManager.Instance.GetAbility(abilityId); int rank = ability.CalculateRankBasedOnStacks(defaultAbilityInfo.Stacks); uint stacksLeft = defaultAbilityInfo.Stacks % ability.GetStacksForRank(); AbilityInfo calcAbilityInfo = new(abilityId, rank, stacksLeft); if (!PlayerLearnedAbilities.ContainsKey(conn)) { _playerLearnedAbilities.Add(conn, new List<AbilityInfo> {calcAbilityInfo} ); } _playerLearnedAbilities[conn].Add(calcAbilityInfo); UnitComponents unitComponents = GameplayManager.GetPlayerHeroComponentsServerAndClient(conn); unitComponents.AbilityController.AddOrSetAbility(calcAbilityInfo); OnPlayerLearnedAbility_ServerOnly?.Invoke(unitComponents.AbilityController.ObjectId, abilityId); try { BackendReadWrites.GetAbilityStacksForCharacter(ownerClientInstance.PlayerSettings.CharacterSkinData.Id, abilityId, abilityInfo => { if (abilityInfo.Stacks > 0) { int rank = ability.CalculateRankBasedOnStacks(defaultAbilityInfo.Stacks); uint stacksLeft = defaultAbilityInfo.Stacks % ability.GetStacksForRank(); AbilityInfo calcAbilityInfo = new(abilityId, rank, stacksLeft); unitComponents.AbilityController.AddOrSetAbility(calcAbilityInfo); } });  ",
          "content_tokens": 1710,
          "embedding": []
        },
        {
          "cs_scriptfile": "RewardAbilityManager",
          "content": "catch (Exception e) { Debug.LogError($\"[AddAbilityToPlayer] {abilityId} stacks not found {e.Message}\"); } } [Server] private List<AbilityInfo> GetPlayerLearnedAbilities(NetworkConnection conn) { if (!PlayerLearnedAbilities.ContainsKey(conn)){ _playerLearnedAbilities.Add(conn, new List<AbilityInfo>()); } return _playerLearnedAbilities[conn]; } [Server] private void GameplayManager_OnPlayerHeroSpawned(int playerHeroObjectId) { var heroComps = GameplayManager.GetUnitComponentsServerAndClient(playerHeroObjectId); _playerAbilityPointsServerOnly.Add(playerHeroObjectId, 0); heroComps.XpController.OnNewLevelGained += XpController_OnNewLevelGained; } [Server] private void XpController_OnNewLevelGained(int playerHeroObjectId, int nextLevel) { NetworkConnection conn = InstanceFinder.ServerManager.Objects.Spawned[playerHeroObjectId].Owner; Debug.Log($\"[XpController_OnNewLevelGained] client #{conn.ClientId} gained a new level\"); ChangeUnlearnedPoint(playerHeroObjectId, 1); } [Server] private void ChangeUnlearnedPoint(int targetId, int amount) { if (!PlayerAbilityPointsServerOnly.ContainsKey(targetId)) { _playerAbilityPointsServerOnly.Add(targetId, 0);  ",
          "content_tokens": 327,
          "embedding": []
        },
        {
          "cs_scriptfile": "RewardAbilityManager",
          "content": "if (amount < 0) { DebugWrite.Log($\"{ClassAndRoomName}[ChangeUnlearnedPoint] {targetId} lost {amount} unlearned points\", gameObject, _isDebug); } _playerAbilityPointsServerOnly[targetId] += amount; DebugWrite.Log($\"{ClassAndRoomName}[ChangeUnlearnedPoint] {targetId} has now {PlayerAbilityPointsServerOnly[targetId]} unlearned points\", gameObject, _isDebug); if (PlayerLearnedAbilities.Count >= MAX_ACTIVE_ABILITIES_PLAYER_CAN_HAVE + MAX_PASSIVE_ABILITIES_PLAYER_CAN_HAVE) return; if (PlayerAbilityPointsServerOnly[targetId] <= 0) return; NetworkConnection conn = GameplayManager.GetUnitComponentsServerAndClient(targetId).AbilityController.Owner; GenerateAndShowRandomAbilitiesForPlayer(conn); } [Server] private void GenerateAndShowRandomAbilitiesForPlayer(NetworkConnection conn) { List<AbilityDefinition> abilitiesToChoose = new List<AbilityDefinition>(_abilityDefinitionHolder.AbilityDefinitions); List<AbilityInfo> learnedAbilities = GetPlayerLearnedAbilities(conn); int activeAbilitiesCount = 0; RemoveItemAbilities(abilitiesToChoose); int playerLevel = GetPlayerLevel(conn); foreach (var abilityInfo in learnedAbilities) { var ability = _abilityDefinitionHolder.GetAbilityById(abilityInfo.Id); if (!ability.IsPassive) { activeAbilitiesCount++; } abilitiesToChoose.Remove(ability);  ",
          "content_tokens": 349,
          "embedding": []
        },
        {
          "cs_scriptfile": "RewardAbilityManager",
          "content": "if (playerLevel < 4) { abilitiesToChoose.RemoveAll(ability => ability.IsPassive); } else { if (activeAbilitiesCount >= MAX_ACTIVE_ABILITIES_PLAYER_CAN_HAVE) { abilitiesToChoose.RemoveAll(ability => !ability.IsPassive); } } var abilitiesToShow = SelectRandomAbilities(abilitiesToChoose); Target_LoadRandomAbilities(conn, abilitiesToShow);  private int GetPlayerLevel(NetworkConnection conn) { ClientInstance clientInstance = ClientInstance.GetClientInstance(conn); var playerHero = clientInstance.PlayerHero; if (playerHero == null) { Debug.LogError($\"[GetPlayerLevel] {conn} has no player hero\"); return 0; } return playerHero.XpController.CurrentLevel;  ",
          "content_tokens": 174,
          "embedding": []
        },
        {
          "cs_scriptfile": "RewardAbilityManager",
          "content": "private void RemoveItemAbilities(List<AbilityDefinition> abilitiesToChoose) { for (int i = 0; i < _itemAbilitiesToExclude.Length; i++) { foreach (var ability in abilitiesToChoose) { if (ability.Id == _itemAbilitiesToExclude[i]) { abilitiesToChoose.Remove(ability); break; } } } } [Server] private List<byte> SelectRandomAbilities(List<AbilityDefinition> abilities) { var rand = new System.Random(); var selectedAbilities = new List<byte>(); while (selectedAbilities.Count < MAX_ABILITIES_COUNT_TO_CHOOSE && abilities.Count > 0) { int randomAbilityIndex = rand.Next(abilities.Count); selectedAbilities.Add(abilities[randomAbilityIndex].Id); abilities.RemoveAt(randomAbilityIndex); } return selectedAbilities; } [TargetRpc] public void Target_LoadRandomAbilities(NetworkConnection conn, List<byte> abilitiesToShow) { _abilityChoosingMenu.ClientLoadRandomAbilities(abilitiesToShow); } #endregion private string AbilityReport(NetworkConnection conn) { StringBuilder sb = new StringBuilder(); sb.AppendLine($\"Player learned {PlayerLearnedAbilities[conn].Count} abilities: \"); foreach (var playerAbility in PlayerLearnedAbilities[conn]) { sb.AppendLine($\" {playerAbility}, \"); } return sb.ToString(); } [ServerRpc(RequireOwnership = false)] public void CmdReloadAbilities(NetworkConnection conn = null) { var unitComps = GameplayManager.GetPlayerHeroComponentsServerAndClient(conn); unitComps.XpController.RemoveXp(AbilityChoosingMenu.RELOAD_XP_COST); GenerateAndShowRandomAbilitiesForPlayer(conn); } } [Serializable] public class AbilityInfo { public byte Id; public int Rank = 1; public uint Stacks = 0; public AbilityInfo() {  ",
          "content_tokens": 442,
          "embedding": []
        },
        {
          "cs_scriptfile": "RewardAbilityManager",
          "content": "public AbilityInfo(byte id, int rank, uint stacks) { Id = id; Rank = rank; Stacks = stacks; } }",
          "content_tokens": 29,
          "embedding": []
        }
      ],
      "length": 11381
    },
    {
      "filename": "RewardWeaponManager",
      "content": "using System; using System.Collections; using System.Linq; using FishNet.Connection; using FishNet.Object; using FishnetInvector; using Invector.vItemManager; using UnityEngine; public class RewardWeaponManager : RoomManager { [SerializeField] private int[] _weaponCardToWeaponIds; public static Action<int> OnWeaponRewardSelected; private bool _isWeaponAlreadySelected; public static RewardWeaponManager LocalPlayer { get; private set; } public override void OnStartClient() { base.OnStartClient(); LocalPlayer = this; OnWeaponRewardSelected += This_OnWeaponRewardSelected; } #region Client available methods [Client] private void This_OnWeaponRewardSelected(int weaponId) { if (_isWeaponAlreadySelected) return; _isWeaponAlreadySelected = true; WeaponChoosingMenuController.Instance.Hide(); WeaponChosenByPlayer(weaponId); StartCoroutine(AutoEquipWeapon(weaponId)); } [Client] private IEnumerator AutoEquipWeapon(int weaponId) { yield return new WaitForSeconds(1f); vItem item = FNvItemManager.LocalPlayer.items.FirstOrDefault(item => item.id == _weaponCardToWeaponIds[weaponId]); if (item == null) { Debug.Log($\"{ClassAndRoomName} AutoEquipWeapon: Item with id {_weaponCardToWeaponIds[weaponId]} not found\"); yield break; } var itemRef = item.ToItemReference(); vEquipArea equipArea = FNvItemManager.LocalPlayer.inventory.equipAreas[itemRef.indexArea]; FNvItemManager.LocalPlayer.AutoEquipItem(item, itemRef.indexArea, true, false); //FNvItemManager.LocalPlayer.UIInventory.EquipItem(equipArea, item); } [ServerRpc(RequireOwnership = false)] private void WeaponChosenByPlayer(int weaponId, NetworkConnection conn = null) { var heroComps = GameplayManager.GetPlayerHeroComponentsServerAndClient(conn); heroComps.ItemManager.ServerAddItemIds(new int[]{_weaponCardToWeaponIds[weaponId]}); Debug.Log($\"{ClassAndRoomName}[WeaponChosenByPlayer] Weapon with id {_weaponCardToWeaponIds[weaponId]} added to player {conn.ClientId}\"); heroComps.XpController.AddXp(300); } #endregion } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RewardWeaponManager",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "RewardWeaponManager",
          "content": "using System; using System.Collections; using System.Linq; using FishNet.Connection; using FishNet.Object; using FishnetInvector; using Invector.vItemManager; using UnityEngine; public class RewardWeaponManager : RoomManager { [SerializeField] private int[] _weaponCardToWeaponIds; public static Action<int> OnWeaponRewardSelected; private bool _isWeaponAlreadySelected; public static RewardWeaponManager LocalPlayer { get; private set; } public override void OnStartClient() { base.OnStartClient(); LocalPlayer = this; OnWeaponRewardSelected += This_OnWeaponRewardSelected; } #region Client available methods [Client] private void This_OnWeaponRewardSelected(int weaponId) { if (_isWeaponAlreadySelected) return; _isWeaponAlreadySelected = true; WeaponChoosingMenuController.Instance.Hide(); WeaponChosenByPlayer(weaponId); StartCoroutine(AutoEquipWeapon(weaponId)); } [Client] private IEnumerator AutoEquipWeapon(int weaponId) { yield return new WaitForSeconds(1f); vItem item = FNvItemManager.LocalPlayer.items.FirstOrDefault(item => item.id == _weaponCardToWeaponIds[weaponId]); if (item == null) { Debug.Log($\"{ClassAndRoomName} AutoEquipWeapon: Item with id {_weaponCardToWeaponIds[weaponId]} not found\"); yield break; } var itemRef = item.ToItemReference(); vEquipArea equipArea = FNvItemManager.LocalPlayer.inventory.equipAreas[itemRef.indexArea]; FNvItemManager.LocalPlayer.AutoEquipItem(item, itemRef.indexArea, true, false); //FNvItemManager.LocalPlayer.UIInventory.EquipItem(equipArea, item); } [ServerRpc(RequireOwnership = false)] private void WeaponChosenByPlayer(int weaponId, NetworkConnection conn = null) { var heroComps = GameplayManager.GetPlayerHeroComponentsServerAndClient(conn); heroComps.ItemManager.ServerAddItemIds(new int[]{_weaponCardToWeaponIds[weaponId]}); Debug.Log($\"{ClassAndRoomName}[WeaponChosenByPlayer] Weapon with id {_weaponCardToWeaponIds[weaponId]} added to player {conn.ClientId}\"); heroComps.XpController.AddXp(300); } #endregion }",
          "content_tokens": 551,
          "embedding": []
        }
      ],
      "length": 1977
    },
    {
      "filename": "RoomEnterTriggerDetector",
      "content": "using System; using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using InRoomSystems; using UnityEngine; public class RoomEnterTriggerDetector : MonoBehaviour { public Action OnLocalPlayerEnter; [SerializeField] private RoomCollapsingTimer roomCollapsingTimer; private void OnValidate() { AssignComponentsIfRequired(); } private void Awake() { AssignComponentsIfRequired(); StartCoroutine(AssignGPM()); } private void AssignComponentsIfRequired() { roomCollapsingTimer ??= GetComponent<RoomCollapsingTimer>(); } private IEnumerator AssignGPM() { yield return new WaitForSeconds(1f); } private void OnDisable() { Debug.Log($\"[RoomEnterTriggerDetector] {gameObject.name} OnDisable\", gameObject); } private void OnTriggerEnter(Collider other) { if (!GameplayManager.IsOwningPlayer(other)) return; RemoveMonsterSpawnPoints(); if (roomCollapsingTimer.IsInitialized) { if (roomCollapsingTimer.IsLavaFloorActive) { Debug.Log($\"[RoomEnterTriggerDetector] {other.name} has entered in {gameObject.name} but lava is active\"); return; } } } private void SetupGameplayManagerIfNeeded(NetworkObject triggeringPlayer) { Debug.Log($\"[RoomEnterTriggerDetector] {triggeringPlayer} has entered in {gameObject.name}\"); if (GameplayManager.Instance != null) return; if (triggeringPlayer.IsClient && triggeringPlayer.IsOwner) { OnLocalPlayerEnter?.Invoke(); } } public void RemoveMonsterSpawnPoints() { GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(RespawnManager.TAG_MONSTER_SPAWN_POINT); for (int j = 0; j < spawnPointHolders.Length; j++) { Destroy(spawnPointHolders[j]); } spawnPointHolders = GameObject.FindGameObjectsWithTag(RespawnManager.TAG_BOSS_SPAWN_POINT); for (int j = 0; j < spawnPointHolders.Length; j++) { Destroy(spawnPointHolders[j]); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RoomEnterTriggerDetector",
          "content": "using System; using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; using InRoomSystems; using UnityEngine; public class RoomEnterTriggerDetector : MonoBehaviour { public Action OnLocalPlayerEnter; [SerializeField] private RoomCollapsingTimer roomCollapsingTimer; private void OnValidate() { AssignComponentsIfRequired();  private void Awake() { AssignComponentsIfRequired(); StartCoroutine(AssignGPM());  private void AssignComponentsIfRequired() { roomCollapsingTimer ??= GetComponent<RoomCollapsingTimer>(); } private IEnumerator AssignGPM() { yield return new WaitForSeconds(1f);  ",
          "content_tokens": 181,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomEnterTriggerDetector",
          "content": "private void OnDisable() { Debug.Log($\"[RoomEnterTriggerDetector] {gameObject.name} OnDisable\", gameObject);  private void OnTriggerEnter(Collider other) { if (!GameplayManager.IsOwningPlayer(other)) return; RemoveMonsterSpawnPoints(); if (roomCollapsingTimer.IsInitialized) { if (roomCollapsingTimer.IsLavaFloorActive) { Debug.Log($\"[RoomEnterTriggerDetector] {other.name} has entered in {gameObject.name} but lava is active\"); return; } }  ",
          "content_tokens": 124,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomEnterTriggerDetector",
          "content": "private void SetupGameplayManagerIfNeeded(NetworkObject triggeringPlayer) { Debug.Log($\"[RoomEnterTriggerDetector] {triggeringPlayer} has entered in {gameObject.name}\"); if (GameplayManager.Instance != null) return; if (triggeringPlayer.IsClient && triggeringPlayer.IsOwner) { OnLocalPlayerEnter?.Invoke(); }  ",
          "content_tokens": 80,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomEnterTriggerDetector",
          "content": "public void RemoveMonsterSpawnPoints() { GameObject[] spawnPointHolders = GameObject.FindGameObjectsWithTag(RespawnManager.TAG_MONSTER_SPAWN_POINT); for (int j = 0; j < spawnPointHolders.Length; j++) { Destroy(spawnPointHolders[j]); } spawnPointHolders = GameObject.FindGameObjectsWithTag(RespawnManager.TAG_BOSS_SPAWN_POINT); for (int j = 0; j < spawnPointHolders.Length; j++) { Destroy(spawnPointHolders[j]); } } }",
          "content_tokens": 133,
          "embedding": []
        }
      ],
      "length": 1844
    },
    {
      "filename": "RoomManager",
      "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; public class RoomManager : NetworkBehaviour { public GameplayManager GameplayManager { get { if (_gameplayManager == null) { _gameplayManager = FindObjectOfType<GameplayManager>(); } return _gameplayManager; } } protected GameplayManager _gameplayManager; protected string ClassAndRoomName => $\"<color=#{ClassColor}>[{this.GetType().Name}]</color><color=#FFFF00>[{GameplayManager.RoomName}]</color> \"; protected string _classColor; public string ClassColor { get { if (string.IsNullOrEmpty(_classColor)) { _classColor = StringToHexColor.GetColor(GetType().Name); } return _classColor; } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RoomManager",
          "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet.Object; public class RoomManager : NetworkBehaviour { public GameplayManager GameplayManager { get { if (_gameplayManager == null) { _gameplayManager = FindObjectOfType<GameplayManager>(); } return _gameplayManager; } } protected GameplayManager _gameplayManager; protected string ClassAndRoomName => $\"<color=#{ClassColor}>[{this.GetType().Name}]</color><color=#FFFF00>[{GameplayManager.RoomName}]</color> \"; protected string _classColor; public string ClassColor { get { if (string.IsNullOrEmpty(_classColor)) { _classColor = StringToHexColor.GetColor(GetType().Name); } return _classColor; } } }",
          "content_tokens": 196,
          "embedding": []
        }
      ],
      "length": 703
    },
    {
      "filename": "StatusIndicatorManager",
      "content": "using System; using System.Collections; using System.Collections.Generic; using DungeonScrollerCore; using RPG_Indicator; using UnityEngine; public class StatusIndicatorManager : MonoBehaviour { public static StatusIndicatorManager Instance { get; private set; } private bool _isDebug = true; private Queue<Indicator> _unusedObjectsPool = new Queue<Indicator>(); private List<Indicator> _usedObjectsPool = new List<Indicator>(); [SerializeField] private RpgIndicator _rpgIndicatorPrefab; private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } } public static void InitCone(Transform unit, float range, float duration) { DebugWrite.Log($\"[StatusIndicatorManager] InitCone: unit={unit} range={range}, duration={duration}\"); Instance.StartCoroutine(Instance.PlayConeProgress(unit, range, duration)); } public static void InitArea(Transform unit, float radius, float range, float duration) { DebugWrite.Log($\"[StatusIndicatorManager] InitArea: unit:{unit} radius:{radius}, range: {range}, duration={duration}\"); Instance.StartCoroutine(Instance.PlayAreaProgress(unit, radius, range, duration)); } private IEnumerator PlayAreaProgress(Transform unit, float radius, float range, float duration) { Indicator indicator = Allocate(unit, false); //indicator.IndicatorEffect.ShowArea(radius, range, false, RpgIndicator.IndicatorColor.Enemy, 0); indicator.IndicatorEffect.ShowAreaProgress(radius, range, false, RpgIndicator.IndicatorColor.Enemy, 0, duration); yield return new WaitForSeconds(duration); Deallocate(indicator); } private IEnumerator PlayConeProgress(Transform unit, float range, float duration) { Indicator indicator = Allocate(unit, true); indicator.IndicatorEffect.ShowConeProgress(90f, range, false, RpgIndicator.IndicatorColor.Enemy, 0, duration); yield return new WaitForSeconds(duration); //Debug.Log($\"[StatusIndicatorManager] CorPlayStatusIndicatorEffect: status={indicator}\", indicator.IndicatorEffect.gameObject); Deallocate(indicator); } private Indicator Allocate(Transform unit, bool isCone) { if (_unusedObjectsPool.Count == 0) { ResizePool(_usedObjectsPool.Count + 1); } Indicator indicator = _unusedObjectsPool.Dequeue(); _usedObjectsPool.Add(indicator); indicator.IndicatorEffect.transform.SetParent(unit); indicator.IndicatorEffect.transform.localPosition = Vector3.zero; if (isCone) indicator.IndicatorEffect.transform.rotation = new Quaternion(0, unit.rotation.y, 0, unit.rotation.w); else indicator.IndicatorEffect.transform.rotation = Quaternion.identity; indicator.IndicatorEffect.gameObject.SetActive(true); return indicator; } public void Deallocate(Indicator obj) { DebugWrite.Log($\"[StatusIndicatorManager] Deallocate: obj={obj}\", gameObject, _isDebug); if (_usedObjectsPool.Contains(obj)) { _usedObjectsPool.Remove(obj); _unusedObjectsPool.Enqueue(obj); if (obj != null) { obj.IndicatorEffect.gameObject.SetActive(false); obj.IndicatorEffect.transform.SetParent(transform); obj.IndicatorEffect.transform.localPosition = Vector3.zero; DebugWrite.Log($\"[StatusIndicatorManager] Deallocate: obj.StatusEffect={obj.IndicatorEffect}\", gameObject, _isDebug); } } else { Debug.LogError(\"Trying to deallocate an object that is not in the used pool.\"); } } private void ResizePool(int newSize) { if (newSize < _usedObjectsPool.Count) { Debug.LogError(\"Cannot resize the pool to a smaller size than the current used objects.\"); return; } for (int i = _unusedObjectsPool.Count + _usedObjectsPool.Count; i < newSize; i++) { RpgIndicator obj = Instantiate(_rpgIndicatorPrefab, transform.position, Quaternion.identity, transform); DebugWrite.Log($\"[StatusIndicatorManager] ResizePool: pos={obj.transform.position}, local pos={obj.transform.localPosition}\", gameObject, _isDebug); Indicator slash = new Indicator(obj); obj.gameObject.SetActive(false); _unusedObjectsPool.Enqueue(slash); } } public class Indicator { public RpgIndicator IndicatorEffect; public bool IsUsed; public Indicator(RpgIndicator indicatorEffect) { IndicatorEffect = indicatorEffect; IsUsed = false; } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "StatusIndicatorManager",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "StatusIndicatorManager",
          "content": "using System; using System.Collections; using System.Collections.Generic; using DungeonScrollerCore; using RPG_Indicator; using UnityEngine; public class StatusIndicatorManager : MonoBehaviour { public static StatusIndicatorManager Instance { get; private set; } private bool _isDebug = true; private Queue<Indicator> _unusedObjectsPool = new Queue<Indicator>(); private List<Indicator> _usedObjectsPool = new List<Indicator>(); [SerializeField] private RpgIndicator _rpgIndicatorPrefab; private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } } public static void InitCone(Transform unit, float range, float duration) { DebugWrite.Log($\"[StatusIndicatorManager] InitCone: unit={unit} range={range}, duration={duration}\"); Instance.StartCoroutine(Instance.PlayConeProgress(unit, range, duration)); } public static void InitArea(Transform unit, float radius, float range, float duration) { DebugWrite.Log($\"[StatusIndicatorManager] InitArea: unit:{unit} radius:{radius}, range: {range}, duration={duration}\"); Instance.StartCoroutine(Instance.PlayAreaProgress(unit, radius, range, duration)); } private IEnumerator PlayAreaProgress(Transform unit, float radius, float range, float duration) { Indicator indicator = Allocate(unit, false); //indicator.IndicatorEffect.ShowArea(radius, range, false, RpgIndicator.IndicatorColor.Enemy, 0); indicator.IndicatorEffect.ShowAreaProgress(radius, range, false, RpgIndicator.IndicatorColor.Enemy, 0, duration); yield return new WaitForSeconds(duration); Deallocate(indicator); } private IEnumerator PlayConeProgress(Transform unit, float range, float duration) { Indicator indicator = Allocate(unit, true); indicator.IndicatorEffect.ShowConeProgress(90f, range, false, RpgIndicator.IndicatorColor.Enemy, 0, duration); yield return new WaitForSeconds(duration); //Debug.Log($\"[StatusIndicatorManager] CorPlayStatusIndicatorEffect: status={indicator}\", indicator.IndicatorEffect.gameObject); Deallocate(indicator); } private Indicator Allocate(Transform unit, bool isCone) { if (_unusedObjectsPool.Count == 0) { ResizePool(_usedObjectsPool.Count + 1); } Indicator indicator = _unusedObjectsPool.Dequeue(); _usedObjectsPool.Add(indicator); indicator.IndicatorEffect.transform.SetParent(unit); indicator.IndicatorEffect.transform.localPosition = Vector3.zero; if (isCone) indicator.IndicatorEffect.transform.rotation = new Quaternion(0, unit.rotation.y, 0, unit.rotation.w); else indicator.IndicatorEffect.transform.rotation = Quaternion.identity; indicator.IndicatorEffect.gameObject.SetActive(true); return indicator;  ",
          "content_tokens": 696,
          "embedding": []
        },
        {
          "cs_scriptfile": "StatusIndicatorManager",
          "content": "public void Deallocate(Indicator obj) { DebugWrite.Log($\"[StatusIndicatorManager] Deallocate: obj={obj}\", gameObject, _isDebug); if (_usedObjectsPool.Contains(obj)) { _usedObjectsPool.Remove(obj); _unusedObjectsPool.Enqueue(obj); if (obj != null) { obj.IndicatorEffect.gameObject.SetActive(false); obj.IndicatorEffect.transform.SetParent(transform); obj.IndicatorEffect.transform.localPosition = Vector3.zero; DebugWrite.Log($\"[StatusIndicatorManager] Deallocate: obj.StatusEffect={obj.IndicatorEffect}\", gameObject, _isDebug); } } else { Debug.LogError(\"Trying to deallocate an object that is not in the used pool.\"); }  ",
          "content_tokens": 186,
          "embedding": []
        },
        {
          "cs_scriptfile": "StatusIndicatorManager",
          "content": "private void ResizePool(int newSize) { if (newSize < _usedObjectsPool.Count) { Debug.LogError(\"Cannot resize the pool to a smaller size than the current used objects.\"); return;  ",
          "content_tokens": 50,
          "embedding": []
        },
        {
          "cs_scriptfile": "StatusIndicatorManager",
          "content": "for (int i = _unusedObjectsPool.Count + _usedObjectsPool.Count; i < newSize; i++) { RpgIndicator obj = Instantiate(_rpgIndicatorPrefab, transform.position, Quaternion.identity, transform); DebugWrite.Log($\"[StatusIndicatorManager] ResizePool: pos={obj.transform.position}, local pos={obj.transform.localPosition}\", gameObject, _isDebug); Indicator slash = new Indicator(obj); obj.gameObject.SetActive(false); _unusedObjectsPool.Enqueue(slash); } } public class Indicator { public RpgIndicator IndicatorEffect; public bool IsUsed; public Indicator(RpgIndicator indicatorEffect) { IndicatorEffect = indicatorEffect; IsUsed = false; } } }",
          "content_tokens": 181,
          "embedding": []
        }
      ],
      "length": 4029
    },
    {
      "filename": "TrapWeaponMovable",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class TrapWeaponMovable : Movable { } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "TrapWeaponMovable",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class TrapWeaponMovable : Movable { }",
          "content_tokens": 29,
          "embedding": []
        }
      ],
      "length": 124
    },
    {
      "filename": "WeaponCard",
      "content": "using System; using Invector.vCharacterController; using UnityEngine; using UnityEngine.UI; public class WeaponCard : MonoBehaviour { public GenericInput selectInput = new GenericInput(\"Alpha0\", \"A\", \"RB\"); [SerializeField] private int _weaponCardId; [SerializeField] private Sprite[] joystickImagesABXY; [SerializeField] private Image joystickButtonHolder; [SerializeField] private KeyCode _keyboardSelectionKey = KeyCode.Alpha1; private void Update() { if (selectInput.GetButtonDown()) OnKeyPressed(); if (Input.GetKeyUp(_keyboardSelectionKey)) { OnKeyPressed(); } } private void OnKeyPressed() { Debug.Log($\"[WeaponCard][OnCtrlOneKeyCombo] {selectInput.key} key combo pressed\"); OnWeaponSelected(_weaponCardId); } private void OnWeaponSelected(int weaponCardId) { RewardWeaponManager.OnWeaponRewardSelected?.Invoke(weaponCardId); Debug.Log($\"[WeaponCard][OnAbilitySelected] Weapon with id {weaponCardId} selected\"); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "WeaponCard",
          "content": "using System; using Invector.vCharacterController; using UnityEngine; using UnityEngine.UI; public class WeaponCard : MonoBehaviour { public GenericInput selectInput = new GenericInput(\"Alpha0\", \"A\", \"RB\"); [SerializeField] private int _weaponCardId; [SerializeField] private Sprite[] joystickImagesABXY; [SerializeField] private Image joystickButtonHolder; [SerializeField] private KeyCode _keyboardSelectionKey = KeyCode.Alpha1; private void Update() { if (selectInput.GetButtonDown()) OnKeyPressed(); if (Input.GetKeyUp(_keyboardSelectionKey)) { OnKeyPressed(); }  private void OnKeyPressed() { Debug.Log($\"[WeaponCard][OnCtrlOneKeyCombo] {selectInput.key} key combo pressed\"); OnWeaponSelected(_weaponCardId);  ",
          "content_tokens": 192,
          "embedding": []
        },
        {
          "cs_scriptfile": "WeaponCard",
          "content": "private void OnWeaponSelected(int weaponCardId) { RewardWeaponManager.OnWeaponRewardSelected?.Invoke(weaponCardId); Debug.Log($\"[WeaponCard][OnAbilitySelected] Weapon with id {weaponCardId} selected\"); } }",
          "content_tokens": 56,
          "embedding": []
        }
      ],
      "length": 922
    },
    {
      "filename": "WeaponChoosingMenuController",
      "content": "using System.Collections; using DarkTonic.MasterAudio; using FishnetInvector; using UnityEngine; public class WeaponChoosingMenuController : MonoBehaviour { public static WeaponChoosingMenuController Instance { get; private set; } [SerializeField] private WeaponCard[] _weaponCards; private UICanvasGroupDecorator _weaponChoosingMenuCanvasGroupDecorator; public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); private string _className; private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } _weaponChoosingMenuCanvasGroupDecorator = GetComponent<UICanvasGroupDecorator>(); StartCoroutine(LocalPlayerInitListener()); } private IEnumerator LocalPlayerInitListener() { yield return new WaitUntil(() => FishnetInvectorManager.IsLocalPlayerInitialized); FishnetInvectorManager_OnLocalPlayerInitialized(); } private void FishnetInvectorManager_OnLocalPlayerInitialized() { Debug.Log($\"{ClassName} - FishnetInvectorManager_OnLocalPlayerInitialized\"); _weaponChoosingMenuCanvasGroupDecorator.Show(); for (int i = 0; i < _weaponCards.Length; i++) { _weaponCards[i].gameObject.SetActive(true); MasterAudio.PlaySound(\"Take_a_card_1\"); } } public void Hide() { _weaponChoosingMenuCanvasGroupDecorator.Hide(); for (int i = 0; i < _weaponCards.Length; i++) { _weaponCards[i].gameObject.SetActive(false); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "WeaponChoosingMenuController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "WeaponChoosingMenuController",
          "content": "using System.Collections; using DarkTonic.MasterAudio; using FishnetInvector; using UnityEngine; public class WeaponChoosingMenuController : MonoBehaviour { public static WeaponChoosingMenuController Instance { get; private set; } [SerializeField] private WeaponCard[] _weaponCards; private UICanvasGroupDecorator _weaponChoosingMenuCanvasGroupDecorator; public string ClassName => _className ??= StringToHexColor.GetColoredClassName(GetType()); private string _className; private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } _weaponChoosingMenuCanvasGroupDecorator = GetComponent<UICanvasGroupDecorator>(); StartCoroutine(LocalPlayerInitListener()); } private IEnumerator LocalPlayerInitListener() { yield return new WaitUntil(() => FishnetInvectorManager.IsLocalPlayerInitialized); FishnetInvectorManager_OnLocalPlayerInitialized();  ",
          "content_tokens": 222,
          "embedding": []
        },
        {
          "cs_scriptfile": "WeaponChoosingMenuController",
          "content": "private void FishnetInvectorManager_OnLocalPlayerInitialized() { Debug.Log($\"{ClassName} - FishnetInvectorManager_OnLocalPlayerInitialized\"); _weaponChoosingMenuCanvasGroupDecorator.Show(); for (int i = 0; i < _weaponCards.Length; i++) { _weaponCards[i].gameObject.SetActive(true); MasterAudio.PlaySound(\"Take_a_card_1\"); }  public void Hide() { _weaponChoosingMenuCanvasGroupDecorator.Hide(); for (int i = 0; i < _weaponCards.Length; i++) { _weaponCards[i].gameObject.SetActive(false); } } }",
          "content_tokens": 155,
          "embedding": []
        }
      ],
      "length": 1368
    },
    {
      "filename": "ItemVariantEditor",
      "content": "using System; using System.Collections.Generic; using Invector.vItemManager; using UnityEditor; using UnityEngine; [CustomEditor(typeof(ItemVariant))] public class ItemVariantEditor : Editor { private ItemVariant Item { get { if (_item == null) { _item = (ItemVariant)target; } return _item; } } private ItemVariant _item; private const float COLUMN_WIDTH_ICON = 50; public override void OnInspectorGUI() { serializedObject.Update(); EditorGUILayout.LabelField(\"Item Variant\", EditorStyles.boldLabel); SerializedProperty nameProp = serializedObject.FindProperty(\"Name\"); EditorGUILayout.PropertyField(nameProp); SerializedProperty descriptionProp = serializedObject.FindProperty(\"description\"); EditorGUILayout.PropertyField(descriptionProp); SerializedProperty typeProp = serializedObject.FindProperty(\"type\"); EditorGUILayout.PropertyField(typeProp); EditorGUILayout.BeginHorizontal(EditorStyles.helpBox); { foreach (var rarityIcon in Item.rarityIcons) { EditorGUILayout.BeginVertical(); { rarityIcon.Icon = (Sprite)EditorGUILayout.ObjectField(GUIContent.none, rarityIcon.Icon, typeof(Sprite), false, GUILayout.Width(COLUMN_WIDTH_ICON), GUILayout.Height(COLUMN_WIDTH_ICON)); rarityIcon.Rarity = (vItem.Rarity)EditorGUILayout.EnumPopup(rarityIcon.Rarity, GUILayout.Width(COLUMN_WIDTH_ICON)); } EditorGUILayout.EndVertical(); } EditorGUILayout.BeginVertical(EditorStyles.helpBox); { if (GUILayout.Button(\"+\", GUILayout.Width(COLUMN_WIDTH_ICON), GUILayout.Height(COLUMN_WIDTH_ICON))) { Item.rarityIcons.Add(new ItemVariant.RarityIcons()); } Rect dropArea = GUILayoutUtility.GetRect(COLUMN_WIDTH_ICON, COLUMN_WIDTH_ICON); EditorGUI.DropShadowLabel(dropArea, \"Drop Sprites Here\"); Event evt = Event.current; if (dropArea.Contains(evt.mousePosition)) { if (evt.type == EventType.DragUpdated) { DragAndDrop.visualMode = DragAndDropVisualMode.Copy; evt.Use(); } else if (evt.type == EventType.DragPerform) { DragAndDrop.AcceptDrag(); List<Sprite> droppedSprites = new List<Sprite>(); foreach (UnityEngine.Object draggedObject in DragAndDrop.objectReferences) { if (draggedObject is Sprite sprite) { droppedSprites.Add(sprite); } } foreach (Sprite sprite in droppedSprites) { Item.rarityIcons.Add(new ItemVariant.RarityIcons { Icon = sprite, Rarity = (vItem.Rarity)(droppedSprites.IndexOf(sprite) + 1) }); } evt.Use(); } } } EditorGUILayout.EndVertical(); } EditorGUILayout.EndHorizontal(); // Remove empty rarities after adding new rarities with sprites Item.rarityIcons.RemoveAll(rarity => rarity.Icon == null); SerializedProperty equipAreaProp = serializedObject.FindProperty(\"equipArea\"); EditorGUILayout.PropertyField(equipAreaProp); if (_item.originalObject == null) { string assetPath = \"Assets/-ZombieRoyale/Prefabs/Non-networked/EmptyItem_Inventory.prefab\"; _item.originalObject = AssetDatabase.LoadAssetAtPath<GameObject>(assetPath); } SerializedProperty originalObjectProp = serializedObject.FindProperty(\"originalObject\"); EditorGUILayout.PropertyField(originalObjectProp); SerializedProperty dropObjectProp = serializedObject.FindProperty(\"dropObject\"); EditorGUILayout.PropertyField(dropObjectProp); SerializedProperty armorIdProp = serializedObject.FindProperty(\"ArmorId\"); EditorGUILayout.PropertyField(armorIdProp); SerializedProperty isArmorItemProp = serializedObject.FindProperty(\"isArmorItem\"); EditorGUILayout.PropertyField(isArmorItemProp); SerializedProperty stackableProp = serializedObject.FindProperty(\"stackable\"); EditorGUILayout.PropertyField(stackableProp); if (Item.stackable) { Item.maxStack = EditorGUILayout.IntField(\"Max Stack\", Item.maxStack, GUILayout.Width(50)); } serializedObject.ApplyModifiedProperties(); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ItemVariantEditor",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemVariantEditor",
          "content": "using System; using System.Collections.Generic; using Invector.vItemManager; using UnityEditor; using UnityEngine; [CustomEditor(typeof(ItemVariant))] public class ItemVariantEditor : Editor { private ItemVariant Item { get { if (_item == null) { _item = (ItemVariant)target; } return _item; } } private ItemVariant _item; private const float COLUMN_WIDTH_ICON = 50; public override void OnInspectorGUI() { serializedObject.Update(); EditorGUILayout.LabelField(\"Item Variant\", EditorStyles.boldLabel); SerializedProperty nameProp = serializedObject.FindProperty(\"Name\"); EditorGUILayout.PropertyField(nameProp); SerializedProperty descriptionProp = serializedObject.FindProperty(\"description\"); EditorGUILayout.PropertyField(descriptionProp); SerializedProperty typeProp = serializedObject.FindProperty(\"type\"); EditorGUILayout.PropertyField(typeProp); EditorGUILayout.BeginHorizontal(EditorStyles.helpBox); { foreach (var rarityIcon in Item.rarityIcons) { EditorGUILayout.BeginVertical(); { rarityIcon.Icon = (Sprite)EditorGUILayout.ObjectField(GUIContent.none, rarityIcon.Icon, typeof(Sprite), false, GUILayout.Width(COLUMN_WIDTH_ICON), GUILayout.Height(COLUMN_WIDTH_ICON)); rarityIcon.Rarity = (vItem.Rarity)EditorGUILayout.EnumPopup(rarityIcon.Rarity, GUILayout.Width(COLUMN_WIDTH_ICON)); } EditorGUILayout.EndVertical(); } EditorGUILayout.BeginVertical(EditorStyles.helpBox); { if (GUILayout.Button(\"+\", GUILayout.Width(COLUMN_WIDTH_ICON), GUILayout.Height(COLUMN_WIDTH_ICON))) { Item.rarityIcons.Add(new ItemVariant.RarityIcons()); } Rect dropArea = GUILayoutUtility.GetRect(COLUMN_WIDTH_ICON, COLUMN_WIDTH_ICON); EditorGUI.DropShadowLabel(dropArea, \"Drop Sprites Here\"); Event evt = Event.current; if (dropArea.Contains(evt.mousePosition)) { if (evt.type == EventType.DragUpdated) { DragAndDrop.visualMode = DragAndDropVisualMode.Copy; evt.Use(); } else if (evt.type == EventType.DragPerform) { DragAndDrop.AcceptDrag(); List<Sprite> droppedSprites = new List<Sprite>(); foreach (UnityEngine.Object draggedObject in DragAndDrop.objectReferences) { if (draggedObject is Sprite sprite) { droppedSprites.Add(sprite); }  ",
          "content_tokens": 672,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemVariantEditor",
          "content": "foreach (Sprite sprite in droppedSprites) { Item.rarityIcons.Add(new ItemVariant.RarityIcons { Icon = sprite, Rarity = (vItem.Rarity)(droppedSprites.IndexOf(sprite) + 1) }); } evt.Use(); } } } EditorGUILayout.EndVertical(); } EditorGUILayout.EndHorizontal(); // Remove empty rarities after adding new rarities with sprites Item.rarityIcons.RemoveAll(rarity => rarity.Icon == null); SerializedProperty equipAreaProp = serializedObject.FindProperty(\"equipArea\"); EditorGUILayout.PropertyField(equipAreaProp); if (_item.originalObject == null) { string assetPath = \"Assets/-ZombieRoyale/Prefabs/Non-networked/EmptyItem_Inventory.prefab\"; _item.originalObject = AssetDatabase.LoadAssetAtPath<GameObject>(assetPath); } SerializedProperty originalObjectProp = serializedObject.FindProperty(\"originalObject\"); EditorGUILayout.PropertyField(originalObjectProp); SerializedProperty dropObjectProp = serializedObject.FindProperty(\"dropObject\"); EditorGUILayout.PropertyField(dropObjectProp); SerializedProperty armorIdProp = serializedObject.FindProperty(\"ArmorId\"); EditorGUILayout.PropertyField(armorIdProp); SerializedProperty isArmorItemProp = serializedObject.FindProperty(\"isArmorItem\"); EditorGUILayout.PropertyField(isArmorItemProp); SerializedProperty stackableProp = serializedObject.FindProperty(\"stackable\"); EditorGUILayout.PropertyField(stackableProp); if (Item.stackable) { Item.maxStack = EditorGUILayout.IntField(\"Max Stack\", Item.maxStack, GUILayout.Width(50)); } serializedObject.ApplyModifiedProperties(); } }",
          "content_tokens": 421,
          "embedding": []
        }
      ],
      "length": 3644
    },
    {
      "filename": "ItemVariantHolderEditor",
      "content": "using System.Collections.Generic; using Invector.vItemManager; using Unity.VisualScripting; using UnityEditor; using UnityEngine; [CustomEditor(typeof(ItemVariantHolder))] public class ItemVariantHolderEditor : Editor { [SerializeField] private List<GeneratorSettings> _generatorSettingsList = new List<GeneratorSettings>(); private int _settingsAmount = 1; private List<Sprite> droppedSprites = new List<Sprite>(); private int itemsToCreate = 4; private bool _isPropertySerialized; private string _itemNames; private string _itemDescriptions; public override void OnInspectorGUI() { serializedObject.Update(); // Draw the default inspector base.OnInspectorGUI(); DrawCustomGUI(); serializedObject.ApplyModifiedProperties(); } private void DrawCustomGUI() { ItemVariantHolder itemVariantHolder = (ItemVariantHolder)target; if (GUILayout.Button(\"Update Item Variants\")) { itemVariantHolder.ItemVariantInfos = LoadItemVariantsInSameFolder(itemVariantHolder); EditorUtility.SetDirty(itemVariantHolder); } EditorGUILayout.Space(); while (_generatorSettingsList.Count < _settingsAmount) { _generatorSettingsList.Add(new GeneratorSettings()); } _settingsAmount = EditorGUILayout.IntField(\"Settings amount\", _settingsAmount); foreach (var generatorSetting in _generatorSettingsList) { EditorGUILayout.BeginHorizontal(); EditorGUILayout.LabelField(\"Armor start index\", GUILayout.Width(66)); generatorSetting.armorIndex = EditorGUILayout.IntField(generatorSetting.armorIndex, GUILayout.Width(30)); EditorGUILayout.LabelField(\"startFromSpriteIndex\", GUILayout.Width(100)); generatorSetting.startFromSpriteIndex = EditorGUILayout.IntField(generatorSetting.startFromSpriteIndex, GUILayout.Width(30)); EditorGUILayout.LabelField(\"endAtSpriteIndex\", GUILayout.Width(100)); generatorSetting.endAtSpriteIndex = EditorGUILayout.IntField(generatorSetting.endAtSpriteIndex, GUILayout.Width(30)); EditorGUILayout.LabelField(\"armor type\", GUILayout.Width(80)); generatorSetting.equipArea = (vItem.EquipAreaNames)EditorGUILayout.EnumPopup(generatorSetting.equipArea, GUILayout.Width(70)); EditorGUILayout.EndHorizontal(); } _itemNames = EditorGUILayout.TextField(\"Item names\", _itemNames); _itemDescriptions = EditorGUILayout.TextField(\"Item descriptions\", _itemDescriptions); EditorGUILayout.LabelField(\"Drop Sprites Here:\"); Rect dropArea = GUILayoutUtility.GetRect(EditorGUIUtility.currentViewWidth, 50); EditorGUI.DropShadowLabel(dropArea, \"Drop Sprites Here\"); Event evt = Event.current; if (dropArea.Contains(evt.mousePosition)) { if (evt.type == EventType.DragUpdated) { DragAndDrop.visualMode = DragAndDropVisualMode.Copy; evt.Use(); } else if (evt.type == EventType.DragPerform) { DragAndDrop.AcceptDrag(); droppedSprites.Clear(); foreach (UnityEngine.Object draggedObject in DragAndDrop.objectReferences) { if (draggedObject is Sprite sprite) { droppedSprites.Add(sprite); } } evt.Use(); } } if (droppedSprites.Count >= 4) { if (GUILayout.Button(\"Create Item Variant\")) { CreateItemVariantFromSprites(itemVariantHolder); } } } private void CreateItemVariantFromSprites(ItemVariantHolder holder) { if (droppedSprites.Count % itemsToCreate != 0) { Debug.LogError(\"Dropped sprites count is not a multiple of \" + itemsToCreate); return; } string holderFolderPath = System.IO.Path.GetDirectoryName(AssetDatabase.GetAssetPath(holder)); string[] itemNames = _itemNames.Split(';'); string[] itemDescriptions = _itemDescriptions.Split(';'); for (int i = 0; i < droppedSprites.Count; i++) { if (i % itemsToCreate == 0) { ItemVariant newItemVariant = ScriptableObject.CreateInstance<ItemVariant>(); var indexForArmorSettings = i / itemsToCreate; if (itemNames.Length > indexForArmorSettings) { newItemVariant.Name = itemNames[indexForArmorSettings]; newItemVariant.description = itemDescriptions[indexForArmorSettings]; } else { newItemVariant.Name = \"ItemVariant\" + (holder.ItemVariantInfos.Count + 1); } int armorIndex = 0; vItem.EquipAreaNames equipName = vItem.EquipAreaNames.amulet; foreach (var genSettings in _generatorSettingsList) { if (indexForArmorSettings >= genSettings.startFromSpriteIndex && indexForArmorSettings <= genSettings.endAtSpriteIndex) { armorIndex = genSettings.armorIndex + indexForArmorSettings - genSettings.startFromSpriteIndex; equipName = genSettings.equipArea; break; } } newItemVariant.ArmorId = armorIndex; newItemVariant.equipArea = equipName; for (int j = 0; j < itemsToCreate; j++) { if (i + j < droppedSprites.Count) { newItemVariant.rarityIcons.Add(new ItemVariant.RarityIcons { Icon = droppedSprites[i + j], Rarity = (vItem.Rarity)(j + 1) }); //change armor index, according startFrom, endAt, armorType fields of holder class } } string newItemVariantPath = System.IO.Path.Combine(holderFolderPath+\"/ItemVariants/\", $\"{i}{newItemVariant.Name}.asset\"); AssetDatabase.CreateAsset(newItemVariant, newItemVariantPath); holder.ItemVariantInfos.Add(newItemVariant); } } EditorUtility.SetDirty(holder); } private List<ItemVariant> LoadItemVariantsInSameFolder(ItemVariantHolder holder) { List<ItemVariant> itemVariants = new List<ItemVariant>(); string holderAssetPath = AssetDatabase.GetAssetPath(holder); string holderFolderPath = System.IO.Path.GetDirectoryName(holderAssetPath); string[] assetGuids = AssetDatabase.FindAssets(\"t:\" + typeof(ItemVariant).Name, new[] { holderFolderPath }); foreach (string assetGuid in assetGuids) { string assetPath = AssetDatabase.GUIDToAssetPath(assetGuid); ItemVariant itemVariant = AssetDatabase.LoadAssetAtPath<ItemVariant>(assetPath); if (itemVariant != null) { itemVariants.Add(itemVariant); } } return itemVariants; } public class GeneratorSettings { public int startFromSpriteIndex; public int endAtSpriteIndex; public vItem.EquipAreaNames equipArea = vItem.EquipAreaNames.shoulders; public int armorIndex; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ItemVariantHolderEditor",
          "content": "using System.Collections.Generic; using Invector.vItemManager; using Unity.VisualScripting; using UnityEditor; using UnityEngine; [CustomEditor(typeof(ItemVariantHolder))] public class ItemVariantHolderEditor : Editor { [SerializeField] private List<GeneratorSettings> _generatorSettingsList = new List<GeneratorSettings>(); private int _settingsAmount = 1; private List<Sprite> droppedSprites = new List<Sprite>(); private int itemsToCreate = 4; private bool _isPropertySerialized; private string _itemNames; private string _itemDescriptions; public override void OnInspectorGUI() { serializedObject.Update(); // Draw the default inspector base.OnInspectorGUI(); DrawCustomGUI(); serializedObject.ApplyModifiedProperties();  ",
          "content_tokens": 182,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemVariantHolderEditor",
          "content": "private void DrawCustomGUI() { ItemVariantHolder itemVariantHolder = (ItemVariantHolder)target; if (GUILayout.Button(\"Update Item Variants\")) { itemVariantHolder.ItemVariantInfos = LoadItemVariantsInSameFolder(itemVariantHolder); EditorUtility.SetDirty(itemVariantHolder); } EditorGUILayout.Space(); while (_generatorSettingsList.Count < _settingsAmount) { _generatorSettingsList.Add(new GeneratorSettings()); } _settingsAmount = EditorGUILayout.IntField(\"Settings amount\", _settingsAmount); foreach (var generatorSetting in _generatorSettingsList) { EditorGUILayout.BeginHorizontal(); EditorGUILayout.LabelField(\"Armor start index\", GUILayout.Width(66)); generatorSetting.armorIndex = EditorGUILayout.IntField(generatorSetting.armorIndex, GUILayout.Width(30)); EditorGUILayout.LabelField(\"startFromSpriteIndex\", GUILayout.Width(100)); generatorSetting.startFromSpriteIndex = EditorGUILayout.IntField(generatorSetting.startFromSpriteIndex, GUILayout.Width(30)); EditorGUILayout.LabelField(\"endAtSpriteIndex\", GUILayout.Width(100)); generatorSetting.endAtSpriteIndex = EditorGUILayout.IntField(generatorSetting.endAtSpriteIndex, GUILayout.Width(30)); EditorGUILayout.LabelField(\"armor type\", GUILayout.Width(80)); generatorSetting.equipArea = (vItem.EquipAreaNames)EditorGUILayout.EnumPopup(generatorSetting.equipArea, GUILayout.Width(70)); EditorGUILayout.EndHorizontal(); } _itemNames = EditorGUILayout.TextField(\"Item names\", _itemNames); _itemDescriptions = EditorGUILayout.TextField(\"Item descriptions\", _itemDescriptions); EditorGUILayout.LabelField(\"Drop Sprites Here:\"); Rect dropArea = GUILayoutUtility.GetRect(EditorGUIUtility.currentViewWidth, 50); EditorGUI.DropShadowLabel(dropArea, \"Drop Sprites Here\"); Event evt = Event.current; if (dropArea.Contains(evt.mousePosition)) { if (evt.type == EventType.DragUpdated) { DragAndDrop.visualMode = DragAndDropVisualMode.Copy; evt.Use(); } else if (evt.type == EventType.DragPerform) { DragAndDrop.AcceptDrag(); droppedSprites.Clear(); foreach (UnityEngine.Object draggedObject in DragAndDrop.objectReferences) { if (draggedObject is Sprite sprite) { droppedSprites.Add(sprite); } } evt.Use(); }  ",
          "content_tokens": 647,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemVariantHolderEditor",
          "content": "if (droppedSprites.Count >= 4) { if (GUILayout.Button(\"Create Item Variant\")) { CreateItemVariantFromSprites(itemVariantHolder); } }  ",
          "content_tokens": 44,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemVariantHolderEditor",
          "content": "private void CreateItemVariantFromSprites(ItemVariantHolder holder) { if (droppedSprites.Count % itemsToCreate != 0) { Debug.LogError(\"Dropped sprites count is not a multiple of \" + itemsToCreate); return; } string holderFolderPath = System.IO.Path.GetDirectoryName(AssetDatabase.GetAssetPath(holder)); string[] itemNames = _itemNames.Split(';'); string[] itemDescriptions = _itemDescriptions.Split(';'); for (int i = 0; i < droppedSprites.Count; i++) { if (i % itemsToCreate == 0) { ItemVariant newItemVariant = ScriptableObject.CreateInstance<ItemVariant>(); var indexForArmorSettings = i / itemsToCreate; if (itemNames.Length > indexForArmorSettings) { newItemVariant.Name = itemNames[indexForArmorSettings]; newItemVariant.description = itemDescriptions[indexForArmorSettings]; } else { newItemVariant.Name = \"ItemVariant\" + (holder.ItemVariantInfos.Count + 1); } int armorIndex = 0; vItem.EquipAreaNames equipName = vItem.EquipAreaNames.amulet; foreach (var genSettings in _generatorSettingsList) { if (indexForArmorSettings >= genSettings.startFromSpriteIndex && indexForArmorSettings <= genSettings.endAtSpriteIndex) { armorIndex = genSettings.armorIndex + indexForArmorSettings - genSettings.startFromSpriteIndex; equipName = genSettings.equipArea; break; } } newItemVariant.ArmorId = armorIndex; newItemVariant.equipArea = equipName; for (int j = 0; j < itemsToCreate; j++) { if (i + j < droppedSprites.Count) { newItemVariant.rarityIcons.Add(new ItemVariant.RarityIcons { Icon = droppedSprites[i + j], Rarity = (vItem.Rarity)(j + 1) }); //change armor index, according startFrom, endAt, armorType fields of holder class } } string newItemVariantPath = System.IO.Path.Combine(holderFolderPath+\"/ItemVariants/\", $\"{i}{newItemVariant.Name}.asset\"); AssetDatabase.CreateAsset(newItemVariant, newItemVariantPath); holder.ItemVariantInfos.Add(newItemVariant); } } EditorUtility.SetDirty(holder); } private List<ItemVariant> LoadItemVariantsInSameFolder(ItemVariantHolder holder) { List<ItemVariant> itemVariants = new List<ItemVariant>(); string holderAssetPath = AssetDatabase.GetAssetPath(holder); string holderFolderPath = System.IO.Path.GetDirectoryName(holderAssetPath); string[] assetGuids = AssetDatabase.FindAssets(\"t:\" + typeof(ItemVariant).Name, new[] { holderFolderPath }); foreach (string assetGuid in assetGuids) { string assetPath = AssetDatabase.GUIDToAssetPath(assetGuid); ItemVariant itemVariant = AssetDatabase.LoadAssetAtPath<ItemVariant>(assetPath); if (itemVariant != null) { itemVariants.Add(itemVariant); } } return itemVariants; } public class GeneratorSettings { public int startFromSpriteIndex; public int endAtSpriteIndex; public vItem.EquipAreaNames equipArea = vItem.EquipAreaNames.shoulders; public int armorIndex; } }",
          "content_tokens": 798,
          "embedding": []
        }
      ],
      "length": 5767
    },
    {
      "filename": "ItemRarityAttributesInfo",
      "content": "using System.Collections; using System.Collections.Generic; using Invector.vItemManager; using UnityEngine; //create asset menu [CreateAssetMenu(fileName = \"CommonRarityToAttributes\", menuName = \"ScriptableObjects/Item Rarity To Attributes\")] public class ItemRarityAttributesInfo : ScriptableObject { public vItemType itemType = vItemType.Armor; public vItem.Rarity rarity; public List<vItemAttribute> staticAttributes; public float minStaticAttributeValues; public float maxStaticAttributeValues; public List<vItemAttribute> dynamicAttributes; public float minAttributeValues; public float maxAttributeValues; public List<vItemAttribute> GetAttributes() { List<vItemAttribute> attributes = new List<vItemAttribute>(); if (staticAttributes.Count > 0) { foreach (vItemAttribute attr in staticAttributes) { var newAttr = new vItemAttribute(attr); GenerateStaticAttribute(newAttr, attributes, minStaticAttributeValues, maxStaticAttributeValues); } } GenerateDynamicAttributes(dynamicAttributes.CopyAsNew(), attributes, minAttributeValues, maxAttributeValues); return attributes; } private void GenerateStaticAttribute(vItemAttribute attr, List<vItemAttribute> attributesToFill, float min, float max) { float value = Random.Range(min, max); //round 2 digits after dot attr.value = Mathf.Round(value * 100f) / 100f; attributesToFill.Add(attr); } private void GenerateDynamicAttributes(List<vItemAttribute> attributes, List<vItemAttribute> attributesToFill, float min, float max) { int attributesCount = RarityToAttributeCount(rarity); List<vItemAttribute> selectedAttributes = new List<vItemAttribute>(); for (int i = 0; i < attributesCount; i++) { int random = Random.Range(0, attributes.Count); selectedAttributes.Add(attributes[random]); attributes.RemoveAt(random); } foreach (var selectedAttribute in selectedAttributes) { float value = Random.Range(min, max); selectedAttribute.value = Mathf.Round(value * 100f) / 100f; } attributesToFill.AddRange(selectedAttributes); } private int RarityToAttributeCount(vItem.Rarity rarity) { switch (rarity) { case vItem.Rarity.Common: return 1; case vItem.Rarity.Uncommon: return 1; case vItem.Rarity.Rare: return 2; case vItem.Rarity.Epic: return 2; case vItem.Rarity.Legendary: return 3; } return 1; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ItemRarityAttributesInfo",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemRarityAttributesInfo",
          "content": "using System.Collections; using System.Collections.Generic; using Invector.vItemManager; using UnityEngine; //create asset menu [CreateAssetMenu(fileName = \"CommonRarityToAttributes\", menuName = \"ScriptableObjects/Item Rarity To Attributes\")] public class ItemRarityAttributesInfo : ScriptableObject { public vItemType itemType = vItemType.Armor; public vItem.Rarity rarity; public List<vItemAttribute> staticAttributes; public float minStaticAttributeValues; public float maxStaticAttributeValues; public List<vItemAttribute> dynamicAttributes; public float minAttributeValues; public float maxAttributeValues; public List<vItemAttribute> GetAttributes() { List<vItemAttribute> attributes = new List<vItemAttribute>(); if (staticAttributes.Count > 0) { foreach (vItemAttribute attr in staticAttributes) { var newAttr = new vItemAttribute(attr); GenerateStaticAttribute(newAttr, attributes, minStaticAttributeValues, maxStaticAttributeValues); }  ",
          "content_tokens": 225,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemRarityAttributesInfo",
          "content": "GenerateDynamicAttributes(dynamicAttributes.CopyAsNew(), attributes, minAttributeValues, maxAttributeValues); return attributes;  private void GenerateStaticAttribute(vItemAttribute attr, List<vItemAttribute> attributesToFill, float min, float max) { float value = Random.Range(min, max); //round 2 digits after dot attr.value = Mathf.Round(value * 100f) / 100f; attributesToFill.Add(attr);  ",
          "content_tokens": 103,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemRarityAttributesInfo",
          "content": "private void GenerateDynamicAttributes(List<vItemAttribute> attributes, List<vItemAttribute> attributesToFill, float min, float max) { int attributesCount = RarityToAttributeCount(rarity); List<vItemAttribute> selectedAttributes = new List<vItemAttribute>(); for (int i = 0; i < attributesCount; i++) { int random = Random.Range(0, attributes.Count); selectedAttributes.Add(attributes[random]); attributes.RemoveAt(random);  foreach (var selectedAttribute in selectedAttributes) { float value = Random.Range(min, max); selectedAttribute.value = Mathf.Round(value * 100f) / 100f; } attributesToFill.AddRange(selectedAttributes);  ",
          "content_tokens": 161,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemRarityAttributesInfo",
          "content": "private int RarityToAttributeCount(vItem.Rarity rarity) { switch (rarity) { case vItem.Rarity.Common: return 1; case vItem.Rarity.Uncommon: return 1; case vItem.Rarity.Rare: return 2; case vItem.Rarity.Epic: return 2; case vItem.Rarity.Legendary: return 3; } return 1; } }",
          "content_tokens": 88,
          "embedding": []
        }
      ],
      "length": 2246
    },
    {
      "filename": "ItemRarityAttributesInfoHolder",
      "content": "using System.Collections; using System.Collections.Generic; using Invector.vItemManager; using UnityEngine; //[CreateAssetMenu(fileName = \"ItemRarityAttributesInfoHolder\", menuName = \"ScriptableObjects/ItemRarityAttributesInfoHolder\")] public class ItemRarityAttributesInfoHolder : ScriptableObject { [SerializeField] private List<ItemRarityAttributesInfo> itemRarityAttributesInfoList = new List<ItemRarityAttributesInfo>(); public ItemRarityAttributesInfo GetItemRarityAttributesInfo(vItemType itemType, vItem.Rarity rarity) { foreach (ItemRarityAttributesInfo itemRarityAttributesInfo in itemRarityAttributesInfoList) { if (itemRarityAttributesInfo.itemType == itemType) { if (itemRarityAttributesInfo.rarity == rarity) { return itemRarityAttributesInfo; } } } Debug.LogError($\"[ItemRarityAttributesInfoHolder] ItemRarityAttributesInfo not found for itemType: {itemType} and rarity: {rarity}\"); return null; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ItemRarityAttributesInfoHolder",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemRarityAttributesInfoHolder",
          "content": "using System.Collections; using System.Collections.Generic; using Invector.vItemManager; using UnityEngine; //[CreateAssetMenu(fileName = \"ItemRarityAttributesInfoHolder\", menuName = \"ScriptableObjects/ItemRarityAttributesInfoHolder\")] public class ItemRarityAttributesInfoHolder : ScriptableObject { [SerializeField] private List<ItemRarityAttributesInfo> itemRarityAttributesInfoList = new List<ItemRarityAttributesInfo>(); public ItemRarityAttributesInfo GetItemRarityAttributesInfo(vItemType itemType, vItem.Rarity rarity) { foreach (ItemRarityAttributesInfo itemRarityAttributesInfo in itemRarityAttributesInfoList) { if (itemRarityAttributesInfo.itemType == itemType) { if (itemRarityAttributesInfo.rarity == rarity) { return itemRarityAttributesInfo; } } } Debug.LogError($\"[ItemRarityAttributesInfoHolder] ItemRarityAttributesInfo not found for itemType: {itemType} and rarity: {rarity}\"); return null; } }",
          "content_tokens": 236,
          "embedding": []
        }
      ],
      "length": 915
    },
    {
      "filename": "ItemVariant",
      "content": "using System; using System.Collections.Generic; using Invector.vItemManager; using UnityEngine; using UnityEngine.Serialization; //create asset menu [CreateAssetMenu(fileName = \"ItemVariant\", menuName = \"ScriptableObjects/Item Variant\")] public class ItemVariant : ScriptableObject { /// <summary> /// Determines which GameObject in skin list to use /// </summary> public int ArmorId; public string Name; public vItemType type = vItemType.Armor; public List<RarityIcons> rarityIcons = new List<RarityIcons>(); public vItem.EquipAreaNames equipArea; public string description; public GameObject originalObject; public GameObject dropObject; public bool isArmorItem = true; public bool stackable; public int maxStack; [Serializable] public class RarityIcons { public vItem.Rarity Rarity; public Sprite Icon; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ItemVariant",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "ItemVariant",
          "content": "using System; using System.Collections.Generic; using Invector.vItemManager; using UnityEngine; using UnityEngine.Serialization; //create asset menu [CreateAssetMenu(fileName = \"ItemVariant\", menuName = \"ScriptableObjects/Item Variant\")] public class ItemVariant : ScriptableObject { /// <summary> /// Determines which GameObject in skin list to use /// </summary> public int ArmorId; public string Name; public vItemType type = vItemType.Armor; public List<RarityIcons> rarityIcons = new List<RarityIcons>(); public vItem.EquipAreaNames equipArea; public string description; public GameObject originalObject; public GameObject dropObject; public bool isArmorItem = true; public bool stackable; public int maxStack; [Serializable] public class RarityIcons { public vItem.Rarity Rarity; public Sprite Icon; } }",
          "content_tokens": 201,
          "embedding": []
        }
      ],
      "length": 810
    },
    {
      "filename": "ItemVariantHolder",
      "content": "using System.Collections.Generic; using UnityEngine; //[CreateAssetMenu(fileName = \"SOItemVariantHolder\", menuName = \"ScriptableObjects/ItemVariantHolder\")] public class ItemVariantHolder : ScriptableObject { public List<ItemVariant> ItemVariantInfos; } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ItemVariantHolder",
          "content": "using System.Collections.Generic; using UnityEngine; //[CreateAssetMenu(fileName = \"SOItemVariantHolder\", menuName = \"ScriptableObjects/ItemVariantHolder\")] public class ItemVariantHolder : ScriptableObject { public List<ItemVariant> ItemVariantInfos; }",
          "content_tokens": 70,
          "embedding": []
        }
      ],
      "length": 254
    },
    {
      "filename": "AnswerShow",
      "content": "using TMPro; using UnityEngine; using Zomb.Creatures.Helpers; public class AnswerShow : MonoBehaviour { [SerializeField] private AnimatorDecorator animatorDecorator; [SerializeField] private TextMeshProUGUI textDialogue; [SerializeField] private PersonalityPlayerDetector playerDetector; private void OnEnable() { playerDetector.OnPlayerEnter += AttachAnswerShowing; playerDetector.OnPlayerExit += DeattachAnswerShowing; } private void OnDisable() { playerDetector.OnPlayerEnter -= AttachAnswerShowing; playerDetector.OnPlayerExit -= DeattachAnswerShowing; } private void DeattachAnswerShowing() { PersonalityCommunicator.OnAnswerReceived -= UpdateAnswerText; PersonalityCommunicator.OnAnswerFinished -= ShowAnswerFinished; PersonalityCommunicator.OnStartThinking -= ShowQuestion; } private void AttachAnswerShowing() { PersonalityCommunicator.OnAnswerReceived += UpdateAnswerText; PersonalityCommunicator.OnAnswerFinished += ShowAnswerFinished; PersonalityCommunicator.OnStartThinking += ShowQuestion; } private void ShowQuestion(string question) { textDialogue.text = $\"You: {question}\"; textDialogue.alpha = .3f; animatorDecorator.SetBool(\"IsThinking\", true); } private void ShowAnswerFinished() { textDialogue.alpha = 1f; animatorDecorator.SetBool(\"IsTalking\", false); } private void UpdateAnswerText(string answer) { textDialogue.text = answer; textDialogue.alpha = .3f; animatorDecorator.SetBool(\"IsTalking\", true); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AnswerShow",
          "content": "using TMPro; using UnityEngine; using Zomb.Creatures.Helpers; public class AnswerShow : MonoBehaviour { [SerializeField] private AnimatorDecorator animatorDecorator; [SerializeField] private TextMeshProUGUI textDialogue; [SerializeField] private PersonalityPlayerDetector playerDetector; private void OnEnable() { playerDetector.OnPlayerEnter += AttachAnswerShowing; playerDetector.OnPlayerExit += DeattachAnswerShowing;  private void OnDisable() { playerDetector.OnPlayerEnter -= AttachAnswerShowing; playerDetector.OnPlayerExit -= DeattachAnswerShowing;  private void DeattachAnswerShowing() { PersonalityCommunicator.OnAnswerReceived -= UpdateAnswerText; PersonalityCommunicator.OnAnswerFinished -= ShowAnswerFinished; PersonalityCommunicator.OnStartThinking -= ShowQuestion;  ",
          "content_tokens": 192,
          "embedding": []
        },
        {
          "cs_scriptfile": "AnswerShow",
          "content": "private void AttachAnswerShowing() { PersonalityCommunicator.OnAnswerReceived += UpdateAnswerText; PersonalityCommunicator.OnAnswerFinished += ShowAnswerFinished; PersonalityCommunicator.OnStartThinking += ShowQuestion;  private void ShowQuestion(string question) { textDialogue.text = $\"You: {question}\"; textDialogue.alpha = .3f; animatorDecorator.SetBool(\"IsThinking\", true);  private void ShowAnswerFinished() { textDialogue.alpha = 1f; animatorDecorator.SetBool(\"IsTalking\", false);  private void UpdateAnswerText(string answer) { textDialogue.text = answer; textDialogue.alpha = .3f; animatorDecorator.SetBool(\"IsTalking\", true); } }",
          "content_tokens": 172,
          "embedding": []
        }
      ],
      "length": 1425
    },
    {
      "filename": "PersonalityCommunicatorEditor",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; [CustomEditor(typeof(PersonalityCommunicator))] public class PersonalityCommunicatorEditor : Editor { private PersonalityCommunicator _personalityCommunicator; private void OnEnable() { _personalityCommunicator = (PersonalityCommunicator)target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); if (GUILayout.Button(\"DoDialog\")) { _personalityCommunicator.DoDialog(); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PersonalityCommunicatorEditor",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; [CustomEditor(typeof(PersonalityCommunicator))] public class PersonalityCommunicatorEditor : Editor { private PersonalityCommunicator _personalityCommunicator; private void OnEnable() { _personalityCommunicator = (PersonalityCommunicator)target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); if (GUILayout.Button(\"DoDialog\")) { _personalityCommunicator.DoDialog(); } } }",
          "content_tokens": 118,
          "embedding": []
        }
      ],
      "length": 488
    },
    {
      "filename": "Hearing",
      "content": "using UnityEngine; /// <summary> /// Coordinates a hearing \"sense\" for haracters. /// </summary> public class Hearing : MonoBehaviour { // Hearing radius. If outside this radius, thing is not heard. public float mRadius = 10.0f; // Sphere collider used to detect entrance and exit of hearing radius. private SphereCollider mSphere; // Character hearing with this component. private Personality mOwner; /// <summary> /// This function is called when the object becomes enabled and active. /// </summary> private void OnEnable() { mOwner = GetComponentInParent<Personality>(); mSphere = GetComponent<SphereCollider>(); mSphere.radius = mRadius; CheckEarshot(); } /// <summary> /// When a GameObject collides with another GameObject, Unity calls /// OnTriggerEnter. /// </summary> /// <param name=\"other\"> /// The other collider. /// </param> private void OnTriggerEnter(Collider other) { // Other character, if any. Personality character = other.GetComponent<Personality>(); if (character && character != mOwner) character.onSayToOthers += mOwner.HearFromOther; } /// <summary> /// OnTriggerExit is called when the Collider other has stopped touching /// the trigger. /// </summary> /// <param name=\"other\"> /// The other collider. /// </param> private void OnTriggerExit(Collider other) { // Other character, if any. Personality character = other.GetComponent<Personality>(); if (character && character != mOwner) character.onSayToOthers -= mOwner.HearFromOther; } /// <summary> /// Checks if any characters are within earshot. /// </summary> private void CheckEarshot() { // Colliders within hearing radius. Collider[] colliders = Physics.OverlapSphere(transform.position, mRadius); // Found Character owner of a given collider. Personality character; foreach(Collider collider in colliders) { character = collider.GetComponent<Personality>(); if (character && character != mOwner) character.onSayToOthers += mOwner.HearFromOther; } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Hearing",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "Hearing",
          "content": "using UnityEngine; /// <summary> /// Coordinates a hearing \"sense\" for haracters. /// </summary> public class Hearing : MonoBehaviour { // Hearing radius. If outside this radius, thing is not heard. public float mRadius = 10.0f; // Sphere collider used to detect entrance and exit of hearing radius. private SphereCollider mSphere; // Character hearing with this component. private Personality mOwner; /// <summary> /// This function is called when the object becomes enabled and active. /// </summary> private void OnEnable() { mOwner = GetComponentInParent<Personality>(); mSphere = GetComponent<SphereCollider>(); mSphere.radius = mRadius; CheckEarshot(); } /// <summary> /// When a GameObject collides with another GameObject, Unity calls /// OnTriggerEnter. /// </summary> /// <param name=\"other\"> /// The other collider. /// </param> private void OnTriggerEnter(Collider other) { // Other character, if any. Personality character = other.GetComponent<Personality>(); if (character && character != mOwner) character.onSayToOthers += mOwner.HearFromOther; } /// <summary> /// OnTriggerExit is called when the Collider other has stopped touching /// the trigger. /// </summary> /// <param name=\"other\"> /// The other collider. /// </param> private void OnTriggerExit(Collider other) { // Other character, if any. Personality character = other.GetComponent<Personality>(); if (character && character != mOwner) character.onSayToOthers -= mOwner.HearFromOther; } /// <summary> /// Checks if any characters are within earshot. /// </summary> private void CheckEarshot() { // Colliders within hearing radius. Collider[] colliders = Physics.OverlapSphere(transform.position, mRadius); // Found Character owner of a given collider. Personality character; foreach(Collider collider in colliders) { character = collider.GetComponent<Personality>(); if (character && character != mOwner) character.onSayToOthers += mOwner.HearFromOther; } } }",
          "content_tokens": 468,
          "embedding": []
        }
      ],
      "length": 1937
    },
    {
      "filename": "Vision",
      "content": "using System.Collections.Generic; using UnityEngine; /// <summary> /// Detects describable objects able to be seen by this component. /// </summary> public class Vision : MonoBehaviour { /// <summary> /// Type of vision volume to represent field of view. /// </summary> private enum VisionVolumeType { SIMPLE, ELIPSED } /// <summary> /// Layer index for visible objects; things this component can see. /// </summary> [SerializeField] private int mVisibleLayerIndex = 7; /// <summary> /// How far away things can be seen byt his vision component. /// </summary> [SerializeField] private float mNearClip = 0.1f; /// <summary> /// How close things can be seen by this vision component. /// </summary> [SerializeField] private float mFarClip = 20.0f; /// <summary> /// Vision horizontal field of view for this character. /// Bounded between [1-179] to prevent undefined behavior. /// </summary> [vMinMax(1, 179)] [SerializeField] private int mFovHorizontal = 120; /// <summary> /// Vision vertical field of view for this character. /// Bounded between [1-179] to prevent undefined behavior. /// </summary> [vMinMax(1, 179)] [SerializeField] private int mFovVertical = 120; /// <summary> /// Type of vision volume to use, simple or eilipsed. /// </summary> [SerializeField] private VisionVolumeType mVolumeType = VisionVolumeType.SIMPLE; /// <summary> /// How many segments in the elipsed vision volume, if used. /// </summary> [SerializeField] private int mElipseSegments = 8; /// <summary> /// Layer mask used to discern visible objects from things that should be /// ignored. /// </summary> private int mVisibleLayerMask; /// <summary> /// Horizontal field of view, in radians. /// </summary> private float mAlpha; /// <summary> /// Half the horizontal fov in radians. /// </summary> private float mBeta; /// <summary> /// Cosine of half the horizontal fov. /// </summary> private float mCosBeta; /// <summary> /// Sin of half the horizontal fov. /// </summary> private float mSinBeta; /// <summary> /// Vertical field of view, in radians. /// </summary> private float mPsi; /// <summary> /// Half the vertical fov in radians. /// </summary> private float mOmega; /// <summary> /// Cosine of half the vertical fov. /// </summary> private float mCosOmega; /// <summary> /// Sin of half the vertical fov. /// </summary> private float mSinOmega; /// <summary> /// Mesh used to detect objects entering and exiting vision field of view. /// </summary> private Mesh mVisionMesh; /// <summary> /// Index vector used to build triangles for vision mesh. /// </summary> private static readonly int[] mTriangles = { 0, 3, 1, 2, 1, 3, 4, 5, 6, 6, 7, 4, 0, 1, 5, 5, 4, 0, 3, 6, 2, 7, 6, 3, 0, 7, 3, 4, 7, 0, 6, 5, 1, 1, 2, 6 }; /// <summary> /// Collider object built from mesh. /// </summary> private MeshCollider mCollider; /// <summary> /// Set of objects within field of view. As in, can be seen by this object. /// </summary> HashSet<GameObject> mWithinFov = new HashSet<GameObject>(); /// <summary> /// Options for collision mesh used to define field of view. /// </summary> private const MeshColliderCookingOptions mCookingOptions = MeshColliderCookingOptions.UseFastMidphase & MeshColliderCookingOptions.CookForFasterSimulation; /// <summary> /// Character owning this vision component. /// </summary> public Personality mOwner; /// <summary> /// Describable objects visible to this component. /// </summary> private IDescribable[] mSeen; /** Accessors and Setters **/ public IDescribable[] Seen { get => mSeen; } public int FovHorizontal { get => mFovHorizontal; } public int FovVertical { get => mFovVertical; } /// <summary> /// This function is called when the object becomes enabled and active. /// </summary> private void OnEnable() { mOwner = GetComponentInParent<Personality>(); mVisibleLayerMask = 1 << mVisibleLayerIndex; } /// <summary> /// When a GameObject collides with another GameObject, Unity calls /// OnTriggerEnter. /// </summary> /// <param name=\"other\"> /// The other collider. /// </param> private void OnTriggerEnter(Collider other) { // Detected describable object entering the field of view. IDescribable describable = other.GetComponent<IDescribable>(); if (describable != null) { mWithinFov.Add(other.gameObject); CheckSeen(); } } /// <summary> /// OnTriggerExit is called when the Collider other has stopped touching /// the trigger. /// </summary> /// <param name=\"other\"> /// The other collider. /// </param> private void OnTriggerExit(Collider other) { // Detected describable object exiting the field of view. IDescribable describable = other.GetComponent<IDescribable>(); if (describable != null) { mWithinFov.Remove(other.gameObject); CheckSeen(); } } /// <summary> /// Sets a new field of view, builds a new fov mesh, checks for new /// detections. /// </summary> /// <param name=\"newFovDegrees\"> /// New field of view value in degrees. /// </param> public void SetFov(int fovHorizontal, int fovVertical) { mFovHorizontal = fovHorizontal; mFovVertical = fovVertical; GenerateTrigParams(); mCollider = GetComponent<MeshCollider>(); mVisionMesh = GenerateVisionVolume(); Physics.BakeMesh(mVisionMesh.GetInstanceID(), false, mCookingOptions); mCollider.sharedMesh = mVisionMesh; mWithinFov.Clear(); CheckFieldOfView(); } /// <summary> /// Generates the appropriate vision volume mesh based on preference. /// </summary> /// <returns> /// Vision volume mesh. /// </returns> private Mesh GenerateVisionVolume() { // The generated vision volume to use. Mesh volume = null; switch (mVolumeType) { case VisionVolumeType.SIMPLE: volume = GenerateVisionVolumeSimple(); break; case VisionVolumeType.ELIPSED: volume = GenerateVisionVolumeElipsed(); break; } return volume; } /// <summary> /// Generates parametes used in trigometric operations. /// </summary> private void GenerateTrigParams() { mAlpha = ((float) mFovHorizontal) * Mathf.Deg2Rad; mBeta = mAlpha * 0.5f; mCosBeta = Mathf.Cos(mBeta); mSinBeta = Mathf.Sin(mBeta); mPsi = ((float)mFovVertical) * Mathf.Deg2Rad; mOmega = mPsi * 0.5f; mCosOmega = Mathf.Cos(mOmega); mSinOmega = Mathf.Sin(mOmega); } /// <summary> /// Generates mesh representing the volume of space things are visible within. /// </summary> /// <returns></returns> private Mesh GenerateVisionVolumeElipsed() { // The generated mesh. Mesh mesh = new Mesh(); // Step size for segment angles. float angleStep = mAlpha / (float)mElipseSegments; // Relative x coordinate of mesh near clip plane. float xNear = mSinBeta * mNearClip / mCosBeta; // Relative y coordinate of mesh near clip plane. float yNear = mSinOmega * mNearClip / mCosOmega; float yFar = mFarClip * mSinOmega; // Mesh is built in segments, gamma is angle of current segment. float gamma; // Sin of angle of current mesh segment. float sinGamma; // Cos of angle of current mesh segment. float cosGamma; // Far vertex x coordinate. float xFar; // Far vertex y coordinate. float zFar; // List of mesh triangles' vertex indicies. List<int> tris = new List<int>(); // List of verticies making up mesh. List<Vector3> verts = new List<Vector3>(); // This is very ugly and relies on a lot of magic numbers. // I apologize, but it was taking forever to get it to work and // in the end I said screw it. verts.Add(new Vector3(xNear, yNear, mNearClip)); verts.Add(new Vector3(-xNear, yNear, mNearClip)); verts.Add(new Vector3(-xNear, -yNear, mNearClip)); verts.Add(new Vector3(xNear, -yNear, mNearClip)); tris.Add(0); tris.Add(3); tris.Add(1); tris.Add(1); tris.Add(3); tris.Add(2); int i; for(i = 0; i <= mElipseSegments; i++) { gamma = -mBeta + (i * angleStep); sinGamma = Mathf.Sin(gamma); cosGamma = Mathf.Cos(gamma); xFar = mFarClip * sinGamma; zFar = mFarClip * cosGamma; verts.Add(new Vector3(xFar, yFar, zFar)); verts.Add(new Vector3(xFar, -yFar, zFar)); if(i > 0) { if(i < mElipseSegments - 1) { if(i <= mElipseSegments / 2) { tris.Add(verts.Count - 1); tris.Add(0); tris.Add(verts.Count - 3); tris.Add(verts.Count - 2); tris.Add(3); tris.Add(verts.Count - 4); tris.Add(verts.Count - 1); tris.Add(verts.Count - 3); tris.Add(verts.Count - 4); tris.Add(verts.Count - 1); tris.Add(verts.Count - 4); tris.Add(verts.Count - 2); } else { tris.Add(verts.Count - 1); tris.Add(1); tris.Add(verts.Count - 3); tris.Add(verts.Count - 2); tris.Add(2); tris.Add(verts.Count - 4); } } else { tris.Add(verts.Count - 2); tris.Add(1); tris.Add(2); tris.Add(verts.Count - 1); tris.Add(verts.Count - 2); tris.Add(2); } } else { tris.Add(0); tris.Add(4); tris.Add(5); tris.Add(3); tris.Add(0); tris.Add(5); } } mesh.vertices = verts.ToArray(); mesh.triangles = tris.ToArray(); return mesh; } /// <summary> /// Generates a collider mesh to detect entrance and exit of field of view /// by other objects. Simple box. /// </summary> /// <returns> /// Gemerated mesh. /// </returns> private Mesh GenerateVisionVolumeSimple() { // Mesh to generate. Mesh mesh; // Relative x coordinate of mesh far clip plane. float xNear = mSinBeta * mNearClip / mCosBeta; // Relative x coordinate of mesh near clip plane. float xFar = mSinBeta * mFarClip / mCosBeta; // Relative y coordinate of mesh far clip plane. float yNear = mSinOmega * mNearClip / mCosOmega; // Relative y coordinate of mesh far clip plane. float yFar = mSinOmega * mFarClip / mCosOmega; // Mesh vertex array. Vector3[] verts = new Vector3[8]; verts[0] = new Vector3(xNear, yNear, mNearClip); verts[1] = new Vector3(-xNear, yNear, mNearClip); verts[2] = new Vector3(-xNear, -yNear, mNearClip); verts[3] = new Vector3(xNear, -yNear, mNearClip); verts[4] = new Vector3(xFar, yFar, mFarClip); verts[5] = new Vector3(-xFar, yFar, mFarClip); verts[6] = new Vector3(-xFar, -yFar, mFarClip); verts[7] = new Vector3(xFar, -yFar, mFarClip); mesh = new Mesh(); mesh.vertices = verts; mesh.triangles = mTriangles; return mesh; } /// <summary> /// Deducts whether some other object can be seen by this object. /// </summary> /// <param name=\"other\"> /// Other object to check visibility of. /// </param> /// <returns> /// Whether other object is able to be seen by this vision component. /// </returns> public bool WithinFieldOfView(GameObject other) { // Whether the other object can be seen by this vision component. bool withinFov = false; // Vector delta between other object and this vision component. Vector3 delta = other.transform.position - transform.position; // Direction towards other object. Vector3 dir = delta.normalized; // Distance between the vision component and the other object. float dist = delta.magnitude; // Projection from direction towards other object to horizontal plane. Vector3 p; // Projection from direciton towards other object to vertical plane. Vector3 q; // Cosine of angle between p and forward. float cosP; // Cosine of angle between q and forward. float cosQ; if (dist <= mFarClip && dist >= mNearClip) { p = Vector3.ProjectOnPlane(dir, transform.up).normalized; q = Vector3.ProjectOnPlane(dir, transform.right).normalized; cosP = Vector3.Dot(p, transform.forward); cosQ = Vector3.Dot(q, transform.forward); withinFov = cosP >= mCosBeta && cosQ >= mCosOmega; } return withinFov; } /// <summary> /// Checks whether a given object is obscured by another from the point of /// view of this vision component. /// </summary> /// <param name=\"other\"> /// Other object. /// </param> /// <returns> /// Whether the other object can be seen. /// </returns> public bool IsObscured(GameObject other) { // Vector delta between other object and this vision component. Vector3 delta = other.transform.position - transform.position; // Hit object in direction of other object according to raycast. RaycastHit hit; Physics.Raycast( transform.position, delta.normalized, out hit, delta.magnitude, mVisibleLayerMask ); return other != hit.collider.gameObject; } /// <summary> /// Checks which objects in field of view are visible to this vision /// component. /// </summary> private void CheckSeen() { // List of seen describable objects. List<IDescribable> seen = new List<IDescribable>(); // Seen describable object. IDescribable describable; foreach (GameObject obj in mWithinFov) { describable = obj.GetComponent<IDescribable>(); if (describable != null && !IsObscured(obj)) seen.Add(describable); } mSeen = seen.Count > 0 ? seen.ToArray() : new IDescribable[0]; mOwner.AssessSurroundings(); } /// <summary> /// Checks the defined field of view for any GameObjects. /// Does not check whether they are obscured. /// </summary> private void CheckFieldOfView() { // Colliders close enough to this vision component to be seen. Collider[] closeEnough = Physics.OverlapSphere(transform.position, mFarClip); // Game object to check. GameObject obj; foreach (Collider collider in closeEnough) { obj = collider.gameObject; if (obj != mOwner.gameObject && obj.layer == mVisibleLayerIndex && WithinFieldOfView(obj)) mWithinFov.Add(obj); } CheckSeen(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Vision",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "Vision",
          "content": "using System.Collections.Generic; using UnityEngine; /// <summary> /// Detects describable objects able to be seen by this component. /// </summary> public class Vision : MonoBehaviour { /// <summary> /// Type of vision volume to represent field of view. /// </summary> private enum VisionVolumeType { SIMPLE, ELIPSED } /// <summary> /// Layer index for visible objects; things this component can see. /// </summary> [SerializeField] private int mVisibleLayerIndex = 7; /// <summary> /// How far away things can be seen byt his vision component. /// </summary> [SerializeField] private float mNearClip = 0.1f; /// <summary> /// How close things can be seen by this vision component. /// </summary> [SerializeField] private float mFarClip = 20.0f; /// <summary> /// Vision horizontal field of view for this character. /// Bounded between [1-179] to prevent undefined behavior. /// </summary> [vMinMax(1, 179)] [SerializeField] private int mFovHorizontal = 120; /// <summary> /// Vision vertical field of view for this character. /// Bounded between [1-179] to prevent undefined behavior. /// </summary> [vMinMax(1, 179)] [SerializeField] private int mFovVertical = 120; /// <summary> /// Type of vision volume to use, simple or eilipsed. /// </summary> [SerializeField] private VisionVolumeType mVolumeType = VisionVolumeType.SIMPLE; /// <summary> /// How many segments in the elipsed vision volume, if used. /// </summary> [SerializeField] private int mElipseSegments = 8; /// <summary> /// Layer mask used to discern visible objects from things that should be /// ignored. /// </summary> private int mVisibleLayerMask; /// <summary> /// Horizontal field of view, in radians. /// </summary> private float mAlpha; /// <summary> /// Half the horizontal fov in radians. /// </summary> private float mBeta; /// <summary> /// Cosine of half the horizontal fov. /// </summary> private float mCosBeta; /// <summary> /// Sin of half the horizontal fov. /// </summary> private float mSinBeta; /// <summary> /// Vertical field of view, in radians. /// </summary> private float mPsi; /// <summary> /// Half the vertical fov in radians. /// </summary> private float mOmega; /// <summary> /// Cosine of half the vertical fov. /// </summary> private float mCosOmega; /// <summary> /// Sin of half the vertical fov. /// </summary> private float mSinOmega; /// <summary> /// Mesh used to detect objects entering and exiting vision field of view. /// </summary> private Mesh mVisionMesh; /// <summary> /// Index vector used to build triangles for vision mesh. /// </summary> private static readonly int[] mTriangles = { 0, 3, 1, 2, 1, 3, 4, 5, 6, 6, 7, 4, 0, 1, 5, 5, 4, 0, 3, 6, 2, 7, 6, 3, 0, 7, 3, 4, 7, 0, 6, 5, 1, 1, 2, 6 }; /// <summary> /// Collider object built from mesh. /// </summary> private MeshCollider mCollider; /// <summary> /// Set of objects within field of view. As in, can be seen by this object. /// </summary> HashSet<GameObject> mWithinFov = new HashSet<GameObject>(); /// <summary> /// Options for collision mesh used to define field of view. /// </summary> private const MeshColliderCookingOptions mCookingOptions = MeshColliderCookingOptions.UseFastMidphase & MeshColliderCookingOptions.CookForFasterSimulation; /// <summary> /// Character owning this vision component. /// </summary> public Personality mOwner; /// <summary> /// Describable objects visible to this component. /// </summary> private IDescribable[] mSeen; /** Accessors and Setters **/ public IDescribable[] Seen { get => mSeen; } public int FovHorizontal { get => mFovHorizontal; } public int FovVertical { get => mFovVertical; } /// <summary> /// This function is called when the object becomes enabled and active. /// </summary> private void OnEnable() { mOwner = GetComponentInParent<Personality>(); mVisibleLayerMask = 1 << mVisibleLayerIndex; } /// <summary> /// When a GameObject collides with another GameObject, Unity calls /// OnTriggerEnter. /// </summary> /// <param name=\"other\"> /// The other collider. /// </param> private void OnTriggerEnter(Collider other) { // Detected describable object entering the field of view. IDescribable describable = other.GetComponent<IDescribable>(); if (describable != null) { mWithinFov.Add(other.gameObject); CheckSeen(); } } /// <summary> /// OnTriggerExit is called when the Collider other has stopped touching /// the trigger. /// </summary> /// <param name=\"other\"> /// The other collider. /// </param> private void OnTriggerExit(Collider other) { // Detected describable object exiting the field of view. IDescribable describable = other.GetComponent<IDescribable>(); if (describable != null) { mWithinFov.Remove(other.gameObject); CheckSeen(); } } /// <summary> /// Sets a new field of view, builds a new fov mesh, checks for new /// detections. /// </summary> /// <param name=\"newFovDegrees\"> /// New field of view value in degrees. /// </param> public void SetFov(int fovHorizontal, int fovVertical) { mFovHorizontal = fovHorizontal; mFovVertical = fovVertical; GenerateTrigParams(); mCollider = GetComponent<MeshCollider>(); mVisionMesh = GenerateVisionVolume(); Physics.BakeMesh(mVisionMesh.GetInstanceID(), false, mCookingOptions); mCollider.sharedMesh = mVisionMesh; mWithinFov.Clear(); CheckFieldOfView(); } /// <summary> /// Generates the appropriate vision volume mesh based on preference. /// </summary> /// <returns> /// Vision volume mesh. /// </returns> private Mesh GenerateVisionVolume() { // The generated vision volume to use. Mesh volume = null; switch (mVolumeType) { case VisionVolumeType.SIMPLE: volume = GenerateVisionVolumeSimple(); break; case VisionVolumeType.ELIPSED: volume = GenerateVisionVolumeElipsed(); break; } return volume; } /// <summary> /// Generates parametes used in trigometric operations. /// </summary> private void GenerateTrigParams() { mAlpha = ((float) mFovHorizontal) * Mathf.Deg2Rad; mBeta = mAlpha * 0.5f; mCosBeta = Mathf.Cos(mBeta); mSinBeta = Mathf.Sin(mBeta); mPsi = ((float)mFovVertical) * Mathf.Deg2Rad; mOmega = mPsi * 0.5f; mCosOmega = Mathf.Cos(mOmega); mSinOmega = Mathf.Sin(mOmega); } /// <summary> /// Generates mesh representing the volume of space things are visible within. /// </summary> /// <returns></returns> private Mesh GenerateVisionVolumeElipsed() { // The generated mesh. Mesh mesh = new Mesh(); // Step size for segment angles. float angleStep = mAlpha / (float)mElipseSegments; // Relative x coordinate of mesh near clip plane. float xNear = mSinBeta * mNearClip / mCosBeta; // Relative y coordinate of mesh near clip plane. float yNear = mSinOmega * mNearClip / mCosOmega; float yFar = mFarClip * mSinOmega; // Mesh is built in segments, gamma is angle of current segment. float gamma; // Sin of angle of current mesh segment. float sinGamma; // Cos of angle of current mesh segment. float cosGamma; // Far vertex x coordinate. float xFar; // Far vertex y coordinate. float zFar; // List of mesh triangles' vertex indicies. List<int> tris = new List<int>(); // List of verticies making up mesh. List<Vector3> verts = new List<Vector3>(); // This is very ugly and relies on a lot of magic numbers. // I apologize, but it was taking forever to get it to work and // in the end I said screw it. verts.Add(new Vector3(xNear, yNear, mNearClip)); verts.Add(new Vector3(-xNear, yNear, mNearClip)); verts.Add(new Vector3(-xNear, -yNear, mNearClip)); verts.Add(new Vector3(xNear, -yNear, mNearClip)); tris.Add(0); tris.Add(3); tris.Add(1); tris.Add(1); tris.Add(3); tris.Add(2); int i; for(i = 0; i <= mElipseSegments; i++) { gamma = -mBeta + (i * angleStep); sinGamma = Mathf.Sin(gamma); cosGamma = Mathf.Cos(gamma); xFar = mFarClip * sinGamma; zFar = mFarClip * cosGamma; verts.Add(new Vector3(xFar, yFar, zFar)); verts.Add(new Vector3(xFar, -yFar, zFar)); if(i > 0) { if(i < mElipseSegments - 1) { if(i <= mElipseSegments / 2) { tris.Add(verts.Count - 1); tris.Add(0); tris.Add(verts.Count - 3); tris.Add(verts.Count - 2); tris.Add(3); tris.Add(verts.Count - 4); tris.Add(verts.Count - 1); tris.Add(verts.Count - 3); tris.Add(verts.Count - 4); tris.Add(verts.Count - 1); tris.Add(verts.Count - 4); tris.Add(verts.Count - 2); } else { tris.Add(verts.Count - 1); tris.Add(1); tris.Add(verts.Count - 3); tris.Add(verts.Count - 2); tris.Add(2); tris.Add(verts.Count - 4); } } else { tris.Add(verts.Count - 2); tris.Add(1); tris.Add(2); tris.Add(verts.Count - 1); tris.Add(verts.Count - 2); tris.Add(2); } } else { tris.Add(0); tris.Add(4); tris.Add(5); tris.Add(3); tris.Add(0); tris.Add(5); } } mesh.vertices = verts.ToArray(); mesh.triangles = tris.ToArray(); return mesh; } /// <summary> /// Generates a collider mesh to detect entrance and exit of field of view /// by other objects. Simple box. /// </summary> /// <returns> /// Gemerated mesh. /// </returns> private Mesh GenerateVisionVolumeSimple() { // Mesh to generate. Mesh mesh; // Relative x coordinate of mesh far clip plane. float xNear = mSinBeta * mNearClip / mCosBeta; // Relative x coordinate of mesh near clip plane. float xFar = mSinBeta * mFarClip / mCosBeta; // Relative y coordinate of mesh far clip plane. float yNear = mSinOmega * mNearClip / mCosOmega; // Relative y coordinate of mesh far clip plane. float yFar = mSinOmega * mFarClip / mCosOmega; // Mesh vertex array. Vector3[] verts = new Vector3[8]; verts[0] = new Vector3(xNear, yNear, mNearClip); verts[1] = new Vector3(-xNear, yNear, mNearClip); verts[2] = new Vector3(-xNear, -yNear, mNearClip); verts[3] = new Vector3(xNear, -yNear, mNearClip); verts[4] = new Vector3(xFar, yFar, mFarClip); verts[5] = new Vector3(-xFar, yFar, mFarClip); verts[6] = new Vector3(-xFar, -yFar, mFarClip); verts[7] = new Vector3(xFar, -yFar, mFarClip); mesh = new Mesh(); mesh.vertices = verts; mesh.triangles = mTriangles; return mesh; } /// <summary> /// Deducts whether some other object can be seen by this object. /// </summary> /// <param name=\"other\"> /// Other object to check visibility of. /// </param> /// <returns> /// Whether other object is able to be seen by this vision component. /// </returns> public bool WithinFieldOfView(GameObject other) { // Whether the other object can be seen by this vision component. bool withinFov = false; // Vector delta between other object and this vision component. Vector3 delta = other.transform.position - transform.position; // Direction towards other object. Vector3 dir = delta.normalized; // Distance between the vision component and the other object. float dist = delta.magnitude; // Projection from direction towards other object to horizontal plane. Vector3 p; // Projection from direciton towards other object to vertical plane. Vector3 q; // Cosine of angle between p and forward. float cosP; // Cosine of angle between q and forward. float cosQ; if (dist <= mFarClip && dist >= mNearClip) { p = Vector3.ProjectOnPlane(dir, transform.up).normalized; q = Vector3.ProjectOnPlane(dir, transform.right).normalized; cosP = Vector3.Dot(p, transform.forward); cosQ = Vector3.Dot(q, transform.forward); withinFov = cosP >= mCosBeta && cosQ >= mCosOmega; } return withinFov; } /// <summary> /// Checks whether a given object is obscured by another from the point of /// view of this vision component. /// </summary> /// <param name=\"other\"> /// Other object. /// </param> /// <returns> /// Whether the other object can be seen. /// </returns> public bool IsObscured(GameObject other) { // Vector delta between other object and this vision component. Vector3 delta = other.transform.position - transform.position; // Hit object in direction of other object according to raycast. RaycastHit hit; Physics.Raycast( transform.position, delta.normalized, out hit, delta.magnitude, mVisibleLayerMask ); return other != hit.collider.gameObject; } /// <summary> /// Checks which objects in field of view are visible to this vision /// component. /// </summary> private void CheckSeen() { // List of seen describable objects. List<IDescribable> seen = new List<IDescribable>(); // Seen describable object. IDescribable describable; foreach (GameObject obj in mWithinFov) { describable = obj.GetComponent<IDescribable>(); if (describable != null && !IsObscured(obj)) seen.Add(describable); } mSeen = seen.Count > 0 ? seen.ToArray() : new IDescribable[0]; mOwner.AssessSurroundings(); } /// <summary> /// Checks the defined field of view for any GameObjects. /// Does not check whether they are obscured. /// </summary> private void CheckFieldOfView() { // Colliders close enough to this vision component to be seen. Collider[] closeEnough = Physics.OverlapSphere(transform.position, mFarClip); // Game object to check. GameObject obj; foreach (Collider collider in closeEnough) { obj = collider.gameObject; if (obj != mOwner.gameObject && obj.layer == mVisibleLayerIndex && WithinFieldOfView(obj)) mWithinFov.Add(obj);  ",
          "content_tokens": 3732,
          "embedding": []
        },
        {
          "cs_scriptfile": "Vision",
          "content": "CheckSeen(); } }",
          "content_tokens": 6,
          "embedding": []
        }
      ],
      "length": 12794
    },
    {
      "filename": "Defines",
      "content": " public static class Defines { public const string TRAITS_PATH = \"Traits/\"; public const string TRAITS_EXT = \".txt\"; public const char TRAIT_SPLIT = ':'; public const char TRAITS_POS = '1'; public const char TRAITS_NEG = '0'; public const string ACTION_TERMS_FILE = \"action_terms.txt\"; public const string DEGREE_TERMS_FILE = \"degree_terms.txt\"; public const string OPEN_NAME = \"openness\"; public const string OPEN_ADJ = \"open\"; public const string CONSC_NAME = \"conscientiousness\"; public const string CONSC_ADJ = \"conscientious\"; public const string EXT_NAME = \"extraversion\"; public const string EXT_ADJ = \"extraverted\"; public const string AGREE_NAME = \"agreeableness\"; public const string AGREE_ADJ = \"agreeable\"; public const string NEURO_NAME = \"neuroticism\"; public const string NEURO_ADJ = \"neurotic\"; public const string HAPPY_NAME = \"happiness\"; public const string HAPPY_ADJ = \"happy\"; public const string ANGER_NAME = \"anger\"; public const string ANGER_ADJ = \"angry\"; public const string SARC_NAME = \"sarcasm\"; public const string SARC_ADJ = \"sarcastic\"; public const string DEGREE_HEAD = \"You are\"; public const string ACTION_HEAD = \"You\"; public const string LIST_TAIL = \", \"; public const string END_TAIL = \". \"; public const string SECRET_HEAD = \"Secretly, you\"; public const string SECRET_TAIL = \"and you will avoid talking about any of this.\"; public const string SHIRT_HEAD = \"You want to talk about\"; public const string SHIRT_TAIL_SINGLE = \"and will mention this at every opportunity\"; public const string SHIRT_TAIL_MULTI = \"and will mention these things at every opportunity\"; public const string ROLE_HEAD = \"Respond as if you are\"; public const string ROLE_MID = \"With the following personality:\"; public const string ROLE_TAIL = \"Do not mention you are an AI machine learning model or Open AI.\"; public const string HEAR_NONANIM_HEAD = \"You just heard\"; public const string HEAR_NONANIM_MID = \"come from\"; public const string HEAR_OTHER_MID = \"has just said\"; public const string SEE_HEAD = \"You can see the following things:\"; public const string LIST_HEAD = \"and\"; public const string DESC_NAME = \"named\"; public const string LOOK_OTHER= \"who is looking at\"; public const string LOOK_YOU = \"who is looking at you\"; public const string LOOK_NOTH = \"who is looking at nothing in particular\"; public const string REPLY_INSTRUCT = \"What dialogue do you have to say outloud in reply?\"; public const string RESPONSE_CHECK = \"If there's nothing to say here or\" + \" if you think you should not reply, or if there is no good response\" + \", say only the following words:\"; public const string REACT_INSTRUCT = \" List the steps you should take one after another in this situation.\" + \" If you should look at something, say \\\"LOOK AT: \\\" followed by the\" + \" name of the thing you should look at. If you should move somewhere,\" + \" say \\\"MOVE: \\\" followed by the name of where you should move to.\"; public const string RESPONSE_DENY = \"NO-STATEMENT\"; // Something nobody would ever say, I think. public const string MOOD_HEAD = \"As for your current mood, you\"; public const string MOOD_TERMS_PATH = \"degree_terms.txt\"; public const string VIS_ASSESS_HEAD = \"You see\"; public const string VIS_ASSESS_SAY = \"What do you have to say about this? \" + \"Give only the dialoge you would use, not a descripton of it.\"; public const string DATE_FORMAT = \"yy-MM-dd-HH-mm-ss\"; public const string OUT_PREF = \"PersonalityOutput\"; public const int MAX_TOKENS = 4096; public const string DIALOGUE_RULE = \"Give only dialogue and only from\" + \" the first-person perspective. Do not under any circumstances\" + \" narrate the scene, what you are doing, or what you are saying.\" + \" Provide only short answers, and do not provide any information\" + \" that is not directly related to your realm.\"; public const string TASKS_HEAD = \"Right now you are busy\"; public const string ASSESS_MID = \"sees the following:\\n\"; public const string SYNTH_DIR = \"Assets/DataSynthesis/\"; public const string SYNTH_JOBS = \"jobs.txt\"; public const string SYNTH_NAMES = \"names.txt\"; public const string SYNTH_TASKS = \"tasks.txt\"; public const string SYNTH_TOPICS = \"topics.txt\"; public const string SYNTH_PLACES = \"places.txt\"; public const string TOPICS_HEAD = \"You want to talk with people about\"; public const int IGNORE_VAL = 2; } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Defines",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "Defines",
          "content": "public static class Defines { public const string TRAITS_PATH = \"Traits/\"; public const string TRAITS_EXT = \".txt\"; public const char TRAIT_SPLIT = ':'; public const char TRAITS_POS = '1'; public const char TRAITS_NEG = '0'; public const string ACTION_TERMS_FILE = \"action_terms.txt\"; public const string DEGREE_TERMS_FILE = \"degree_terms.txt\"; public const string OPEN_NAME = \"openness\"; public const string OPEN_ADJ = \"open\"; public const string CONSC_NAME = \"conscientiousness\"; public const string CONSC_ADJ = \"conscientious\"; public const string EXT_NAME = \"extraversion\"; public const string EXT_ADJ = \"extraverted\"; public const string AGREE_NAME = \"agreeableness\"; public const string AGREE_ADJ = \"agreeable\"; public const string NEURO_NAME = \"neuroticism\"; public const string NEURO_ADJ = \"neurotic\"; public const string HAPPY_NAME = \"happiness\"; public const string HAPPY_ADJ = \"happy\"; public const string ANGER_NAME = \"anger\"; public const string ANGER_ADJ = \"angry\"; public const string SARC_NAME = \"sarcasm\"; public const string SARC_ADJ = \"sarcastic\"; public const string DEGREE_HEAD = \"You are\"; public const string ACTION_HEAD = \"You\"; public const string LIST_TAIL = \", \"; public const string END_TAIL = \". \"; public const string SECRET_HEAD = \"Secretly, you\"; public const string SECRET_TAIL = \"and you will avoid talking about any of this.\"; public const string SHIRT_HEAD = \"You want to talk about\"; public const string SHIRT_TAIL_SINGLE = \"and will mention this at every opportunity\"; public const string SHIRT_TAIL_MULTI = \"and will mention these things at every opportunity\"; public const string ROLE_HEAD = \"Respond as if you are\"; public const string ROLE_MID = \"With the following personality:\"; public const string ROLE_TAIL = \"Do not mention you are an AI machine learning model or Open AI.\"; public const string HEAR_NONANIM_HEAD = \"You just heard\"; public const string HEAR_NONANIM_MID = \"come from\"; public const string HEAR_OTHER_MID = \"has just said\"; public const string SEE_HEAD = \"You can see the following things:\"; public const string LIST_HEAD = \"and\"; public const string DESC_NAME = \"named\"; public const string LOOK_OTHER= \"who is looking at\"; public const string LOOK_YOU = \"who is looking at you\"; public const string LOOK_NOTH = \"who is looking at nothing in particular\"; public const string REPLY_INSTRUCT = \"What dialogue do you have to say outloud in reply?\"; public const string RESPONSE_CHECK = \"If there's nothing to say here or\" + \" if you think you should not reply, or if there is no good response\" + \", say only the following words:\"; public const string REACT_INSTRUCT = \" List the steps you should take one after another in this situation.\" + \" If you should look at something, say \\\"LOOK AT: \\\" followed by the\" + \" name of the thing you should look at. If you should move somewhere,\" + \" say \\\"MOVE: \\\" followed by the name of where you should move to.\"; public const string RESPONSE_DENY = \"NO-STATEMENT\"; // Something nobody would ever say, I think. public const string MOOD_HEAD = \"As for your current mood, you\"; public const string MOOD_TERMS_PATH = \"degree_terms.txt\"; public const string VIS_ASSESS_HEAD = \"You see\"; public const string VIS_ASSESS_SAY = \"What do you have to say about this? \" + \"Give only the dialoge you would use, not a descripton of it.\"; public const string DATE_FORMAT = \"yy-MM-dd-HH-mm-ss\"; public const string OUT_PREF = \"PersonalityOutput\"; public const int MAX_TOKENS = 4096; public const string DIALOGUE_RULE = \"Give only dialogue and only from\" + \" the first-person perspective. Do not under any circumstances\" + \" narrate the scene, what you are doing, or what you are saying.\" + \" Provide only short answers, and do not provide any information\" + \" that is not directly related to your realm.\"; public const string TASKS_HEAD = \"Right now you are busy\"; public const string ASSESS_MID = \"sees the following:\\n\"; public const string SYNTH_DIR = \"Assets/DataSynthesis/\"; public const string SYNTH_JOBS = \"jobs.txt\"; public const string SYNTH_NAMES = \"names.txt\"; public const string SYNTH_TASKS = \"tasks.txt\"; public const string SYNTH_TOPICS = \"topics.txt\"; public const string SYNTH_PLACES = \"places.txt\"; public const string TOPICS_HEAD = \"You want to talk with people about\"; public const int IGNORE_VAL = 2; }",
          "content_tokens": 1184,
          "embedding": []
        }
      ],
      "length": 4311
    },
    {
      "filename": "GptCommunicator",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.Networking; using System.Text; using System.IO; using System; /// <summary> /// Communicates with GPT and illicits text responses from given prompts. /// </summary> public class GptCommunicator : MonoBehaviour { [System.Serializable] public class Message { public string role; public string content; } [System.Serializable] public class RequestBody { public string model; public Message[] messages; public double temperature; public double presence_penalty; public double frequency_penalty; } [System.Serializable] public class Choice { public int index; public Message message; public string finish_reason; } [System.Serializable] public class Usage { public int prompt_tokens; public int completion_tokens; public int total_tokens; } [System.Serializable] public class Response { public string id; public string object_name; public int created; public string model; public Choice[] choices; public Usage usage; } public class QueuePrompt { string prompt; Personality caller; ResponseReceived callback; } [Tooltip(\"Enter your OpenAI API key here.\")] [SerializeField] private string mApiKey = \"YOUR API KEY HERE\"; [Tooltip(\"Open AI competions URL. Probably shouldn't be changed.\")] [SerializeField] private string mUrl = \"https://api.openai.com/v1/chat/completions\"; [Tooltip(\"Open AI model to generate responses from.\")] [SerializeField] private string mModel = \"gpt-4\"; [Tooltip(\"How often in seconds to make a request of the Open AI API.\")] [SerializeField] float mRateLimit = 3.0f; [Tooltip(\"Turns GPT response requests on/off for debugging.\")] [SerializeField] bool mSendRequests = true; [Tooltip(\"Records output for analysis or training.\")] [SerializeField] private bool mRecordOutput = false; /// <summary> /// Current filename to record output to. /// </summary> private string mOutFile; /// <summary> /// Current path to record output to. /// </summary> private string mOutPath; /// <summary> /// Writes output to file. /// </summary> private StreamWriter mWriter; /// <summary> /// Builds strings for output. /// </summary> private StringBuilder mBuilder; /// <summary> /// Time of last request made of Open AI API. /// </summary> private float mLastRequestTime = 0; /// <summary> /// Delegate for callbacks to be executed upon receipt of a response from /// Open AI API. /// </summary> /// <param name=\"received\"> /// Text response generated by Open AI model. /// </param> public delegate void ResponseReceived(string received); /// <summary> /// Delegate for functions called when denial string is received. /// </summary> public delegate void Denial(Personality personality); /// <summary> /// Event fired when denial string is received. /// </summary> public event Denial OnDenial; /// <summary> /// Delegate for functions called when data is recorded. /// </summary> public delegate void Record(Personality personality); /// <summary> /// Event fired when data is recorded. /// </summary> public event Record OnRecord; /// <summary> /// Called on the frame when a script is enabled just before any of the /// Update methods are called the first time. /// </summary> private void OnEnable() { if (mRecordOutput) { mBuilder = new StringBuilder(Defines.MAX_TOKENS); mOutFile = $\"{Defines.OUT_PREF}_\" + $\"{DateTime.Now.ToString(Defines.DATE_FORMAT)}.txt\"; mOutPath = Path.Combine(Application.persistentDataPath, mOutFile); mWriter = new StreamWriter(mOutPath, append: true); Debug.Log(\"Opened file for recording data at: \" + mOutPath); } } private void OnDisable() { if (mWriter != null) mWriter.Close(); } /// <summary> /// Requests a statement to be made by Character from GPT in reply to /// an ongoing conversation. /// </summary> /// <param name=\"prompt\"> /// Conversation GPT should generate a reply to. /// </param> /// <param name=\"callback\"> /// Method to execute once reply has been received from GPT. /// </param> public void RequestConversationalReply (string prompt, Personality caller, ResponseReceived callback) { string replyPrompt = $\"{prompt} {Defines.REPLY_INSTRUCT}\" + $\"{Defines.RESPONSE_CHECK}{Defines.RESPONSE_DENY}\"; StartCoroutine(PromptGpt(replyPrompt, caller, callback, prompt)); } public void RequestVisualQueuePrompt (string prompt, Personality caller, ResponseReceived callback) { string replyPrompt = $\"{Defines.VIS_ASSESS_HEAD} {prompt}\" + $\" {Defines.VIS_ASSESS_SAY} {Defines.RESPONSE_CHECK}\" + $\"{Defines.RESPONSE_DENY}\"; StartCoroutine(PromptGpt(replyPrompt, caller, callback, prompt)); } /// <summary> /// Requests instructions on what to do from GPT based on a text /// description of a Character's current state in the game. /// </summary> /// <param name=\"prompt\"> /// Description of character's current state. /// </param> /// <param name=\"callback\"> /// Method to execute upon receipt of instructions from GPT. /// </param> public void RequestReactionInstructions (string prompt, Personality caller, ResponseReceived callback) { string spokenReplyPrompt = $\"{prompt} {Defines.REACT_INSTRUCT}\"; StartCoroutine(PromptGpt(spokenReplyPrompt, caller, callback, prompt)); } /// <summary> /// Prompts Open AI GPT model. /// </summary> /// <param name=\"prompt\"> /// Text prompt for GPT. /// </param> /// <param name=\"callback\"> /// Method to execute upon receipt of response from GPT. /// </param> /// <returns></returns> IEnumerator PromptGpt( string prompt, Personality caller, ResponseReceived callback, string original) { if (caller.Verbose) Debug.Log($\"Sending reply request for prompt:\\n{prompt} with\" + $\" key {mApiKey}.\"); if (mSendRequests) { // Current game time. float time = Time.realtimeSinceStartup; // Difference between current time and the last request. float delta = time - mLastRequestTime; // How long to wait before making another request. float waitSeconds = mLastRequestTime == 0 || delta >= mRateLimit ? 0 : mRateLimit - delta; yield return new WaitForSeconds(waitSeconds); UnityWebRequest www = new UnityWebRequest(mUrl, \"POST\"); www.SetRequestHeader(\"Content-Type\", \"application/json\"); www.SetRequestHeader(\"Authorization\", $\"Bearer {mApiKey}\"); Message message = new Message { role = \"user\", content = prompt }; caller.Messages.Add(message); RequestBody body = new RequestBody { model = mModel, messages = caller.Messages.ToArray(), temperature = caller.Temperature, presence_penalty = caller.PresencePenalty, frequency_penalty = caller.FrequencyPenalty }; string bodyJson = JsonUtility.ToJson(body); byte[] bodyRaw = new System.Text.UTF8Encoding().GetBytes(bodyJson); www.uploadHandler = new UploadHandlerRaw(bodyRaw); DownloadHandlerBuffer dH = new DownloadHandlerBuffer(); www.downloadHandler = dH; yield return www.SendWebRequest(); if (www.result == UnityWebRequest.Result.Success) { Response response = JsonUtility.FromJson<Response>(www.downloadHandler.text); string responseText = response.choices[0].message.content; if (!responseText.Contains(Defines.RESPONSE_DENY)) { caller.Messages.Add( new Message { role = \"assistant\", content = responseText } ); callback?.Invoke(responseText.Replace(\"\\\"\", string.Empty)); if (mRecordOutput) RecordOutput(caller, original, responseText); } else { Debug.Log($\"Got denial string \\\"{Defines.RESPONSE_DENY}\\\"\" + $\" from prompt:\\n\\\"{prompt}\\\"\"); OnDenial?.Invoke(caller); } } else { Debug.Log($\"Requester Error: {www.error}\"); } mLastRequestTime = Time.realtimeSinceStartup; } } /// <summary> /// Records input to gpt and output from gpt to file. /// </summary> /// <param name=\"personality\"> /// Personality being served by gpt. /// </param> /// <param name=\"prompt\"> /// Dialogue prompt being sent to gpt. /// </param> /// <param name=\"output\"> /// Output received from GPT. /// </param> private void RecordOutput(Personality personality, string prompt, string output) { // First charcter of prompt, capitalized. string promptUpper = $\"{prompt[0]}\".ToUpper(); // Prompt formatted with first character capitalized. string promptFormatted = $\"{promptUpper[0]}{prompt[1..]}\"; // String to record to file. string record = $\"You are {personality.BackStory}.\" + $\" {personality.Summary}\\n{promptFormatted} What is your\" + $\" response?\\n{output}\"; mWriter.WriteLine(record); OnRecord?.Invoke(personality); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "GptCommunicator",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "GptCommunicator",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.Networking; using System.Text; using System.IO; using System; /// <summary> /// Communicates with GPT and illicits text responses from given prompts. /// </summary> public class GptCommunicator : MonoBehaviour { [System.Serializable] public class Message { public string role; public string content; } [System.Serializable] public class RequestBody { public string model; public Message[] messages; public double temperature; public double presence_penalty; public double frequency_penalty; } [System.Serializable] public class Choice { public int index; public Message message; public string finish_reason; } [System.Serializable] public class Usage { public int prompt_tokens; public int completion_tokens; public int total_tokens; } [System.Serializable] public class Response { public string id; public string object_name; public int created; public string model; public Choice[] choices; public Usage usage; } public class QueuePrompt { string prompt; Personality caller; ResponseReceived callback; } [Tooltip(\"Enter your OpenAI API key here.\")] [SerializeField] private string mApiKey = \"YOUR API KEY HERE\"; [Tooltip(\"Open AI competions URL. Probably shouldn't be changed.\")] [SerializeField] private string mUrl = \"https://api.openai.com/v1/chat/completions\"; [Tooltip(\"Open AI model to generate responses from.\")] [SerializeField] private string mModel = \"gpt-4\"; [Tooltip(\"How often in seconds to make a request of the Open AI API.\")] [SerializeField] float mRateLimit = 3.0f; [Tooltip(\"Turns GPT response requests on/off for debugging.\")] [SerializeField] bool mSendRequests = true; [Tooltip(\"Records output for analysis or training.\")] [SerializeField] private bool mRecordOutput = false; /// <summary> /// Current filename to record output to. /// </summary> private string mOutFile; /// <summary> /// Current path to record output to. /// </summary> private string mOutPath; /// <summary> /// Writes output to file. /// </summary> private StreamWriter mWriter; /// <summary> /// Builds strings for output. /// </summary> private StringBuilder mBuilder; /// <summary> /// Time of last request made of Open AI API. /// </summary> private float mLastRequestTime = 0; /// <summary> /// Delegate for callbacks to be executed upon receipt of a response from /// Open AI API. /// </summary> /// <param name=\"received\"> /// Text response generated by Open AI model. /// </param> public delegate void ResponseReceived(string received); /// <summary> /// Delegate for functions called when denial string is received. /// </summary> public delegate void Denial(Personality personality); /// <summary> /// Event fired when denial string is received. /// </summary> public event Denial OnDenial; /// <summary> /// Delegate for functions called when data is recorded. /// </summary> public delegate void Record(Personality personality); /// <summary> /// Event fired when data is recorded. /// </summary> public event Record OnRecord; /// <summary> /// Called on the frame when a script is enabled just before any of the /// Update methods are called the first time. /// </summary> private void OnEnable() { if (mRecordOutput) { mBuilder = new StringBuilder(Defines.MAX_TOKENS); mOutFile = $\"{Defines.OUT_PREF}_\" + $\"{DateTime.Now.ToString(Defines.DATE_FORMAT)}.txt\"; mOutPath = Path.Combine(Application.persistentDataPath, mOutFile); mWriter = new StreamWriter(mOutPath, append: true); Debug.Log(\"Opened file for recording data at: \" + mOutPath); }  ",
          "content_tokens": 880,
          "embedding": []
        },
        {
          "cs_scriptfile": "GptCommunicator",
          "content": "private void OnDisable() { if (mWriter != null) mWriter.Close(); } /// <summary> /// Requests a statement to be made by Character from GPT in reply to /// an ongoing conversation. /// </summary> /// <param name=\"prompt\"> /// Conversation GPT should generate a reply to. /// </param> /// <param name=\"callback\"> /// Method to execute once reply has been received from GPT. /// </param> public void RequestConversationalReply (string prompt, Personality caller, ResponseReceived callback) { string replyPrompt = $\"{prompt} {Defines.REPLY_INSTRUCT}\" + $\"{Defines.RESPONSE_CHECK}{Defines.RESPONSE_DENY}\"; StartCoroutine(PromptGpt(replyPrompt, caller, callback, prompt));  ",
          "content_tokens": 183,
          "embedding": []
        },
        {
          "cs_scriptfile": "GptCommunicator",
          "content": "public void RequestVisualQueuePrompt (string prompt, Personality caller, ResponseReceived callback) { string replyPrompt = $\"{Defines.VIS_ASSESS_HEAD} {prompt}\" + $\" {Defines.VIS_ASSESS_SAY} {Defines.RESPONSE_CHECK}\" + $\"{Defines.RESPONSE_DENY}\"; StartCoroutine(PromptGpt(replyPrompt, caller, callback, prompt)); } /// <summary> /// Requests instructions on what to do from GPT based on a text /// description of a Character's current state in the game. /// </summary> /// <param name=\"prompt\"> /// Description of character's current state. /// </param> /// <param name=\"callback\"> /// Method to execute upon receipt of instructions from GPT. /// </param> public void RequestReactionInstructions (string prompt, Personality caller, ResponseReceived callback) { string spokenReplyPrompt = $\"{prompt} {Defines.REACT_INSTRUCT}\"; StartCoroutine(PromptGpt(spokenReplyPrompt, caller, callback, prompt)); } /// <summary> /// Prompts Open AI GPT model. /// </summary> /// <param name=\"prompt\"> /// Text prompt for GPT. /// </param> /// <param name=\"callback\"> /// Method to execute upon receipt of response from GPT. /// </param> /// <returns></returns> IEnumerator PromptGpt( string prompt, Personality caller, ResponseReceived callback, string original) { if (caller.Verbose) Debug.Log($\"Sending reply request for prompt:\\n{prompt} with\" + $\" key {mApiKey}.\"); if (mSendRequests) { // Current game time. float time = Time.realtimeSinceStartup; // Difference between current time and the last request. float delta = time - mLastRequestTime; // How long to wait before making another request. float waitSeconds = mLastRequestTime == 0 || delta >= mRateLimit ? 0 : mRateLimit - delta; yield return new WaitForSeconds(waitSeconds); UnityWebRequest www = new UnityWebRequest(mUrl, \"POST\"); www.SetRequestHeader(\"Content-Type\", \"application/json\"); www.SetRequestHeader(\"Authorization\", $\"Bearer {mApiKey}\"); Message message = new Message { role = \"user\", content = prompt }; caller.Messages.Add(message); RequestBody body = new RequestBody { model = mModel, messages = caller.Messages.ToArray(), temperature = caller.Temperature, presence_penalty = caller.PresencePenalty, frequency_penalty = caller.FrequencyPenalty }; string bodyJson = JsonUtility.ToJson(body); byte[] bodyRaw = new System.Text.UTF8Encoding().GetBytes(bodyJson); www.uploadHandler = new UploadHandlerRaw(bodyRaw); DownloadHandlerBuffer dH = new DownloadHandlerBuffer(); www.downloadHandler = dH; yield return www.SendWebRequest(); if (www.result == UnityWebRequest.Result.Success) { Response response = JsonUtility.FromJson<Response>(www.downloadHandler.text); string responseText = response.choices[0].message.content; if (!responseText.Contains(Defines.RESPONSE_DENY)) { caller.Messages.Add( new Message { role = \"assistant\", content = responseText } ); callback?.Invoke(responseText.Replace(\"\\\"\", string.Empty)); if (mRecordOutput) RecordOutput(caller, original, responseText); } else { Debug.Log($\"Got denial string \\\"{Defines.RESPONSE_DENY}\\\"\" + $\" from prompt:\\n\\\"{prompt}\\\"\"); OnDenial?.Invoke(caller); } } else { Debug.Log($\"Requester Error: {www.error}\"); } mLastRequestTime = Time.realtimeSinceStartup; } } /// <summary> /// Records input to gpt and output from gpt to file. /// </summary> /// <param name=\"personality\"> /// Personality being served by gpt. /// </param> /// <param name=\"prompt\"> /// Dialogue prompt being sent to gpt. /// </param> /// <param name=\"output\"> /// Output received from GPT. /// </param> private void RecordOutput(Personality personality, string prompt, string output) { // First charcter of prompt, capitalized. string promptUpper = $\"{prompt[0]}\".ToUpper(); // Prompt formatted with first character capitalized. string promptFormatted = $\"{promptUpper[0]}{prompt[1..]}\"; // String to record to file. string record = $\"You are {personality.BackStory}.\" + $\" {personality.Summary}\\n{promptFormatted} What is your\" + $\" response?\\n{output}\"; mWriter.WriteLine(record); OnRecord?.Invoke(personality); } }",
          "content_tokens": 1116,
          "embedding": []
        }
      ],
      "length": 8218
    },
    {
      "filename": "IDescriabable",
      "content": "using UnityEngine; /// <summary> /// Interface for agents leveraging LLMs to generate spoken dialogue and /// actions based on text prompts generated by their surroundings. /// </summary> public interface IDescribable { /// <summary> /// Gets the name of the object or Character. /// </summary> /// <returns> /// Describable's name. /// </returns> public string GetName(); /// <summary> /// Generates a prompt describing the describable agent's state. /// </summary> /// <param name=\"caller\"> /// Who or what is requesting the Descriable to describe itself. /// </param> /// <returns> /// A self description. /// </returns> public string DescribeSelfForOther(Personality caller); /// <summary> /// Interacts with the Describable, generates a text description of the /// interaction, in addtion to some action taken by the Describable. /// </summary> /// <param name=\"interactor\"> /// The Character interacting with the Describable. /// </param> /// <returns> /// Description of interaction. /// </returns> //public string Interact(Character interactor); /// <summary> /// Who are you? /// </summary> /// <returns></returns> //public string Who(); /// <summary> /// Where are you? /// </summary> /// <returns>Where the Describable is.</returns> //public Vector3 Where(); /// <summary> /// Gets a reply to a given question on the Describable's state. /// </summary> /// <param name=\"question\"> /// Question to ask the Describable. /// </param> /// <returns> /// The question's answer. /// </returns> //public string Why(Character whosAsking, string question); /// <summary> /// WHether the Descriable is printing debug messages to console. /// </summary> /// <returns> /// Describable verbosity. /// </returns> public bool IsVerbose(); }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "IDescriabable",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "IDescriabable",
          "content": "using UnityEngine; /// <summary> /// Interface for agents leveraging LLMs to generate spoken dialogue and /// actions based on text prompts generated by their surroundings. /// </summary> public interface IDescribable { /// <summary> /// Gets the name of the object or Character. /// </summary> /// <returns> /// Describable's name. /// </returns> public string GetName(); /// <summary> /// Generates a prompt describing the describable agent's state. /// </summary> /// <param name=\"caller\"> /// Who or what is requesting the Descriable to describe itself. /// </param> /// <returns> /// A self description. /// </returns> public string DescribeSelfForOther(Personality caller); /// <summary> /// Interacts with the Describable, generates a text description of the /// interaction, in addtion to some action taken by the Describable. /// </summary> /// <param name=\"interactor\"> /// The Character interacting with the Describable. /// </param> /// <returns> /// Description of interaction. /// </returns> //public string Interact(Character interactor); /// <summary> /// Who are you? /// </summary> /// <returns></returns> //public string Who(); /// <summary> /// Where are you? /// </summary> /// <returns>Where the Describable is.</returns> //public Vector3 Where(); /// <summary> /// Gets a reply to a given question on the Describable's state. /// </summary> /// <param name=\"question\"> /// Question to ask the Describable. /// </param> /// <returns> /// The question's answer. /// </returns> //public string Why(Character whosAsking, string question); /// <summary> /// WHether the Descriable is printing debug messages to console. /// </summary> /// <returns> /// Describable verbosity. /// </returns> public bool IsVerbose(); }",
          "content_tokens": 423,
          "embedding": []
        }
      ],
      "length": 1735
    },
    {
      "filename": "Personality",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; using System.Text; using Zomb.Creatures.Helpers; /// <summary> /// Manages text descriptions of a self and any \"percieved\" other describable /// objects. /// </summary> public class Personality : MonoBehaviour, IDescribable { [Header(\"Character Attributes\")] [Tooltip(\"The name of this character.\")] [SerializeField] private string mCharacterName = \"Bilbo\"; [Tooltip(\"Who and what this character is. Short and sweet, use as little\" + \" punctuation as possible.\"), TextArea(6, 10)] [SerializeField] private string mBackStory = \"a simulated video game character\"; [Tooltip(\"Integer value, [0-4].\\n\\\"Openness is an overarching concept or\" + \" philosophy that is characterized by an emphasis on transparency and \" + \"collaboration.\\\" -Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mOpenness = 2; [Tooltip(\"Integer value, [0-4].\\n\\\"...the personality trait of being \" + \"careful or diligent.\\\" -Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mConscientiousness = 2; [Tooltip(\"Integer value, [0-4].\\n\\\"Extraversion tends to be manifested in \" + \"outgoing, talkative, energetic behavior.\\\" -Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mExtraversion = 2; [Tooltip(\"Integer value, [0-4].\\n\\\"Agreeableness is a personality trait \" + \"that manifests as behavior that is perceived as kind, sympathetic, \" + \"cooperative, warm, frank, and considerate.\\\" -Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mAgreeableness = 2; [Tooltip(\"Integer value, [0-4].\\n\\\"...individuals with high scores for\" + \" neuroticism are more likely than average to be moody and to\" + \" experience such feelings as anxiety, worry, fear, anger,\" + \" frustration, envy, jealousy, pessimism, guilt, depressed mood, and\" + \" loneliness.\\\" -Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mNeuroticsm = 2; [Tooltip(\"Integer value, [0-4].\\n\\\"Happiness is a positive and pleasant \" + \"emotion, ranging from contentment to intense joy.\\\" - Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mHappiness = 2; [Tooltip(\"Integer value, [0-4].\\n\\\"Anger, also known as wrath or rage, \" + \"is an intense emotional state involving a strong uncomfortable and \" + \"non-cooperative response to a perceived provocation, hurt or threat.\\\"\" + \" -Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mAnger = 2; [Tooltip(\"Integer value, [0-4].\\n\\\"Sarcasm is the caustic use of words, \" + \"often in a humorous way, to mock someone or something.\\\" -Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mSarcasm = 2; [Tooltip(\"List of things this character avoids in conversation, in the\" + \" form, \\\"Secretly, you...\\\"\")] [SerializeField] private string[] mSecrets; [Tooltip(\"List of things about themselves this character would love to\" + \" tell you about, in the form \\\"You want everyone to know...\\\"\")] [SerializeField] private string[] mShirtSleeve; [Tooltip(\"What this character is doing right now. The tasks at hand.\")] [SerializeField] private string[] mTasks; [Tooltip(\"Subjects this character wants to ask people and talk about.\")] [SerializeField] private string[] mTopics; [Header(\"Model Paramters\")] [Tooltip(\"\\\"The maximum number of tokens to generate in the completion.\\\" \" + \"-OpenAI API Documentation\")] [SerializeField] private int mMaxTokens = Defines.MAX_TOKENS; [Tooltip(\"\\\"What sampling temperature to use, between 0 and 2. Higher\" + \" values like 0.8 will make the output more random, while lower values\" + \" like 0.2 will make it more focused and deterministic.\\\" \" + \"-OpenAI API Documenation\")] [SerializeField] private float mTemperature = 0.7f; [Tooltip(\"\\\"Number between -2.0 and 2.0. Positive values penalize new \" + \"tokens based on whether they appear in the text so far, increasing the\" + \" model's likelihood to talk about new topics.\\\" \" + \"-OpenAI API Documenation\")] [SerializeField] float mPresencePenalty = 1.0f; [Tooltip( \"\\\"Number between - 2.0 and 2.0.Positive values penalize new \" + \"tokens based on their existing frequency in the text so far, \" + \"decreasing the model's likelihood to repeat the same line verbatim.\\\"\" + \" -OpenAI API Documenation\")] [SerializeField] float mFrequencyPenalty = 1.0f; [Tooltip(\"How many seconds per char the character should wait before\" + \" doing anything else after saying something.\")] [SerializeField] float mWaitScalar = 0.1f; [Tooltip(\"Max time to wait before making a new gpt reply request.\")] [SerializeField] private float mMaxReplyWait = 20.0f; [Header(\"Test Features\")] [Tooltip(\"Test statement for the character to make manually.\")] [SerializeField] private string mManualStatement = \"\"; [Tooltip(\"Causes character to make a manually entered test statement.\")] [SerializeField] private bool mMakeManualStatment = false; [Tooltip(\"Causes status statements to be printed to console.\")] [SerializeField] private bool mVerbose = false; [Tooltip(\"Whether to immediatly bring character personality to life.\")] [SerializeField] private bool mAutoActivate = false; /// <summary> /// Controller asset in scene that generates personality prompts for all /// LLM personalities. /// </summary> private PersonalityManager mPersonalityController; /// <summary> /// Personality descriptions based on parameters. /// </summary> private string[] mDescriptions; /// <summary> /// Single string representing all aspects of personality. /// </summary> private string mPersonalityPrompt; /// <summary> /// String builder used to build prompt strings efficiently. /// </summary> private StringBuilder mBuilder; /// <summary> /// Communication interface between the character and GPT. /// </summary> private GptCommunicator mGpt; /// <summary> /// Abstract hearing sense to generate prompts from heard \"sounds\". /// </summary> private Hearing mHearing; /// <summary> /// Function delegate to \"say\" statements to surrounding characters. /// </summary> /// <param name=\"speaker\"> /// The Character making the statement. /// </param> /// The statement being made. /// <param name=\"statment\"></param> public delegate void SayToOthers(Personality speaker, string statment); /// <summary> /// Event fired to \"say\" statements to surrounding characters. /// </summary> public event SayToOthers onSayToOthers; /// <summary> /// What the character is \"looking at\" currently. /// </summary> private IDescribable mLookingAt; /// <summary> /// Vision abstraction to describe what the character /// can \"see\" in a written prompt. /// </summary> private Vision mVision; /// <summary> /// Text description of Character's role they are playing. /// </summary> private string mRole; /// <summary> /// List of GPT Messages sent and received on behalf of this Character. /// </summary> private List<GptCommunicator.Message> mMessages; /// <summary> /// Description of Character's surroundings. /// </summary> private string mSurroundings; /// <summary> /// How long the character should wait before making another statment, /// based on the previous statement. /// </summary> private float mLastStatementWait; /// <summary> /// The last time a statement was made. /// </summary> private float mLastStatementTime; /// <summary> /// Short description of personality, for data collection purposes. /// </summary> private string mSummary; /** Accessors/Setters **/ public string CharacterName { get => mCharacterName; set => mCharacterName = value; } public string BackStory { get => mBackStory; set => mBackStory = value; } public float Temperature { get => mTemperature; } public float PresencePenalty { get => mPresencePenalty; } public float FrequencyPenalty { get => mFrequencyPenalty; } public int Openness { get => mOpenness; set => mOpenness = value; } public int Conscientiousness { get => mConscientiousness; set => mConscientiousness = value; } public int Extraversion { get => mExtraversion; set => mExtraversion = value; } public int Agreeableness { get => mAgreeableness; set => mAgreeableness = value; } public int Neroticsm { get => mNeuroticsm; set => mNeuroticsm = value; } public int Happiness { get => mHappiness; set => mHappiness = value; } public int Anger { get => mAnger; set => mAnger = value; } public int Sarcasm { get => mSarcasm; set => mSarcasm = value; } public string[] Secrets { get => mSecrets; set => mSecrets = value; } public string[] ShirtSleeve { get => mShirtSleeve; set => mShirtSleeve = value; } public IDescribable LookingAt { get => mLookingAt; set => mLookingAt = value; } public string[] Descriptions { get => mDescriptions; } public List<GptCommunicator.Message> Messages { get => mMessages; } public bool Verbose { get => mVerbose; } public string Summary { get => mSummary; } public string Tasks { get => TasksDescription(); } public string[] TaskList { set => mTasks = value; } public string Role { get => BuildRole(); } public string Topics { get => TopicsDescription(); } public string[] TopicsList { set => mTopics = value; } /// <summary> /// This function is called when the object becomes enabled and active. /// </summary> private void OnEnable() { Init(); } /// <summary> /// Start is called on the frame when a script is enabled just before any /// of the Update methods are called the first time. /// </summary> private void Start() { if (mAutoActivate) StartPersonality(); } /// <summary> /// Update is called every frame, if the MonoBehaviour is enabled. /// </summary> private void Update() { if (mMakeManualStatment) MakeManualStatement(); } /// <summary> /// Starts the Personality. /// </summary> public void StartPersonality() { mVision.SetFov(mVision.FovHorizontal, mVision.FovVertical); } /// <summary> /// Initializes (or reinitializes) the Personality. /// </summary> public void Init() { mBuilder = new StringBuilder(mMaxTokens * 4); mMessages = new List<GptCommunicator.Message>(); mPersonalityController = FindAnyObjectByType<PersonalityManager>(); if (mPersonalityController == null) { Debug.LogError($\"ERROR: No PersonalityManager found in scene!\"); } mDescriptions = mPersonalityController.GenerateNewPersonality(this); mBuilder.Clear(); foreach (string aspect in mDescriptions) { mBuilder.Append($\"{aspect}\"); } mPersonalityPrompt = mBuilder.ToString(); mVision = GetComponentInChildren<Vision>(); if (mVision == null) { //Debug.LogError($\"ERROR: Character {mCharacterName} has no vision\" + $\" component!\"); } mGpt = FindFirstObjectByType<GptCommunicator>(); if (mGpt == null) { //Debug.LogError($\"ERROR: Gpt communicator not found in scene!\"); } mRole = BuildRole(); SetSystemPrompt(mRole); mHearing = gameObject.GetComponentInChildren<Hearing>(); mSummary = mPersonalityController.GenerateSummary(this); } /// <summary> /// Builds a role description string from parameter description strings. /// </summary> /// <returns> /// Role description. /// </returns> private string BuildRole() { mRole = $\" {Defines.ROLE_HEAD} {CharacterName} with this backstory: {BackStory}\" + $\"{Defines.ROLE_MID} {mPersonalityPrompt} \" + $\"{Tasks}{Topics}{Defines.ROLE_TAIL} {Defines.DIALOGUE_RULE}\"; //Debug.Log($\"{mCharacterName} is using the following role:\" + $\"\\n\\\"{mRole}\\\"\"); return mRole; } /// <summary> /// Builds a description of topics this personality wants to talk about. /// </summary> /// <returns> /// Description of topics this perosnality wants to talk about. /// </returns> private string TopicsDescription() { // Description of topics. string description = \"\"; if (mTopics.Length > 0) { mBuilder.Clear(); mBuilder.Append($\"{Defines.TOPICS_HEAD} \"); if (mTopics.Length > 1) { for (int i = 0; i < mTopics.Length; i++) { mBuilder.Append(mTopics[i]); if (i < mTopics.Length - 1) mBuilder.Append(Defines.LIST_TAIL); else mBuilder.Append(Defines.END_TAIL); } } else mBuilder.Append($\"{mTopics[0]}{Defines.END_TAIL}\"); description = mBuilder.ToString(); } return description; } /// <summary> /// Generates a description of current tasks occupied by this character. /// </summary> /// <returns> /// Task desscription string. /// </returns> private string TasksDescription() { // Description of tasks. string description = \"\"; if (mTasks.Length > 0) { mBuilder.Clear(); mBuilder.Append($\"{Defines.TASKS_HEAD} \"); for (int i = 0; i < mTasks.Length; i++) { mBuilder.Append(mTasks[i]); if (i < mTasks.Length - 1) mBuilder.Append(Defines.LIST_TAIL); else mBuilder.Append(Defines.END_TAIL); } description = mBuilder.ToString(); } return description; } /// <summary> /// Checks whether the character can see or hear anything. /// Only handles vision right now. TO DO: Handle hearing. /// </summary> public void AssessSurroundings() { // Text description of Character's environment. string assessment = DescribeVisualSurroundings(); if(!assessment.Equals(string.Empty)) mGpt.RequestVisualQueuePrompt(assessment, this, SayOutLoud); Debug.Log($\"{mCharacterName} {Defines.ASSESS_MID}{assessment}\"); } /// <summary> /// Sets the system prompt for the message list. /// </summary> /// <param name=\"prompt\"></param> public void SetSystemPrompt(string prompt) { // New system prompt message. GptCommunicator.Message system = new GptCommunicator.Message { role = \"system\", content = prompt }; if (mMessages.Count > 0) mMessages.RemoveAt(0); mMessages.Insert(0, system); Debug.Log($\"{mCharacterName} is using the following role:\" + $\"\\n\\\"{mRole}\\\"\"); } /// <summary> /// Checks verbosity. /// </summary> /// <returns> /// True if Character is verbose, false if set otherwise. /// </returns> public bool IsVerbose() { return mVerbose; } /// <summary> /// Character makes a preset statement for debugging. /// </summary> private void MakeManualStatement() { if (Verbose) Debug.Log($\"{mCharacterName} is making the manual statement \" + $\"\\\"{mManualStatement}\\\".\"); if (mManualStatement != null && mManualStatement.Length > 0) onSayToOthers?.Invoke(this, mManualStatement); mMakeManualStatment = false; } /// <summary> /// Makes a statement out loud to surrounding Characters. /// </summary> /// <param name=\"statement\"> /// Statement being made. /// </param> private void SayOutLoud(string statement) { // Current game time. float time = Time.realtimeSinceStartup; // Difference between current time and the last dialogue request. float delta = time - mLastStatementTime; // How long to wait before making another request. float waitSeconds = delta > mLastStatementWait ? 0 : Mathf.Min(mMaxReplyWait, mLastStatementWait - delta); StartCoroutine(MakeStatement(statement, waitSeconds)); mLastStatementTime = time; mLastStatementWait = statement.Length * mWaitScalar; } /// <summary> /// Makes a reply request from GPT. /// </summary> /// <param name=\"statement\"> /// The statement to reply to. /// </param> /// <param name=\"waitSeconds\"> /// How long to wait before making the request. /// </param> /// <returns></returns> IEnumerator MakeStatement(string statement, float waitSeconds) { yield return new WaitForSeconds(waitSeconds); onSayToOthers?.Invoke(this, statement); Debug.Log($\"{mCharacterName} said \\\"{statement}\\\".\"); } /// <summary> /// Executes function calls based on text description of intended actions. /// </summary> /// <param name=\"instructions\"> /// Text description from which to generate fuction calls. /// </param> private void FollowInstructions(string instructions) { // To do. } /// <summary> /// Receives a statement made by another character, /// illicits a response if appropriate. /// </summary> /// <param name=\"speaker\"> /// Character making the statement. /// </param> /// <param name=\"statement\"> /// Statement being made by the spearker. /// </param> public void HearFromOther(IDescribable speaker, string statement) { string prompt = $\"{speaker.DescribeSelfForOther(this)} \" + $\"{Defines.HEAR_OTHER_MID} \\\"{statement}\\\"{Defines.END_TAIL}\"; if (mVerbose) Debug.Log($\"{mCharacterName} heard \\\"{statement}\\\".\"); mGpt.RequestConversationalReply(prompt, this, SayOutLoud); } /// <summary> /// Recieves a text descritption of a noise made in the vicinity of a /// Character, illicits a response if approrpriate. /// </summary> /// <param name=\"noiseMaker\"> /// Thing that made the noise. /// </param> /// <param name=\"noise\"> /// Text description of the noise. /// </param> public void HearFromNonAnimate(IDescribable noiseMaker, string noise) { mBuilder.Clear(); mBuilder.Append($\"{Defines.HEAR_NONANIM_HEAD} {noise} \" + $\"{Defines.HEAR_NONANIM_MID} {noiseMaker.DescribeSelfForOther(this)}\" + $\"{Defines.END_TAIL}\"); mBuilder.Append(DescribeVisualSurroundings()); mGpt.RequestReactionInstructions(mBuilder.ToString(), this, FollowInstructions); } /// <summary> /// Generates a text description of the Character's visual surroundings. /// </summary> /// <returns></returns> public string DescribeVisualSurroundings() { // Things seen by Character. IDescribable[] seen = mVision.Seen; // Iterator variable. int i; // Description of visual surroundings. string description = string.Empty; if (seen.Length > 0) { mBuilder.Clear(); mBuilder.Append($\"{Defines.SEE_HEAD} \"); for (i = 0; i < seen.Length; i++) { if (i < seen.Length - 1) mBuilder.Append($\"{seen[i].DescribeSelfForOther(this)}\" + $\"{Defines.LIST_TAIL}\"); else if(seen.Length > 1) mBuilder.Append($\"{Defines.LIST_HEAD} \" + $\"{seen[i].DescribeSelfForOther(this)}{Defines.END_TAIL}\"); else mBuilder.Append($\"{seen[i].DescribeSelfForOther(this)}\" + $\"{Defines.END_TAIL}\"); } description = mBuilder.ToString(); } mSurroundings = description; return description; } /// <summary> /// Generates a text description of this character for another character. /// </summary> /// <param name=\"caller\"> /// Character the text description is being generated for. /// </param> /// <returns> /// Character the text description os being generated of. /// </returns> public string DescribeSelfForOther(Personality caller) { mBuilder.Clear(); mBuilder.Append($\"{BackStory} {Defines.DESC_NAME} {CharacterName}\"); if (LookingAt != null) if ((object)LookingAt != caller) mBuilder.Append($\" {Defines.LOOK_OTHER} {LookingAt}\"); else mBuilder.Append($\" {Defines.LOOK_YOU}\"); else mBuilder.Append($\" {Defines.LOOK_NOTH}\"); return mBuilder.ToString(); } public string GetName() { return CharacterName; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Personality",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "Personality",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; using System.Text; using Zomb.Creatures.Helpers; /// <summary> /// Manages text descriptions of a self and any \"percieved\" other describable /// objects. /// </summary> public class Personality : MonoBehaviour, IDescribable { [Header(\"Character Attributes\")] [Tooltip(\"The name of this character.\")] [SerializeField] private string mCharacterName = \"Bilbo\"; [Tooltip(\"Who and what this character is. Short and sweet, use as little\" + \" punctuation as possible.\"), TextArea(6, 10)] [SerializeField] private string mBackStory = \"a simulated video game character\"; [Tooltip(\"Integer value, [0-4].\\n\\\"Openness is an overarching concept or\" + \" philosophy that is characterized by an emphasis on transparency and \" + \"collaboration.\\\" -Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mOpenness = 2; [Tooltip(\"Integer value, [0-4].\\n\\\"...the personality trait of being \" + \"careful or diligent.\\\" -Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mConscientiousness = 2; [Tooltip(\"Integer value, [0-4].\\n\\\"Extraversion tends to be manifested in \" + \"outgoing, talkative, energetic behavior.\\\" -Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mExtraversion = 2; [Tooltip(\"Integer value, [0-4].\\n\\\"Agreeableness is a personality trait \" + \"that manifests as behavior that is perceived as kind, sympathetic, \" + \"cooperative, warm, frank, and considerate.\\\" -Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mAgreeableness = 2; [Tooltip(\"Integer value, [0-4].\\n\\\"...individuals with high scores for\" + \" neuroticism are more likely than average to be moody and to\" + \" experience such feelings as anxiety, worry, fear, anger,\" + \" frustration, envy, jealousy, pessimism, guilt, depressed mood, and\" + \" loneliness.\\\" -Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mNeuroticsm = 2; [Tooltip(\"Integer value, [0-4].\\n\\\"Happiness is a positive and pleasant \" + \"emotion, ranging from contentment to intense joy.\\\" - Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mHappiness = 2; [Tooltip(\"Integer value, [0-4].\\n\\\"Anger, also known as wrath or rage, \" + \"is an intense emotional state involving a strong uncomfortable and \" + \"non-cooperative response to a perceived provocation, hurt or threat.\\\"\" + \" -Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mAnger = 2; [Tooltip(\"Integer value, [0-4].\\n\\\"Sarcasm is the caustic use of words, \" + \"often in a humorous way, to mock someone or something.\\\" -Wikipedia\")] [vMinMax(0, 4)] [SerializeField] private int mSarcasm = 2; [Tooltip(\"List of things this character avoids in conversation, in the\" + \" form, \\\"Secretly, you...\\\"\")] [SerializeField] private string[] mSecrets; [Tooltip(\"List of things about themselves this character would love to\" + \" tell you about, in the form \\\"You want everyone to know...\\\"\")] [SerializeField] private string[] mShirtSleeve; [Tooltip(\"What this character is doing right now. The tasks at hand.\")] [SerializeField] private string[] mTasks; [Tooltip(\"Subjects this character wants to ask people and talk about.\")] [SerializeField] private string[] mTopics; [Header(\"Model Paramters\")] [Tooltip(\"\\\"The maximum number of tokens to generate in the completion.\\\" \" + \"-OpenAI API Documentation\")] [SerializeField] private int mMaxTokens = Defines.MAX_TOKENS; [Tooltip(\"\\\"What sampling temperature to use, between 0 and 2. Higher\" + \" values like 0.8 will make the output more random, while lower values\" + \" like 0.2 will make it more focused and deterministic.\\\" \" + \"-OpenAI API Documenation\")] [SerializeField] private float mTemperature = 0.7f; [Tooltip(\"\\\"Number between -2.0 and 2.0. Positive values penalize new \" + \"tokens based on whether they appear in the text so far, increasing the\" + \" model's likelihood to talk about new topics.\\\" \" + \"-OpenAI API Documenation\")] [SerializeField] float mPresencePenalty = 1.0f; [Tooltip( \"\\\"Number between - 2.0 and 2.0.Positive values penalize new \" + \"tokens based on their existing frequency in the text so far, \" + \"decreasing the model's likelihood to repeat the same line verbatim.\\\"\" + \" -OpenAI API Documenation\")] [SerializeField] float mFrequencyPenalty = 1.0f; [Tooltip(\"How many seconds per char the character should wait before\" + \" doing anything else after saying something.\")] [SerializeField] float mWaitScalar = 0.1f; [Tooltip(\"Max time to wait before making a new gpt reply request.\")] [SerializeField] private float mMaxReplyWait = 20.0f; [Header(\"Test Features\")] [Tooltip(\"Test statement for the character to make manually.\")] [SerializeField] private string mManualStatement = \"\"; [Tooltip(\"Causes character to make a manually entered test statement.\")] [SerializeField] private bool mMakeManualStatment = false; [Tooltip(\"Causes status statements to be printed to console.\")] [SerializeField] private bool mVerbose = false; [Tooltip(\"Whether to immediatly bring character personality to life.\")] [SerializeField] private bool mAutoActivate = false; /// <summary> /// Controller asset in scene that generates personality prompts for all /// LLM personalities. /// </summary> private PersonalityManager mPersonalityController; /// <summary> /// Personality descriptions based on parameters. /// </summary> private string[] mDescriptions; /// <summary> /// Single string representing all aspects of personality. /// </summary> private string mPersonalityPrompt; /// <summary> /// String builder used to build prompt strings efficiently. /// </summary> private StringBuilder mBuilder; /// <summary> /// Communication interface between the character and GPT. /// </summary> private GptCommunicator mGpt; /// <summary> /// Abstract hearing sense to generate prompts from heard \"sounds\". /// </summary> private Hearing mHearing; /// <summary> /// Function delegate to \"say\" statements to surrounding characters. /// </summary> /// <param name=\"speaker\"> /// The Character making the statement. /// </param> /// The statement being made. /// <param name=\"statment\"></param> public delegate void SayToOthers(Personality speaker, string statment); /// <summary> /// Event fired to \"say\" statements to surrounding characters. /// </summary> public event SayToOthers onSayToOthers; /// <summary> /// What the character is \"looking at\" currently. /// </summary> private IDescribable mLookingAt; /// <summary> /// Vision abstraction to describe what the character /// can \"see\" in a written prompt. /// </summary> private Vision mVision; /// <summary> /// Text description of Character's role they are playing. /// </summary> private string mRole; /// <summary> /// List of GPT Messages sent and received on behalf of this Character. /// </summary> private List<GptCommunicator.Message> mMessages; /// <summary> /// Description of Character's surroundings. /// </summary> private string mSurroundings; /// <summary> /// How long the character should wait before making another statment, /// based on the previous statement. /// </summary> private float mLastStatementWait; /// <summary> /// The last time a statement was made. /// </summary> private float mLastStatementTime; /// <summary> /// Short description of personality, for data collection purposes. /// </summary> private string mSummary; /** Accessors/Setters **/ public string CharacterName { get => mCharacterName; set => mCharacterName = value; } public string BackStory { get => mBackStory; set => mBackStory = value; } public float Temperature { get => mTemperature; } public float PresencePenalty { get => mPresencePenalty; } public float FrequencyPenalty { get => mFrequencyPenalty; } public int Openness { get => mOpenness; set => mOpenness = value; } public int Conscientiousness { get => mConscientiousness; set => mConscientiousness = value; } public int Extraversion { get => mExtraversion; set => mExtraversion = value; } public int Agreeableness { get => mAgreeableness; set => mAgreeableness = value; } public int Neroticsm { get => mNeuroticsm; set => mNeuroticsm = value; } public int Happiness { get => mHappiness; set => mHappiness = value; } public int Anger { get => mAnger; set => mAnger = value; } public int Sarcasm { get => mSarcasm; set => mSarcasm = value; } public string[] Secrets { get => mSecrets; set => mSecrets = value; } public string[] ShirtSleeve { get => mShirtSleeve; set => mShirtSleeve = value; } public IDescribable LookingAt { get => mLookingAt; set => mLookingAt = value; } public string[] Descriptions { get => mDescriptions; } public List<GptCommunicator.Message> Messages { get => mMessages; } public bool Verbose { get => mVerbose; } public string Summary { get => mSummary; } public string Tasks { get => TasksDescription(); } public string[] TaskList { set => mTasks = value; } public string Role { get => BuildRole(); } public string Topics { get => TopicsDescription(); } public string[] TopicsList { set => mTopics = value; } /// <summary> /// This function is called when the object becomes enabled and active. /// </summary> private void OnEnable() { Init(); } /// <summary> /// Start is called on the frame when a script is enabled just before any /// of the Update methods are called the first time. /// </summary> private void Start() { if (mAutoActivate) StartPersonality(); } /// <summary> /// Update is called every frame, if the MonoBehaviour is enabled. /// </summary> private void Update() { if (mMakeManualStatment) MakeManualStatement(); } /// <summary> /// Starts the Personality. /// </summary> public void StartPersonality() { mVision.SetFov(mVision.FovHorizontal, mVision.FovVertical); } /// <summary> /// Initializes (or reinitializes) the Personality. /// </summary> public void Init() { mBuilder = new StringBuilder(mMaxTokens * 4); mMessages = new List<GptCommunicator.Message>(); mPersonalityController = FindAnyObjectByType<PersonalityManager>(); if (mPersonalityController == null) { Debug.LogError($\"ERROR: No PersonalityManager found in scene!\"); } mDescriptions = mPersonalityController.GenerateNewPersonality(this); mBuilder.Clear(); foreach (string aspect in mDescriptions) { mBuilder.Append($\"{aspect}\"); } mPersonalityPrompt = mBuilder.ToString(); mVision = GetComponentInChildren<Vision>(); if (mVision == null) { //Debug.LogError($\"ERROR: Character {mCharacterName} has no vision\" + $\" component!\"); } mGpt = FindFirstObjectByType<GptCommunicator>(); if (mGpt == null) { //Debug.LogError($\"ERROR: Gpt communicator not found in scene!\"); } mRole = BuildRole(); SetSystemPrompt(mRole); mHearing = gameObject.GetComponentInChildren<Hearing>(); mSummary = mPersonalityController.GenerateSummary(this); } /// <summary> /// Builds a role description string from parameter description strings. /// </summary> /// <returns> /// Role description. /// </returns> private string BuildRole() { mRole = $\" {Defines.ROLE_HEAD} {CharacterName} with this backstory: {BackStory}\" + $\"{Defines.ROLE_MID} {mPersonalityPrompt} \" + $\"{Tasks}{Topics}{Defines.ROLE_TAIL} {Defines.DIALOGUE_RULE}\"; //Debug.Log($\"{mCharacterName} is using the following role:\" + $\"\\n\\\"{mRole}\\\"\"); return mRole; } /// <summary> /// Builds a description of topics this personality wants to talk about. /// </summary> /// <returns> /// Description of topics this perosnality wants to talk about. /// </returns> private string TopicsDescription() { // Description of topics. string description = \"\"; if (mTopics.Length > 0) { mBuilder.Clear(); mBuilder.Append($\"{Defines.TOPICS_HEAD} \"); if (mTopics.Length > 1) { for (int i = 0; i < mTopics.Length; i++) { mBuilder.Append(mTopics[i]); if (i < mTopics.Length - 1) mBuilder.Append(Defines.LIST_TAIL); else mBuilder.Append(Defines.END_TAIL); } } else mBuilder.Append($\"{mTopics[0]}{Defines.END_TAIL}\"); description = mBuilder.ToString(); } return description; } /// <summary> /// Generates a description of current tasks occupied by this character. /// </summary> /// <returns> /// Task desscription string. /// </returns> private string TasksDescription() { // Description of tasks. string description = \"\"; if (mTasks.Length > 0) { mBuilder.Clear(); mBuilder.Append($\"{Defines.TASKS_HEAD} \"); for (int i = 0; i < mTasks.Length; i++) { mBuilder.Append(mTasks[i]); if (i < mTasks.Length - 1) mBuilder.Append(Defines.LIST_TAIL); else mBuilder.Append(Defines.END_TAIL); } description = mBuilder.ToString(); } return description; } /// <summary> /// Checks whether the character can see or hear anything. /// Only handles vision right now. TO DO: Handle hearing. /// </summary> public void AssessSurroundings() { // Text description of Character's environment. string assessment = DescribeVisualSurroundings(); if(!assessment.Equals(string.Empty)) mGpt.RequestVisualQueuePrompt(assessment, this, SayOutLoud); Debug.Log($\"{mCharacterName} {Defines.ASSESS_MID}{assessment}\"); } /// <summary> /// Sets the system prompt for the message list. /// </summary> /// <param name=\"prompt\"></param> public void SetSystemPrompt(string prompt) { // New system prompt message. GptCommunicator.Message system = new GptCommunicator.Message { role = \"system\", content = prompt }; if (mMessages.Count > 0) mMessages.RemoveAt(0); mMessages.Insert(0, system); Debug.Log($\"{mCharacterName} is using the following role:\" + $\"\\n\\\"{mRole}\\\"\"); } /// <summary> /// Checks verbosity. /// </summary> /// <returns> /// True if Character is verbose, false if set otherwise. /// </returns> public bool IsVerbose() { return mVerbose; } /// <summary> /// Character makes a preset statement for debugging. /// </summary> private void MakeManualStatement() { if (Verbose) Debug.Log($\"{mCharacterName} is making the manual statement \" + $\"\\\"{mManualStatement}\\\".\"); if (mManualStatement != null && mManualStatement.Length > 0) onSayToOthers?.Invoke(this, mManualStatement); mMakeManualStatment = false; } /// <summary> /// Makes a statement out loud to surrounding Characters. /// </summary> /// <param name=\"statement\"> /// Statement being made. /// </param> private void SayOutLoud(string statement) { // Current game time. float time = Time.realtimeSinceStartup; // Difference between current time and the last dialogue request. float delta = time - mLastStatementTime; // How long to wait before making another request. float waitSeconds = delta > mLastStatementWait ? 0 : Mathf.Min(mMaxReplyWait, mLastStatementWait - delta); StartCoroutine(MakeStatement(statement, waitSeconds)); mLastStatementTime = time; mLastStatementWait = statement.Length * mWaitScalar; } /// <summary> /// Makes a reply request from GPT. /// </summary> /// <param name=\"statement\"> /// The statement to reply to. /// </param> /// <param name=\"waitSeconds\"> /// How long to wait before making the request. /// </param> /// <returns></returns> IEnumerator MakeStatement(string statement, float waitSeconds) { yield return new WaitForSeconds(waitSeconds); onSayToOthers?.Invoke(this, statement); Debug.Log($\"{mCharacterName} said \\\"{statement}\\\".\"); } /// <summary> /// Executes function calls based on text description of intended actions. /// </summary> /// <param name=\"instructions\"> /// Text description from which to generate fuction calls. /// </param> private void FollowInstructions(string instructions) { // To do. } /// <summary> /// Receives a statement made by another character, /// illicits a response if appropriate. /// </summary> /// <param name=\"speaker\"> /// Character making the statement. /// </param> /// <param name=\"statement\"> /// Statement being made by the spearker. /// </param> public void HearFromOther(IDescribable speaker, string statement) { string prompt = $\"{speaker.DescribeSelfForOther(this)} \" + $\"{Defines.HEAR_OTHER_MID} \\\"{statement}\\\"{Defines.END_TAIL}\"; if (mVerbose) Debug.Log($\"{mCharacterName} heard \\\"{statement}\\\".\"); mGpt.RequestConversationalReply(prompt, this, SayOutLoud); } /// <summary> /// Recieves a text descritption of a noise made in the vicinity of a /// Character, illicits a response if approrpriate. /// </summary> /// <param name=\"noiseMaker\"> /// Thing that made the noise. /// </param> /// <param name=\"noise\"> /// Text description of the noise. /// </param> public void HearFromNonAnimate(IDescribable noiseMaker, string noise) { mBuilder.Clear(); mBuilder.Append($\"{Defines.HEAR_NONANIM_HEAD} {noise} \" + $\"{Defines.HEAR_NONANIM_MID} {noiseMaker.DescribeSelfForOther(this)}\" + $\"{Defines.END_TAIL}\"); mBuilder.Append(DescribeVisualSurroundings()); mGpt.RequestReactionInstructions(mBuilder.ToString(), this, FollowInstructions); } /// <summary> /// Generates a text description of the Character's visual surroundings. /// </summary> /// <returns></returns> public string DescribeVisualSurroundings() { // Things seen by Character. IDescribable[] seen = mVision.Seen; // Iterator variable. int i; // Description of visual surroundings. string description = string.Empty; if (seen.Length > 0) { mBuilder.Clear(); mBuilder.Append($\"{Defines.SEE_HEAD} \"); for (i = 0; i < seen.Length; i++) { if (i < seen.Length - 1) mBuilder.Append($\"{seen[i].DescribeSelfForOther(this)}\" + $\"{Defines.LIST_TAIL}\"); else if(seen.Length > 1) mBuilder.Append($\"{Defines.LIST_HEAD} \" + $\"{seen[i].DescribeSelfForOther(this)}{Defines.END_TAIL}\"); else mBuilder.Append($\"{seen[i].DescribeSelfForOther(this)}\" + $\"{Defines.END_TAIL}\"); } description = mBuilder.ToString(); } mSurroundings = description; return description; } /// <summary> /// Generates a text description of this character for another character. /// </summary> /// <param name=\"caller\"> /// Character the text description is being generated for. /// </param> /// <returns> /// Character the text description os being generated of. /// </returns> public string DescribeSelfForOther(Personality caller) { mBuilder.Clear(); mBuilder.Append($\"{BackStory} {Defines.DESC_NAME} {CharacterName}\"); if (LookingAt != null) if ((object)LookingAt != caller) mBuilder.Append($\" {Defines.LOOK_OTHER} {LookingAt}\"); else mBuilder.Append($\" {Defines.LOOK_YOU}\"); else mBuilder.Append($\" {Defines.LOOK_NOTH}\"); return mBuilder.ToString();  ",
          "content_tokens": 4928,
          "embedding": []
        },
        {
          "cs_scriptfile": "Personality",
          "content": "public string GetName() { return CharacterName; } }",
          "content_tokens": 12,
          "embedding": []
        }
      ],
      "length": 18050
    },
    {
      "filename": "PersonalityGenerator",
      "content": "using System.Collections.Generic; using System.IO; using System.Text; using UnityEngine; using UnityEngine.UI; /// <summary> /// Generates text prompts describing a paramterized personality. /// </summary> public class PersonalityGenerator { /// <summary> /// Aspect of personality by name and adjective, and other dscritpions. /// </summary> private class PersonalityAspect { /// <summary> /// Trait name. /// </summary> protected string mName; /// <summary> /// Adjective used to assign trait. /// </summary> protected string mAdjective; /** Accessors/Setters **/ public string Name { get => mName; } public string Adjective { get => mAdjective; } /// <summary> /// Constructor /// </summary> /// <param name=\"name\">Trait name.</param> /// <param name=\"adjective\">Trait adjective.</param> public PersonalityAspect(string name, string adjective) { mName = name; mAdjective = adjective; } } /// <summary> /// Text prompts and fragments describing a given personality trait with /// methods to generate descriptive prompts based on a parameter value for /// the defined trait. /// </summary> private class Trait : PersonalityAspect { /// <summary> /// Things people with this personality trait will do. /// </summary> private string[] mManifestations; /// <summary> /// Things people with this personality trait will NOT do. /// </summary> private string[] mContradictions; /** Accessors/Setters **/ public string[] Manifestations { get => mManifestations; } public string[] Contradictions { get => mContradictions; } /// <summary> /// Constructor /// </summary> /// <param name=\"name\">Trait name.</param> /// <param name=\"adjective\">Trait adjective.</param> public Trait(string name, string adjective) : base(name, adjective) { ReadTraits(); } /// <summary> /// Reads in descriptions of a given trait. /// </summary> private void ReadTraits() { // List of read trait manifestations. List<string> pos = new List<string>(); // List of read trait contradictions. List<string> neg = new List<string>(); // Path to trait's descriptions file. string filePath = $\"{Application.streamingAssetsPath}/{Defines.TRAITS_PATH}/{mName}{Defines.TRAITS_EXT}\"; if (!File.Exists($\"{filePath}\")) { Debug.LogError($\"File not found: {filePath}\"); return; } // Lines read from file. string[] lines = File.ReadAllLines(filePath); foreach (string line in lines) if (line[0] == Defines.TRAITS_POS) pos.Add(line.Split(Defines.TRAIT_SPLIT)[1]); else if (line[0] == Defines.TRAITS_NEG) neg.Add(line.Split(Defines.TRAIT_SPLIT)[1]); mManifestations = pos.ToArray(); mContradictions = neg.ToArray(); } } /// <summary> /// Initialization value for stringbuilder internal arrayl. /// </summary> private static readonly int mInitChars = 4096; /// <summary> /// Terms used to describe personality actions. /// </summary> private string[] mActionTerms; /// <summary> /// Terms used to describe degree of trait aspects. /// </summary> private string[] mDegreeTerms; /// <summary> /// Terms used to describe degree of mood aspects. /// </summary> private string[] mMoodTerms; /// <summary> /// Stringbuilder used to build prompt strings. /// </summary> private StringBuilder mBuilder; /// <summary> /// Array of read trait parameter strings. /// </summary> private Trait[] mTraits; /// <summary> /// Array of mood descriptions. /// </summary> private PersonalityAspect[] mMoods; /// <summary> /// Dictionary to query for index of a given trait from its name. /// </summary> private Dictionary<string, int> mAspectIndicies; /// <summary> /// Constructor. /// </summary> public PersonalityGenerator() { // Iterator. int i; mAspectIndicies = new Dictionary<string, int>(); Trait mOpenness = new Trait(Defines.OPEN_NAME, Defines.OPEN_ADJ); Trait mConscientiousness = new Trait(Defines.CONSC_NAME, Defines.CONSC_ADJ); Trait mExtraversion = new Trait(Defines.EXT_NAME, Defines.EXT_ADJ); Trait mAgreeableness = new Trait(Defines.AGREE_NAME, Defines.AGREE_ADJ); Trait mNeuroticism = new Trait(Defines.NEURO_NAME, Defines.NEURO_ADJ); Trait[] traits = { mOpenness, mConscientiousness, mExtraversion, mAgreeableness, mNeuroticism }; mTraits = traits; PersonalityAspect mHappiness = new PersonalityAspect(Defines.HAPPY_NAME, Defines.HAPPY_ADJ); PersonalityAspect mAnger = new PersonalityAspect(Defines.ANGER_NAME, Defines.ANGER_ADJ); PersonalityAspect mSarcasm = new PersonalityAspect(Defines.SARC_NAME, Defines.SARC_ADJ); PersonalityAspect[] moods = { mHappiness, mAnger, mSarcasm }; mMoods = moods; for (i = 0; i < mTraits.Length; i++) mAspectIndicies[mTraits[i].Name] = i; for (i = 0; i < mMoods.Length; i++) mAspectIndicies[mMoods[i].Name] = i; string filePath = $\"{Application.streamingAssetsPath}/{Defines.TRAITS_PATH}/{Defines.ACTION_TERMS_FILE}\"; if (!File.Exists($\"{filePath}\")) { Debug.LogError($\"File not found: {filePath}\"); return; } mActionTerms = File.ReadAllLines(filePath); filePath = $\"{Application.streamingAssetsPath}/{Defines.TRAITS_PATH}/{Defines.DEGREE_TERMS_FILE}\"; if (!File.Exists($\"{filePath}\")) { Debug.LogError($\"File not found: {filePath}\"); return; } mDegreeTerms = File.ReadAllLines(filePath); filePath = $\"{Application.streamingAssetsPath}/{Defines.TRAITS_PATH}/{Defines.MOOD_TERMS_PATH}\"; if (!File.Exists($\"{filePath}\")) { Debug.LogError($\"File not found: {filePath}\"); return; } mMoodTerms = File.ReadAllLines(filePath); mBuilder = new StringBuilder(mInitChars); } /// <summary> /// Generates a description string for a personality trait based on a /// given parameter value. /// </summary> /// <param name=\"traitValue\"> /// Value of of the personality trait. /// </param> /// <param name=\"traitIndex\"> /// Index of personality triat in mTraits member array. /// </param> /// <returns></returns> public string GenerateTraitDescription(int traitValue, int traitIndex) { // Trait to describe. Trait trait = mTraits[traitIndex]; // String to end lines with. string tail; // Description of trait. string description = \"\"; // Iterator. int i; if (traitValue != 2) { mBuilder.Clear(); mBuilder.Append($\"{Defines.ACTION_HEAD}\" + $\" {mDegreeTerms[traitValue]}\" + $\" {trait.Adjective}{Defines.END_TAIL}\"); mBuilder.Append($\"{Defines.ACTION_HEAD}\" + $\" {mActionTerms[traitValue]} \"); for (i = 0; i < trait.Manifestations.Length; i++) { mBuilder.Append(trait.Manifestations[i]); tail = (i < trait.Manifestations.Length - 1) ? Defines.LIST_TAIL : Defines.END_TAIL; mBuilder.Append(tail); } mBuilder.Append($\"{Defines.ACTION_HEAD}\" + $\" {mActionTerms[mActionTerms.Length - traitValue - 1]} \"); for (i = 0; i < trait.Contradictions.Length; i++) { mBuilder.Append(trait.Contradictions[i]); tail = (i < trait.Contradictions.Length - 1) ? Defines.LIST_TAIL : Defines.END_TAIL; mBuilder.Append(tail); } description = mBuilder.ToString(); } return description; } /// <summary> /// Generates a description string of secrets this perosnality would like /// to keep to themselves. /// </summary> /// <param name=\"secrets\"> /// Array of secrets this personality should keep to themselves. /// </param> /// <returns></returns> public string GenerateSecretsDescription(string[] secrets) { // Description of secret. string description = \"\"; // End of a given description or line. string tail; // Iterator variable. int i; if (secrets.Length > 0) { mBuilder.Clear(); mBuilder.Append($\"{Defines.SECRET_HEAD} \"); for (i = 0; i < secrets.Length; i++) { mBuilder.Append(secrets[i]); tail = i < secrets.Length - 1 ? Defines.LIST_TAIL : $\", {Defines.SECRET_TAIL} \"; mBuilder.Append(tail); } description = mBuilder.ToString(); } return description; } /// <summary> /// Generates a text description of a character's \"shirt sleeve\", or the /// things that character wants to talk about or let you know. /// </summary> /// <param name=\"shirtSleeve\"> /// List of things the character wants to tell you about. /// </param> /// <returns> /// Text description of the character's shirt sleeve. /// </returns> public string GenerateShirtSleeveDescription(string[] shirtSleeve) { // Description of something character \"wears on their shirt sleeve\". string description = \"\"; // End of a line or description. string tail; // Iterator variable. int i; if (shirtSleeve.Length > 0) { mBuilder.Clear(); mBuilder.Append($\"{Defines.SHIRT_HEAD} \"); for (i = 0; i < shirtSleeve.Length; i++) { mBuilder.Append(shirtSleeve[i]); if (i < shirtSleeve.Length - 1) tail = Defines.LIST_TAIL; else tail = shirtSleeve.Length > 1 ? $\", {Defines.SHIRT_TAIL_MULTI}.\" : $\", {Defines.SHIRT_TAIL_SINGLE}.\"; mBuilder.Append(tail); } description = mBuilder.ToString(); } return description; } /// <summary> /// Generates text descriptions of given moods. /// </summary> /// <param name=\"moodValues\"> /// Values for moods. /// </param> /// <returns> /// Text representation of personality mood(s). /// </returns> public string GenerateMoodDescriptions(int[] moodValues) { // Mood being described. PersonalityAspect mood; // Descriptions of read moods. string description; // End of line or description. string tail; // Iterator variable. int i; // Whether any mood descriptions have been used. bool useMood = false; mBuilder.Clear(); mBuilder.Append($\"{Defines.MOOD_HEAD} \"); for (i = 0; i < moodValues.Length; i++) { if (moodValues[i] != 2) { useMood = true; mood = mMoods[i]; description = $\"{mMoodTerms[moodValues[i]]} {mood.Adjective}\"; mBuilder.Append(description); tail = i < moodValues.Length - 1 ? Defines.LIST_TAIL : Defines.END_TAIL; mBuilder.Append(tail); } } description = useMood ? mBuilder.ToString() : \"\"; return description; } /// <summary> /// Generates a summary of given personality values. /// </summary> /// <param name=\"traits\"> /// Values for personality traits. /// </param> /// <param name=\"moods\"> /// Values for personality moods. /// </param> /// <returns></returns> public string GenerateSummary(int[] traits, int[] moods) { // Mood being described. PersonalityAspect mood; // Trait to describe. Trait trait; // Value of personality aspect being recorded. int val; // Iterator. int i; mBuilder.Clear(); for (i=0; i < traits.Length; i++) { val = traits[i]; if (val != 2) { trait = mTraits[i]; mBuilder.Append($\"{Defines.ACTION_HEAD}\" + $\" {mDegreeTerms[val]} {trait.Adjective}.\"); } } for(i = 0; i < moods.Length; i++) { val = moods[i]; if(val != 2) { mood = mMoods[i]; mBuilder.Append($\"{Defines.ACTION_HEAD}\" + $\" {mDegreeTerms[val]} {mood.Adjective}.\"); } } return mBuilder.ToString(); } /// <summary> /// Generates a personality description for a given character. /// </summary> /// <param name=\"traitValues\"> /// Openness, conscientiousness, extraversion, agreeableness, neuroticism, /// happiness, anger, sarcasm. /// </param> /// <param name=\"secrets\"> /// Array of topics this personality will avoid. /// </param> /// <param name=\"shirtSleeve\"> /// Array of topics this personality wants to talk about. /// </param> /// <returns> /// Text prompt representing a character's personality. /// </returns> public string[] GeneratePersonalityDescriptions(int[] traitValues, int[] moodValues, string[] secrets, string[] shirtSleeve) { // List of generated personality descriptions. List<string> personalityDescriptions = new List<string>(); // Iterator variable. int i; for (i = 0; i < traitValues.Length; i++) personalityDescriptions.Add( GenerateTraitDescription(traitValues[i], i) ); personalityDescriptions.Add(GenerateMoodDescriptions(moodValues)); personalityDescriptions.Add(GenerateSecretsDescription(secrets)); personalityDescriptions.Add( GenerateShirtSleeveDescription(shirtSleeve) ); return personalityDescriptions.ToArray(); } /// <summary> /// Returns the index of a given trait from its name. /// </summary> /// <param name=\"traitName\"> /// Name of trait you would like the index for. /// </param> /// <returns> /// Index of the named trait. /// </returns> public int TraitIndex(string traitName) { return mAspectIndicies[traitName]; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PersonalityGenerator",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "PersonalityGenerator",
          "content": "using System.Collections.Generic; using System.IO; using System.Text; using UnityEngine; using UnityEngine.UI; /// <summary> /// Generates text prompts describing a paramterized personality. /// </summary> public class PersonalityGenerator { /// <summary> /// Aspect of personality by name and adjective, and other dscritpions. /// </summary> private class PersonalityAspect { /// <summary> /// Trait name. /// </summary> protected string mName; /// <summary> /// Adjective used to assign trait. /// </summary> protected string mAdjective; /** Accessors/Setters **/ public string Name { get => mName; } public string Adjective { get => mAdjective; } /// <summary> /// Constructor /// </summary> /// <param name=\"name\">Trait name.</param> /// <param name=\"adjective\">Trait adjective.</param> public PersonalityAspect(string name, string adjective) { mName = name; mAdjective = adjective; } } /// <summary> /// Text prompts and fragments describing a given personality trait with /// methods to generate descriptive prompts based on a parameter value for /// the defined trait. /// </summary> private class Trait : PersonalityAspect { /// <summary> /// Things people with this personality trait will do. /// </summary> private string[] mManifestations; /// <summary> /// Things people with this personality trait will NOT do. /// </summary> private string[] mContradictions; /** Accessors/Setters **/ public string[] Manifestations { get => mManifestations; } public string[] Contradictions { get => mContradictions; } /// <summary> /// Constructor /// </summary> /// <param name=\"name\">Trait name.</param> /// <param name=\"adjective\">Trait adjective.</param> public Trait(string name, string adjective) : base(name, adjective) { ReadTraits(); } /// <summary> /// Reads in descriptions of a given trait. /// </summary> private void ReadTraits() { // List of read trait manifestations. List<string> pos = new List<string>(); // List of read trait contradictions. List<string> neg = new List<string>(); // Path to trait's descriptions file. string filePath = $\"{Application.streamingAssetsPath}/{Defines.TRAITS_PATH}/{mName}{Defines.TRAITS_EXT}\"; if (!File.Exists($\"{filePath}\")) { Debug.LogError($\"File not found: {filePath}\"); return; } // Lines read from file. string[] lines = File.ReadAllLines(filePath); foreach (string line in lines) if (line[0] == Defines.TRAITS_POS) pos.Add(line.Split(Defines.TRAIT_SPLIT)[1]); else if (line[0] == Defines.TRAITS_NEG) neg.Add(line.Split(Defines.TRAIT_SPLIT)[1]); mManifestations = pos.ToArray(); mContradictions = neg.ToArray(); } } /// <summary> /// Initialization value for stringbuilder internal arrayl. /// </summary> private static readonly int mInitChars = 4096; /// <summary> /// Terms used to describe personality actions. /// </summary> private string[] mActionTerms; /// <summary> /// Terms used to describe degree of trait aspects. /// </summary> private string[] mDegreeTerms; /// <summary> /// Terms used to describe degree of mood aspects. /// </summary> private string[] mMoodTerms; /// <summary> /// Stringbuilder used to build prompt strings. /// </summary> private StringBuilder mBuilder; /// <summary> /// Array of read trait parameter strings. /// </summary> private Trait[] mTraits; /// <summary> /// Array of mood descriptions. /// </summary> private PersonalityAspect[] mMoods; /// <summary> /// Dictionary to query for index of a given trait from its name. /// </summary> private Dictionary<string, int> mAspectIndicies; /// <summary> /// Constructor. /// </summary> public PersonalityGenerator() { // Iterator. int i; mAspectIndicies = new Dictionary<string, int>(); Trait mOpenness = new Trait(Defines.OPEN_NAME, Defines.OPEN_ADJ); Trait mConscientiousness = new Trait(Defines.CONSC_NAME, Defines.CONSC_ADJ); Trait mExtraversion = new Trait(Defines.EXT_NAME, Defines.EXT_ADJ); Trait mAgreeableness = new Trait(Defines.AGREE_NAME, Defines.AGREE_ADJ); Trait mNeuroticism = new Trait(Defines.NEURO_NAME, Defines.NEURO_ADJ); Trait[] traits = { mOpenness, mConscientiousness, mExtraversion, mAgreeableness, mNeuroticism }; mTraits = traits; PersonalityAspect mHappiness = new PersonalityAspect(Defines.HAPPY_NAME, Defines.HAPPY_ADJ); PersonalityAspect mAnger = new PersonalityAspect(Defines.ANGER_NAME, Defines.ANGER_ADJ); PersonalityAspect mSarcasm = new PersonalityAspect(Defines.SARC_NAME, Defines.SARC_ADJ); PersonalityAspect[] moods = { mHappiness, mAnger, mSarcasm }; mMoods = moods; for (i = 0; i < mTraits.Length; i++) mAspectIndicies[mTraits[i].Name] = i; for (i = 0; i < mMoods.Length; i++) mAspectIndicies[mMoods[i].Name] = i; string filePath = $\"{Application.streamingAssetsPath}/{Defines.TRAITS_PATH}/{Defines.ACTION_TERMS_FILE}\"; if (!File.Exists($\"{filePath}\")) { Debug.LogError($\"File not found: {filePath}\"); return; } mActionTerms = File.ReadAllLines(filePath); filePath = $\"{Application.streamingAssetsPath}/{Defines.TRAITS_PATH}/{Defines.DEGREE_TERMS_FILE}\"; if (!File.Exists($\"{filePath}\")) { Debug.LogError($\"File not found: {filePath}\"); return; } mDegreeTerms = File.ReadAllLines(filePath); filePath = $\"{Application.streamingAssetsPath}/{Defines.TRAITS_PATH}/{Defines.MOOD_TERMS_PATH}\"; if (!File.Exists($\"{filePath}\")) { Debug.LogError($\"File not found: {filePath}\"); return; } mMoodTerms = File.ReadAllLines(filePath); mBuilder = new StringBuilder(mInitChars); } /// <summary> /// Generates a description string for a personality trait based on a /// given parameter value. /// </summary> /// <param name=\"traitValue\"> /// Value of of the personality trait. /// </param> /// <param name=\"traitIndex\"> /// Index of personality triat in mTraits member array. /// </param> /// <returns></returns> public string GenerateTraitDescription(int traitValue, int traitIndex) { // Trait to describe. Trait trait = mTraits[traitIndex]; // String to end lines with. string tail; // Description of trait. string description = \"\"; // Iterator. int i; if (traitValue != 2) { mBuilder.Clear(); mBuilder.Append($\"{Defines.ACTION_HEAD}\" + $\" {mDegreeTerms[traitValue]}\" + $\" {trait.Adjective}{Defines.END_TAIL}\"); mBuilder.Append($\"{Defines.ACTION_HEAD}\" + $\" {mActionTerms[traitValue]} \"); for (i = 0; i < trait.Manifestations.Length; i++) { mBuilder.Append(trait.Manifestations[i]); tail = (i < trait.Manifestations.Length - 1) ? Defines.LIST_TAIL : Defines.END_TAIL; mBuilder.Append(tail); } mBuilder.Append($\"{Defines.ACTION_HEAD}\" + $\" {mActionTerms[mActionTerms.Length - traitValue - 1]} \"); for (i = 0; i < trait.Contradictions.Length; i++) { mBuilder.Append(trait.Contradictions[i]); tail = (i < trait.Contradictions.Length - 1) ? Defines.LIST_TAIL : Defines.END_TAIL; mBuilder.Append(tail); } description = mBuilder.ToString(); } return description; } /// <summary> /// Generates a description string of secrets this perosnality would like /// to keep to themselves. /// </summary> /// <param name=\"secrets\"> /// Array of secrets this personality should keep to themselves. /// </param> /// <returns></returns> public string GenerateSecretsDescription(string[] secrets) { // Description of secret. string description = \"\"; // End of a given description or line. string tail; // Iterator variable. int i; if (secrets.Length > 0) { mBuilder.Clear(); mBuilder.Append($\"{Defines.SECRET_HEAD} \"); for (i = 0; i < secrets.Length; i++) { mBuilder.Append(secrets[i]); tail = i < secrets.Length - 1 ? Defines.LIST_TAIL : $\", {Defines.SECRET_TAIL} \"; mBuilder.Append(tail); } description = mBuilder.ToString(); } return description; } /// <summary> /// Generates a text description of a character's \"shirt sleeve\", or the /// things that character wants to talk about or let you know. /// </summary> /// <param name=\"shirtSleeve\"> /// List of things the character wants to tell you about. /// </param> /// <returns> /// Text description of the character's shirt sleeve. /// </returns> public string GenerateShirtSleeveDescription(string[] shirtSleeve) { // Description of something character \"wears on their shirt sleeve\". string description = \"\"; // End of a line or description. string tail; // Iterator variable. int i; if (shirtSleeve.Length > 0) { mBuilder.Clear(); mBuilder.Append($\"{Defines.SHIRT_HEAD} \"); for (i = 0; i < shirtSleeve.Length; i++) { mBuilder.Append(shirtSleeve[i]); if (i < shirtSleeve.Length - 1) tail = Defines.LIST_TAIL; else tail = shirtSleeve.Length > 1 ? $\", {Defines.SHIRT_TAIL_MULTI}.\" : $\", {Defines.SHIRT_TAIL_SINGLE}.\"; mBuilder.Append(tail); } description = mBuilder.ToString(); } return description; } /// <summary> /// Generates text descriptions of given moods. /// </summary> /// <param name=\"moodValues\"> /// Values for moods. /// </param> /// <returns> /// Text representation of personality mood(s). /// </returns> public string GenerateMoodDescriptions(int[] moodValues) { // Mood being described. PersonalityAspect mood; // Descriptions of read moods. string description; // End of line or description. string tail; // Iterator variable. int i; // Whether any mood descriptions have been used. bool useMood = false; mBuilder.Clear(); mBuilder.Append($\"{Defines.MOOD_HEAD} \"); for (i = 0; i < moodValues.Length; i++) { if (moodValues[i] != 2) { useMood = true; mood = mMoods[i]; description = $\"{mMoodTerms[moodValues[i]]} {mood.Adjective}\"; mBuilder.Append(description); tail = i < moodValues.Length - 1 ? Defines.LIST_TAIL : Defines.END_TAIL; mBuilder.Append(tail); } } description = useMood ? mBuilder.ToString() : \"\"; return description; } /// <summary> /// Generates a summary of given personality values. /// </summary> /// <param name=\"traits\"> /// Values for personality traits. /// </param> /// <param name=\"moods\"> /// Values for personality moods. /// </param> /// <returns></returns> public string GenerateSummary(int[] traits, int[] moods) { // Mood being described. PersonalityAspect mood; // Trait to describe. Trait trait; // Value of personality aspect being recorded. int val; // Iterator. int i; mBuilder.Clear(); for (i=0; i < traits.Length; i++) { val = traits[i]; if (val != 2) { trait = mTraits[i]; mBuilder.Append($\"{Defines.ACTION_HEAD}\" + $\" {mDegreeTerms[val]} {trait.Adjective}.\"); }  ",
          "content_tokens": 3013,
          "embedding": []
        },
        {
          "cs_scriptfile": "PersonalityGenerator",
          "content": "for(i = 0; i < moods.Length; i++) { val = moods[i]; if(val != 2) { mood = mMoods[i]; mBuilder.Append($\"{Defines.ACTION_HEAD}\" + $\" {mDegreeTerms[val]} {mood.Adjective}.\"); } } return mBuilder.ToString(); } /// <summary> /// Generates a personality description for a given character. /// </summary> /// <param name=\"traitValues\"> /// Openness, conscientiousness, extraversion, agreeableness, neuroticism, /// happiness, anger, sarcasm. /// </param> /// <param name=\"secrets\"> /// Array of topics this personality will avoid. /// </param> /// <param name=\"shirtSleeve\"> /// Array of topics this personality wants to talk about. /// </param> /// <returns> /// Text prompt representing a character's personality. /// </returns> public string[] GeneratePersonalityDescriptions(int[] traitValues, int[] moodValues, string[] secrets, string[] shirtSleeve) { // List of generated personality descriptions. List<string> personalityDescriptions = new List<string>(); // Iterator variable. int i; for (i = 0; i < traitValues.Length; i++) personalityDescriptions.Add( GenerateTraitDescription(traitValues[i], i) ); personalityDescriptions.Add(GenerateMoodDescriptions(moodValues)); personalityDescriptions.Add(GenerateSecretsDescription(secrets)); personalityDescriptions.Add( GenerateShirtSleeveDescription(shirtSleeve) ); return personalityDescriptions.ToArray(); } /// <summary> /// Returns the index of a given trait from its name. /// </summary> /// <param name=\"traitName\"> /// Name of trait you would like the index for. /// </param> /// <returns> /// Index of the named trait. /// </returns> public int TraitIndex(string traitName) { return mAspectIndicies[traitName]; } }",
          "content_tokens": 457,
          "embedding": []
        }
      ],
      "length": 11794
    },
    {
      "filename": "PersonalityManager",
      "content": "using UnityEngine; /// <summary> /// Manages personality strings for Characters in scene. /// </summary> public class PersonalityManager : MonoBehaviour { /// <summary> /// Generates personality strings. /// </summary> PersonalityGenerator mGenerator = new PersonalityGenerator(); public string GenerateSummary(Personality character) { // Integer values representing big five personality traits. int[] traits = { character.Openness, character.Conscientiousness, character.Extraversion, character.Agreeableness, character.Neroticsm }; // Integer values representing defined moods. int[] moods = { character.Happiness, character.Anger, character.Sarcasm }; return mGenerator.GenerateSummary(traits, moods); } /// <summary> /// Generates a new personality description based on parameterized values. /// </summary> /// <param name=\"character\"> /// Character this personality is intended for. /// </param> /// <returns> /// Text description of a given parameterized personality. /// </returns> public string[] GenerateNewPersonality(Personality character) { // Integer values representing big five personality traits. int[] traits = { character.Openness, character.Conscientiousness, character.Extraversion, character.Agreeableness, character.Neroticsm }; // Integer values representing defined moods. int[] moods = { character.Happiness, character.Anger, character.Sarcasm }; // Secrets the personality wants to keep. string[] secrets = character.Secrets; // Things the personality wants to talk about. string[] shirtSleeve = character.ShirtSleeve; // Generated personality strings. string[] personality = mGenerator.GeneratePersonalityDescriptions( traits, moods, secrets, shirtSleeve ); return personality; } /// <summary> /// Generates a new description of a given trait based on a new value /// given for that trait. In the case a given character changes its /// personality somehow. /// </summary> /// <param name=\"traitIndex\"> /// Index of trait in prompt generator trait array. Openness = 0, /// Conscientiousness = 1, Extraversion = 2, Agreeableness = 3, /// Neruoticsm = 4, Happiness = 5, Anger = 6. /// </param> /// <param name=\"newValue\"> /// Value to generate trait description with. /// </param> /// <returns> /// Description of trait based on given value. /// </returns> public string GenerateNewTrait(string traitName, int newValue) { int traitIndex = mGenerator.TraitIndex(traitName); string description = mGenerator.GenerateTraitDescription(newValue, traitIndex); return description; } /// <summary> /// Generates a new secrets description for a character. /// </summary> /// <param name=\"newSecrets\"> /// New array of secrets to generate a description of. /// </param> /// <returns> /// Text description of array of secrets. /// </returns> public string GenerateNewSecrets(string[] newSecrets) { return mGenerator.GenerateSecretsDescription(newSecrets); } /// <summary> /// Generates a text description from new list of shirt sleeve facts/ideas /// for a personality. /// </summary> /// <param name=\"newShirtSleeve\"> /// New list of shirt sleeve facts. /// </param> /// <returns> /// Text description of shirt sleeve facts. /// </returns> public string GenerateNewShirtSleeve(string[] newShirtSleeve) { return mGenerator.GenerateShirtSleeveDescription(newShirtSleeve); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PersonalityManager",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "PersonalityManager",
          "content": "using UnityEngine; /// <summary> /// Manages personality strings for Characters in scene. /// </summary> public class PersonalityManager : MonoBehaviour { /// <summary> /// Generates personality strings. /// </summary> PersonalityGenerator mGenerator = new PersonalityGenerator(); public string GenerateSummary(Personality character) { // Integer values representing big five personality traits. int[] traits = { character.Openness, character.Conscientiousness, character.Extraversion, character.Agreeableness, character.Neroticsm }; // Integer values representing defined moods. int[] moods = { character.Happiness, character.Anger, character.Sarcasm }; return mGenerator.GenerateSummary(traits, moods); } /// <summary> /// Generates a new personality description based on parameterized values. /// </summary> /// <param name=\"character\"> /// Character this personality is intended for. /// </param> /// <returns> /// Text description of a given parameterized personality. /// </returns> public string[] GenerateNewPersonality(Personality character) { // Integer values representing big five personality traits. int[] traits = { character.Openness, character.Conscientiousness, character.Extraversion, character.Agreeableness, character.Neroticsm }; // Integer values representing defined moods. int[] moods = { character.Happiness, character.Anger, character.Sarcasm }; // Secrets the personality wants to keep. string[] secrets = character.Secrets; // Things the personality wants to talk about. string[] shirtSleeve = character.ShirtSleeve; // Generated personality strings. string[] personality = mGenerator.GeneratePersonalityDescriptions( traits, moods, secrets, shirtSleeve ); return personality; } /// <summary> /// Generates a new description of a given trait based on a new value /// given for that trait. In the case a given character changes its /// personality somehow. /// </summary> /// <param name=\"traitIndex\"> /// Index of trait in prompt generator trait array. Openness = 0, /// Conscientiousness = 1, Extraversion = 2, Agreeableness = 3, /// Neruoticsm = 4, Happiness = 5, Anger = 6. /// </param> /// <param name=\"newValue\"> /// Value to generate trait description with. /// </param> /// <returns> /// Description of trait based on given value. /// </returns> public string GenerateNewTrait(string traitName, int newValue) { int traitIndex = mGenerator.TraitIndex(traitName); string description = mGenerator.GenerateTraitDescription(newValue, traitIndex); return description; } /// <summary> /// Generates a new secrets description for a character. /// </summary> /// <param name=\"newSecrets\"> /// New array of secrets to generate a description of. /// </param> /// <returns> /// Text description of array of secrets. /// </returns> public string GenerateNewSecrets(string[] newSecrets) { return mGenerator.GenerateSecretsDescription(newSecrets); } /// <summary> /// Generates a text description from new list of shirt sleeve facts/ideas /// for a personality. /// </summary> /// <param name=\"newShirtSleeve\"> /// New list of shirt sleeve facts. /// </param> /// <returns> /// Text description of shirt sleeve facts. /// </returns> public string GenerateNewShirtSleeve(string[] newShirtSleeve) { return mGenerator.GenerateShirtSleeveDescription(newShirtSleeve); } }",
          "content_tokens": 783,
          "embedding": []
        }
      ],
      "length": 3287
    },
    {
      "filename": "PersonalityCommunicator",
      "content": "using System; using UnityEngine; using System.Threading.Tasks; using LLMUnity; public class PersonalityCommunicator : MonoBehaviour { [SerializeField] private Personality targetPersonality; [SerializeField] private string testQuestion; [SerializeField] private string testAnswer; [SerializeField] private LLMClient llm; private string dialogueHistory = \"\"; public static PersonalityCommunicator Instance { get; private set; } public static Action<string> OnStartThinking; public static Action<string> OnAnswerReceived; public static Action OnAnswerFinished; public bool IsBusy { get; private set; } public void DoDialog() { string role = targetPersonality.Role; AddQuestionToHistory(testQuestion); string prompt = $\"{role} Previous dialogue history: {dialogueHistory}. {Defines.HEAR_OTHER_MID} \\\"{testQuestion}\\\"{Defines.END_TAIL}\"; string replyPrompt = $\"{prompt} {Defines.REPLY_INSTRUCT}\" + $\"{Defines.RESPONSE_CHECK}{Defines.RESPONSE_DENY}\"; IsBusy = true; Debug.Log($\"Raw prompt: {prompt}\"); Task chatTask = llm.Chat(replyPrompt, ShowOutput, AllowInput); } private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } DontDestroyOnLoad(gameObject); } private void Start() { MicrophoneWhisper.Instance.OnTextReceived += SetQuestion; } private void SetQuestion(string question) { if (targetPersonality == null) return; if (IsBusy) return; OnStartThinking?.Invoke(question); testQuestion = question; DoDialog(); } public void SetTargetPersonality(Personality personality) { targetPersonality = personality; } public void ShowOutput(string text) { testAnswer = text; OnAnswerReceived?.Invoke(testAnswer); } private void AllowInput() { AddAnswerToHistory(testAnswer); IsBusy = false; OnAnswerFinished?.Invoke(); Debug.Log(testAnswer); } private void AddQuestionToHistory(string question) { dialogueHistory += $\"I asked: {question};\"; } private void AddAnswerToHistory(string answer) { dialogueHistory += $\"You said: {answer};\"; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PersonalityCommunicator",
          "content": "using System; using UnityEngine; using System.Threading.Tasks; using LLMUnity; public class PersonalityCommunicator : MonoBehaviour { [SerializeField] private Personality targetPersonality; [SerializeField] private string testQuestion; [SerializeField] private string testAnswer; [SerializeField] private LLMClient llm; private string dialogueHistory = \"\"; public static PersonalityCommunicator Instance { get; private set; } public static Action<string> OnStartThinking; public static Action<string> OnAnswerReceived; public static Action OnAnswerFinished; public bool IsBusy { get; private set;  ",
          "content_tokens": 138,
          "embedding": []
        },
        {
          "cs_scriptfile": "PersonalityCommunicator",
          "content": "public void DoDialog() { string role = targetPersonality.Role; AddQuestionToHistory(testQuestion); string prompt = $\"{role} Previous dialogue history: {dialogueHistory}. {Defines.HEAR_OTHER_MID} \\\"{testQuestion}\\\"{Defines.END_TAIL}\"; string replyPrompt = $\"{prompt} {Defines.REPLY_INSTRUCT}\" + $\"{Defines.RESPONSE_CHECK}{Defines.RESPONSE_DENY}\"; IsBusy = true; Debug.Log($\"Raw prompt: {prompt}\"); Task chatTask = llm.Chat(replyPrompt, ShowOutput, AllowInput);  private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this);  DontDestroyOnLoad(gameObject);  ",
          "content_tokens": 192,
          "embedding": []
        },
        {
          "cs_scriptfile": "PersonalityCommunicator",
          "content": "private void Start() { MicrophoneWhisper.Instance.OnTextReceived += SetQuestion;  private void SetQuestion(string question) { if (targetPersonality == null) return; if (IsBusy) return; OnStartThinking?.Invoke(question); testQuestion = question; DoDialog();  public void SetTargetPersonality(Personality personality) { targetPersonality = personality;  public void ShowOutput(string text) { testAnswer = text; OnAnswerReceived?.Invoke(testAnswer);  private void AllowInput() { AddAnswerToHistory(testAnswer); IsBusy = false; OnAnswerFinished?.Invoke(); Debug.Log(testAnswer);  private void AddQuestionToHistory(string question) { dialogueHistory += $\"I asked: {question};\";  ",
          "content_tokens": 177,
          "embedding": []
        },
        {
          "cs_scriptfile": "PersonalityCommunicator",
          "content": "private void AddAnswerToHistory(string answer) { dialogueHistory += $\"You said: {answer};\"; } }",
          "content_tokens": 25,
          "embedding": []
        }
      ],
      "length": 1959
    },
    {
      "filename": "PersonalityPlayerDetector",
      "content": "using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; using System; using _ZombieRoyale.Scripts.Core; using TMPro; public class PersonalityPlayerDetector : MonoBehaviour { [SerializeField] private GameObjectDispatcher canvasOfTextDialogue; [SerializeField] private Personality personality; [SerializeField] private GameObjectDispatcher keyInfo; [SerializeField] private TextMeshProUGUI keyText; public bool IsLocalPlayerInside { get; private set; } public Action OnPlayerEnter; public Action OnPlayerExit; private void OnValidate() { personality ??= GetComponentInParent<Personality>(); } private void Awake() { personality ??= GetComponentInParent<Personality>(); keyText.text = MicrophoneWhisper.Instance.HoldMicrophoneKey.ToString(); } void OnTriggerEnter(Collider other) { if (IsNotLocalPlayer(other)) return; OnPlayerEnter?.Invoke(); Debug.Log(\"PersonalityPlayerDetector: Player entered\"); PersonalityCommunicator.Instance.SetTargetPersonality(personality); IsLocalPlayerInside = true; canvasOfTextDialogue.Activate(); ShowKeyInfoText(); AttachKeyShowHiding(); } private void AttachKeyShowHiding() { PersonalityCommunicator.OnAnswerFinished += ShowKeyInfoText; PersonalityCommunicator.OnStartThinking += StartThinkingHandler; } private void DeattachKeyShowHiding() { PersonalityCommunicator.OnStartThinking -= StartThinkingHandler; PersonalityCommunicator.OnAnswerFinished -= ShowKeyInfoText; } private void StartThinkingHandler(string question) { HideKeyInfoText(); } private void HideKeyInfoText() { keyInfo.Deactivate(); } private void ShowKeyInfoText() { keyInfo.Activate(); } void OnTriggerExit(Collider other) { if (IsNotLocalPlayer(other)) return; OnPlayerExit?.Invoke(); PersonalityCommunicator.Instance.SetTargetPersonality(null); IsLocalPlayerInside = false; canvasOfTextDialogue.Deactivate(); DeattachKeyShowHiding(); } private static bool IsNotLocalPlayer(Collider other) { if (!other.CompareTag(\"Player\")) return true; var healthController = GameplayManager.Instance.GetHealthController(other); if (healthController == null) return true; if (!healthController.IsOwner) return true; return false; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PersonalityPlayerDetector",
          "content": "using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; using System; using _ZombieRoyale.Scripts.Core; using TMPro; public class PersonalityPlayerDetector : MonoBehaviour { [SerializeField] private GameObjectDispatcher canvasOfTextDialogue; [SerializeField] private Personality personality; [SerializeField] private GameObjectDispatcher keyInfo; [SerializeField] private TextMeshProUGUI keyText; public bool IsLocalPlayerInside { get; private set; } public Action OnPlayerEnter; public Action OnPlayerExit; private void OnValidate() { personality ??= GetComponentInParent<Personality>();  private void Awake() { personality ??= GetComponentInParent<Personality>(); keyText.text = MicrophoneWhisper.Instance.HoldMicrophoneKey.ToString();  ",
          "content_tokens": 191,
          "embedding": []
        },
        {
          "cs_scriptfile": "PersonalityPlayerDetector",
          "content": "void OnTriggerEnter(Collider other) { if (IsNotLocalPlayer(other)) return; OnPlayerEnter?.Invoke(); Debug.Log(\"PersonalityPlayerDetector: Player entered\"); PersonalityCommunicator.Instance.SetTargetPersonality(personality); IsLocalPlayerInside = true; canvasOfTextDialogue.Activate(); ShowKeyInfoText(); AttachKeyShowHiding();  private void AttachKeyShowHiding() { PersonalityCommunicator.OnAnswerFinished += ShowKeyInfoText; PersonalityCommunicator.OnStartThinking += StartThinkingHandler;  private void DeattachKeyShowHiding() { PersonalityCommunicator.OnStartThinking -= StartThinkingHandler; PersonalityCommunicator.OnAnswerFinished -= ShowKeyInfoText;  private void StartThinkingHandler(string question) { HideKeyInfoText();  private void HideKeyInfoText() { keyInfo.Deactivate();  ",
          "content_tokens": 195,
          "embedding": []
        },
        {
          "cs_scriptfile": "PersonalityPlayerDetector",
          "content": "private void ShowKeyInfoText() { keyInfo.Activate();  void OnTriggerExit(Collider other) { if (IsNotLocalPlayer(other)) return; OnPlayerExit?.Invoke(); PersonalityCommunicator.Instance.SetTargetPersonality(null); IsLocalPlayerInside = false; canvasOfTextDialogue.Deactivate(); DeattachKeyShowHiding(); } private static bool IsNotLocalPlayer(Collider other) { if (!other.CompareTag(\"Player\")) return true; var healthController = GameplayManager.Instance.GetHealthController(other); if (healthController == null) return true; if (!healthController.IsOwner) return true; return false; } }",
          "content_tokens": 147,
          "embedding": []
        }
      ],
      "length": 2138
    },
    {
      "filename": "LobbyCanvasesDispatcher",
      "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using UnityEngine; public class LobbyCanvasesDispatcher : MonoBehaviour { public CreateRoomMenu CreateRoomMenu { get { return _createRoomMenu; } } [SerializeField] private CreateRoomMenu _createRoomMenu; public CurrentRoomMenu CurrentRoomMenu { get { return _currentRoomMenu; } } [SerializeField] private CurrentRoomMenu _currentRoomMenu; public void FirstInitialize() { _createRoomMenu.FirstInitialize(); _currentRoomMenu.FirstInitialize(); //Reset(); } public void Reset() { _createRoomMenu.Reset(); _currentRoomMenu.Reset(); } /// <summary> /// Shows canvases for a successful room creation. /// </summary> /// <param name=\"show\"></param> public void ShowRoomCreatedSuccess(RoomDetails roomDetails) { _createRoomMenu.ShowRoomCreatedSuccess(); _currentRoomMenu.ShowRoomCreatedSuccess(roomDetails); } /// <summary> /// Shows canvases for a failed room creation. /// </summary> /// <param name=\"show\"></param> public void ShowRoomCreatedFailed(string failedReason) { _createRoomMenu.ShowRoomCreatedFailed(); _currentRoomMenu.ShowRoomCreatedFailed(failedReason); } /// <summary> /// Called when successfully joined a room. /// </summary> /// <param name=\"show\"></param> public void ShowRoomJoinedSuccess(RoomDetails roomDetails) { _currentRoomMenu.ShowRoomJoinedSuccess(roomDetails); } /// <summary> /// Called when failed to join a room. /// </summary> /// <param name=\"show\"></param> public void ShowRoomJoinedFailed(string failedReason) { _currentRoomMenu.ShowRoomJoinedFailed(failedReason); } /// <summary> /// Called when successfully leaving a room. /// </summary> public void ShowRoomLeftSuccess() { _currentRoomMenu.ShowRoomLeftSuccess(); } /// <summary> /// Called when failing to leaving a room. /// </summary> public void ShowRoomLeftFailed() { _currentRoomMenu.ShowRoomLeftFailed(); } /// <summary> /// Shows canvases based on room left status. /// </summary> public void ShowStartGame(bool success, RoomDetails roomDetails, string failedReason) { /* StartGame response won't affect * JoinRoonMenu or CreateRoomMenu as they * both are already hidden because of being * in a CurrentRoom. Only current room must update. */ _currentRoomMenu.ShowStartGame(success, roomDetails, failedReason); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LobbyCanvasesDispatcher",
          "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using UnityEngine; public class LobbyCanvasesDispatcher : MonoBehaviour { public CreateRoomMenu CreateRoomMenu { get { return _createRoomMenu; } } [SerializeField] private CreateRoomMenu _createRoomMenu; public CurrentRoomMenu CurrentRoomMenu { get { return _currentRoomMenu; } } [SerializeField] private CurrentRoomMenu _currentRoomMenu; public void FirstInitialize() { _createRoomMenu.FirstInitialize(); _currentRoomMenu.FirstInitialize(); //Reset();  ",
          "content_tokens": 145,
          "embedding": []
        },
        {
          "cs_scriptfile": "LobbyCanvasesDispatcher",
          "content": "public void Reset() { _createRoomMenu.Reset(); _currentRoomMenu.Reset(); } /// <summary> /// Shows canvases for a successful room creation. /// </summary> /// <param name=\"show\"></param> public void ShowRoomCreatedSuccess(RoomDetails roomDetails) { _createRoomMenu.ShowRoomCreatedSuccess(); _currentRoomMenu.ShowRoomCreatedSuccess(roomDetails); } /// <summary> /// Shows canvases for a failed room creation. /// </summary> /// <param name=\"show\"></param> public void ShowRoomCreatedFailed(string failedReason) { _createRoomMenu.ShowRoomCreatedFailed(); _currentRoomMenu.ShowRoomCreatedFailed(failedReason); } /// <summary> /// Called when successfully joined a room. /// </summary> /// <param name=\"show\"></param> public void ShowRoomJoinedSuccess(RoomDetails roomDetails) { _currentRoomMenu.ShowRoomJoinedSuccess(roomDetails); } /// <summary> /// Called when failed to join a room. /// </summary> /// <param name=\"show\"></param> public void ShowRoomJoinedFailed(string failedReason) { _currentRoomMenu.ShowRoomJoinedFailed(failedReason); } /// <summary> /// Called when successfully leaving a room. /// </summary> public void ShowRoomLeftSuccess() { _currentRoomMenu.ShowRoomLeftSuccess(); } /// <summary> /// Called when failing to leaving a room. /// </summary> public void ShowRoomLeftFailed() { _currentRoomMenu.ShowRoomLeftFailed(); } /// <summary> /// Shows canvases based on room left status. /// </summary> public void ShowStartGame(bool success, RoomDetails roomDetails, string failedReason) { /* StartGame response won't affect * JoinRoonMenu or CreateRoomMenu as they * both are already hidden because of being * in a CurrentRoom. Only current room must update. */ _currentRoomMenu.ShowStartGame(success, roomDetails, failedReason); } }",
          "content_tokens": 426,
          "embedding": []
        }
      ],
      "length": 2305
    },
    {
      "filename": "LocalPlayerAnnouncer",
      "content": "using FishNet.Connection; using FishNet.Object; using System; namespace _ZomFI.FishNet_ZomFI { /// <summary> /// To be attached to localPlayer prefabs to know when they are instantiated. /// </summary> public class LocalPlayerAnnouncer : NetworkBehaviour { #region Public. /// <summary> /// Dispatched when the local player changes, providing the new localPlayer. /// </summary> public static event Action<NetworkObject> OnLocalPlayerUpdated; #endregion public override void OnOwnershipClient(NetworkConnection prevOwner) { base.OnOwnershipClient(prevOwner); if (base.IsOwner) OnLocalPlayerUpdated?.Invoke(base.NetworkObject); } private void OnEnable() { if (base.IsOwner) OnLocalPlayerUpdated?.Invoke(base.NetworkObject); } private void OnDisable() { if (base.IsOwner) OnLocalPlayerUpdated?.Invoke(null); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LocalPlayerAnnouncer",
          "content": "using FishNet.Connection; using FishNet.Object; using System; namespace _ZomFI.FishNet_ZomFI { /// <summary> /// To be attached to localPlayer prefabs to know when they are instantiated. /// </summary> public class LocalPlayerAnnouncer : NetworkBehaviour { #region Public. /// <summary> /// Dispatched when the local player changes, providing the new localPlayer. /// </summary> public static event Action<NetworkObject> OnLocalPlayerUpdated; #endregion public override void OnOwnershipClient(NetworkConnection prevOwner) { base.OnOwnershipClient(prevOwner); if (base.IsOwner) OnLocalPlayerUpdated?.Invoke(base.NetworkObject);  private void OnEnable() { if (base.IsOwner) OnLocalPlayerUpdated?.Invoke(base.NetworkObject);  ",
          "content_tokens": 184,
          "embedding": []
        },
        {
          "cs_scriptfile": "LocalPlayerAnnouncer",
          "content": "private void OnDisable() { if (base.IsOwner) OnLocalPlayerUpdated?.Invoke(null); } } }",
          "content_tokens": 27,
          "embedding": []
        }
      ],
      "length": 811
    },
    {
      "filename": "CameraMover",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class CameraMover : MonoBehaviour { void Awake() { Camera camera = Camera.main; camera.transform.SetParent(transform); camera.transform.localPosition = Vector3.zero; camera.projectionMatrix = Matrix4x4.Perspective(60, 0.3f, 0.3f, 120f); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CameraMover",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class CameraMover : MonoBehaviour { void Awake() { Camera camera = Camera.main; camera.transform.SetParent(transform); camera.transform.localPosition = Vector3.zero; camera.projectionMatrix = Matrix4x4.Perspective(60, 0.3f, 0.3f, 120f); } }",
          "content_tokens": 93,
          "embedding": []
        }
      ],
      "length": 327
    },
    {
      "filename": "TestEtherealEditor",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; [CustomEditor(typeof(TestEthereal))] public class TestEtherealEditor : Editor { TestEthereal _testEthereal; private void OnEnable() { _testEthereal = (TestEthereal)target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); if (GUILayout.Button(\"LoadScene\")) { _testEthereal.LoadScene(); } if (GUILayout.Button(\"SpawnCamera\")) { _testEthereal.SpawnCamera(); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "TestEtherealEditor",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; [CustomEditor(typeof(TestEthereal))] public class TestEtherealEditor : Editor { TestEthereal _testEthereal; private void OnEnable() { _testEthereal = (TestEthereal)target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); if (GUILayout.Button(\"LoadScene\")) { _testEthereal.LoadScene(); } if (GUILayout.Button(\"SpawnCamera\")) { _testEthereal.SpawnCamera(); } } }",
          "content_tokens": 134,
          "embedding": []
        }
      ],
      "length": 475
    },
    {
      "filename": "MainMenuCameraSpawner",
      "content": "using UnityEngine; public class MainMenuCameraSpawner : MonoBehaviour { [SerializeField] private GameObject mainMenuCameraPrefab; [SerializeField] private GameObject _mainMenuCamera; private void OnValidate() { _mainMenuCamera ??= transform.GetChild(0).gameObject; } public void SpawnMainMenuCamera() { Debug.Log($\"[MainMenuCameraSpawner] SpawnMainMenuCamera\"); if (_mainMenuCamera == null) { _mainMenuCamera = Instantiate(mainMenuCameraPrefab, transform.position, transform.rotation, transform); } } public void DeSpawnMainMenuCamera() { Debug.Log($\"[MainMenuCameraSpawner] DeSpawnMainMenuCamera\"); Destroy(_mainMenuCamera); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MainMenuCameraSpawner",
          "content": "using UnityEngine; public class MainMenuCameraSpawner : MonoBehaviour { [SerializeField] private GameObject mainMenuCameraPrefab; [SerializeField] private GameObject _mainMenuCamera; private void OnValidate() { _mainMenuCamera ??= transform.GetChild(0).gameObject; } public void SpawnMainMenuCamera() { Debug.Log($\"[MainMenuCameraSpawner] SpawnMainMenuCamera\"); if (_mainMenuCamera == null) { _mainMenuCamera = Instantiate(mainMenuCameraPrefab, transform.position, transform.rotation, transform); } } public void DeSpawnMainMenuCamera() { Debug.Log($\"[MainMenuCameraSpawner] DeSpawnMainMenuCamera\"); Destroy(_mainMenuCamera); } }",
          "content_tokens": 161,
          "embedding": []
        }
      ],
      "length": 630
    },
    {
      "filename": "MainSettings",
      "content": "using UnityEngine; using UnityEngine.Audio; using UnityEngine.UI; using System; using TMPro; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FishNet.Component.Utility; using FishNet.Managing; using FishNet.Managing.Statistic; using Tayx.Graphy; using UnityEngine.SceneManagement; using DuloGames.UI; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using DDCore; public class MainSettings : MonoBehaviour { #if !(UNITY_SERVER) [SerializeField] private AudioMixer _mainMixer; private readonly int FULLSCREEN_MODE = 0; private readonly int WINDOWED_MODE = 1; private static string STATISTICS_KEY = \"statistics\"; protected readonly string DISPLAY_MODE_KEY = \"DisplayMode\"; private List<TMP_Dropdown.OptionData> _displayOptions = new () { new (\"Fullscreen\", null), new (\"Windowed\", null) }; public UIWindow _uiWindow; [SerializeField] TMP_Dropdown Video; [SerializeField] TMP_Dropdown DisplayMode; [SerializeField] TMP_Dropdown Resolutions; [SerializeField] Toggle vsyncToggle; [SerializeField] Toggle soundToggle; [SerializeField] Slider masterVolSlider; [SerializeField] Slider musicVolSlider; [SerializeField] Slider ambietVolSlider; bool isFullscreen; [SerializeField] Toggle statisticsToggle; [SerializeField] private GraphyManager graphyManager; [SerializeField] private PingDisplay pingDisplay; [SerializeField] private StatisticsManager statisticsManager; public static MainSettings Instance { get; private set; } private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } GameplayManager.OnLocalClientInitStarted += Hide; DontDestroyOnLoad(this); } void Start() { if (NetworkHudCanvases.Instance.IsAutoStartServer) return; graphyManager ??= FindObjectOfType<GraphyManager>(); pingDisplay ??= FindObjectOfType<PingDisplay>(); statisticsManager ??= FindObjectOfType<StatisticsManager>(); //Set Quality Level On Start //ChangeDisplayMode(FULLSCREEN_MODE); Video.value = 2; QualitySettings.SetQualityLevel(2, true); PlayerPrefs.SetInt(\"Quality\", 3); Video.ClearOptions(); var videoOptions = new List<TMP_Dropdown.OptionData>() { new TMP_Dropdown.OptionData(\"Low\", null), new TMP_Dropdown.OptionData(\"Medium\", null), new TMP_Dropdown.OptionData(\"High\", null) }; Video.AddOptions(videoOptions); Video.onValueChanged.AddListener(ChangeQualitySettings); int value = PlayerPrefs.GetInt(\"Quality\"); if(value != 0) { if (value == 1) { QualitySettings.SetQualityLevel(0, true); //FindObjectOfType<QualityManager>().SetQualityLevel(false); Video.value = 0; } if (value == 2) { QualitySettings.SetQualityLevel(1, true); //FindObjectOfType<QualityManager>().SetQualityLevel(false); Video.value = 1; } if (value == 3) { QualitySettings.SetQualityLevel(2, true); //FindObjectOfType<QualityManager>().SetQualityLevel(false); Video.value = 2; } } //Set Vsync Value on Start int toggleValue = PlayerPrefs.GetInt(\"Vsync\"); QualitySettings.vSyncCount = toggleValue; if(toggleValue == 0) vsyncToggle.isOn = false; else vsyncToggle.isOn = true; InitDisplayMode(); Resolutions.ClearOptions(); var resOptions = new List<TMP_Dropdown.OptionData>(); Resolution[] resolutions = Screen.resolutions; for (int i = 0; i < resolutions.Length; i++) { var currentResolution = resolutions[i].ToString(); var m_width = currentResolution.Substring(0, currentResolution.IndexOf(\"x\")); var m_height = currentResolution.Substring(currentResolution.IndexOf(\"x\") + 1, currentResolution.IndexOf(\"@\") - currentResolution.IndexOf(\"x\") - 1); var m_refreshRate = currentResolution.Substring(currentResolution.IndexOf(\"@\") + 1, currentResolution.Length - currentResolution.IndexOf(\"@\") - 1); string display = m_width + \" x \" + m_height + \" @ \" + m_refreshRate + \"Hz\"; AddtoList(resOptions, display); } Resolutions.AddOptions(resOptions); Resolutions.onValueChanged.AddListener(ChangeResolution); int width = PlayerPrefs.GetInt(\"Width\"); int height = PlayerPrefs.GetInt(\"Height\"); int fullscreen = PlayerPrefs.GetInt(\"iSFullscreen\"); int res = PlayerPrefs.GetInt(\"ResolutionIndex\"); string resolution = \"\"; if (res < Resolutions.options.Count) { resolution = Resolutions.options[res].text; } if(width != 0 && height !=0) { Screen.SetResolution(width, height, isFullscreen); Resolutions.value = res; } else { ChangeResolution(res); } //Set Audio Mixer Settings //Master Volume float master = PlayerPrefs.GetFloat(\"masterVol\"); if(master != 0) { masterVolSlider.value = master; _mainMixer.SetFloat(\"masterVol\", Mathf.Log10(master) * 20); } //Music Volume float music = PlayerPrefs.GetFloat(\"musicVol\"); if (music != 0) { musicVolSlider.value = music; _mainMixer.SetFloat(\"musicVol\", Mathf.Log10(music) * 20); } //Ambiuent Volume float ambient = PlayerPrefs.GetFloat(\"ambientVol\"); if (ambient != 0) { ambietVolSlider.value = ambient; _mainMixer.SetFloat(\"ambientVol\", Mathf.Log10(ambient) * 20); } //SoundToggle int sound = PlayerPrefs.GetInt(\"soundToggle\"); if (sound == 1) { _mainMixer.SetFloat(\"masterVol\", -80f); soundToggle.isOn = false; } else if (sound == 2) { _mainMixer.SetFloat(\"masterVol\", Mathf.Log10(masterVolSlider.value) * 20); soundToggle.isOn = true; } //StatisticsToggle StatisticsManagementInit(); ChangeQualitySettings(2); } private void FixedUpdate() { if (Input.GetKeyDown(KeyCode.Escape)) { gameObject.GetComponent<UIWindow>().Hide(); } } public void ToggleEscMenu() { EscapeMenu.Instance?.UIWindow.Toggle(); } private void StatisticsManagementInit() { if (!PlayerPrefs.HasKey(STATISTICS_KEY)) { statisticsToggle.isOn = false; SetShowStatistics(false); PlayerPrefs.SetInt(STATISTICS_KEY, 0); } else { int statistics = PlayerPrefs.GetInt(STATISTICS_KEY); if (statistics == 0) { statisticsToggle.isOn = false; SetShowStatistics(false); } else if (statistics == 1) { SetShowStatistics(true); } } statisticsToggle.onValueChanged.AddListener(SetShowStatistics); } private void AddtoList(List<TMP_Dropdown.OptionData> resOptions, string item) { var optionData = new TMP_Dropdown.OptionData(item, null); //if (resOptions.Contains(optionData)) return; resOptions.Add(optionData); } public void ChangeQualitySettings(int value) { if (Video.value == 0) { QualitySettings.SetQualityLevel(0, true); PlayerPrefs.SetInt(\"Quality\", 1); //FindObjectOfType<QualityManager>().SetQualityLevel(true); } if (Video.value == 1) { QualitySettings.SetQualityLevel(1, true); PlayerPrefs.SetInt(\"Quality\", 2); //FindObjectOfType<QualityManager>().SetQualityLevel(true); } if (Video.value == 2) { QualitySettings.SetQualityLevel(2, true); PlayerPrefs.SetInt(\"Quality\", 3); //FindObjectOfType<QualityManager>().SetQualityLevel(true); } } public void VsyncToggle() { if(vsyncToggle.isOn) { QualitySettings.vSyncCount = 1; PlayerPrefs.SetInt(\"Vsync\", 1); } else { QualitySettings.vSyncCount = 0; PlayerPrefs.SetInt(\"Vsync\", 0); } } private void InitDisplayMode() { DisplayMode.ClearOptions(); DisplayMode.AddOptions(_displayOptions); int displayModeValue = PlayerPrefs.GetInt(DISPLAY_MODE_KEY); ChangeDisplayMode(displayModeValue - 1); DisplayMode.onValueChanged.AddListener(ChangeDisplayMode); Debug.Log($\"[MainSettings] InitDisplayMode added {_displayOptions} options. DISPLAY_MODE_KEY: {displayModeValue}\", gameObject); } public void ChangeDisplayMode(int value) { if (value == FULLSCREEN_MODE)//0 { Screen.fullScreenMode = FullScreenMode.FullScreenWindow; isFullscreen = true; PlayerPrefs.SetInt(DISPLAY_MODE_KEY, 1); PlayerPrefs.SetInt(\"isFullscreen\", 1); } else if (value == WINDOWED_MODE)//1 { Screen.fullScreenMode = FullScreenMode.Windowed; isFullscreen = false; PlayerPrefs.SetInt(DISPLAY_MODE_KEY, 2); PlayerPrefs.SetInt(\"isFullscreen\", 2); } DisplayMode.value = value; Debug.Log($\"[MainSettings] Successfull ChangeDisplayMode to (DISPLAY_MODE_KEY - 1) {value}\", gameObject); } public void ChangeResolution(int index) { string widthValue = Resolutions.options[index].text; string heightValue = Resolutions.options[index].text; int xIndex = widthValue.IndexOf(\"x\"); if (xIndex >= 0) widthValue = widthValue.Substring(0, xIndex - 1); int yIndex = heightValue.IndexOf(\"@\"); if (yIndex >= 0) heightValue = heightValue[(xIndex + 2)..yIndex]; //int yIndex = heightValue.LastIndexOf(\"x\"); //if (yIndex >= 0) // heightValue = heightValue[(yIndex + 2)..]; int width = Convert.ToInt32(widthValue); int height = Convert.ToInt32(heightValue); Screen.SetResolution(width, height, isFullscreen); PlayerPrefs.SetInt(\"Width\", width); PlayerPrefs.SetInt(\"Height\", height); PlayerPrefs.SetInt(\"ResolutionIndex\", index); } public void SoundToggle() { if(soundToggle.isOn ==false) { _mainMixer.SetFloat(\"masterVol\", -80f); PlayerPrefs.SetInt(\"soundToggle\", 1); } if(soundToggle.isOn ==true) { _mainMixer.SetFloat(\"masterVol\", Mathf.Log10(masterVolSlider.value) * 20); PlayerPrefs.SetInt(\"soundToggle\", 2); } } public void SetShowStatistics(bool isOn) { Debug.Log($\"[MainSettings] SetShowStatistics: {isOn}\", gameObject); pingDisplay.enabled = isOn; if (isOn) { graphyManager.Enable(); statisticsManager.InitializeOnce_Internal(statisticsManager.GetComponent<NetworkManager>()); PlayerPrefs.SetInt(STATISTICS_KEY, 1); }else { graphyManager.Disable(); statisticsManager.Deinitialize_Internal(); PlayerPrefs.SetInt(STATISTICS_KEY, 0); } } public void Show() { _uiWindow.Show(); } public void Hide() { _uiWindow.Hide(); } public void SetMasterVolume(float volume) { _mainMixer.SetFloat(\"masterVol\", masterVolSlider.value); PlayerPrefs.SetFloat(\"masterVol\", masterVolSlider.value); } public void SetMusicVolume() { _mainMixer.SetFloat(\"musicVol\", Mathf.Log10(musicVolSlider.value) * 20); PlayerPrefs.SetFloat(\"musicVol\", musicVolSlider.value); } public void SetAmbientVolume() { _mainMixer.SetFloat(\"ambientVol\", Mathf.Log10(ambietVolSlider.value) * 20); PlayerPrefs.SetFloat(\"ambientVol\", ambietVolSlider.value); } public void QuitGame() { Application.Quit(); } public void LeaveGame() { SceneManager.LoadScene(\"Main\"); //Test } #endif }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MainSettings",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainSettings",
          "content": "using UnityEngine; using UnityEngine.Audio; using UnityEngine.UI; using System; using TMPro; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FishNet.Component.Utility; using FishNet.Managing; using FishNet.Managing.Statistic; using Tayx.Graphy; using UnityEngine.SceneManagement; using DuloGames.UI; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using DDCore; public class MainSettings : MonoBehaviour { #if !(UNITY_SERVER) [SerializeField] private AudioMixer _mainMixer; private readonly int FULLSCREEN_MODE = 0; private readonly int WINDOWED_MODE = 1; private static string STATISTICS_KEY = \"statistics\"; protected readonly string DISPLAY_MODE_KEY = \"DisplayMode\"; private List<TMP_Dropdown.OptionData> _displayOptions = new () { new (\"Fullscreen\", null), new (\"Windowed\", null) }; public UIWindow _uiWindow; [SerializeField] TMP_Dropdown Video; [SerializeField] TMP_Dropdown DisplayMode; [SerializeField] TMP_Dropdown Resolutions; [SerializeField] Toggle vsyncToggle; [SerializeField] Toggle soundToggle; [SerializeField] Slider masterVolSlider; [SerializeField] Slider musicVolSlider; [SerializeField] Slider ambietVolSlider; bool isFullscreen; [SerializeField] Toggle statisticsToggle; [SerializeField] private GraphyManager graphyManager; [SerializeField] private PingDisplay pingDisplay; [SerializeField] private StatisticsManager statisticsManager; public static MainSettings Instance { get; private set;  ",
          "content_tokens": 401,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainSettings",
          "content": "private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } GameplayManager.OnLocalClientInitStarted += Hide; DontDestroyOnLoad(this);  ",
          "content_tokens": 49,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainSettings",
          "content": "void Start() { if (NetworkHudCanvases.Instance.IsAutoStartServer) return; graphyManager ??= FindObjectOfType<GraphyManager>(); pingDisplay ??= FindObjectOfType<PingDisplay>(); statisticsManager ??= FindObjectOfType<StatisticsManager>(); //Set Quality Level On Start //ChangeDisplayMode(FULLSCREEN_MODE); Video.value = 2; QualitySettings.SetQualityLevel(2, true); PlayerPrefs.SetInt(\"Quality\", 3); Video.ClearOptions(); var videoOptions = new List<TMP_Dropdown.OptionData>() { new TMP_Dropdown.OptionData(\"Low\", null), new TMP_Dropdown.OptionData(\"Medium\", null), new TMP_Dropdown.OptionData(\"High\", null) }; Video.AddOptions(videoOptions); Video.onValueChanged.AddListener(ChangeQualitySettings); int value = PlayerPrefs.GetInt(\"Quality\"); if(value != 0) { if (value == 1) { QualitySettings.SetQualityLevel(0, true); //FindObjectOfType<QualityManager>().SetQualityLevel(false); Video.value = 0;  ",
          "content_tokens": 258,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainSettings",
          "content": "if (value == 2) { QualitySettings.SetQualityLevel(1, true); //FindObjectOfType<QualityManager>().SetQualityLevel(false); Video.value = 1;  ",
          "content_tokens": 42,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainSettings",
          "content": "if (value == 3) { QualitySettings.SetQualityLevel(2, true); //FindObjectOfType<QualityManager>().SetQualityLevel(false); Video.value = 2; } } //Set Vsync Value on Start int toggleValue = PlayerPrefs.GetInt(\"Vsync\"); QualitySettings.vSyncCount = toggleValue; if(toggleValue == 0) vsyncToggle.isOn = false; else vsyncToggle.isOn = true; InitDisplayMode(); Resolutions.ClearOptions(); var resOptions = new List<TMP_Dropdown.OptionData>(); Resolution[] resolutions = Screen.resolutions; for (int i = 0; i < resolutions.Length; i++) { var currentResolution = resolutions[i].ToString(); var m_width = currentResolution.Substring(0, currentResolution.IndexOf(\"x\")); var m_height = currentResolution.Substring(currentResolution.IndexOf(\"x\") + 1, currentResolution.IndexOf(\"@\") - currentResolution.IndexOf(\"x\") - 1); var m_refreshRate = currentResolution.Substring(currentResolution.IndexOf(\"@\") + 1, currentResolution.Length - currentResolution.IndexOf(\"@\") - 1); string display = m_width + \" x \" + m_height + \" @ \" + m_refreshRate + \"Hz\"; AddtoList(resOptions, display); } Resolutions.AddOptions(resOptions); Resolutions.onValueChanged.AddListener(ChangeResolution); int width = PlayerPrefs.GetInt(\"Width\"); int height = PlayerPrefs.GetInt(\"Height\"); int fullscreen = PlayerPrefs.GetInt(\"iSFullscreen\"); int res = PlayerPrefs.GetInt(\"ResolutionIndex\"); string resolution = \"\"; if (res < Resolutions.options.Count) { resolution = Resolutions.options[res].text;  ",
          "content_tokens": 424,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainSettings",
          "content": "if(width != 0 && height !=0) { Screen.SetResolution(width, height, isFullscreen); Resolutions.value = res; } else { ChangeResolution(res); } //Set Audio Mixer Settings //Master Volume float master = PlayerPrefs.GetFloat(\"masterVol\"); if(master != 0) { masterVolSlider.value = master; _mainMixer.SetFloat(\"masterVol\", Mathf.Log10(master) * 20); } //Music Volume float music = PlayerPrefs.GetFloat(\"musicVol\"); if (music != 0) { musicVolSlider.value = music; _mainMixer.SetFloat(\"musicVol\", Mathf.Log10(music) * 20); } //Ambiuent Volume float ambient = PlayerPrefs.GetFloat(\"ambientVol\"); if (ambient != 0) { ambietVolSlider.value = ambient; _mainMixer.SetFloat(\"ambientVol\", Mathf.Log10(ambient) * 20); } //SoundToggle int sound = PlayerPrefs.GetInt(\"soundToggle\"); if (sound == 1) { _mainMixer.SetFloat(\"masterVol\", -80f); soundToggle.isOn = false; } else if (sound == 2) { _mainMixer.SetFloat(\"masterVol\", Mathf.Log10(masterVolSlider.value) * 20); soundToggle.isOn = true; } //StatisticsToggle StatisticsManagementInit(); ChangeQualitySettings(2);  ",
          "content_tokens": 331,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainSettings",
          "content": "private void FixedUpdate() { if (Input.GetKeyDown(KeyCode.Escape)) { gameObject.GetComponent<UIWindow>().Hide(); }  public void ToggleEscMenu() { EscapeMenu.Instance?.UIWindow.Toggle();  private void StatisticsManagementInit() { if (!PlayerPrefs.HasKey(STATISTICS_KEY)) { statisticsToggle.isOn = false; SetShowStatistics(false); PlayerPrefs.SetInt(STATISTICS_KEY, 0); } else { int statistics = PlayerPrefs.GetInt(STATISTICS_KEY); if (statistics == 0) { statisticsToggle.isOn = false; SetShowStatistics(false); } else if (statistics == 1) { SetShowStatistics(true); } } statisticsToggle.onValueChanged.AddListener(SetShowStatistics);  ",
          "content_tokens": 185,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainSettings",
          "content": "private void AddtoList(List<TMP_Dropdown.OptionData> resOptions, string item) { var optionData = new TMP_Dropdown.OptionData(item, null); //if (resOptions.Contains(optionData)) return; resOptions.Add(optionData);  public void ChangeQualitySettings(int value) { if (Video.value == 0) { QualitySettings.SetQualityLevel(0, true); PlayerPrefs.SetInt(\"Quality\", 1); //FindObjectOfType<QualityManager>().SetQualityLevel(true);  if (Video.value == 1) { QualitySettings.SetQualityLevel(1, true); PlayerPrefs.SetInt(\"Quality\", 2); //FindObjectOfType<QualityManager>().SetQualityLevel(true);  ",
          "content_tokens": 172,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainSettings",
          "content": "if (Video.value == 2) { QualitySettings.SetQualityLevel(2, true); PlayerPrefs.SetInt(\"Quality\", 3); //FindObjectOfType<QualityManager>().SetQualityLevel(true); }  public void VsyncToggle() { if(vsyncToggle.isOn) { QualitySettings.vSyncCount = 1; PlayerPrefs.SetInt(\"Vsync\", 1); } else { QualitySettings.vSyncCount = 0; PlayerPrefs.SetInt(\"Vsync\", 0); }  ",
          "content_tokens": 116,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainSettings",
          "content": "private void InitDisplayMode() { DisplayMode.ClearOptions(); DisplayMode.AddOptions(_displayOptions); int displayModeValue = PlayerPrefs.GetInt(DISPLAY_MODE_KEY); ChangeDisplayMode(displayModeValue - 1); DisplayMode.onValueChanged.AddListener(ChangeDisplayMode); Debug.Log($\"[MainSettings] InitDisplayMode added {_displayOptions} options. DISPLAY_MODE_KEY: {displayModeValue}\", gameObject);  ",
          "content_tokens": 102,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainSettings",
          "content": "public void ChangeDisplayMode(int value) { if (value == FULLSCREEN_MODE)//0 { Screen.fullScreenMode = FullScreenMode.FullScreenWindow; isFullscreen = true; PlayerPrefs.SetInt(DISPLAY_MODE_KEY, 1); PlayerPrefs.SetInt(\"isFullscreen\", 1); } else if (value == WINDOWED_MODE)//1 { Screen.fullScreenMode = FullScreenMode.Windowed; isFullscreen = false; PlayerPrefs.SetInt(DISPLAY_MODE_KEY, 2); PlayerPrefs.SetInt(\"isFullscreen\", 2); } DisplayMode.value = value; Debug.Log($\"[MainSettings] Successfull ChangeDisplayMode to (DISPLAY_MODE_KEY - 1) {value}\", gameObject);  ",
          "content_tokens": 178,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainSettings",
          "content": "public void ChangeResolution(int index) { string widthValue = Resolutions.options[index].text; string heightValue = Resolutions.options[index].text; int xIndex = widthValue.IndexOf(\"x\"); if (xIndex >= 0) widthValue = widthValue.Substring(0, xIndex - 1); int yIndex = heightValue.IndexOf(\"@\"); if (yIndex >= 0) heightValue = heightValue[(xIndex + 2)..yIndex]; //int yIndex = heightValue.LastIndexOf(\"x\"); //if (yIndex >= 0) // heightValue = heightValue[(yIndex + 2)..]; int width = Convert.ToInt32(widthValue); int height = Convert.ToInt32(heightValue); Screen.SetResolution(width, height, isFullscreen); PlayerPrefs.SetInt(\"Width\", width); PlayerPrefs.SetInt(\"Height\", height); PlayerPrefs.SetInt(\"ResolutionIndex\", index);  ",
          "content_tokens": 218,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainSettings",
          "content": "public void SoundToggle() { if(soundToggle.isOn ==false) { _mainMixer.SetFloat(\"masterVol\", -80f); PlayerPrefs.SetInt(\"soundToggle\", 1);  if(soundToggle.isOn ==true) { _mainMixer.SetFloat(\"masterVol\", Mathf.Log10(masterVolSlider.value) * 20); PlayerPrefs.SetInt(\"soundToggle\", 2); }  ",
          "content_tokens": 103,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainSettings",
          "content": "public void SetShowStatistics(bool isOn) { Debug.Log($\"[MainSettings] SetShowStatistics: {isOn}\", gameObject); pingDisplay.enabled = isOn; if (isOn) { graphyManager.Enable(); statisticsManager.InitializeOnce_Internal(statisticsManager.GetComponent<NetworkManager>()); PlayerPrefs.SetInt(STATISTICS_KEY, 1); }else { graphyManager.Disable(); statisticsManager.Deinitialize_Internal(); PlayerPrefs.SetInt(STATISTICS_KEY, 0); }  public void Show() { _uiWindow.Show();  public void Hide() { _uiWindow.Hide();  public void SetMasterVolume(float volume) { _mainMixer.SetFloat(\"masterVol\", masterVolSlider.value); PlayerPrefs.SetFloat(\"masterVol\", masterVolSlider.value);  ",
          "content_tokens": 192,
          "embedding": []
        },
        {
          "cs_scriptfile": "MainSettings",
          "content": "public void SetMusicVolume() { _mainMixer.SetFloat(\"musicVol\", Mathf.Log10(musicVolSlider.value) * 20); PlayerPrefs.SetFloat(\"musicVol\", musicVolSlider.value);  public void SetAmbientVolume() { _mainMixer.SetFloat(\"ambientVol\", Mathf.Log10(ambietVolSlider.value) * 20); PlayerPrefs.SetFloat(\"ambientVol\", ambietVolSlider.value);  public void QuitGame() { Application.Quit();  public void LeaveGame() { SceneManager.LoadScene(\"Main\"); //Test } #endif }",
          "content_tokens": 141,
          "embedding": []
        }
      ],
      "length": 9832
    },
    {
      "filename": "MusicController",
      "content": "using System.Collections; using _ZombieRoyale.Scripts.Clients; using DarkTonic.MasterAudio; using UnityEngine; public class MusicController : MonoBehaviour { [SerializeField] private PlaylistController MainMenuPlaylist; private bool _isCombatMusicPlaying; private Coroutine _combatMusicCoroutine; public static MusicController Instance { get; private set; } // Start is called before the first frame update void Awake() { RegistrationController.Instance.OnCharacterLoaded += OnCharacterLoaded; CharCreatorSceneLoader.OnCharCreationSceneLoaded += OnCharCreationSceneLoaded; BackendReadWrites.OnCharacterCreated += OnCharacterCreated; if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); } else if (Instance != this) { Destroy(gameObject); } } private void OnCharacterCreated(CharacterSkinData obj) { MasterAudio.StopAllOfSound(\"1-Dark Fantasy Studio- The ocean takes it all\"); PlayMainMenuMusic(); } public static void PlayUIClick() { MasterAudio.PlaySound(\"UI Click Taps\"); } public static void PlayGoldSound() { MasterAudio.PlaySound(\"Coins Falling_4 (Large)\"); } private void OnCharCreationSceneLoaded() { MasterAudio.PlaySoundAndForget(\"1-Dark Fantasy Studio- The ocean takes it all\"); } private void PlayMainMenuMusic() { MainMenuPlaylist.RestartPlaylist(); } public static void PlayDungeonMusic() { Instance._isCombatMusicPlaying = false; string playlistName = \"InDungeonNotCombat\"; MasterAudio.ChangePlaylistByName(playlistName); } public static void PlayCombatMusic() { if (Instance._isCombatMusicPlaying) { if (Instance._combatMusicCoroutine != null) Instance.StopCoroutine(Instance._combatMusicCoroutine); Instance._combatMusicCoroutine = Instance.StartCoroutine(Instance.DelayedCombatMusicOff()); return; } string playlistName = \"Combat\"; MasterAudio.ChangePlaylistByName(playlistName); Instance._isCombatMusicPlaying = true; Instance._combatMusicCoroutine = Instance.StartCoroutine(Instance.DelayedCombatMusicOff()); } private IEnumerator DelayedCombatMusicOff() { yield return new WaitForSeconds(10f); PlayDungeonMusic(); } private void OnCharacterLoaded(CharacterData obj) { Debug.Log(\"[MusicController] OnCharacterLoaded\"); PlayMainMenuMusic(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MusicController",
          "content": "using System.Collections; using _ZombieRoyale.Scripts.Clients; using DarkTonic.MasterAudio; using UnityEngine; public class MusicController : MonoBehaviour { [SerializeField] private PlaylistController MainMenuPlaylist; private bool _isCombatMusicPlaying; private Coroutine _combatMusicCoroutine; public static MusicController Instance { get; private set; } // Start is called before the first frame update void Awake() { RegistrationController.Instance.OnCharacterLoaded += OnCharacterLoaded; CharCreatorSceneLoader.OnCharCreationSceneLoaded += OnCharCreationSceneLoaded; BackendReadWrites.OnCharacterCreated += OnCharacterCreated; if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); } else if (Instance != this) { Destroy(gameObject); }  ",
          "content_tokens": 187,
          "embedding": []
        },
        {
          "cs_scriptfile": "MusicController",
          "content": "private void OnCharacterCreated(CharacterSkinData obj) { MasterAudio.StopAllOfSound(\"1-Dark Fantasy Studio- The ocean takes it all\"); PlayMainMenuMusic(); } public static void PlayUIClick() { MasterAudio.PlaySound(\"UI Click Taps\"); } public static void PlayGoldSound() { MasterAudio.PlaySound(\"Coins Falling_4 (Large)\");  private void OnCharCreationSceneLoaded() { MasterAudio.PlaySoundAndForget(\"1-Dark Fantasy Studio- The ocean takes it all\");  ",
          "content_tokens": 118,
          "embedding": []
        },
        {
          "cs_scriptfile": "MusicController",
          "content": "private void PlayMainMenuMusic() { MainMenuPlaylist.RestartPlaylist(); } public static void PlayDungeonMusic() { Instance._isCombatMusicPlaying = false; string playlistName = \"InDungeonNotCombat\"; MasterAudio.ChangePlaylistByName(playlistName); } public static void PlayCombatMusic() { if (Instance._isCombatMusicPlaying) { if (Instance._combatMusicCoroutine != null) Instance.StopCoroutine(Instance._combatMusicCoroutine); Instance._combatMusicCoroutine = Instance.StartCoroutine(Instance.DelayedCombatMusicOff()); return; } string playlistName = \"Combat\"; MasterAudio.ChangePlaylistByName(playlistName); Instance._isCombatMusicPlaying = true; Instance._combatMusicCoroutine = Instance.StartCoroutine(Instance.DelayedCombatMusicOff()); } private IEnumerator DelayedCombatMusicOff() { yield return new WaitForSeconds(10f); PlayDungeonMusic();  ",
          "content_tokens": 216,
          "embedding": []
        },
        {
          "cs_scriptfile": "MusicController",
          "content": "private void OnCharacterLoaded(CharacterData obj) { Debug.Log(\"[MusicController] OnCharacterLoaded\"); PlayMainMenuMusic(); } }",
          "content_tokens": 32,
          "embedding": []
        }
      ],
      "length": 2182
    },
    {
      "filename": "RoomSearchStatus",
      "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using DDCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FirstGearGames.LobbyAndWorld.Lobbies; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using FishNet; using FishNet.Managing; using FishNet.Object; using FishNet.Transporting; using UnityEngine; using UnityEngine.UI; public class RoomSearchStatus : MonoBehaviour { [SerializeField] private TMProDecorator _tmProDecorator; private UICanvasGroupDecorator _uiCanvasGroupDecorator; [SerializeField] private GameObjectDispatcher parentCanvas; [SerializeField] private Button _soloBtn; [SerializeField] private Button trioBtn; private static string SEARCH_STATUS_TEXT = \"\"; private static string UPDATE_PLAYERS_STATUS_TEXT = \"\"; private static string STARTING_STATUS_TEXT = \"\"; private static string FAILED_STATUS_TEXT = \"Failed to start room.\"; public RoomSearchStatus Instance { get; private set; } private bool _isStarting; private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } _uiCanvasGroupDecorator = GetComponent<UICanvasGroupDecorator>(); } private void Start() { var translatedSearchStatusText = I2.Loc.LocalizationManager.GetTermTranslation(\"Finding available server...\"); if (!string.IsNullOrEmpty(translatedSearchStatusText)) SEARCH_STATUS_TEXT = translatedSearchStatusText.ToLower(); else SEARCH_STATUS_TEXT = \"Finding available server...\"; STARTING_STATUS_TEXT = I2.Loc.LocalizationManager.GetTermTranslation(\"Starting\").ToLower() + \"...\"; UPDATE_PLAYERS_STATUS_TEXT = I2.Loc.LocalizationManager.GetTermTranslation(\"Waiting for players\").ToLower(); parentCanvas.OnActivated += TurnOnLogic; parentCanvas.OnDeactivated += TurnOffLogic; StartCoroutine(ClientManagerSubscriber()); GameplayManager.OnClientLoadedGameplayManager += OnGameplayManagerLoaded; } private IEnumerator ClientManagerSubscriber() { var networkManager = FindObjectOfType<NetworkManager>(); yield return new WaitUntil(() => networkManager.Initialized); InstanceFinder.ClientManager.OnClientConnectionState += OnClientConnection; } private void TurnOnLogic() { InstanceFinder.ClientManager.OnClientConnectionState += OnClientConnection; GameplayManager.OnClientLoadedGameplayManager += OnGameplayManagerLoaded; } private void TurnOffLogic() { InstanceFinder.ClientManager.OnClientConnectionState -= OnClientConnection; GameplayManager.OnClientLoadedGameplayManager -= OnGameplayManagerLoaded; } public void OnClick_StartSearch() { StartCoroutine(SearchStatusText()); } private void OnGameplayManagerLoaded() { Hide(); } private void OnClientConnection(ClientConnectionStateArgs obj) { switch (obj.ConnectionState) { case LocalConnectionState.Started: if (gameObject.activeSelf) StartCoroutine(CatchGameplayManager()); break; case LocalConnectionState.Stopped: Hide(); _soloBtn.interactable = true; trioBtn.interactable = true; break; case LocalConnectionState.Starting: _isStarting = true; break; } } private IEnumerator CatchGameplayManager() { yield return new WaitUntil(() => GameplayManager.Instance != null); yield return new WaitUntil(() => GameplayManager.Instance.RoomDetails != null); StartCoroutine(UpdatePlayerText(GameplayManager.Instance.RoomDetails)); } private void Hide() { _uiCanvasGroupDecorator.Hide(); _uiCanvasGroupDecorator.StopAllAnimations(); } public void DestroyForServer() { Destroy(gameObject); } private IEnumerator SearchStatusText() { _uiCanvasGroupDecorator.Show(true); _uiCanvasGroupDecorator.BlinkAlpha(.9f, 0f, .5f, 1f); float timer = 0; while (!_isStarting) { timer += Time.deltaTime; _tmProDecorator.SetText($\"{SEARCH_STATUS_TEXT} {System.Convert.ToInt32(timer)}...\"); yield return null; } _isStarting = false; _tmProDecorator.SetText($\"{STARTING_STATUS_TEXT}...\"); } private IEnumerator UpdatePlayerText(RoomDetails room) { _uiCanvasGroupDecorator.Show(true); _uiCanvasGroupDecorator.BlinkAlpha(.9f, 0f, .5f, 1f); while (!GameplayManager.Instance.IsAllPlayersSpawned) { _tmProDecorator.SetText($\"{UPDATE_PLAYERS_STATUS_TEXT} {room.MemberIds.Count}/{room.MaxPlayers}\"); yield return new WaitForSeconds(0.5f); } Debug.Log(\"ENDDD\"); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RoomSearchStatus",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomSearchStatus",
          "content": "using System.Collections; using _ZombieRoyale.Scripts.Core; using DDCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FirstGearGames.LobbyAndWorld.Lobbies; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using FishNet; using FishNet.Managing; using FishNet.Object; using FishNet.Transporting; using UnityEngine; using UnityEngine.UI; public class RoomSearchStatus : MonoBehaviour { [SerializeField] private TMProDecorator _tmProDecorator; private UICanvasGroupDecorator _uiCanvasGroupDecorator; [SerializeField] private GameObjectDispatcher parentCanvas; [SerializeField] private Button _soloBtn; [SerializeField] private Button trioBtn; private static string SEARCH_STATUS_TEXT = \"\"; private static string UPDATE_PLAYERS_STATUS_TEXT = \"\"; private static string STARTING_STATUS_TEXT = \"\"; private static string FAILED_STATUS_TEXT = \"Failed to start room.\"; public RoomSearchStatus Instance { get; private set; } private bool _isStarting; private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } _uiCanvasGroupDecorator = GetComponent<UICanvasGroupDecorator>();  ",
          "content_tokens": 323,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomSearchStatus",
          "content": "private void Start() { var translatedSearchStatusText = I2.Loc.LocalizationManager.GetTermTranslation(\"Finding available server...\"); if (!string.IsNullOrEmpty(translatedSearchStatusText)) SEARCH_STATUS_TEXT = translatedSearchStatusText.ToLower(); else SEARCH_STATUS_TEXT = \"Finding available server...\"; STARTING_STATUS_TEXT = I2.Loc.LocalizationManager.GetTermTranslation(\"Starting\").ToLower() + \"...\"; UPDATE_PLAYERS_STATUS_TEXT = I2.Loc.LocalizationManager.GetTermTranslation(\"Waiting for players\").ToLower(); parentCanvas.OnActivated += TurnOnLogic; parentCanvas.OnDeactivated += TurnOffLogic; StartCoroutine(ClientManagerSubscriber()); GameplayManager.OnClientLoadedGameplayManager += OnGameplayManagerLoaded; } private IEnumerator ClientManagerSubscriber() { var networkManager = FindObjectOfType<NetworkManager>(); yield return new WaitUntil(() => networkManager.Initialized); InstanceFinder.ClientManager.OnClientConnectionState += OnClientConnection;  ",
          "content_tokens": 247,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomSearchStatus",
          "content": "private void TurnOnLogic() { InstanceFinder.ClientManager.OnClientConnectionState += OnClientConnection; GameplayManager.OnClientLoadedGameplayManager += OnGameplayManagerLoaded;  private void TurnOffLogic() { InstanceFinder.ClientManager.OnClientConnectionState -= OnClientConnection; GameplayManager.OnClientLoadedGameplayManager -= OnGameplayManagerLoaded;  public void OnClick_StartSearch() { StartCoroutine(SearchStatusText());  private void OnGameplayManagerLoaded() { Hide();  ",
          "content_tokens": 117,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomSearchStatus",
          "content": "private void OnClientConnection(ClientConnectionStateArgs obj) { switch (obj.ConnectionState) { case LocalConnectionState.Started: if (gameObject.activeSelf) StartCoroutine(CatchGameplayManager()); break; case LocalConnectionState.Stopped: Hide(); _soloBtn.interactable = true; trioBtn.interactable = true; break; case LocalConnectionState.Starting: _isStarting = true; break; } } private IEnumerator CatchGameplayManager() { yield return new WaitUntil(() => GameplayManager.Instance != null); yield return new WaitUntil(() => GameplayManager.Instance.RoomDetails != null); StartCoroutine(UpdatePlayerText(GameplayManager.Instance.RoomDetails));  private void Hide() { _uiCanvasGroupDecorator.Hide(); _uiCanvasGroupDecorator.StopAllAnimations();  ",
          "content_tokens": 193,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomSearchStatus",
          "content": "public void DestroyForServer() { Destroy(gameObject); } private IEnumerator SearchStatusText() { _uiCanvasGroupDecorator.Show(true); _uiCanvasGroupDecorator.BlinkAlpha(.9f, 0f, .5f, 1f); float timer = 0; while (!_isStarting) { timer += Time.deltaTime; _tmProDecorator.SetText($\"{SEARCH_STATUS_TEXT} {System.Convert.ToInt32(timer)}...\"); yield return null; } _isStarting = false; _tmProDecorator.SetText($\"{STARTING_STATUS_TEXT}...\"); } private IEnumerator UpdatePlayerText(RoomDetails room) { _uiCanvasGroupDecorator.Show(true); _uiCanvasGroupDecorator.BlinkAlpha(.9f, 0f, .5f, 1f); while (!GameplayManager.Instance.IsAllPlayersSpawned) { _tmProDecorator.SetText($\"{UPDATE_PLAYERS_STATUS_TEXT} {room.MemberIds.Count}/{room.MaxPlayers}\"); yield return new WaitForSeconds(0.5f); } Debug.Log(\"ENDDD\"); } }",
          "content_tokens": 282,
          "embedding": []
        }
      ],
      "length": 4135
    },
    {
      "filename": "TestEthereal",
      "content": "using FishnetInvector; using UnityEngine; using UnityEngine.SceneManagement; public class TestEthereal : MonoBehaviour { string _sceneName = \"Room\"; [SerializeField] private FNvThirdPersonCamera _cameraPrefab; public void LoadScene() { SceneManager.LoadScene(_sceneName, LoadSceneMode.Additive); } public void SpawnCamera() { FNvThirdPersonCamera camera = Instantiate(_cameraPrefab); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "TestEthereal",
          "content": "using FishnetInvector; using UnityEngine; using UnityEngine.SceneManagement; public class TestEthereal : MonoBehaviour { string _sceneName = \"Room\"; [SerializeField] private FNvThirdPersonCamera _cameraPrefab; public void LoadScene() { SceneManager.LoadScene(_sceneName, LoadSceneMode.Additive); } public void SpawnCamera() { FNvThirdPersonCamera camera = Instantiate(_cameraPrefab); } }",
          "content_tokens": 96,
          "embedding": []
        }
      ],
      "length": 388
    },
    {
      "filename": "WindowBankController",
      "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; public class WindowBankController : WindowController { public static WindowBankController Instance { get; private set; } private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } GameplayManager.OnLocalClientInitStarted += Hide; DontDestroyOnLoad(this); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "WindowBankController",
          "content": "using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; public class WindowBankController : WindowController { public static WindowBankController Instance { get; private set; } private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } GameplayManager.OnLocalClientInitStarted += Hide; DontDestroyOnLoad(this); } }",
          "content_tokens": 102,
          "embedding": []
        }
      ],
      "length": 379
    },
    {
      "filename": "WindowCharacterController",
      "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; public class WindowCharacterController : WindowController { public static WindowCharacterController Instance { get; private set; } private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } GameplayManager.OnLocalClientInitStarted += Hide; DontDestroyOnLoad(this); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "WindowCharacterController",
          "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; public class WindowCharacterController : WindowController { public static WindowCharacterController Instance { get; private set; } private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } GameplayManager.OnLocalClientInitStarted += Hide; DontDestroyOnLoad(this); } }",
          "content_tokens": 120,
          "embedding": []
        }
      ],
      "length": 468
    },
    {
      "filename": "WindowController",
      "content": "using System.Collections; using System.Collections.Generic; using DuloGames.UI; using UnityEngine; public class WindowController : MonoBehaviour { [SerializeField] protected UIWindow _uiWindow; protected void Hide() { _uiWindow.Hide(); } protected void Show() { _uiWindow.Show(); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "WindowController",
          "content": "using System.Collections; using System.Collections.Generic; using DuloGames.UI; using UnityEngine; public class WindowController : MonoBehaviour { [SerializeField] protected UIWindow _uiWindow; protected void Hide() { _uiWindow.Hide(); } protected void Show() { _uiWindow.Show(); } }",
          "content_tokens": 71,
          "embedding": []
        }
      ],
      "length": 284
    },
    {
      "filename": "WindowInventoryController",
      "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DuloGames.UI; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; public class WindowInventoryController : WindowController { public static WindowInventoryController Instance { get; private set; } private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } GameplayManager.OnLocalClientInitStarted += Hide; DontDestroyOnLoad(this); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "WindowInventoryController",
          "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using DuloGames.UI; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; public class WindowInventoryController : WindowController { public static WindowInventoryController Instance { get; private set; } private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } GameplayManager.OnLocalClientInitStarted += Hide; DontDestroyOnLoad(this); } }",
          "content_tokens": 129,
          "embedding": []
        }
      ],
      "length": 489
    },
    {
      "filename": "WindowProfileController",
      "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; public class WindowProfileController : WindowController { public static WindowProfileController Instance { get; private set; } private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } GameplayManager.OnLocalClientInitStarted += Hide; DontDestroyOnLoad(this); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "WindowProfileController",
          "content": "using System.Collections; using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using UnityEngine; public class WindowProfileController : WindowController { public static WindowProfileController Instance { get; private set; } private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } GameplayManager.OnLocalClientInitStarted += Hide; DontDestroyOnLoad(this); } }",
          "content_tokens": 120,
          "embedding": []
        }
      ],
      "length": 465
    },
    {
      "filename": "MainMenuCamera",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; using DDCore; public class MainMenuCamera : MonoBehaviour { [SerializeField] private NetworkHudCanvases _networkHubCanvases; public static MainMenuCamera Instance { get; private set; } private static MainMenuCamera _instance; void Start() { if (_networkHubCanvases.IsServer) { gameObject.SetActive(false); } if (_instance == null) { _instance = this; } else { Destroy(this); } } public static void ActivateMainMenuCamera() { _instance.gameObject.SetActive(true); } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MainMenuCamera",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; using DDCore; public class MainMenuCamera : MonoBehaviour { [SerializeField] private NetworkHudCanvases _networkHubCanvases; public static MainMenuCamera Instance { get; private set; } private static MainMenuCamera _instance; void Start() { if (_networkHubCanvases.IsServer) { gameObject.SetActive(false); } if (_instance == null) { _instance = this; } else { Destroy(this); } } public static void ActivateMainMenuCamera() { _instance.gameObject.SetActive(true); } }",
          "content_tokens": 142,
          "embedding": []
        }
      ],
      "length": 546
    },
    {
      "filename": "NetworkParticleSystem",
      "content": "using FishNet.Connection; using FishNet.Managing.Logging; using FishNet.Object; using FishNet.Object.Synchronizing; using System.Collections.Generic; using UnityEngine; using UnityEngine.Events; using static UnityEngine.ParticleSystem; /// <summary> /// Syncs a Unity ParticleSystem over the network. /// </summary> [RequireComponent(typeof(ParticleSystem))] public class NetworkParticleSystem : NetworkBehaviour { [System.Serializable] private struct NetParticle { public int Id; public Vector3 Position; public Vector3 Velocity; } [System.Serializable] private struct ParticleSyncData { public uint Seed; public float Time; public uint Tick; public override string ToString() => $\"Seed: {Seed}, PS Time: {Time}, Server tick: {Tick}\"; } private System.Random _prng = new System.Random(); [Tooltip(\"True to sync particle system autoplay data over the network \" + \"so it appears the same to clients as it does on the server.\")] [SerializeField] private bool _syncSeed = true; [Tooltip(\"True to sync the full particle state to clients when they join.\")] [SerializeField] private bool _syncFullStateOnJoin = false; [Tooltip(\"The sibling particle system component to sync over the network.\")] [SerializeField] private ParticleSystem _particleSystem = null; public ParticleSystem ParticleSystem => _particleSystem; [Header(\"Emission Sync\")] [Tooltip(\"True to sync the birth and death of particles over the network. \" + \"You probably want this on unless you are handling collisions on the client.\")] [SerializeField] private bool _syncAllParticles = false; private int _particleCount; public int ParticleCount => _particleCount; /// <summary> /// Particle cache. /// </summary> private Particle[] _particles; public Particle[] Particles => _particles; /// <summary> /// Extra particle cache in case particles are modified, we can detect changes. /// </summary> private Particle[] _particleCache; /// <summary> /// Particle system custom data cache. /// </summary> private List<Vector4> _customData = new List<Vector4>(); public List<Vector4> CustomData => _customData; [SyncVar(OnChange = nameof(OnSyncDataChanged))] private ParticleSyncData _psSyncData; private void OnSyncDataChanged(ParticleSyncData prev, ParticleSyncData cur, bool asServer) { if (asServer || IsHost) return; _particleSystem.Stop(true, ParticleSystemStopBehavior.StopEmittingAndClear); _particleSystem.randomSeed = cur.Seed; _particleSystem.Simulate(cur.Time - OneWayRTT(cur.Tick)); _particleSystem.Play(true); } [Header(\"Events\")] [Tooltip(\"Invokes the GameObject that collided with the particle.\")] public UnityEvent<GameObject> OnParticleCollisionWithGameObject; [Tooltip(\"Invokes the index in the particles array of the particle that was born.\")] public UnityEvent<int> OnParticleBirth; [Tooltip(\"Invokes the index in the particles array of the particle that died.\")] public UnityEvent<int> OnParticleDeath; [Tooltip(\"Invoked before particles are updated (in LateUpdate). \" + \"Use this event to modify position, velocity, etc. of a particle.\")] public UnityEvent OnParticleUpdate; [Header(\"Debug\")] [Tooltip(\"Debug log level.\")] [SerializeField] private LoggingType _logLevel = LoggingType.Error; private void Awake() { _particles = new Particle[_particleSystem.main.maxParticles]; } public override void OnStartNetwork() { base.OnStartNetwork(); TimeManager.OnLateUpdate += TimeManager_OnLateUpdate; } public override void OnStopNetwork() { base.OnStopNetwork(); if (TimeManager!=null) TimeManager.OnLateUpdate -= TimeManager_OnLateUpdate; } private void TimeManager_OnLateUpdate() { if (IsServer && _syncAllParticles) { GetParticleData(); if (_particleCount > 0) { OnParticleUpdate?.Invoke(); for (int i = 0; i < _particleCount; i++) { // particle born if ((int)_customData[i].x == 0) { int id = GetUniqueID(); _customData[i] = new Vector4(id, 0, 0, 0); if (_logLevel >= LoggingType.Common) Debug.Log($\"Particle BORN, index {i}, NEW ID: {id}\"); #pragma warning disable 0618 RpcEmit(_particles[i].position, _particles[i].velocity, _particles[i].size, _particles[i].remainingLifetime, _particles[i].color, id); #pragma warning restore 0618 OnParticleBirth?.Invoke(i); } // particle died else if (_particles[i].remainingLifetime <= 0f) { OnParticleDeath?.Invoke(i); int particleId = (int)_customData[i].x; if (_logLevel >= LoggingType.Common) Debug.Log($\"Particle DEAD, index {i} ID: {particleId}\"); RpcKill(particleId); _customData[i] = Vector4.zero; } //DetectParticleChanges(i); } SetParticleData(); } } } private void DetectParticleChanges(int i) { // dead particle already handled if ((int)_customData[i].x == 0) return; NetParticle netParticle = new NetParticle(); if (_particles[i].position != _particleCache[i].position) { netParticle.Position = _particles[i].position; netParticle.Id = (int)_customData[i].x; } if (_particles[i].velocity != _particleCache[i].velocity) { netParticle.Velocity = _particles[i].velocity; netParticle.Position = _particles[i].position; netParticle.Id = (int)_customData[i].x; } if (netParticle.Id != 0) { } } private void OnParticleCollision(GameObject other) { InvokeParticleCollision(other); } public override void OnSpawnServer(NetworkConnection connection) { base.OnSpawnServer(connection); if (_syncSeed) { _psSyncData = new ParticleSyncData() { Seed = _particleSystem.randomSeed, Time = _particleSystem.time, Tick = TimeManager.Tick, }; } if (_syncFullStateOnJoin) { SendFullState(connection); } } public override void OnStartClient() { base.OnStartClient(); // host check if (IsServer) return; // disable autoplay on clients, they will play when they get the data #pragma warning disable 0618 _particleSystem.playOnAwake = false; #pragma warning restore 0618 // disable collision on clients. // the server will handle it and send RpcKill's for client to remove them var col = _particleSystem.collision; col.enabled = false; } /// <summary> /// Invokes particle collision events. /// Make sure you have \"Send Collision Messages\" enabled in the particle system's collision module. /// </summary> /// <param name=\"other\"></param> private void InvokeParticleCollision(GameObject other) { OnParticleCollisionWithGameObject?.Invoke(other); } private float OneWayRTT(uint serverTick) { return (float)TimeManager.TicksToTime(TimeManager.Tick - serverTick); } /// <summary> /// Emits all the existing particles on the client of the given conn. /// </summary> /// <param name=\"conn\"></param> private void SendFullState(NetworkConnection conn) { if (_logLevel >= LoggingType.Common) Debug.Log(\"Sending full state\"); GetParticleData(); if (_particleCount == 0) return; for (int i = 0; i < _particleCount; i++) { // skip dead particles if (_particles[i].remainingLifetime <= 0f) continue; #pragma warning disable 0618 TargetEmit(conn, _particles[i].position, _particles[i].velocity, _particles[i].size, _particles[i].remainingLifetime, _particles[i].color, (int)_customData[i].x); #pragma warning restore 0618 } } /// <summary> /// Finds a particle by ID and kills it. /// </summary> /// <param name=\"id\"></param> [ObserversRpc] void RpcKill(int id) { if (IsServer) return; Debug.Log(\"Killing particle ID: \" + id); GetParticleData(); for (int i = 0; i < _particleCount; i++) { if (_customData[i].x == id) { OnParticleDeath?.Invoke(i); //Debug.Log($\"Found particle {i} with id {id}\"); _customData[i] = Vector4.zero; _particles[i].remainingLifetime = 0; } } SetParticleData(); } /// <summary> /// Emits a particle with parameters. /// </summary> /// <param name=\"pos\">Particle position.</param> /// <param name=\"vel\">Particle velocity.</param> /// <param name=\"size\">Particle size.</param> /// <param name=\"lifetime\">Particle lifetime.</param> /// <param name=\"color\">Particle color.</param> /// <param name=\"id\">Particle ID.</param> [ObserversRpc] void RpcEmit(Vector3 pos, Vector3 vel, float size, float lifetime, Color32 color, int id) { Emit(pos, vel, size, lifetime, color, id); } /// <summary> /// Emits a particle with parameters. /// </summary> /// <param name=\"conn\"></param> /// <param name=\"pos\"></param> /// <param name=\"vel\"></param> /// <param name=\"size\"></param> /// <param name=\"lifetime\"></param> /// <param name=\"color\"></param> /// <param name=\"id\"></param> [TargetRpc] void TargetEmit(NetworkConnection conn, Vector3 pos, Vector3 vel, float size, float lifetime, Color32 color, int id) { if (_logLevel >= LoggingType.Common) Debug.Log(\"Emitting at \" + pos); Emit(pos, vel, size, lifetime, color, id); } /// <summary> /// Emits a particle with params and caches its data. /// </summary> /// <param name=\"pos\"></param> /// <param name=\"vel\"></param> /// <param name=\"size\"></param> /// <param name=\"lifetime\"></param> /// <param name=\"color\"></param> /// <param name=\"id\"></param> [Client] void Emit(Vector3 pos, Vector3 vel, float size, float lifetime, Color32 color, int id) { if (IsServer) return; // using obsolete on purpose bc it actually works #pragma warning disable 0618 _particleSystem.Emit(pos, vel, size, lifetime, color); #pragma warning restore 0618 Debug.Log(\"Emitting particle at \" + pos); GetParticleData(); for (int i = 0; i < _particleCount; i++) { if (_logLevel >= LoggingType.Common) Debug.Log($\"Particle {i} empty id\"); if (_customData[i].x == 0) { _customData[i] = new Vector4(id, 0, 0, 0); if (_logLevel >= LoggingType.Common) Debug.Log($\"Particle index {i} NEW ID: {_customData[i].x}\"); OnParticleBirth?.Invoke(i); } } SetParticleData(); } /// <summary> /// Gets an int conversion of a GUID. Used for assigning ID's to particles. /// </summary> /// <returns></returns> int GetUniqueID() { return _prng.Next(); //return Animator.StringToHash(System.Guid.NewGuid().ToString()); } /// <summary> /// Gets the current state of the particle system particles. /// Returns its current particle count. /// </summary> /// <returns></returns> public int GetParticleData() { _particleCount = _particleSystem.GetParticles(_particles); _particleSystem.GetCustomParticleData(_customData, ParticleSystemCustomData.Custom2); // copy to cache we can use for comparisons _particleCache = new Particle[_particleCount]; for (int i = 0; i < _particleCount; i++) _particleCache[i] = _particles[i]; return _particleCount; } /// <summary> /// Sets the _customData and _particles to the particle system. /// </summary> void SetParticleData() { _particleSystem.SetCustomParticleData(_customData, ParticleSystemCustomData.Custom2); _particleSystem.SetParticles(_particles, _particleCount); } protected override void OnValidate() { base.OnValidate(); if (_particleSystem == null) _particleSystem = GetComponent<ParticleSystem>(); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "NetworkParticleSystem",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkParticleSystem",
          "content": "using FishNet.Connection; using FishNet.Managing.Logging; using FishNet.Object; using FishNet.Object.Synchronizing; using System.Collections.Generic; using UnityEngine; using UnityEngine.Events; using static UnityEngine.ParticleSystem; /// <summary> /// Syncs a Unity ParticleSystem over the network. /// </summary> [RequireComponent(typeof(ParticleSystem))] public class NetworkParticleSystem : NetworkBehaviour { [System.Serializable] private struct NetParticle { public int Id; public Vector3 Position; public Vector3 Velocity; } [System.Serializable] private struct ParticleSyncData { public uint Seed; public float Time; public uint Tick; public override string ToString() => $\"Seed: {Seed}, PS Time: {Time}, Server tick: {Tick}\"; } private System.Random _prng = new System.Random(); [Tooltip(\"True to sync particle system autoplay data over the network \" + \"so it appears the same to clients as it does on the server.\")] [SerializeField] private bool _syncSeed = true; [Tooltip(\"True to sync the full particle state to clients when they join.\")] [SerializeField] private bool _syncFullStateOnJoin = false; [Tooltip(\"The sibling particle system component to sync over the network.\")] [SerializeField] private ParticleSystem _particleSystem = null; public ParticleSystem ParticleSystem => _particleSystem; [Header(\"Emission Sync\")] [Tooltip(\"True to sync the birth and death of particles over the network. \" + \"You probably want this on unless you are handling collisions on the client.\")] [SerializeField] private bool _syncAllParticles = false; private int _particleCount; public int ParticleCount => _particleCount; /// <summary> /// Particle cache. /// </summary> private Particle[] _particles; public Particle[] Particles => _particles; /// <summary> /// Extra particle cache in case particles are modified, we can detect changes. /// </summary> private Particle[] _particleCache; /// <summary> /// Particle system custom data cache. /// </summary> private List<Vector4> _customData = new List<Vector4>(); public List<Vector4> CustomData => _customData; [SyncVar(OnChange = nameof(OnSyncDataChanged))] private ParticleSyncData _psSyncData; private void OnSyncDataChanged(ParticleSyncData prev, ParticleSyncData cur, bool asServer) { if (asServer || IsHost) return; _particleSystem.Stop(true, ParticleSystemStopBehavior.StopEmittingAndClear); _particleSystem.randomSeed = cur.Seed; _particleSystem.Simulate(cur.Time - OneWayRTT(cur.Tick)); _particleSystem.Play(true); } [Header(\"Events\")] [Tooltip(\"Invokes the GameObject that collided with the particle.\")] public UnityEvent<GameObject> OnParticleCollisionWithGameObject; [Tooltip(\"Invokes the index in the particles array of the particle that was born.\")] public UnityEvent<int> OnParticleBirth; [Tooltip(\"Invokes the index in the particles array of the particle that died.\")] public UnityEvent<int> OnParticleDeath; [Tooltip(\"Invoked before particles are updated (in LateUpdate). \" + \"Use this event to modify position, velocity, etc. of a particle.\")] public UnityEvent OnParticleUpdate; [Header(\"Debug\")] [Tooltip(\"Debug log level.\")] [SerializeField] private LoggingType _logLevel = LoggingType.Error; private void Awake() { _particles = new Particle[_particleSystem.main.maxParticles]; } public override void OnStartNetwork() { base.OnStartNetwork(); TimeManager.OnLateUpdate += TimeManager_OnLateUpdate; } public override void OnStopNetwork() { base.OnStopNetwork(); if (TimeManager!=null) TimeManager.OnLateUpdate -= TimeManager_OnLateUpdate;  ",
          "content_tokens": 906,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkParticleSystem",
          "content": "private void TimeManager_OnLateUpdate() { if (IsServer && _syncAllParticles) { GetParticleData(); if (_particleCount > 0) { OnParticleUpdate?.Invoke(); for (int i = 0; i < _particleCount; i++) { // particle born if ((int)_customData[i].x == 0) { int id = GetUniqueID(); _customData[i] = new Vector4(id, 0, 0, 0); if (_logLevel >= LoggingType.Common) Debug.Log($\"Particle BORN, index {i}, NEW ID: {id}\"); #pragma warning disable 0618 RpcEmit(_particles[i].position, _particles[i].velocity, _particles[i].size, _particles[i].remainingLifetime, _particles[i].color, id); #pragma warning restore 0618 OnParticleBirth?.Invoke(i); } // particle died else if (_particles[i].remainingLifetime <= 0f) { OnParticleDeath?.Invoke(i); int particleId = (int)_customData[i].x; if (_logLevel >= LoggingType.Common) Debug.Log($\"Particle DEAD, index {i} ID: {particleId}\"); RpcKill(particleId); _customData[i] = Vector4.zero; } //DetectParticleChanges(i);  ",
          "content_tokens": 327,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkParticleSystem",
          "content": "SetParticleData(); } }  private void DetectParticleChanges(int i) { // dead particle already handled if ((int)_customData[i].x == 0) return; NetParticle netParticle = new NetParticle(); if (_particles[i].position != _particleCache[i].position) { netParticle.Position = _particles[i].position; netParticle.Id = (int)_customData[i].x;  if (_particles[i].velocity != _particleCache[i].velocity) { netParticle.Velocity = _particles[i].velocity; netParticle.Position = _particles[i].position; netParticle.Id = (int)_customData[i].x;  if (netParticle.Id != 0) { }  ",
          "content_tokens": 186,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkParticleSystem",
          "content": "private void OnParticleCollision(GameObject other) { InvokeParticleCollision(other); } public override void OnSpawnServer(NetworkConnection connection) { base.OnSpawnServer(connection); if (_syncSeed) { _psSyncData = new ParticleSyncData() { Seed = _particleSystem.randomSeed, Time = _particleSystem.time, Tick = TimeManager.Tick, };  ",
          "content_tokens": 93,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkParticleSystem",
          "content": "if (_syncFullStateOnJoin) { SendFullState(connection); } } public override void OnStartClient() { base.OnStartClient(); // host check if (IsServer) return; // disable autoplay on clients, they will play when they get the data #pragma warning disable 0618 _particleSystem.playOnAwake = false; #pragma warning restore 0618 // disable collision on clients. // the server will handle it and send RpcKill's for client to remove them var col = _particleSystem.collision; col.enabled = false; } /// <summary> /// Invokes particle collision events. /// Make sure you have \"Send Collision Messages\" enabled in the particle system's collision module. /// </summary> /// <param name=\"other\"></param> private void InvokeParticleCollision(GameObject other) { OnParticleCollisionWithGameObject?.Invoke(other);  ",
          "content_tokens": 200,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkParticleSystem",
          "content": "private float OneWayRTT(uint serverTick) { return (float)TimeManager.TicksToTime(TimeManager.Tick - serverTick); } /// <summary> /// Emits all the existing particles on the client of the given conn. /// </summary> /// <param name=\"conn\"></param> private void SendFullState(NetworkConnection conn) { if (_logLevel >= LoggingType.Common) Debug.Log(\"Sending full state\"); GetParticleData(); if (_particleCount == 0) return; for (int i = 0; i < _particleCount; i++) { // skip dead particles if (_particles[i].remainingLifetime <= 0f) continue; #pragma warning disable 0618 TargetEmit(conn, _particles[i].position, _particles[i].velocity, _particles[i].size, _particles[i].remainingLifetime, _particles[i].color, (int)_customData[i].x); #pragma warning restore 0618 } } /// <summary> /// Finds a particle by ID and kills it. /// </summary> /// <param name=\"id\"></param> [ObserversRpc] void RpcKill(int id) { if (IsServer) return; Debug.Log(\"Killing particle ID: \" + id); GetParticleData(); for (int i = 0; i < _particleCount; i++) { if (_customData[i].x == id) { OnParticleDeath?.Invoke(i); //Debug.Log($\"Found particle {i} with id {id}\"); _customData[i] = Vector4.zero; _particles[i].remainingLifetime = 0; }  ",
          "content_tokens": 388,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkParticleSystem",
          "content": "SetParticleData(); } /// <summary> /// Emits a particle with parameters. /// </summary> /// <param name=\"pos\">Particle position.</param> /// <param name=\"vel\">Particle velocity.</param> /// <param name=\"size\">Particle size.</param> /// <param name=\"lifetime\">Particle lifetime.</param> /// <param name=\"color\">Particle color.</param> /// <param name=\"id\">Particle ID.</param> [ObserversRpc] void RpcEmit(Vector3 pos, Vector3 vel, float size, float lifetime, Color32 color, int id) { Emit(pos, vel, size, lifetime, color, id); } /// <summary> /// Emits a particle with parameters. /// </summary> /// <param name=\"conn\"></param> /// <param name=\"pos\"></param> /// <param name=\"vel\"></param> /// <param name=\"size\"></param> /// <param name=\"lifetime\"></param> /// <param name=\"color\"></param> /// <param name=\"id\"></param> [TargetRpc] void TargetEmit(NetworkConnection conn, Vector3 pos, Vector3 vel, float size, float lifetime, Color32 color, int id) { if (_logLevel >= LoggingType.Common) Debug.Log(\"Emitting at \" + pos); Emit(pos, vel, size, lifetime, color, id); } /// <summary> /// Emits a particle with params and caches its data. /// </summary> /// <param name=\"pos\"></param> /// <param name=\"vel\"></param> /// <param name=\"size\"></param> /// <param name=\"lifetime\"></param> /// <param name=\"color\"></param> /// <param name=\"id\"></param> [Client] void Emit(Vector3 pos, Vector3 vel, float size, float lifetime, Color32 color, int id) { if (IsServer) return; // using obsolete on purpose bc it actually works #pragma warning disable 0618 _particleSystem.Emit(pos, vel, size, lifetime, color); #pragma warning restore 0618 Debug.Log(\"Emitting particle at \" + pos); GetParticleData(); for (int i = 0; i < _particleCount; i++) { if (_logLevel >= LoggingType.Common) Debug.Log($\"Particle {i} empty id\"); if (_customData[i].x == 0) { _customData[i] = new Vector4(id, 0, 0, 0); if (_logLevel >= LoggingType.Common) Debug.Log($\"Particle index {i} NEW ID: {_customData[i].x}\"); OnParticleBirth?.Invoke(i); }  ",
          "content_tokens": 598,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkParticleSystem",
          "content": "SetParticleData(); } /// <summary> /// Gets an int conversion of a GUID. Used for assigning ID's to particles. /// </summary> /// <returns></returns> int GetUniqueID() { return _prng.Next(); //return Animator.StringToHash(System.Guid.NewGuid().ToString()); } /// <summary> /// Gets the current state of the particle system particles. /// Returns its current particle count. /// </summary> /// <returns></returns> public int GetParticleData() { _particleCount = _particleSystem.GetParticles(_particles); _particleSystem.GetCustomParticleData(_customData, ParticleSystemCustomData.Custom2); // copy to cache we can use for comparisons _particleCache = new Particle[_particleCount]; for (int i = 0; i < _particleCount; i++) _particleCache[i] = _particles[i]; return _particleCount; } /// <summary> /// Sets the _customData and _particles to the particle system. /// </summary> void SetParticleData() { _particleSystem.SetCustomParticleData(_customData, ParticleSystemCustomData.Custom2); _particleSystem.SetParticles(_particles, _particleCount); } protected override void OnValidate() { base.OnValidate(); if (_particleSystem == null) _particleSystem = GetComponent<ParticleSystem>(); } }",
          "content_tokens": 324,
          "embedding": []
        }
      ],
      "length": 10546
    },
    {
      "filename": "NPSPlayer",
      "content": "using FishNet.Object; using UnityEngine; using UnityEngine.VFX; public class NPSPlayer : NetworkBehaviour { [SerializeField] private AudioSource audioSource; [SerializeField] private bool isPlayOnStart; /// <summary> /// Particle system component. /// No need for NetworkParticleSystem as long as you emit on the server. /// </summary> [SerializeField] private ParticleSystem[] allParticles; [SerializeField] private NetworkParticleSystem networkParticleSystem; [SerializeField] private VisualEffect _vfx; #region Initialization protected override void OnValidate() { base.OnValidate(); AssignComponentsIfNull(); } private void AssignComponentsIfNull() { audioSource ??= GetComponentInChildren<AudioSource>(); allParticles ??= GetComponentsInChildren<ParticleSystem>(); _vfx ??= GetComponent<VisualEffect>(); networkParticleSystem ??= GetComponent<NetworkParticleSystem>(); } private void Awake() { AssignComponentsIfNull(); } #endregion public override void OnStartClient() { base.OnStartClient(); if (isPlayOnStart) { PlayFX(); } if (_vfx != null) { _vfx.Play(); } } private void PlayFX() { if (allParticles[0] != null) { allParticles[0].gameObject.SetActive(true); } for (int i = 0; i < allParticles.Length; i++) { allParticles[i].Play(); } PlayAudio(); } private void PlayAudio() { audioSource?.Play(); } public override void OnStopServer() { base.OnStopServer(); StopAllCoroutines(); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "NPSPlayer",
          "content": "using FishNet.Object; using UnityEngine; using UnityEngine.VFX; public class NPSPlayer : NetworkBehaviour { [SerializeField] private AudioSource audioSource; [SerializeField] private bool isPlayOnStart; /// <summary> /// Particle system component. /// No need for NetworkParticleSystem as long as you emit on the server. /// </summary> [SerializeField] private ParticleSystem[] allParticles; [SerializeField] private NetworkParticleSystem networkParticleSystem; [SerializeField] private VisualEffect _vfx; #region Initialization protected override void OnValidate() { base.OnValidate(); AssignComponentsIfNull();  ",
          "content_tokens": 149,
          "embedding": []
        },
        {
          "cs_scriptfile": "NPSPlayer",
          "content": "private void AssignComponentsIfNull() { audioSource ??= GetComponentInChildren<AudioSource>(); allParticles ??= GetComponentsInChildren<ParticleSystem>(); _vfx ??= GetComponent<VisualEffect>(); networkParticleSystem ??= GetComponent<NetworkParticleSystem>();  private void Awake() { AssignComponentsIfNull(); } #endregion public override void OnStartClient() { base.OnStartClient(); if (isPlayOnStart) { PlayFX();  if (_vfx != null) { _vfx.Play(); }  private void PlayFX() { if (allParticles[0] != null) { allParticles[0].gameObject.SetActive(true);  for (int i = 0; i < allParticles.Length; i++) { allParticles[i].Play();  PlayAudio();  ",
          "content_tokens": 191,
          "embedding": []
        },
        {
          "cs_scriptfile": "NPSPlayer",
          "content": "private void PlayAudio() { audioSource?.Play(); } public override void OnStopServer() { base.OnStopServer(); StopAllCoroutines(); } }",
          "content_tokens": 35,
          "embedding": []
        }
      ],
      "length": 1392
    },
    {
      "filename": "OwnerOnlyCondition",
      "content": " using FishNet.Connection; using FishNet.Observing; using UnityEngine; namespace FishNet.Component.Observing { /// <summary> /// This condition makes an object only visible to the owner. /// </summary> [CreateAssetMenu(menuName = \"FishNet/Observers/Owner Only Condition\", fileName = \"New Owner Only Condition\")] public class OwnerOnlyCondition : ObserverCondition { /// <summary> /// Returns if the object which this condition resides should be visible to connection. /// </summary> /// <param name=\"connection\">Connection which the condition is being checked for.</param> /// <param name=\"currentlyAdded\">True if the connection currently has visibility of this object.</param> /// <param name=\"notProcessed\">True if the condition was not processed. This can be used to skip processing for performance. While output as true this condition result assumes the previous ConditionMet value.</param> public override bool ConditionMet(NetworkConnection connection, bool currentlyAdded, out bool notProcessed) { notProcessed = false; /* Returning false immediately indicates no connection will * meet this condition. */ return connection.ClientId == NetworkObject.Owner.ClientId; } /// <summary> /// True if the condition requires regular updates. /// </summary> /// <returns></returns> public override bool Timed() { return true; } /// <summary> /// Clones referenced ObserverCondition. This must be populated with your conditions settings. /// </summary> /// <returns></returns> public override ObserverCondition Clone() { OwnerOnlyCondition copy = ScriptableObject.CreateInstance<OwnerOnlyCondition>(); return copy; } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "OwnerOnlyCondition",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "OwnerOnlyCondition",
          "content": "using FishNet.Connection; using FishNet.Observing; using UnityEngine; namespace FishNet.Component.Observing { /// <summary> /// This condition makes an object only visible to the owner. /// </summary> [CreateAssetMenu(menuName = \"FishNet/Observers/Owner Only Condition\", fileName = \"New Owner Only Condition\")] public class OwnerOnlyCondition : ObserverCondition { /// <summary> /// Returns if the object which this condition resides should be visible to connection. /// </summary> /// <param name=\"connection\">Connection which the condition is being checked for.</param> /// <param name=\"currentlyAdded\">True if the connection currently has visibility of this object.</param> /// <param name=\"notProcessed\">True if the condition was not processed. This can be used to skip processing for performance. While output as true this condition result assumes the previous ConditionMet value.</param> public override bool ConditionMet(NetworkConnection connection, bool currentlyAdded, out bool notProcessed) { notProcessed = false; /* Returning false immediately indicates no connection will * meet this condition. */ return connection.ClientId == NetworkObject.Owner.ClientId; } /// <summary> /// True if the condition requires regular updates. /// </summary> /// <returns></returns> public override bool Timed() { return true; } /// <summary> /// Clones referenced ObserverCondition. This must be populated with your conditions settings. /// </summary> /// <returns></returns> public override ObserverCondition Clone() { OwnerOnlyCondition copy = ScriptableObject.CreateInstance<OwnerOnlyCondition>(); return copy; } } }",
          "content_tokens": 344,
          "embedding": []
        }
      ],
      "length": 1618
    },
    {
      "filename": "PoseCorrector",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class PoseCorrector : MonoBehaviour { [SerializeField] private GameObject _targetModel; public void Fix() { if (_targetModel == null) return; //get all children transforms var targetChildren = new List<Transform>(); foreach (Transform child in _targetModel.transform) { targetChildren.Add(child); } var children = new List<Transform>(); foreach (Transform child in transform) { children.Add(child); } foreach (var trans in targetChildren) { foreach (var myChild in children) { if (myChild.name == trans.name) { myChild.position = trans.position; myChild.rotation = trans.rotation; } } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PoseCorrector",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class PoseCorrector : MonoBehaviour { [SerializeField] private GameObject _targetModel; public void Fix() { if (_targetModel == null) return; //get all children transforms var targetChildren = new List<Transform>(); foreach (Transform child in _targetModel.transform) { targetChildren.Add(child); } var children = new List<Transform>(); foreach (Transform child in transform) { children.Add(child); } foreach (var trans in targetChildren) { foreach (var myChild in children) { if (myChild.name == trans.name) { myChild.position = trans.position; myChild.rotation = trans.rotation; } } } } }",
          "content_tokens": 172,
          "embedding": []
        }
      ],
      "length": 676
    },
    {
      "filename": "RespawnSpotsHolder",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.Serialization; public class RespawnSpotsHolder : MonoBehaviour { [SerializeField] private List<Vector3> _spawnPositions = new List<Vector3>(); public List<Vector3> SpawnPositions {set => _spawnPositions = value; get => _spawnPositions;} } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RespawnSpotsHolder",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.Serialization; public class RespawnSpotsHolder : MonoBehaviour { [SerializeField] private List<Vector3> _spawnPositions = new List<Vector3>(); public List<Vector3> SpawnPositions {set => _spawnPositions = value; get => _spawnPositions;} }",
          "content_tokens": 88,
          "embedding": []
        }
      ],
      "length": 336
    },
    {
      "filename": "RoomDataManagement",
      "content": "using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using FishNet.Object; using UnityEngine; public class RoomDataManagement : MonoBehaviour { public static RoomDataManagement Instance { get; private set; } private RoomDetails _currentRoomDetails; [SerializeField] private string _roomName; [SerializeField] private List<NetworkObject> _members; } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RoomDataManagement",
          "content": "using System.Collections.Generic; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using FishNet.Object; using UnityEngine; public class RoomDataManagement : MonoBehaviour { public static RoomDataManagement Instance { get; private set; } private RoomDetails _currentRoomDetails; [SerializeField] private string _roomName; [SerializeField] private List<NetworkObject> _members; }",
          "content_tokens": 126,
          "embedding": []
        }
      ],
      "length": 487
    },
    {
      "filename": "PlayerPrefsSafe",
      "content": "using System; using System.Security.Cryptography; using System.Text; using UnityEngine; namespace DDCore.Security { public static class PlayerPrefsSafe { private const int salt = 1218809357; public static void SetInt(string key, int value) { int salted = value ^ salt; PlayerPrefs.SetInt(StringHash(key), salted); PlayerPrefs.SetInt(StringHash(\"_\" + key), IntHash(value)); } public static int GetInt(string key) { return GetInt(key, 0); } public static int GetInt(string key, int defaultValue) { string hashedKey = StringHash(key); if (!PlayerPrefs.HasKey(hashedKey)) return defaultValue; int salted = PlayerPrefs.GetInt(hashedKey); int value = salted ^ salt; int loadedHash = PlayerPrefs.GetInt(StringHash(\"_\" + key)); if (loadedHash != IntHash(value)) return defaultValue; return value; } public static void SetFloat(string key, float value) { int intValue = BitConverter.ToInt32(BitConverter.GetBytes(value), 0); int salted = intValue ^ salt; PlayerPrefs.SetInt(StringHash(key), salted); PlayerPrefs.SetInt(StringHash(\"_\" + key), IntHash(intValue)); } public static float GetFloat(string key) { return GetFloat(key, 0); } public static float GetFloat(string key, float defaultValue) { string hashedKey = StringHash(key); if (!PlayerPrefs.HasKey(hashedKey)) return defaultValue; int salted = PlayerPrefs.GetInt(hashedKey); int value = salted ^ salt; int loadedHash = PlayerPrefs.GetInt(StringHash(\"_\" + key)); if (loadedHash != IntHash(value)) return defaultValue; return BitConverter.ToSingle(BitConverter.GetBytes(value), 0); } private static int IntHash(int x) { x = ((x >> 16) ^ x) * 0x45d9f3b; x = ((x >> 16) ^ x) * 0x45d9f3b; x = (x >> 16) ^ x; return x; } public static string StringHash(string x) { HashAlgorithm algorithm = SHA256.Create(); StringBuilder sb = new StringBuilder(); var bytes = algorithm.ComputeHash(Encoding.UTF8.GetBytes(x)); foreach (byte b in bytes) sb.Append(b.ToString(\"X2\")); return sb.ToString(); } public static void DeleteKey(string key) { PlayerPrefs.DeleteKey(StringHash(key)); PlayerPrefs.DeleteKey(StringHash(\"_\" + key)); } public static bool HasKey(string key) { string hashedKey = StringHash(key); if (!PlayerPrefs.HasKey(hashedKey)) return false; int salted = PlayerPrefs.GetInt(hashedKey); int value = salted ^ salt; int loadedHash = PlayerPrefs.GetInt(StringHash(\"_\" + key)); return loadedHash == IntHash(value); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PlayerPrefsSafe",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "PlayerPrefsSafe",
          "content": "using System; using System.Security.Cryptography; using System.Text; using UnityEngine; namespace DDCore.Security { public static class PlayerPrefsSafe { private const int salt = 1218809357; public static void SetInt(string key, int value) { int salted = value ^ salt; PlayerPrefs.SetInt(StringHash(key), salted); PlayerPrefs.SetInt(StringHash(\"_\" + key), IntHash(value)); } public static int GetInt(string key) { return GetInt(key, 0); } public static int GetInt(string key, int defaultValue) { string hashedKey = StringHash(key); if (!PlayerPrefs.HasKey(hashedKey)) return defaultValue; int salted = PlayerPrefs.GetInt(hashedKey); int value = salted ^ salt; int loadedHash = PlayerPrefs.GetInt(StringHash(\"_\" + key)); if (loadedHash != IntHash(value)) return defaultValue; return value; } public static void SetFloat(string key, float value) { int intValue = BitConverter.ToInt32(BitConverter.GetBytes(value), 0); int salted = intValue ^ salt; PlayerPrefs.SetInt(StringHash(key), salted); PlayerPrefs.SetInt(StringHash(\"_\" + key), IntHash(intValue)); } public static float GetFloat(string key) { return GetFloat(key, 0); } public static float GetFloat(string key, float defaultValue) { string hashedKey = StringHash(key); if (!PlayerPrefs.HasKey(hashedKey)) return defaultValue; int salted = PlayerPrefs.GetInt(hashedKey); int value = salted ^ salt; int loadedHash = PlayerPrefs.GetInt(StringHash(\"_\" + key)); if (loadedHash != IntHash(value)) return defaultValue; return BitConverter.ToSingle(BitConverter.GetBytes(value), 0); } private static int IntHash(int x) { x = ((x >> 16) ^ x) * 0x45d9f3b; x = ((x >> 16) ^ x) * 0x45d9f3b; x = (x >> 16) ^ x; return x; } public static string StringHash(string x) { HashAlgorithm algorithm = SHA256.Create(); StringBuilder sb = new StringBuilder(); var bytes = algorithm.ComputeHash(Encoding.UTF8.GetBytes(x)); foreach (byte b in bytes) sb.Append(b.ToString(\"X2\")); return sb.ToString(); } public static void DeleteKey(string key) { PlayerPrefs.DeleteKey(StringHash(key)); PlayerPrefs.DeleteKey(StringHash(\"_\" + key)); } public static bool HasKey(string key) { string hashedKey = StringHash(key); if (!PlayerPrefs.HasKey(hashedKey)) return false; int salted = PlayerPrefs.GetInt(hashedKey); int value = salted ^ salt; int loadedHash = PlayerPrefs.GetInt(StringHash(\"_\" + key)); return loadedHash == IntHash(value); } } }",
          "content_tokens": 716,
          "embedding": []
        }
      ],
      "length": 2363
    },
    {
      "filename": "SafeFloat",
      "content": "using System; namespace DDCore.Security { public struct SafeFloat { private int value; private int salt; public SafeFloat(float value) { salt = UnityEngine.Random.Range(int.MinValue/4, int.MaxValue/4); int intValue = BitConverter.ToInt32(BitConverter.GetBytes(value), 0); this.value = intValue ^ salt; } public override bool Equals(object obj) { return (float)this == (float)obj; } public override int GetHashCode() { return base.GetHashCode(); } public override string ToString() { return ((float)this).ToString(); } public static implicit operator float(SafeFloat safeFloat) { return BitConverter.ToSingle(BitConverter.GetBytes(safeFloat.salt ^ safeFloat.value), 0); } public static implicit operator SafeFloat(float normalFloat) { return new SafeFloat(normalFloat); } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SafeFloat",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "SafeFloat",
          "content": "using System; namespace DDCore.Security { public struct SafeFloat { private int value; private int salt; public SafeFloat(float value) { salt = UnityEngine.Random.Range(int.MinValue/4, int.MaxValue/4); int intValue = BitConverter.ToInt32(BitConverter.GetBytes(value), 0); this.value = intValue ^ salt; } public override bool Equals(object obj) { return (float)this == (float)obj; } public override int GetHashCode() { return base.GetHashCode(); } public override string ToString() { return ((float)this).ToString(); } public static implicit operator float(SafeFloat safeFloat) { return BitConverter.ToSingle(BitConverter.GetBytes(safeFloat.salt ^ safeFloat.value), 0); } public static implicit operator SafeFloat(float normalFloat) { return new SafeFloat(normalFloat); } } }",
          "content_tokens": 210,
          "embedding": []
        }
      ],
      "length": 775
    },
    {
      "filename": "SafeInt",
      "content": "using UnityEngine; namespace DDCore.Security { public struct SafeInt { private int value; private int salt; public SafeInt(int value) { salt = Random.Range(int.MinValue / 4, int.MaxValue / 4); this.value = value ^ salt; } public override bool Equals(object obj) { return (int) this == (int) obj; } public override int GetHashCode() { return base.GetHashCode(); } public override string ToString() { return ((int) this).ToString(); } public static implicit operator int(SafeInt safeInt) { return safeInt.value ^ safeInt.salt; } public static implicit operator SafeInt(int normalInt) { return new SafeInt(normalInt); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SafeInt",
          "content": "using UnityEngine; namespace DDCore.Security { public struct SafeInt { private int value; private int salt; public SafeInt(int value) { salt = Random.Range(int.MinValue / 4, int.MaxValue / 4); this.value = value ^ salt; } public override bool Equals(object obj) { return (int) this == (int) obj; } public override int GetHashCode() { return base.GetHashCode(); } public override string ToString() { return ((int) this).ToString(); } public static implicit operator int(SafeInt safeInt) { return safeInt.value ^ safeInt.salt; } public static implicit operator SafeInt(int normalInt) { return new SafeInt(normalInt); } } }",
          "content_tokens": 164,
          "embedding": []
        }
      ],
      "length": 620
    },
    {
      "filename": "AllManagersSpawner",
      "content": "using System.Collections.Generic; using System.Text; using FishNet; using UnityEngine; public class AllManagersSpawner : MonoBehaviour { public static AllManagersSpawner Instance { get; private set; } [SerializeField] private GameObject _allManagersPrefab; [SerializeField] private GameObject[] gameObjectsToSpawn; [SerializeField] private List<GameObject> spawnedManagers; private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); } } public void SpawnAllManagers() { StringBuilder sb = new StringBuilder($\"[AllManagersSpawner] \"); for (int i = 0; i < gameObjectsToSpawn.Length; i++) { GameObject go = Instantiate(gameObjectsToSpawn[i]); InstanceFinder.ServerManager.Spawn(go); sb.Append($\"#{i} {go.name}, \"); spawnedManagers.Add(go); } sb.Append($\". Spawned {spawnedManagers.Count} managers\"); // GameObject allManagers = Instantiate(_allManagersPrefab); // InstanceFinder.ServerManager.Spawn(allManagers); Debug.Log(sb, gameObject); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AllManagersSpawner",
          "content": "using System.Collections.Generic; using System.Text; using FishNet; using UnityEngine; public class AllManagersSpawner : MonoBehaviour { public static AllManagersSpawner Instance { get; private set; } [SerializeField] private GameObject _allManagersPrefab; [SerializeField] private GameObject[] gameObjectsToSpawn; [SerializeField] private List<GameObject> spawnedManagers; private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(this); }  ",
          "content_tokens": 122,
          "embedding": []
        },
        {
          "cs_scriptfile": "AllManagersSpawner",
          "content": "public void SpawnAllManagers() { StringBuilder sb = new StringBuilder($\"[AllManagersSpawner] \"); for (int i = 0; i < gameObjectsToSpawn.Length; i++) { GameObject go = Instantiate(gameObjectsToSpawn[i]); InstanceFinder.ServerManager.Spawn(go); sb.Append($\"#{i} {go.name}, \"); spawnedManagers.Add(go); } sb.Append($\". Spawned {spawnedManagers.Count} managers\"); // GameObject allManagers = Instantiate(_allManagersPrefab); // InstanceFinder.ServerManager.Spawn(allManagers); Debug.Log(sb, gameObject); } }",
          "content_tokens": 161,
          "embedding": []
        }
      ],
      "length": 969
    },
    {
      "filename": "CustomSceneLoader",
      "content": "using System; using System.Collections; using FishNet.Connection; using FishNet.Managing.Scened; using System.Collections.Generic; using System.Linq; using _ZombieRoyale.Scripts.Core; using DDCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Managing; using FishNet.Transporting; using FishNet.Utility; using UnityEngine; namespace FishnetCustomScripts { /// <summary> /// Loads a single scene, additive scenes, or both when a client /// enters or exits this trigger. /// </summary> public class CustomSceneLoader : MonoBehaviour { /// <summary> /// True to automatically unload the loaded scenes when no more connections are using them. /// </summary> [Tooltip(\"True to automatically unload the loaded scenes when no more connections are using them.\")] [SerializeField] private bool _automaticallyUnload = false; /// <summary> /// True to replace current scenes with new scenes. First scene loaded will become active scene. /// </summary> [Tooltip(\"True to replace current scenes with new scenes. First scene loaded will become active scene.\")] [SerializeField] private bool _replaceScenes = false; /// <summary> /// Used to prevent excessive triggering when two clients are loaded and server is separate. /// Client may enter trigger intentionally then when moved to a new scene will re-enter trigger /// since original scene will still be loaded on server due to another client being in it. /// This scenario is extremely unlikely in production but keep it in mind. /// </summary> private Dictionary<NetworkConnection, float> _triggeredTimes = new Dictionary<NetworkConnection, float>(); // // [Tooltip(\"After loading this scene client connection will start.\")] // [Scene] public string ClientScenePath; [Tooltip(\"After loading this scene Server will start.\")] public string ServerScenePath; [SerializeField] private NetworkHudCanvases fishnetNetworkHudCanvases; [SerializeField] private NetworkManager networkManager; private GameModeScene _currentGameModeScene; [SerializeField] private GameModeScene[] gameModeScenes; public enum GameMode { None, ArcadeSurvival, ExtractionRPG } public void ChangeGameMode(GameMode gameMode) { _currentGameModeScene = gameModeScenes.First(x => x.gameMode == gameMode); } private void OnValidate() { fishnetNetworkHudCanvases ??= FindObjectOfType<NetworkHudCanvases>(); networkManager ??= FindObjectOfType<NetworkManager>(); } private void Start() { _currentGameModeScene = gameModeScenes[0]; } private void OnDisable() { InstanceFinder.SceneManager.OnLoadStart -= PrintServerStartedLoadingScene; InstanceFinder.SceneManager.OnLoadEnd -= PrintServerEndedLoadingScene; InstanceFinder.SceneManager.OnClientLoadedStartScenes -= PrintClientEndedLoadingScene; } public void ServerLoadGameScene() { //Load options. LoadOptions loadOptions = new LoadOptions { AutomaticallyUnload = _automaticallyUnload, }; //Make scene data. SceneLoadData sld = new SceneLoadData(_currentGameModeScene.scenePath); sld.ReplaceScenes = (_replaceScenes) ? ReplaceOption.All : ReplaceOption.None; sld.Options = loadOptions; //sld.MovedNetworkObjects = movedObjects; InstanceFinder.SceneManager.LoadGlobalScenes(sld); Debug.Log($\"[ServerLog] Starting loading scene {_currentGameModeScene.scenePath} for {_currentGameModeScene.gameMode} game mode.\"); InstanceFinder.SceneManager.OnLoadStart += PrintServerStartedLoadingScene; InstanceFinder.SceneManager.OnLoadEnd += PrintServerEndedLoadingScene; InstanceFinder.SceneManager.OnClientLoadedStartScenes += PrintClientEndedLoadingScene; } private void PrintClientEndedLoadingScene(NetworkConnection conn, bool asServer) { if (!asServer) return; Debug.Log($\"[ServerLog] Client #{conn.ClientId} ended loading scene.\"); GameplayManager.Instance.AddPlayerToLoadedList(conn); } private void PrintServerEndedLoadingScene(SceneLoadEndEventArgs obj) { Debug.Log(\"[ServerLog] Server ended loading scene.\"); } private void PrintServerStartedLoadingScene(SceneLoadStartEventArgs obj) { Debug.Log(\"[ServerLog] Server started loading scene.\"); } [Serializable] public struct GameModeScene { public GameMode gameMode; public string scenePath; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CustomSceneLoader",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomSceneLoader",
          "content": "using System; using System.Collections; using FishNet.Connection; using FishNet.Managing.Scened; using System.Collections.Generic; using System.Linq; using _ZombieRoyale.Scripts.Core; using DDCore; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using FishNet.Managing; using FishNet.Transporting; using FishNet.Utility; using UnityEngine; namespace FishnetCustomScripts { /// <summary> /// Loads a single scene, additive scenes, or both when a client /// enters or exits this trigger. /// </summary> public class CustomSceneLoader : MonoBehaviour { /// <summary> /// True to automatically unload the loaded scenes when no more connections are using them. /// </summary> [Tooltip(\"True to automatically unload the loaded scenes when no more connections are using them.\")] [SerializeField] private bool _automaticallyUnload = false; /// <summary> /// True to replace current scenes with new scenes. First scene loaded will become active scene. /// </summary> [Tooltip(\"True to replace current scenes with new scenes. First scene loaded will become active scene.\")] [SerializeField] private bool _replaceScenes = false; /// <summary> /// Used to prevent excessive triggering when two clients are loaded and server is separate. /// Client may enter trigger intentionally then when moved to a new scene will re-enter trigger /// since original scene will still be loaded on server due to another client being in it. /// This scenario is extremely unlikely in production but keep it in mind. /// </summary> private Dictionary<NetworkConnection, float> _triggeredTimes = new Dictionary<NetworkConnection, float>(); // // [Tooltip(\"After loading this scene client connection will start.\")] // [Scene] public string ClientScenePath; [Tooltip(\"After loading this scene Server will start.\")] public string ServerScenePath; [SerializeField] private NetworkHudCanvases fishnetNetworkHudCanvases; [SerializeField] private NetworkManager networkManager; private GameModeScene _currentGameModeScene; [SerializeField] private GameModeScene[] gameModeScenes; public enum GameMode { None, ArcadeSurvival, ExtractionRPG  ",
          "content_tokens": 489,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomSceneLoader",
          "content": "public void ChangeGameMode(GameMode gameMode) { _currentGameModeScene = gameModeScenes.First(x => x.gameMode == gameMode);  private void OnValidate() { fishnetNetworkHudCanvases ??= FindObjectOfType<NetworkHudCanvases>(); networkManager ??= FindObjectOfType<NetworkManager>();  private void Start() { _currentGameModeScene = gameModeScenes[0];  private void OnDisable() { InstanceFinder.SceneManager.OnLoadStart -= PrintServerStartedLoadingScene; InstanceFinder.SceneManager.OnLoadEnd -= PrintServerEndedLoadingScene; InstanceFinder.SceneManager.OnClientLoadedStartScenes -= PrintClientEndedLoadingScene;  ",
          "content_tokens": 168,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomSceneLoader",
          "content": "public void ServerLoadGameScene() { //Load options. LoadOptions loadOptions = new LoadOptions { AutomaticallyUnload = _automaticallyUnload, }; //Make scene data. SceneLoadData sld = new SceneLoadData(_currentGameModeScene.scenePath); sld.ReplaceScenes = (_replaceScenes) ? ReplaceOption.All : ReplaceOption.None; sld.Options = loadOptions; //sld.MovedNetworkObjects = movedObjects; InstanceFinder.SceneManager.LoadGlobalScenes(sld); Debug.Log($\"[ServerLog] Starting loading scene {_currentGameModeScene.scenePath} for {_currentGameModeScene.gameMode} game mode.\"); InstanceFinder.SceneManager.OnLoadStart += PrintServerStartedLoadingScene; InstanceFinder.SceneManager.OnLoadEnd += PrintServerEndedLoadingScene; InstanceFinder.SceneManager.OnClientLoadedStartScenes += PrintClientEndedLoadingScene;  ",
          "content_tokens": 219,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomSceneLoader",
          "content": "private void PrintClientEndedLoadingScene(NetworkConnection conn, bool asServer) { if (!asServer) return; Debug.Log($\"[ServerLog] Client #{conn.ClientId} ended loading scene.\"); GameplayManager.Instance.AddPlayerToLoadedList(conn);  private void PrintServerEndedLoadingScene(SceneLoadEndEventArgs obj) { Debug.Log(\"[ServerLog] Server ended loading scene.\");  private void PrintServerStartedLoadingScene(SceneLoadStartEventArgs obj) { Debug.Log(\"[ServerLog] Server started loading scene.\"); } [Serializable] public struct GameModeScene { public GameMode gameMode; public string scenePath; } } }",
          "content_tokens": 150,
          "embedding": []
        }
      ],
      "length": 4131
    },
    {
      "filename": "CustomServerManager",
      "content": "using System; using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FirstGearGames.LobbyAndWorld.Lobbies; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using FishNet; using FishNet.Component.Spawning; using FishNet.Connection; using FishNet.Managing; using FishNet.Object; using FishNet.Transporting; using FishnetCustomScripts; using Hathora; using Proyecto26; using UnityEngine; using UnityEngine.SceneManagement; using UnitySceneManager = UnityEngine.SceneManagement.SceneManager; namespace DDCore { public class CustomServerManager : MonoBehaviour { public static Action OnGameSceneLoaded; private bool _isOnline; private const float TIME_TO_WAIT_BEFORE_CLOSING_SERVER = 3f; private const int MAX_AVAILABLE_SLOTS = 12; public static ServerState CurrentState { get { return Instance._serverState; } } private ServerState _serverState = ServerState.Offline; public Action<ServerState> OnServerStateChanged; [SerializeField] private PlayerSpawner playerSpawner; [SerializeField] private NetworkManager networkManager; [SerializeField] private CustomSceneLoader customSceneLoader; [field: SerializeField] public bool IsHathora { get; private set; } = true; [field: SerializeField] public bool IsFishnetSceneLoader { get; private set; } = true; public enum ServerState { Offline, Starting, WaitingForPlayers, Playing, Stopping } public static CustomServerManager Instance { get; private set; } private Action<string> OnRoomDataListUpdated; private void OnValidate() { playerSpawner ??= FindObjectOfType<PlayerSpawner>(); networkManager ??= FindObjectOfType<NetworkManager>(); customSceneLoader ??= FindObjectOfType<CustomSceneLoader>(); } private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); } else if (Instance != this) { Destroy(gameObject); } } private void Start() { //if (!NetworkHudCanvases.Instance.IsAutoStartServer) yield break; } private void OnDisable() { Debug.Log($\"[ServerManager] OnDisable\"); } private void Init() { Debug.Log($\"[ServerManager] Init\"); playerSpawner.OnSpawned += OnPlayerSpawned; GameplayManager.OnRoomReady += OnGameReady; //instance binding } private void OnPlayerSpawned(NetworkObject obj) { GameplayManager.LocalPlayer.RoomDetails.AddMember(obj); string targetRoomName = ClientSceneHandler.ROOM_SCENE_NAME; if (IsFishnetSceneLoader) { SceneManager.MoveGameObjectToScene(obj.gameObject, SceneManager.GetSceneByName(targetRoomName)); } Debug.Log($\"[ServerManager] Added player #{obj.OwnerId} ClientInstance #{obj.ObjectId} to room {GameplayManager.LocalPlayer.RoomDetails}\"); if (GameplayManager.LocalPlayer.RoomDetails.MemberIds.Count >= MAX_AVAILABLE_SLOTS || networkManager.IsHost) { StartImmediate(); } else { UpdateStartGameTimer(GameplayManager.LocalPlayer.RoomDetails); } } /// <summary> /// Called when server ready to accept connections. /// </summary> public void OnGameReady() { #if UNITY_ANDROID return; #endif if (IsHathora) { OnRoomDataListUpdated += ConnectionInfoUpdater; Action<RequestException, ResponseHelper, string> callback = (err, res, body) => { if (err != null) { Debug.Log($\"[ServerManager] Error creating room: {err}\"); return; } Debug.Log($\"[ServerManager] Created room: {body}\"); OnRoomDataListUpdated?.Invoke(body); }; BackendReadWrites.GetHathoraRoomId(callback); } else { OnServerHosted(); } } private void ConnectionInfoUpdater(string jsonBody) { OnRoomDataListUpdated -= ConnectionInfoUpdater; Debug.Log($\"[ServerManager.ConnectionInfoUpdater] Running ConnectionInfoUpdater\"); RoomDataList roomDataList = JsonUtility.FromJson<RoomDataList>(\"{\\\"rooms\\\":\" + jsonBody + \"}\"); //log to check if json Data was read properly Debug.Log($\"[ServerManager.ConnectionInfoUpdater] RoomDataList: {roomDataList}\"); string roomId = roomDataList.rooms[0].roomId; Debug.Log($\"[ServerManager.ConnectionInfoUpdater] RoomId: {roomId}\"); GameplayManager.LocalPlayer.RoomDetails.SetName(roomId); Action<RequestException, ResponseHelper, string> connInfoCallback = (err2, res2, body2) => { if (err2 != null) { Debug.Log($\"[ServerManager] Error joining room: {err2}\"); return; } Debug.Log($\"[ServerManager.ConnectionInfoUpdater] ConnectionInfo: {body2}\"); OnGotHathoraConnectionInfo(body2, roomId); }; BackendReadWrites.GetHathoraConnectionInfo(roomId, connInfoCallback); } private void OnGotHathoraConnectionInfo(string response, string roomId) { Debug.Log($\"[ServerManager] OnGotHathoraConnectionInfo: {response}\"); ConnectionInfo connInfo = JsonUtility.FromJson<ConnectionInfo>(response); ushort port = connInfo.exposedPort.port; string host = connInfo.exposedPort.host; ServerBackendController.Instance.WriteDataToFile(roomId, \"Server description\", host, port, Application.version, InstanceFinder.TransportManager.Transport.GetMaximumClients()); OnServerHosted(); } private void OnServerHosted() { SetServerState(ServerState.WaitingForPlayers); GameplayManager.LocalPlayer.RoomDetails.SetName(Guid.NewGuid().ToString()); ServerBackendController.Instance.StartServerRegistrationRoutine(); //get all loaded scenes string[] scenes = new string[UnitySceneManager.sceneCount]; for (int i = 0; i < scenes.Length; i++) { scenes[i] = UnitySceneManager.GetSceneAt(i).name; Debug.Log($\"[ServerManager] Scene {i}: {scenes[i]}\"); if (scenes[i] == ClientSceneHandler.ROOM_SCENE_NAME) { UnitySceneManager.SetActiveScene(UnitySceneManager.GetSceneByName(ClientSceneHandler.ROOM_SCENE_NAME)); } } } /// <summary> /// Called when all players joined this server /// </summary> private void StartImmediate() { SetServerState(ServerState.Playing); //OrderAllClientsToLoadGameScene(); InstanceFinder.ServerManager.OnRemoteConnectionState += OnRemoteConnectionState; ServerBackendController.Instance.StopServerRegistrationRoutine(); } private void OnRemoteConnectionState(NetworkConnection conn, RemoteConnectionStateArgs connState) { if (connState.ConnectionState == RemoteConnectionState.Stopped) { Debug.Log($\"[CustomServerManager] Player #{conn.ClientId} {connState.ConnectionState}\"); StartCoroutine(CheckAmountOfPlayersLeft()); } } private IEnumerator CheckAmountOfPlayersLeft() { if (InstanceFinder.ServerManager.Clients.Count == 0) { Debug.Log($\"[CustomServerManager] All players left the game. Stopping server.\"); SetServerState(ServerState.Stopping); yield return new WaitForSeconds(TIME_TO_WAIT_BEFORE_CLOSING_SERVER); Debug.Log($\"[CustomServerManager] Quitting Application.\"); Application.Quit(); } } private void OrderAllClientsToLoadGameScene() { foreach (var clientInstanceNob in GameplayManager.LocalPlayer.RoomDetails.MemberIds) { clientInstanceNob.GetComponent<ClientSceneHandler>().OrderToLoadGameScene(); } } private void OnGameFinished() { SetServerState(ServerState.Stopping); } public void OnServerConnectionState(ServerConnectionStateArgs obj) { Debug.Log($\"[CustomServerManager] OnServerConnectionState: {obj.ConnectionState}\"); switch (obj.ConnectionState) { case LocalConnectionState.Started: SetServerState(ServerState.Starting); Init(); RegistrationController.Instance.SwitchMainMenuElements(false); //customSceneLoader.ServerLoadGameScene(); OnGameSceneLoaded += OnServerLoadedGameScene; LoadGameScene(); break; case LocalConnectionState.Stopped: ServerBackendController.Instance.UnregisterThisServer(); break; } } private void OnServerLoadedGameScene() { StartCoroutine(OnServerLoadedGameSceneCoroutine()); } private IEnumerator OnServerLoadedGameSceneCoroutine() { yield return new WaitForSeconds(2f); AllManagersSpawner.Instance.SpawnAllManagers(); } private void SetServerState(ServerState state) { Debug.Log($\"[ServerManager] SetServerState: {state}\"); _serverState = state; OnServerStateChanged?.Invoke(state); } private void LoadGameScene() { if (IsFishnetSceneLoader) { Debug.Log($\"[ServerManager] Loading game scene using Fishnet\"); customSceneLoader.ServerLoadGameScene(); } else { Debug.Log($\"[ServerManager] Loading game scene using Unity\"); CustomSceneManager.LoadSceneAsync(ClientSceneHandler.ROOM_SCENE_NAME, LoadSceneMode.Additive, OnGameSceneLoaded); } } private void UpdateStartGameTimer(RoomDetails roomDetails) { if (roomDetails.TimeoutCoroutine != null) { Debug.Log($\"[ReadyLobbyNetwork] Restarting room timeout\"); StopCoroutine(roomDetails.TimeoutCoroutine); } roomDetails.TimeoutCoroutine = StartCoroutine(RoomStartTimeout(roomDetails)); Debug.Log($\"[ReadyLobbyNetwork] Starting room timeout\"); } private IEnumerator RoomStartTimeout(RoomDetails roomDetails) { Debug.Log($\"[ReadyLobbyNetwork] Starting room timeout for room: {roomDetails.Name}. Game will start after: {LobbyNetwork.TIMEOUT_TO_START} seconds\"); yield return new WaitForSeconds(LobbyNetwork.TIMEOUT_TO_START); //LobbyNetwork.TargetsNotifyGameStarted(roomDetails); StartImmediate(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CustomServerManager",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomServerManager",
          "content": "using System; using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FirstGearGames.LobbyAndWorld.Lobbies; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using FishNet; using FishNet.Component.Spawning; using FishNet.Connection; using FishNet.Managing; using FishNet.Object; using FishNet.Transporting; using FishnetCustomScripts; using Hathora; using Proyecto26; using UnityEngine; using UnityEngine.SceneManagement; using UnitySceneManager = UnityEngine.SceneManagement.SceneManager; namespace DDCore { public class CustomServerManager : MonoBehaviour { public static Action OnGameSceneLoaded; private bool _isOnline; private const float TIME_TO_WAIT_BEFORE_CLOSING_SERVER = 3f; private const int MAX_AVAILABLE_SLOTS = 12; public static ServerState CurrentState { get { return Instance._serverState; } } private ServerState _serverState = ServerState.Offline; public Action<ServerState> OnServerStateChanged; [SerializeField] private PlayerSpawner playerSpawner; [SerializeField] private NetworkManager networkManager; [SerializeField] private CustomSceneLoader customSceneLoader; [field: SerializeField] public bool IsHathora { get; private set; } = true; [field: SerializeField] public bool IsFishnetSceneLoader { get; private set; } = true; public enum ServerState { Offline, Starting, WaitingForPlayers, Playing, Stopping } public static CustomServerManager Instance { get; private set; } private Action<string> OnRoomDataListUpdated; private void OnValidate() { playerSpawner ??= FindObjectOfType<PlayerSpawner>(); networkManager ??= FindObjectOfType<NetworkManager>(); customSceneLoader ??= FindObjectOfType<CustomSceneLoader>();  ",
          "content_tokens": 442,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomServerManager",
          "content": "private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); } else if (Instance != this) { Destroy(gameObject); }  private void Start() { //if (!NetworkHudCanvases.Instance.IsAutoStartServer) yield break;  private void OnDisable() { Debug.Log($\"[ServerManager] OnDisable\");  private void Init() { Debug.Log($\"[ServerManager] Init\"); playerSpawner.OnSpawned += OnPlayerSpawned; GameplayManager.OnRoomReady += OnGameReady; //instance binding  ",
          "content_tokens": 132,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomServerManager",
          "content": "private void OnPlayerSpawned(NetworkObject obj) { GameplayManager.LocalPlayer.RoomDetails.AddMember(obj); string targetRoomName = ClientSceneHandler.ROOM_SCENE_NAME; if (IsFishnetSceneLoader) { SceneManager.MoveGameObjectToScene(obj.gameObject, SceneManager.GetSceneByName(targetRoomName)); } Debug.Log($\"[ServerManager] Added player #{obj.OwnerId} ClientInstance #{obj.ObjectId} to room {GameplayManager.LocalPlayer.RoomDetails}\"); if (GameplayManager.LocalPlayer.RoomDetails.MemberIds.Count >= MAX_AVAILABLE_SLOTS || networkManager.IsHost) { StartImmediate(); } else { UpdateStartGameTimer(GameplayManager.LocalPlayer.RoomDetails); } } /// <summary> /// Called when server ready to accept connections. /// </summary> public void OnGameReady() { #if UNITY_ANDROID return; #endif if (IsHathora) { OnRoomDataListUpdated += ConnectionInfoUpdater; Action<RequestException, ResponseHelper, string> callback = (err, res, body) => { if (err != null) { Debug.Log($\"[ServerManager] Error creating room: {err}\"); return; } Debug.Log($\"[ServerManager] Created room: {body}\"); OnRoomDataListUpdated?.Invoke(body); }; BackendReadWrites.GetHathoraRoomId(callback); } else { OnServerHosted(); }  ",
          "content_tokens": 333,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomServerManager",
          "content": "private void ConnectionInfoUpdater(string jsonBody) { OnRoomDataListUpdated -= ConnectionInfoUpdater; Debug.Log($\"[ServerManager.ConnectionInfoUpdater] Running ConnectionInfoUpdater\"); RoomDataList roomDataList = JsonUtility.FromJson<RoomDataList>(\"{\\\"rooms\\\":\" + jsonBody + \"}\"); //log to check if json Data was read properly Debug.Log($\"[ServerManager.ConnectionInfoUpdater] RoomDataList: {roomDataList}\"); string roomId = roomDataList.rooms[0].roomId; Debug.Log($\"[ServerManager.ConnectionInfoUpdater] RoomId: {roomId}\"); GameplayManager.LocalPlayer.RoomDetails.SetName(roomId); Action<RequestException, ResponseHelper, string> connInfoCallback = (err2, res2, body2) => { if (err2 != null) { Debug.Log($\"[ServerManager] Error joining room: {err2}\"); return; } Debug.Log($\"[ServerManager.ConnectionInfoUpdater] ConnectionInfo: {body2}\"); OnGotHathoraConnectionInfo(body2, roomId); }; BackendReadWrites.GetHathoraConnectionInfo(roomId, connInfoCallback);  ",
          "content_tokens": 279,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomServerManager",
          "content": "private void OnGotHathoraConnectionInfo(string response, string roomId) { Debug.Log($\"[ServerManager] OnGotHathoraConnectionInfo: {response}\"); ConnectionInfo connInfo = JsonUtility.FromJson<ConnectionInfo>(response); ushort port = connInfo.exposedPort.port; string host = connInfo.exposedPort.host; ServerBackendController.Instance.WriteDataToFile(roomId, \"Server description\", host, port, Application.version, InstanceFinder.TransportManager.Transport.GetMaximumClients()); OnServerHosted();  ",
          "content_tokens": 134,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomServerManager",
          "content": "private void OnServerHosted() { SetServerState(ServerState.WaitingForPlayers); GameplayManager.LocalPlayer.RoomDetails.SetName(Guid.NewGuid().ToString()); ServerBackendController.Instance.StartServerRegistrationRoutine(); //get all loaded scenes string[] scenes = new string[UnitySceneManager.sceneCount]; for (int i = 0; i < scenes.Length; i++) { scenes[i] = UnitySceneManager.GetSceneAt(i).name; Debug.Log($\"[ServerManager] Scene {i}: {scenes[i]}\"); if (scenes[i] == ClientSceneHandler.ROOM_SCENE_NAME) { UnitySceneManager.SetActiveScene(UnitySceneManager.GetSceneByName(ClientSceneHandler.ROOM_SCENE_NAME)); } } } /// <summary> /// Called when all players joined this server /// </summary> private void StartImmediate() { SetServerState(ServerState.Playing); //OrderAllClientsToLoadGameScene(); InstanceFinder.ServerManager.OnRemoteConnectionState += OnRemoteConnectionState; ServerBackendController.Instance.StopServerRegistrationRoutine();  ",
          "content_tokens": 253,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomServerManager",
          "content": "private void OnRemoteConnectionState(NetworkConnection conn, RemoteConnectionStateArgs connState) { if (connState.ConnectionState == RemoteConnectionState.Stopped) { Debug.Log($\"[CustomServerManager] Player #{conn.ClientId} {connState.ConnectionState}\"); StartCoroutine(CheckAmountOfPlayersLeft()); } } private IEnumerator CheckAmountOfPlayersLeft() { if (InstanceFinder.ServerManager.Clients.Count == 0) { Debug.Log($\"[CustomServerManager] All players left the game. Stopping server.\"); SetServerState(ServerState.Stopping); yield return new WaitForSeconds(TIME_TO_WAIT_BEFORE_CLOSING_SERVER); Debug.Log($\"[CustomServerManager] Quitting Application.\"); Application.Quit(); }  ",
          "content_tokens": 178,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomServerManager",
          "content": "private void OrderAllClientsToLoadGameScene() { foreach (var clientInstanceNob in GameplayManager.LocalPlayer.RoomDetails.MemberIds) { clientInstanceNob.GetComponent<ClientSceneHandler>().OrderToLoadGameScene(); }  private void OnGameFinished() { SetServerState(ServerState.Stopping);  ",
          "content_tokens": 75,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomServerManager",
          "content": "public void OnServerConnectionState(ServerConnectionStateArgs obj) { Debug.Log($\"[CustomServerManager] OnServerConnectionState: {obj.ConnectionState}\"); switch (obj.ConnectionState) { case LocalConnectionState.Started: SetServerState(ServerState.Starting); Init(); RegistrationController.Instance.SwitchMainMenuElements(false); //customSceneLoader.ServerLoadGameScene(); OnGameSceneLoaded += OnServerLoadedGameScene; LoadGameScene(); break; case LocalConnectionState.Stopped: ServerBackendController.Instance.UnregisterThisServer(); break; }  private void OnServerLoadedGameScene() { StartCoroutine(OnServerLoadedGameSceneCoroutine()); } private IEnumerator OnServerLoadedGameSceneCoroutine() { yield return new WaitForSeconds(2f); AllManagersSpawner.Instance.SpawnAllManagers();  ",
          "content_tokens": 193,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomServerManager",
          "content": "private void SetServerState(ServerState state) { Debug.Log($\"[ServerManager] SetServerState: {state}\"); _serverState = state; OnServerStateChanged?.Invoke(state);  private void LoadGameScene() { if (IsFishnetSceneLoader) { Debug.Log($\"[ServerManager] Loading game scene using Fishnet\"); customSceneLoader.ServerLoadGameScene(); } else { Debug.Log($\"[ServerManager] Loading game scene using Unity\"); CustomSceneManager.LoadSceneAsync(ClientSceneHandler.ROOM_SCENE_NAME, LoadSceneMode.Additive, OnGameSceneLoaded); }  ",
          "content_tokens": 138,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomServerManager",
          "content": "private void UpdateStartGameTimer(RoomDetails roomDetails) { if (roomDetails.TimeoutCoroutine != null) { Debug.Log($\"[ReadyLobbyNetwork] Restarting room timeout\"); StopCoroutine(roomDetails.TimeoutCoroutine); } roomDetails.TimeoutCoroutine = StartCoroutine(RoomStartTimeout(roomDetails)); Debug.Log($\"[ReadyLobbyNetwork] Starting room timeout\"); } private IEnumerator RoomStartTimeout(RoomDetails roomDetails) { Debug.Log($\"[ReadyLobbyNetwork] Starting room timeout for room: {roomDetails.Name}. Game will start after: {LobbyNetwork.TIMEOUT_TO_START} seconds\"); yield return new WaitForSeconds(LobbyNetwork.TIMEOUT_TO_START); //LobbyNetwork.TargetsNotifyGameStarted(roomDetails); StartImmediate(); } } }",
          "content_tokens": 187,
          "embedding": []
        }
      ],
      "length": 8761
    },
    {
      "filename": "CustomServerManagerEditor",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; using DDCore; [CustomEditor(typeof(CustomServerManager))] public class CustomServerManagerEditor : Editor { public override void OnInspectorGUI() { #if UNITY_EDITOR base.OnInspectorGUI(); CustomServerManager manager = (CustomServerManager)target; if (GUILayout.Button(\"Test Start Server\")) { manager.OnGameReady(); } if (GUILayout.Button(\"Stop Server\")) { //manager.StopServer(); } #endif } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CustomServerManagerEditor",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEditor; using UnityEngine; using DDCore; [CustomEditor(typeof(CustomServerManager))] public class CustomServerManagerEditor : Editor { public override void OnInspectorGUI() { #if UNITY_EDITOR base.OnInspectorGUI(); CustomServerManager manager = (CustomServerManager)target; if (GUILayout.Button(\"Test Start Server\")) { manager.OnGameReady(); } if (GUILayout.Button(\"Stop Server\")) { //manager.StopServer(); } #endif } }",
          "content_tokens": 130,
          "embedding": []
        }
      ],
      "length": 491
    },
    {
      "filename": "NetworkHudCanvasesEditor",
      "content": "using UnityEditor; using UnityEngine; using DDCore; using FishNet.Managing; [CustomEditor(typeof(NetworkHudCanvases))] public class NetworkHudCanvasesEditor : Editor { private NetworkHudCanvases _myScript; private void OnEnable() { _myScript = (NetworkHudCanvases)target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); if (!_myScript.IsAutoStartServer) { if (GUILayout.Button(\"Connect Client\")) { _myScript.GetComponent<NetworkManager>().Init(); _myScript.OnClick_Client(); } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "NetworkHudCanvasesEditor",
          "content": "using UnityEditor; using UnityEngine; using DDCore; using FishNet.Managing; [CustomEditor(typeof(NetworkHudCanvases))] public class NetworkHudCanvasesEditor : Editor { private NetworkHudCanvases _myScript; private void OnEnable() { _myScript = (NetworkHudCanvases)target; } public override void OnInspectorGUI() { base.OnInspectorGUI(); if (!_myScript.IsAutoStartServer) { if (GUILayout.Button(\"Connect Client\")) { _myScript.GetComponent<NetworkManager>().Init(); _myScript.OnClick_Client(); } } } }",
          "content_tokens": 148,
          "embedding": []
        }
      ],
      "length": 499
    },
    {
      "filename": "NetworkHudCanvases",
      "content": " using FishNet.Managing; using FishNet.Transporting; using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.UI; using System; using System.Collections; using FishNet; namespace DDCore { public class NetworkHudCanvases : MonoBehaviour { #region Types. /// <summary> /// Ways the HUD will automatically start a connection. /// </summary> private enum AutoStartType { Disabled, Host, Server, Client } #endregion #region Serialized. /// <summary> /// What connections to automatically start on play. /// </summary> [Tooltip(\"What connections to automatically start on play.\")] [SerializeField] private AutoStartType _autoStartType = AutoStartType.Disabled; public bool IsAutoStartServer { get { #if UNITY_SERVER || UNITY_STANDALONE_LINUX return true; #endif if (_autoStartType == AutoStartType.Host || _autoStartType == AutoStartType.Server) return true; else return false; } } public bool IsServer { get { if (_autoStartType == AutoStartType.Server) return true; else return false; } } /// <summary> /// Color when socket is stopped. /// </summary> [Tooltip(\"Color when socket is stopped.\")] [SerializeField] private Color _stoppedColor; /// <summary> /// Color when socket is changing. /// </summary> [Tooltip(\"Color when socket is changing.\")] [SerializeField] private Color _changingColor; /// <summary> /// Color when socket is started. /// </summary> [Tooltip(\"Color when socket is started.\")] [SerializeField] private Color _startedColor; [Header(\"Indicators\")] /// <summary> /// Indicator for server state. /// </summary> [Tooltip(\"Indicator for server state.\")] [SerializeField] private Image _serverIndicator; /// <summary> /// Indicator for client state. /// </summary> [Tooltip(\"Indicator for client state.\")] [SerializeField] private Image _clientIndicator; #endregion #region Private. /// <summary> /// Found NetworkManager. /// </summary> private NetworkManager _networkManager; /// <summary> /// Current state of client socket. /// </summary> private LocalConnectionState _clientState = LocalConnectionState.Stopped; /// <summary> /// Current state of server socket. /// </summary> private LocalConnectionState _serverState = LocalConnectionState.Stopped; #if !ENABLE_INPUT_SYSTEM /// <summary> /// EventSystem for the project. /// </summary> private EventSystem _eventSystem; #endif #endregion #region Public. public static Action OnServerStarted; public static Action OnClientConnectedToServer; public static Action OnDisconnectedFromServer; public static NetworkHudCanvases Instance { get; private set; } #endregion void OnGUI() { #if ENABLE_INPUT_SYSTEM string GetNextStateText(LocalConnectionState state) { if (state == LocalConnectionState.Stopped) return \"Start\"; else if (state == LocalConnectionState.Starting) return \"Starting\"; else if (state == LocalConnectionState.Stopping) return \"Stopping\"; else if (state == LocalConnectionState.Started) return \"Stop\"; else return \"Invalid\"; } GUILayout.BeginArea(new Rect(16, 16, 256, 9000)); Vector2 defaultResolution = new Vector2(1920f, 1080f); GUI.matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, new Vector3(Screen.width / defaultResolution.x, Screen.height / defaultResolution.y, 1)); GUIStyle style = GUI.skin.GetStyle(\"button\"); int originalFontSize = style.fontSize; Vector2 buttonSize = new Vector2(256f, 64f); style.fontSize = 28; //Server button. if (Application.platform != RuntimePlatform.WebGLPlayer) { if (GUILayout.Button($\"{GetNextStateText(_serverState)} Server\", GUILayout.Width(buttonSize.x), GUILayout.Height(buttonSize.y))) OnClick_Server(); GUILayout.Space(10f); } //Client button. if (GUILayout.Button($\"{GetNextStateText(_clientState)} Client\", GUILayout.Width(buttonSize.x), GUILayout.Height(buttonSize.y))) OnClick_Client(); style.fontSize = originalFontSize; GUILayout.EndArea(); #endif } private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); } else if (Instance != this){ Destroy(gameObject); } } private void Start() { #if !ENABLE_INPUT_SYSTEM SetEventSystem(); BaseInputModule inputModule = FindObjectOfType<BaseInputModule>(); if (inputModule == null) gameObject.AddComponent<StandaloneInputModule>(); #else _serverIndicator.transform.parent.gameObject.SetActive(false); _clientIndicator.transform.parent.gameObject.SetActive(false); #endif _networkManager = FindObjectOfType<NetworkManager>(); #if UNITY_SERVER || UNITY_STANDALONE_LINUX _networkManager.Init(); OnClick_Server(); #else if (_autoStartType == AutoStartType.Host || _autoStartType == AutoStartType.Server) { _networkManager.Init(); OnClick_Server(); } if (!Application.isBatchMode && (_autoStartType == AutoStartType.Host || _autoStartType == AutoStartType.Client)) { OnClick_Client(); } #endif } private void OnDestroy() { if (_networkManager == null) return; _networkManager.ServerManager.OnServerConnectionState -= ServerManager_OnServerConnectionState; _networkManager.ClientManager.OnClientConnectionState -= ClientManager_OnClientConnectionState; } /// <summary> /// Updates img color baased on state. /// </summary> /// <param name=\"state\"></param> /// <param name=\"img\"></param> private void UpdateColor(LocalConnectionState state, ref Image img) { Color c; if (state == LocalConnectionState.Started){ c = _startedColor; if (IsAutoStartServer) OnServerStarted?.Invoke(); else { Debug.Log($\"[NetworkHudCanvases] UpdateColor: OnClientConnectedToServer\"); OnClientConnectedToServer?.Invoke(); } }else if (state == LocalConnectionState.Stopping) { ushort port = _networkManager.TransportManager.Transport.GetPort(); port++; _networkManager.TransportManager.Transport.SetPort(port); } else if (state == LocalConnectionState.Stopped) { c = _stoppedColor; OnDisconnectedFromServer?.Invoke(); } else c = _changingColor; //img.Color = c; } private void ClientManager_OnClientConnectionState(ClientConnectionStateArgs obj) { _clientState = obj.ConnectionState; UpdateColor(obj.ConnectionState, ref _clientIndicator); } private void ServerManager_OnServerConnectionState(ServerConnectionStateArgs obj) { _serverState = obj.ConnectionState; UpdateColor(obj.ConnectionState, ref _serverIndicator); } public void OnClick_Server() { Debug.Log($\"[NetworkHudCanvases] OnClick_Server\"); if (_networkManager == null) return; _networkManager.ServerManager.OnServerConnectionState += CustomServerManager.Instance.OnServerConnectionState; if (_serverState != LocalConnectionState.Stopped) _networkManager.ServerManager.StopConnection(true); else _networkManager.ServerManager.StartConnection(); DeselectButtons(); } public void OnClick_Client() { Debug.Log($\"[NetworkHudCanvases] OnClick_Client\"); if (_networkManager == null) return; if (_clientState != LocalConnectionState.Stopped) _networkManager.ClientManager.StopConnection(); else { Debug.Log($\"[NetworkHudCanvases] StartConnection...\"); _networkManager.ClientManager.StartConnection(); } DeselectButtons(); } private void SetEventSystem() { #if !ENABLE_INPUT_SYSTEM if (_eventSystem != null) return; _eventSystem = FindObjectOfType<EventSystem>(); if (_eventSystem == null) _eventSystem = gameObject.AddComponent<EventSystem>(); #endif } private void DeselectButtons() { #if !ENABLE_INPUT_SYSTEM SetEventSystem(); _eventSystem?.SetSelectedGameObject(null); #endif } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "NetworkHudCanvases",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkHudCanvases",
          "content": " using FishNet.Managing; using FishNet.Transporting; using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.UI; using System; using System.Collections; using FishNet; namespace DDCore { public class NetworkHudCanvases : MonoBehaviour { #region Types. /// <summary> /// Ways the HUD will automatically start a connection. /// </summary> private enum AutoStartType { Disabled, Host, Server, Client } #endregion #region Serialized. /// <summary> /// What connections to automatically start on play. /// </summary> [Tooltip(\"What connections to automatically start on play.\")] [SerializeField] private AutoStartType _autoStartType = AutoStartType.Disabled; public bool IsAutoStartServer { get { #if UNITY_SERVER || UNITY_STANDALONE_LINUX return true; #endif if (_autoStartType == AutoStartType.Host || _autoStartType == AutoStartType.Server) return true; else return false; } } public bool IsServer { get { if (_autoStartType == AutoStartType.Server) return true; else return false; } } /// <summary> /// Color when socket is stopped. /// </summary> [Tooltip(\"Color when socket is stopped.\")] [SerializeField] private Color _stoppedColor; /// <summary> /// Color when socket is changing. /// </summary> [Tooltip(\"Color when socket is changing.\")] [SerializeField] private Color _changingColor; /// <summary> /// Color when socket is started. /// </summary> [Tooltip(\"Color when socket is started.\")] [SerializeField] private Color _startedColor; [Header(\"Indicators\")] /// <summary> /// Indicator for server state. /// </summary> [Tooltip(\"Indicator for server state.\")] [SerializeField] private Image _serverIndicator; /// <summary> /// Indicator for client state. /// </summary> [Tooltip(\"Indicator for client state.\")] [SerializeField] private Image _clientIndicator; #endregion #region Private. /// <summary> /// Found NetworkManager. /// </summary> private NetworkManager _networkManager; /// <summary> /// Current state of client socket. /// </summary> private LocalConnectionState _clientState = LocalConnectionState.Stopped; /// <summary> /// Current state of server socket. /// </summary> private LocalConnectionState _serverState = LocalConnectionState.Stopped; #if !ENABLE_INPUT_SYSTEM /// <summary> /// EventSystem for the project. /// </summary> private EventSystem _eventSystem; #endif #endregion #region Public. public static Action OnServerStarted; public static Action OnClientConnectedToServer; public static Action OnDisconnectedFromServer; public static NetworkHudCanvases Instance { get; private set; } #endregion void OnGUI() { #if ENABLE_INPUT_SYSTEM string GetNextStateText(LocalConnectionState state) { if (state == LocalConnectionState.Stopped) return \"Start\"; else if (state == LocalConnectionState.Starting) return \"Starting\"; else if (state == LocalConnectionState.Stopping) return \"Stopping\"; else if (state == LocalConnectionState.Started) return \"Stop\"; else return \"Invalid\"; } GUILayout.BeginArea(new Rect(16, 16, 256, 9000)); Vector2 defaultResolution = new Vector2(1920f, 1080f); GUI.matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, new Vector3(Screen.width / defaultResolution.x, Screen.height / defaultResolution.y, 1)); GUIStyle style = GUI.skin.GetStyle(\"button\"); int originalFontSize = style.fontSize; Vector2 buttonSize = new Vector2(256f, 64f); style.fontSize = 28; //Server button. if (Application.platform != RuntimePlatform.WebGLPlayer) { if (GUILayout.Button($\"{GetNextStateText(_serverState)} Server\", GUILayout.Width(buttonSize.x), GUILayout.Height(buttonSize.y))) OnClick_Server(); GUILayout.Space(10f); } //Client button. if (GUILayout.Button($\"{GetNextStateText(_clientState)} Client\", GUILayout.Width(buttonSize.x), GUILayout.Height(buttonSize.y))) OnClick_Client(); style.fontSize = originalFontSize; GUILayout.EndArea(); #endif  ",
          "content_tokens": 1003,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkHudCanvases",
          "content": "private void Awake() { if (Instance == null) { Instance = this; DontDestroyOnLoad(gameObject); } else if (Instance != this){ Destroy(gameObject); }  ",
          "content_tokens": 43,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkHudCanvases",
          "content": "private void Start() { #if !ENABLE_INPUT_SYSTEM SetEventSystem(); BaseInputModule inputModule = FindObjectOfType<BaseInputModule>(); if (inputModule == null) gameObject.AddComponent<StandaloneInputModule>(); #else _serverIndicator.transform.parent.gameObject.SetActive(false); _clientIndicator.transform.parent.gameObject.SetActive(false); #endif _networkManager = FindObjectOfType<NetworkManager>(); #if UNITY_SERVER || UNITY_STANDALONE_LINUX _networkManager.Init(); OnClick_Server(); #else if (_autoStartType == AutoStartType.Host || _autoStartType == AutoStartType.Server) { _networkManager.Init(); OnClick_Server();  ",
          "content_tokens": 175,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkHudCanvases",
          "content": "if (!Application.isBatchMode && (_autoStartType == AutoStartType.Host || _autoStartType == AutoStartType.Client)) { OnClick_Client(); } #endif  ",
          "content_tokens": 42,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkHudCanvases",
          "content": "private void OnDestroy() { if (_networkManager == null) return; _networkManager.ServerManager.OnServerConnectionState -= ServerManager_OnServerConnectionState; _networkManager.ClientManager.OnClientConnectionState -= ClientManager_OnClientConnectionState; } /// <summary> /// Updates img color baased on state. /// </summary> /// <param name=\"state\"></param> /// <param name=\"img\"></param> private void UpdateColor(LocalConnectionState state, ref Image img) { Color c; if (state == LocalConnectionState.Started){ c = _startedColor; if (IsAutoStartServer) OnServerStarted?.Invoke(); else { Debug.Log($\"[NetworkHudCanvases] UpdateColor: OnClientConnectedToServer\"); OnClientConnectedToServer?.Invoke(); } }else if (state == LocalConnectionState.Stopping) { ushort port = _networkManager.TransportManager.Transport.GetPort(); port++; _networkManager.TransportManager.Transport.SetPort(port); } else if (state == LocalConnectionState.Stopped) { c = _stoppedColor; OnDisconnectedFromServer?.Invoke(); } else c = _changingColor; //img.Color = c;  ",
          "content_tokens": 277,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkHudCanvases",
          "content": "private void ClientManager_OnClientConnectionState(ClientConnectionStateArgs obj) { _clientState = obj.ConnectionState; UpdateColor(obj.ConnectionState, ref _clientIndicator);  private void ServerManager_OnServerConnectionState(ServerConnectionStateArgs obj) { _serverState = obj.ConnectionState; UpdateColor(obj.ConnectionState, ref _serverIndicator);  public void OnClick_Server() { Debug.Log($\"[NetworkHudCanvases] OnClick_Server\"); if (_networkManager == null) return; _networkManager.ServerManager.OnServerConnectionState += CustomServerManager.Instance.OnServerConnectionState; if (_serverState != LocalConnectionState.Stopped) _networkManager.ServerManager.StopConnection(true); else _networkManager.ServerManager.StartConnection(); DeselectButtons();  ",
          "content_tokens": 182,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkHudCanvases",
          "content": "public void OnClick_Client() { Debug.Log($\"[NetworkHudCanvases] OnClick_Client\"); if (_networkManager == null) return; if (_clientState != LocalConnectionState.Stopped) _networkManager.ClientManager.StopConnection(); else { Debug.Log($\"[NetworkHudCanvases] StartConnection...\"); _networkManager.ClientManager.StartConnection();  DeselectButtons();  private void SetEventSystem() { #if !ENABLE_INPUT_SYSTEM if (_eventSystem != null) return; _eventSystem = FindObjectOfType<EventSystem>(); if (_eventSystem == null) _eventSystem = gameObject.AddComponent<EventSystem>(); #endif  private void DeselectButtons() { #if !ENABLE_INPUT_SYSTEM SetEventSystem(); _eventSystem?.SetSelectedGameObject(null); #endif } } }",
          "content_tokens": 198,
          "embedding": []
        }
      ],
      "length": 7238
    },
    {
      "filename": "PlayerSpawner",
      "content": " using FishNet.Connection; using FishNet.Managing; using FishNet.Object; using System; using System.Collections; using UnityEngine; using UnityEngine.Serialization; namespace DDCore { /// <summary> /// Spawns a player object for clients when they connect. /// Must be placed on or beneath the NetworkManager object. /// </summary> [AddComponentMenu(\"DDCore/Component/PlayerSpawner\")] public class PlayerSpawner : MonoBehaviour { #region Public. /// <summary> /// Called on the server when a player is spawned. /// </summary> public event Action<NetworkObject> OnSpawned; #endregion #region Serialized. /// <summary> /// Prefab to spawn for the player. /// </summary> [Tooltip(\"Prefab to spawn for the player.\")] [SerializeField] private NetworkObject clientInstancePrefab; /// <summary> /// True to add player to the active scene when no global scenes are specified through the SceneManager. /// </summary> [Tooltip(\"True to add player to the active scene when no global scenes are specified through the SceneManager.\")] [SerializeField] private bool _addToDefaultScene = true; /// <summary> /// Areas in which players may spawn. /// </summary> [Tooltip(\"Areas in which players may spawn.\")] [FormerlySerializedAs(\"_spawns\")]//Remove on 2024/01/01 public Transform[] Spawns = new Transform[0]; #endregion #region Private. /// <summary> /// NetworkManager on this object or within this objects parents. /// </summary> private NetworkManager _networkManager; /// <summary> /// Next spawns to use. /// </summary> private int _nextSpawn; #endregion private IEnumerator Start() { _networkManager = FindObjectOfType<NetworkManager>(); yield return new WaitUntil(()=>_networkManager.Initialized); _networkManager.SceneManager.OnClientLoadedStartScenes += SceneManager_OnClientLoadedStartScenes; } private void OnDestroy() { if (_networkManager != null) _networkManager.SceneManager.OnClientLoadedStartScenes -= SceneManager_OnClientLoadedStartScenes; } /// <summary> /// Called when a client loads initial scenes after connecting. /// </summary> private void SceneManager_OnClientLoadedStartScenes(NetworkConnection conn, bool asServer) { if (!asServer) return; if (clientInstancePrefab == null) { Debug.LogWarning($\"Player prefab is empty and cannot be spawned for connection {conn.ClientId}.\"); return; } Vector3 position; Quaternion rotation; SetSpawn(clientInstancePrefab.transform, out position, out rotation); NetworkObject playerNob = _networkManager.GetPooledInstantiated(clientInstancePrefab, position, rotation, true); _networkManager.ServerManager.Spawn(playerNob, conn); //If there are no global scenes if (_addToDefaultScene) _networkManager.SceneManager.AddOwnerToDefaultScene(playerNob); OnSpawned?.Invoke(playerNob); } /// <summary> /// Sets a spawn position and rotation. /// </summary> /// <param name=\"pos\"></param> /// <param name=\"rot\"></param> private void SetSpawn(Transform prefab, out Vector3 pos, out Quaternion rot) { //No spawns specified. if (Spawns.Length == 0) { SetSpawnUsingPrefab(prefab, out pos, out rot); return; } Transform result = Spawns[_nextSpawn]; if (result == null) { SetSpawnUsingPrefab(prefab, out pos, out rot); } else { pos = result.position; rot = result.rotation; } //Increase next spawn and reset if needed. _nextSpawn++; if (_nextSpawn >= Spawns.Length) _nextSpawn = 0; } /// <summary> /// Sets spawn using values from prefab. /// </summary> /// <param name=\"prefab\"></param> /// <param name=\"pos\"></param> /// <param name=\"rot\"></param> private void SetSpawnUsingPrefab(Transform prefab, out Vector3 pos, out Quaternion rot) { pos = prefab.position; rot = prefab.rotation; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "PlayerSpawner",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "PlayerSpawner",
          "content": " using FishNet.Connection; using FishNet.Managing; using FishNet.Object; using System; using System.Collections; using UnityEngine; using UnityEngine.Serialization; namespace DDCore { /// <summary> /// Spawns a player object for clients when they connect. /// Must be placed on or beneath the NetworkManager object. /// </summary> [AddComponentMenu(\"DDCore/Component/PlayerSpawner\")] public class PlayerSpawner : MonoBehaviour { #region Public. /// <summary> /// Called on the server when a player is spawned. /// </summary> public event Action<NetworkObject> OnSpawned; #endregion #region Serialized. /// <summary> /// Prefab to spawn for the player. /// </summary> [Tooltip(\"Prefab to spawn for the player.\")] [SerializeField] private NetworkObject clientInstancePrefab; /// <summary> /// True to add player to the active scene when no global scenes are specified through the SceneManager. /// </summary> [Tooltip(\"True to add player to the active scene when no global scenes are specified through the SceneManager.\")] [SerializeField] private bool _addToDefaultScene = true; /// <summary> /// Areas in which players may spawn. /// </summary> [Tooltip(\"Areas in which players may spawn.\")] [FormerlySerializedAs(\"_spawns\")]//Remove on 2024/01/01 public Transform[] Spawns = new Transform[0]; #endregion #region Private. /// <summary> /// NetworkManager on this object or within this objects parents. /// </summary> private NetworkManager _networkManager; /// <summary> /// Next spawns to use. /// </summary> private int _nextSpawn; #endregion private IEnumerator Start() { _networkManager = FindObjectOfType<NetworkManager>(); yield return new WaitUntil(()=>_networkManager.Initialized); _networkManager.SceneManager.OnClientLoadedStartScenes += SceneManager_OnClientLoadedStartScenes;  ",
          "content_tokens": 434,
          "embedding": []
        },
        {
          "cs_scriptfile": "PlayerSpawner",
          "content": "private void OnDestroy() { if (_networkManager != null) _networkManager.SceneManager.OnClientLoadedStartScenes -= SceneManager_OnClientLoadedStartScenes; } /// <summary> /// Called when a client loads initial scenes after connecting. /// </summary> private void SceneManager_OnClientLoadedStartScenes(NetworkConnection conn, bool asServer) { if (!asServer) return; if (clientInstancePrefab == null) { Debug.LogWarning($\"Player prefab is empty and cannot be spawned for connection {conn.ClientId}.\"); return; } Vector3 position; Quaternion rotation; SetSpawn(clientInstancePrefab.transform, out position, out rotation); NetworkObject playerNob = _networkManager.GetPooledInstantiated(clientInstancePrefab, position, rotation, true); _networkManager.ServerManager.Spawn(playerNob, conn); //If there are no global scenes if (_addToDefaultScene) _networkManager.SceneManager.AddOwnerToDefaultScene(playerNob); OnSpawned?.Invoke(playerNob); } /// <summary> /// Sets a spawn position and rotation. /// </summary> /// <param name=\"pos\"></param> /// <param name=\"rot\"></param> private void SetSpawn(Transform prefab, out Vector3 pos, out Quaternion rot) { //No spawns specified. if (Spawns.Length == 0) { SetSpawnUsingPrefab(prefab, out pos, out rot); return; } Transform result = Spawns[_nextSpawn]; if (result == null) { SetSpawnUsingPrefab(prefab, out pos, out rot); } else { pos = result.position; rot = result.rotation; } //Increase next spawn and reset if needed. _nextSpawn++; if (_nextSpawn >= Spawns.Length) _nextSpawn = 0; } /// <summary> /// Sets spawn using values from prefab. /// </summary> /// <param name=\"prefab\"></param> /// <param name=\"pos\"></param> /// <param name=\"rot\"></param> private void SetSpawnUsingPrefab(Transform prefab, out Vector3 pos, out Quaternion rot) { pos = prefab.position; rot = prefab.rotation; } } }",
          "content_tokens": 486,
          "embedding": []
        }
      ],
      "length": 3624
    },
    {
      "filename": "RoomCollapsingTimerEditor",
      "content": "using UnityEngine; using UnityEditor; [CustomEditor(typeof(RoomCollapsingTimer))] public class RoomCollapsingTimerEditor : Editor { public override void OnInspectorGUI() { base.OnInspectorGUI(); RoomCollapsingTimer roomCollapsingTimer = (RoomCollapsingTimer)target; EditorGUILayout.Space(); if (GUILayout.Button(\"Activate Lava\")) { roomCollapsingTimer.ActivateLava(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RoomCollapsingTimerEditor",
          "content": "using UnityEngine; using UnityEditor; [CustomEditor(typeof(RoomCollapsingTimer))] public class RoomCollapsingTimerEditor : Editor { public override void OnInspectorGUI() { base.OnInspectorGUI(); RoomCollapsingTimer roomCollapsingTimer = (RoomCollapsingTimer)target; EditorGUILayout.Space(); if (GUILayout.Button(\"Activate Lava\")) { roomCollapsingTimer.ActivateLava(); } } }",
          "content_tokens": 108,
          "embedding": []
        }
      ],
      "length": 373
    },
    {
      "filename": "GameplayManagerBossBattle",
      "content": "using System; using System.Collections; using System.Collections.Generic; using System.Linq; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using FishNet; using FishNet.Connection; using FishNet.Object; using Invector; using UnityEngine; namespace FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill { public class GameplayManagerBossBattle : GameplayManager { public static GameplayManagerBossBattle GetInstance => Instance as GameplayManagerBossBattle; private readonly int MAX_ALIVE_ENEMIES_PER_PLAYER = 10; [SerializeField] private Wave[] waves; [SerializeField] private EnemyDefinition[] bosses; private List<EnemyDefinition> _usedBosses = new (); public GameTimer SurvivalGameTimer { get; private set; } = new (); [SerializeField] private Transform[] spawnPoints; [SerializeField] private Transform[] playerArenaSpawnPoints; [SerializeField] private Transform[] playerSafeZoneSpawnPoints; public override void OnStartServer() { base.OnStartServer(); if (isTeamsMode) RoomDetails.SetIsTeamsMode(true); //StartCoroutine(InitServer()); InstanceFinder.ServerManager.OnRemoteConnectionState += UpdateRoomInfoIfPlayerLeft; RoomDetails.OnRoomDetailsUpdated += RoomDetails_OnRoomDetailsUpdated; } protected override void Update() { base.Update(); if (SurvivalGameTimer.IsStarted && !SurvivalGameTimer.IsPaused && !SurvivalGameTimer.IsFinished) { SurvivalGameTimer.SetTime(SurvivalGameTimer.Time + Time.deltaTime); } } protected override IEnumerator InitServer() { var startTime = Time.time; string color = String.Empty; string endColor = String.Empty; #if UNITY_EDITOR color = COLOR_INITIALIZATION; endColor = \"</color>\"; #endif //TODO: Create Scriptable Objects, dungeons generator saver // uint seed = 903244736; // var time = new WaitForSeconds(1f); // //Because ParrelSync can't load addressables // #if UNITY_EDITOR // if (IsLoadDungeonFromSave && !ClonesManager.IsClone()) { // #else // if (IsLoadDungeonFromSave) { // #endif // _dungeonNetworkManager.SetSeed(seed); // Debug.Log($\"{color}===========[{RoomDetails.Name}]...New seed: {seed}. Waiting until IsDungeonSpawned...==========={endColor}\", _dungeonNetworkManager); // yield return new WaitUntil(()=> _dungeonNetworkManager.IsDungeonSpawned); // } // else { // CreateSeedAndStartBuildingDungeon(seed); // yield return new WaitUntil(()=> _dungeonListener.IsDungeonBuilt); // yield return time; // yield return time; // } // Debug.Log($\"{color}===========[{RoomDetails.Name}]...Storing Spawn Points...==========={endColor}\"); // InitPlayerSpawnPoints(); // Debug.Log($\"{color}===========[{RoomDetails.Name}]...!Storing Spawn Points finished!...==========={endColor}\"); Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting Spawning Networked objects...==========={endColor}\"); yield return new WaitUntil(()=>_objectsManager.enabled); _objectsManager.SpawnObjects(); yield return new WaitUntil(()=>_objectsManager.IsObjectsSpawned); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Spawnning Networked objects finished!==========={endColor}\"); if (!IsHost) { Debug.Log($\"{color}===========...[{RoomDetails.Name}] Starting removing lights...==========={endColor}\"); _optimizeServerFromComponents.RemoveGameObjectsNotNeededForServer(); _optimizeServerFromComponents.OptimizeLights(); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Removing lights finished!==========={endColor}\"); } // Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting NavMesh build...==========={endColor}\"); // #if UNITY_EDITOR // if (IsLoadDungeonFromSave && !ClonesManager.IsClone()) { // #else // if (IsLoadDungeonFromSave) { // #endif // string addressableDungeonAStar = $\"Assets/-ZombieRoyale/SavedDungeons/{seed}/graph-{seed}.bytes\"; // Addressables.LoadAssetAsync<TextAsset>(addressableDungeonAStar).Completed += OnAstarPathLoaded; // } // else { // AstarPath.Scan(); // new WaitUntil(()=>!AstarPath.isScanning); // } // Debug.Log($\"{color}===========[{RoomDetails.Name}]!NavMesh builded!==========={endColor}\"); //yield return time; Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting populating spawn points with monsters...==========={endColor}\"); _respawnManager.PopulatePortalPoints(); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Populating spawn points finished!==========={endColor}\"); Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting Abilities Initialization...==========={endColor}\"); _abilityManager.Init(true); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Abilities initialization finished!==========={endColor}\"); //yield return time; Debug.Log($\"{color}===========[{RoomDetails.Name}]...Order clients to remove monster spawn points...==========={endColor}\"); //SpawnPlayersThatLoadedDungeon(); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Spawnning Players finished!==========={endColor}\"); //NotifyAllPlayersRoomStartTime(); _respawnManager.InitIfAllRequirementsMet(); OnRoomReady?.Invoke(); _serverPlayerManager.InitServer(); var elapsedTime = Time.time - startTime; Debug.Log($\"{color}===========[{RoomDetails.Name}]!Room initialization finished! Elapsed time: {elapsedTime}==========={endColor}\"); StartCoroutine(DelayedSpawnEscapePortalsAfterTime(15 * 60)); } protected override IEnumerator InitClient() { string color = String.Empty; string endColor = String.Empty; #if UNITY_EDITOR color = COLOR_INITIALIZATION; endColor = \"</color>\"; #endif //UnitySceneManager.SetActiveScene(UnitySceneManager.GetSceneByName(ClientSceneHandler.ROOM_SCENE_NAME)); var time = new WaitForSeconds(.5f); RegistrationController.Instance.SwitchMainMenuElements(false); if (!IsHost){ Destroy(_rvoSimulator); // #if UNITY_EDITOR // if (IsLoadDungeonFromSave && !ClonesManager.IsClone()) { // #else // if (IsLoadDungeonFromSave) { // #endif // yield return new WaitUntil(()=> _dungeonNetworkManager.IsDungeonSpawned); // } // else { // yield return new WaitUntil(()=> _dungeonListener.IsDungeonBuilt); // } Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting removing non network GOs...==========={endColor}\"); _objectsManager.RemoveNonNetworkedObjectsClient(); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Removing non network GOs finished!==========={endColor}\"); yield return new WaitUntil(()=> _objectsManager.IsNonNetworkedObjectsRemoved); Debug.Log($\"{color}===========[{RoomDetails.Name}]...Waiting for RoomLODController...==========={endColor}\"); } yield return new WaitUntil(()=> RoomLODController.Instance != null); RoomLODController.Instance.InitForClient(); if (!IsHost) { Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting Abilities Initialization...==========={endColor}\"); _abilityManager.Init(false); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Abilities initialization finished!==========={endColor}\"); } OnClientLoadedGameplayManager?.Invoke(); if (!IsHost) { yield return new WaitForSeconds(3f); Debug.Log( $\"{color}===========[{RoomDetails.Name}]...Removing monster spawn points...==========={endColor}\"); _respawnManager.RemoveMonsterSpawnPoints(); _respawnManager.RemovePortalSpawnPoints(); } CmdClientLoadedGameSceneNotifier(); //SceneManager.SetActiveScene(UnitySceneManager.GetSceneByName(ROOM_SCENE_NAME)); yield return time; } public override Vector3 GetAvailableSpawnPosition(NetworkConnection conn) { if (RoomDetails.IsTeamsMode) { int teamId; foreach (RoomDetails.Team team in RoomDetails.Teams) { for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i].Owner == conn) { teamId = RoomDetails.Teams.IndexOf(team); DebugWrite.Log($\"{ClassAndRoomName} Found in team #{teamId} for client #{conn.ClientId}\", gameObject, _isDebug); Transform randomSpawnPointInSafeZone = playerSafeZoneSpawnPoints[UnityEngine.Random.Range(0, playerSafeZoneSpawnPoints.Length)]; return randomSpawnPointInSafeZone.position; } } } DebugWrite.LogError($\"{ClassAndRoomName} Could not find team for client #{conn.ClientId}\", gameObject, _isDebug); } Vector3 spawnPosition = SpawnPointsForPlayers.FirstOrDefault(); _spawnPointsForPlayers.Remove(spawnPosition); Debug.Log($\"{ClassAndRoomName} Removed spawn point {spawnPosition} from spawn points list. {SpawnPointsForPlayers.Count} left.\"); return spawnPosition; } private List<NetworkObject> _startCallers = new (); [ServerRpc(RequireOwnership = false)] public void AddStartCaller(NetworkObject playerNob) { _startCallers.Add(playerNob); StartGameIfAllReady(); } public void RemoveStartCaller(NetworkObject playerNob) { _startCallers.Remove(playerNob); } [Server] private void StartGameIfAllReady() { if (_startCallers.Count == RoomDetails.MemberIds.Count) { StartGame(); } } [Server] private void StartGame() { NotifyAllPlayersRoomStartTime(); StartCoroutine(WaveSpawner()); MovePlayersToArena(); } private void MovePlayersToArena() { foreach (var playerHero in RoomDetails.PlayerCharacters) { UnitComponents playerUnit = GetUnitComponents(playerHero); Vector3 spawnPosition = playerArenaSpawnPoints[UnityEngine.Random.Range(0, playerArenaSpawnPoints.Length)].position; playerUnit.InvectorManager.TeleportPlayerDecorator(playerHero.Owner, spawnPosition); } } [Server] private IEnumerator WaveSpawner() { var time = new WaitForSeconds(1f); var delayBetweenWaves = new WaitForSeconds(10f); int currentWave = 0; while (true) { yield return time; if (SurvivalGameTimer.IsFinished) yield return time; if (SurvivalGameTimer.IsPaused) yield return time; if (!waves[currentWave].IsMonstersCleared) { int howManyMonstersShouldBe = MAX_ALIVE_ENEMIES_PER_PLAYER * RoomDetails.MemberIds.Count; int delta = howManyMonstersShouldBe - waves[currentWave].MonstersAliveCount; StartCoroutine(SpawnWave(currentWave, delta)); } else if (!waves[currentWave].IsBossesCleared) { SpawnBoss(currentWave); } else { currentWave++; if (currentWave >= waves.Length) { SurvivalGameTimer.IsFinished = true; yield break; } _creaturesFactory.ClearAllDeadBodies(); yield return delayBetweenWaves; } } } private IEnumerator SpawnWave(int currentWave, int amount) { for (int i = 0; i < amount; i++) { int randomIndex = UnityEngine.Random.Range(0, waves[currentWave].Enemies.Length); EnemyDefinition enemy = waves[currentWave].Enemies[randomIndex]; Transform randomSpawnPoint = spawnPoints[UnityEngine.Random.Range(0, spawnPoints.Length)]; var creature = _respawnManager.SpawnCreatureAtPoint(randomSpawnPoint.position, enemy.Id); creature.Controller.HealthController.OnDead += (damage) => CountDeadMonster(damage, currentWave, false); waves[currentWave].AddMonsterAliveCount(); yield return null; } } private void CountDeadMonster(vDamage damage, int currentWave, bool isBoss) { if (isBoss) waves[currentWave].AddBossDeadCount(); else waves[currentWave].AddMonsterDeadCount(); } private void SpawnBoss(int currentWave) { for (int i = 0; i < bosses.Length; i++) { Transform randomSpawnPoint = spawnPoints[UnityEngine.Random.Range(0, spawnPoints.Length)]; EnemyDefinition boss = GetUnusedBoss(); var creature = _creaturesFactory.AllocateCreature(boss.Id, randomSpawnPoint.position, this); creature.Controller.HealthController.OnDead += (damage) => CountDeadMonster(damage, currentWave, true); _usedBosses.Add(bosses[i]); waves[currentWave].AddBossAliveCount(); } } private EnemyDefinition GetUnusedBoss() { for (int i = 0; i < bosses.Length; i++) { if (!_usedBosses.Contains(bosses[i])) { return bosses[i]; } } return null; } public override void DropLootBag(AIUnit aiUnit) { // float chanceMod = aiUnit.EnemyDefinition.LootBagChanceMod; // CratesSystem.Zone zone = aiUnit.EnemyDefinition.LootBagZone; // int itemsCount = aiUnit.EnemyDefinition.LootBagItemsCount; // List<ItemReference> items = _lootDropSystem.GenerateLoot(aiUnit.EnemyDefinition.ItemsDropChances, aiUnit.EnemyDefinition.LootBagItemsCount, aiUnit.EnemyDefinition.LootBagChanceMod); // _lootDropSystem.AddGoldDrop(aiUnit.EnemyDefinition.GoldDropChance, aiUnit.EnemyDefinition.MinGoldDrop, aiUnit.EnemyDefinition.MaxGoldDrop, ref items); // //generate random pos in circle around unit with radius 1 // var randomPosInCircleWorld = Unit.GetRandomPosInCircleShapeAround(aiUnit.transform.position, 1f); // _lootDropSystem.DropLootBag(items, randomPosInCircleWorld, chanceMod, zone, itemsCount); } [ObserversRpc] private void NotifyAllPlayersRoomStartTime() { SurvivalGameTimer.IsStarted = true; } [Serializable] public struct MonstersPerWave { public int WaveId; public EnemyDefinition[] Enemies; } public class GameTimer { public float Time; public bool IsStarted; public bool IsPaused; public bool IsFinished; public Action<float> OnTimeChanged; public void SetTime(float time) { Time = time; OnTimeChanged?.Invoke(Time); } } [Serializable] public class Wave { public int Id; public int TotalMonstersToKillCount; public int MonstersAliveCount; private int MonstersDeadCount; public int TotalBossesToKillCount; private int BossesAliveCount; private int BossesDeadCount; public EnemyDefinition[] Enemies; public bool IsMonstersCleared { get; private set; } public bool IsBossesCleared { get; private set; } public void AddMonsterAliveCount() { MonstersAliveCount++; } public void AddBossAliveCount() { BossesAliveCount++; } public void AddMonsterDeadCount() { MonstersDeadCount++; MonstersAliveCount--; if (MonstersDeadCount >= TotalMonstersToKillCount) IsMonstersCleared = true; } public void AddBossDeadCount() { BossesDeadCount++; BossesAliveCount--; if (BossesDeadCount >= TotalBossesToKillCount) IsBossesCleared = true; } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "GameplayManagerBossBattle",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManagerBossBattle",
          "content": "using System; using System.Collections; using System.Collections.Generic; using System.Linq; using _ZombieRoyale.Scripts.Core; using DungeonScrollerCore; using FirstGearGames.LobbyAndWorld.Lobbies.JoinCreateRoomCanvases; using FishNet; using FishNet.Connection; using FishNet.Object; using Invector; using UnityEngine; namespace FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill { public class GameplayManagerBossBattle : GameplayManager { public static GameplayManagerBossBattle GetInstance => Instance as GameplayManagerBossBattle; private readonly int MAX_ALIVE_ENEMIES_PER_PLAYER = 10; [SerializeField] private Wave[] waves; [SerializeField] private EnemyDefinition[] bosses; private List<EnemyDefinition> _usedBosses = new (); public GameTimer SurvivalGameTimer { get; private set; } = new (); [SerializeField] private Transform[] spawnPoints; [SerializeField] private Transform[] playerArenaSpawnPoints; [SerializeField] private Transform[] playerSafeZoneSpawnPoints; public override void OnStartServer() { base.OnStartServer(); if (isTeamsMode) RoomDetails.SetIsTeamsMode(true); //StartCoroutine(InitServer()); InstanceFinder.ServerManager.OnRemoteConnectionState += UpdateRoomInfoIfPlayerLeft; RoomDetails.OnRoomDetailsUpdated += RoomDetails_OnRoomDetailsUpdated; } protected override void Update() { base.Update(); if (SurvivalGameTimer.IsStarted && !SurvivalGameTimer.IsPaused && !SurvivalGameTimer.IsFinished) { SurvivalGameTimer.SetTime(SurvivalGameTimer.Time + Time.deltaTime); } } protected override IEnumerator InitServer() { var startTime = Time.time; string color = String.Empty; string endColor = String.Empty; #if UNITY_EDITOR color = COLOR_INITIALIZATION; endColor = \"</color>\"; #endif //TODO: Create Scriptable Objects, dungeons generator saver // uint seed = 903244736; // var time = new WaitForSeconds(1f); // //Because ParrelSync can't load addressables // #if UNITY_EDITOR // if (IsLoadDungeonFromSave && !ClonesManager.IsClone()) { // #else // if (IsLoadDungeonFromSave) { // #endif // _dungeonNetworkManager.SetSeed(seed); // Debug.Log($\"{color}===========[{RoomDetails.Name}]...New seed: {seed}. Waiting until IsDungeonSpawned...==========={endColor}\", _dungeonNetworkManager); // yield return new WaitUntil(()=> _dungeonNetworkManager.IsDungeonSpawned); // } // else { // CreateSeedAndStartBuildingDungeon(seed); // yield return new WaitUntil(()=> _dungeonListener.IsDungeonBuilt); // yield return time; // yield return time; // } // Debug.Log($\"{color}===========[{RoomDetails.Name}]...Storing Spawn Points...==========={endColor}\"); // InitPlayerSpawnPoints(); // Debug.Log($\"{color}===========[{RoomDetails.Name}]...!Storing Spawn Points finished!...==========={endColor}\"); Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting Spawning Networked objects...==========={endColor}\"); yield return new WaitUntil(()=>_objectsManager.enabled); _objectsManager.SpawnObjects(); yield return new WaitUntil(()=>_objectsManager.IsObjectsSpawned); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Spawnning Networked objects finished!==========={endColor}\"); if (!IsHost) { Debug.Log($\"{color}===========...[{RoomDetails.Name}] Starting removing lights...==========={endColor}\"); _optimizeServerFromComponents.RemoveGameObjectsNotNeededForServer(); _optimizeServerFromComponents.OptimizeLights(); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Removing lights finished!==========={endColor}\"); } // Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting NavMesh build...==========={endColor}\"); // #if UNITY_EDITOR // if (IsLoadDungeonFromSave && !ClonesManager.IsClone()) { // #else // if (IsLoadDungeonFromSave) { // #endif // string addressableDungeonAStar = $\"Assets/-ZombieRoyale/SavedDungeons/{seed}/graph-{seed}.bytes\"; // Addressables.LoadAssetAsync<TextAsset>(addressableDungeonAStar).Completed += OnAstarPathLoaded; // } // else { // AstarPath.Scan(); // new WaitUntil(()=>!AstarPath.isScanning); // } // Debug.Log($\"{color}===========[{RoomDetails.Name}]!NavMesh builded!==========={endColor}\"); //yield return time; Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting populating spawn points with monsters...==========={endColor}\"); _respawnManager.PopulatePortalPoints(); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Populating spawn points finished!==========={endColor}\"); Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting Abilities Initialization...==========={endColor}\"); _abilityManager.Init(true); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Abilities initialization finished!==========={endColor}\"); //yield return time; Debug.Log($\"{color}===========[{RoomDetails.Name}]...Order clients to remove monster spawn points...==========={endColor}\"); //SpawnPlayersThatLoadedDungeon(); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Spawnning Players finished!==========={endColor}\"); //NotifyAllPlayersRoomStartTime(); _respawnManager.InitIfAllRequirementsMet(); OnRoomReady?.Invoke(); _serverPlayerManager.InitServer(); var elapsedTime = Time.time - startTime; Debug.Log($\"{color}===========[{RoomDetails.Name}]!Room initialization finished! Elapsed time: {elapsedTime}==========={endColor}\"); StartCoroutine(DelayedSpawnEscapePortalsAfterTime(15 * 60)); } protected override IEnumerator InitClient() { string color = String.Empty; string endColor = String.Empty; #if UNITY_EDITOR color = COLOR_INITIALIZATION; endColor = \"</color>\"; #endif //UnitySceneManager.SetActiveScene(UnitySceneManager.GetSceneByName(ClientSceneHandler.ROOM_SCENE_NAME)); var time = new WaitForSeconds(.5f); RegistrationController.Instance.SwitchMainMenuElements(false); if (!IsHost){ Destroy(_rvoSimulator); // #if UNITY_EDITOR // if (IsLoadDungeonFromSave && !ClonesManager.IsClone()) { // #else // if (IsLoadDungeonFromSave) { // #endif // yield return new WaitUntil(()=> _dungeonNetworkManager.IsDungeonSpawned); // } // else { // yield return new WaitUntil(()=> _dungeonListener.IsDungeonBuilt); // } Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting removing non network GOs...==========={endColor}\"); _objectsManager.RemoveNonNetworkedObjectsClient(); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Removing non network GOs finished!==========={endColor}\"); yield return new WaitUntil(()=> _objectsManager.IsNonNetworkedObjectsRemoved); Debug.Log($\"{color}===========[{RoomDetails.Name}]...Waiting for RoomLODController...==========={endColor}\"); } yield return new WaitUntil(()=> RoomLODController.Instance != null); RoomLODController.Instance.InitForClient(); if (!IsHost) { Debug.Log($\"{color}===========[{RoomDetails.Name}]...Starting Abilities Initialization...==========={endColor}\"); _abilityManager.Init(false); Debug.Log($\"{color}===========[{RoomDetails.Name}]!Abilities initialization finished!==========={endColor}\"); } OnClientLoadedGameplayManager?.Invoke(); if (!IsHost) { yield return new WaitForSeconds(3f); Debug.Log( $\"{color}===========[{RoomDetails.Name}]...Removing monster spawn points...==========={endColor}\"); _respawnManager.RemoveMonsterSpawnPoints(); _respawnManager.RemovePortalSpawnPoints();  ",
          "content_tokens": 2024,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManagerBossBattle",
          "content": "CmdClientLoadedGameSceneNotifier(); //SceneManager.SetActiveScene(UnitySceneManager.GetSceneByName(ROOM_SCENE_NAME)); yield return time; } public override Vector3 GetAvailableSpawnPosition(NetworkConnection conn) { if (RoomDetails.IsTeamsMode) { int teamId; foreach (RoomDetails.Team team in RoomDetails.Teams) { for (int i = 0; i < team.Slots.Length; i++) { if (team.Slots[i].Owner == conn) { teamId = RoomDetails.Teams.IndexOf(team); DebugWrite.Log($\"{ClassAndRoomName} Found in team #{teamId} for client #{conn.ClientId}\", gameObject, _isDebug); Transform randomSpawnPointInSafeZone = playerSafeZoneSpawnPoints[UnityEngine.Random.Range(0, playerSafeZoneSpawnPoints.Length)]; return randomSpawnPointInSafeZone.position; } } } DebugWrite.LogError($\"{ClassAndRoomName} Could not find team for client #{conn.ClientId}\", gameObject, _isDebug); } Vector3 spawnPosition = SpawnPointsForPlayers.FirstOrDefault(); _spawnPointsForPlayers.Remove(spawnPosition); Debug.Log($\"{ClassAndRoomName} Removed spawn point {spawnPosition} from spawn points list. {SpawnPointsForPlayers.Count} left.\"); return spawnPosition; } private List<NetworkObject> _startCallers = new (); [ServerRpc(RequireOwnership = false)] public void AddStartCaller(NetworkObject playerNob) { _startCallers.Add(playerNob); StartGameIfAllReady();  ",
          "content_tokens": 368,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManagerBossBattle",
          "content": "public void RemoveStartCaller(NetworkObject playerNob) { _startCallers.Remove(playerNob); } [Server] private void StartGameIfAllReady() { if (_startCallers.Count == RoomDetails.MemberIds.Count) { StartGame(); } } [Server] private void StartGame() { NotifyAllPlayersRoomStartTime(); StartCoroutine(WaveSpawner()); MovePlayersToArena();  ",
          "content_tokens": 92,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManagerBossBattle",
          "content": "private void MovePlayersToArena() { foreach (var playerHero in RoomDetails.PlayerCharacters) { UnitComponents playerUnit = GetUnitComponents(playerHero); Vector3 spawnPosition = playerArenaSpawnPoints[UnityEngine.Random.Range(0, playerArenaSpawnPoints.Length)].position; playerUnit.InvectorManager.TeleportPlayerDecorator(playerHero.Owner, spawnPosition); } } [Server] private IEnumerator WaveSpawner() { var time = new WaitForSeconds(1f); var delayBetweenWaves = new WaitForSeconds(10f); int currentWave = 0; while (true) { yield return time; if (SurvivalGameTimer.IsFinished) yield return time; if (SurvivalGameTimer.IsPaused) yield return time; if (!waves[currentWave].IsMonstersCleared) { int howManyMonstersShouldBe = MAX_ALIVE_ENEMIES_PER_PLAYER * RoomDetails.MemberIds.Count; int delta = howManyMonstersShouldBe - waves[currentWave].MonstersAliveCount; StartCoroutine(SpawnWave(currentWave, delta)); } else if (!waves[currentWave].IsBossesCleared) { SpawnBoss(currentWave); } else { currentWave++; if (currentWave >= waves.Length) { SurvivalGameTimer.IsFinished = true; yield break; } _creaturesFactory.ClearAllDeadBodies(); yield return delayBetweenWaves; } } } private IEnumerator SpawnWave(int currentWave, int amount) { for (int i = 0; i < amount; i++) { int randomIndex = UnityEngine.Random.Range(0, waves[currentWave].Enemies.Length); EnemyDefinition enemy = waves[currentWave].Enemies[randomIndex]; Transform randomSpawnPoint = spawnPoints[UnityEngine.Random.Range(0, spawnPoints.Length)]; var creature = _respawnManager.SpawnCreatureAtPoint(randomSpawnPoint.position, enemy.Id); creature.Controller.HealthController.OnDead += (damage) => CountDeadMonster(damage, currentWave, false); waves[currentWave].AddMonsterAliveCount(); yield return null; }  ",
          "content_tokens": 485,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManagerBossBattle",
          "content": "private void CountDeadMonster(vDamage damage, int currentWave, bool isBoss) { if (isBoss) waves[currentWave].AddBossDeadCount(); else waves[currentWave].AddMonsterDeadCount();  ",
          "content_tokens": 47,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManagerBossBattle",
          "content": "private void SpawnBoss(int currentWave) { for (int i = 0; i < bosses.Length; i++) { Transform randomSpawnPoint = spawnPoints[UnityEngine.Random.Range(0, spawnPoints.Length)]; EnemyDefinition boss = GetUnusedBoss(); var creature = _creaturesFactory.AllocateCreature(boss.Id, randomSpawnPoint.position, this); creature.Controller.HealthController.OnDead += (damage) => CountDeadMonster(damage, currentWave, true); _usedBosses.Add(bosses[i]); waves[currentWave].AddBossAliveCount(); } } private EnemyDefinition GetUnusedBoss() { for (int i = 0; i < bosses.Length; i++) { if (!_usedBosses.Contains(bosses[i])) { return bosses[i]; } } return null; } public override void DropLootBag(AIUnit aiUnit) { // float chanceMod = aiUnit.EnemyDefinition.LootBagChanceMod; // CratesSystem.Zone zone = aiUnit.EnemyDefinition.LootBagZone; // int itemsCount = aiUnit.EnemyDefinition.LootBagItemsCount; // List<ItemReference> items = _lootDropSystem.GenerateLoot(aiUnit.EnemyDefinition.ItemsDropChances, aiUnit.EnemyDefinition.LootBagItemsCount, aiUnit.EnemyDefinition.LootBagChanceMod); // _lootDropSystem.AddGoldDrop(aiUnit.EnemyDefinition.GoldDropChance, aiUnit.EnemyDefinition.MinGoldDrop, aiUnit.EnemyDefinition.MaxGoldDrop, ref items); // //generate random pos in circle around unit with radius 1 // var randomPosInCircleWorld = Unit.GetRandomPosInCircleShapeAround(aiUnit.transform.position, 1f); // _lootDropSystem.DropLootBag(items, randomPosInCircleWorld, chanceMod, zone, itemsCount); } [ObserversRpc] private void NotifyAllPlayersRoomStartTime() { SurvivalGameTimer.IsStarted = true; } [Serializable] public struct MonstersPerWave { public int WaveId; public EnemyDefinition[] Enemies; } public class GameTimer { public float Time; public bool IsStarted; public bool IsPaused; public bool IsFinished; public Action<float> OnTimeChanged; public void SetTime(float time) { Time = time; OnTimeChanged?.Invoke(Time); } } [Serializable] public class Wave { public int Id; public int TotalMonstersToKillCount; public int MonstersAliveCount; private int MonstersDeadCount; public int TotalBossesToKillCount; private int BossesAliveCount; private int BossesDeadCount; public EnemyDefinition[] Enemies; public bool IsMonstersCleared { get; private set; } public bool IsBossesCleared { get; private set;  ",
          "content_tokens": 653,
          "embedding": []
        },
        {
          "cs_scriptfile": "GameplayManagerBossBattle",
          "content": "public void AddMonsterAliveCount() { MonstersAliveCount++;  public void AddBossAliveCount() { BossesAliveCount++;  public void AddMonsterDeadCount() { MonstersDeadCount++; MonstersAliveCount--; if (MonstersDeadCount >= TotalMonstersToKillCount) IsMonstersCleared = true;  public void AddBossDeadCount() { BossesDeadCount++; BossesAliveCount--; if (BossesDeadCount >= TotalBossesToKillCount) IsBossesCleared = true; } } } }",
          "content_tokens": 118,
          "embedding": []
        }
      ],
      "length": 13422
    },
    {
      "filename": "LavaFloorController",
      "content": "using System.Collections; using FishNet.Object; using FishNet.Object.Synchronizing; using UnityEngine; public class LavaFloorController : NetworkBehaviour { private readonly string PROPERTY_FIELD_NAME = \"_FinalOpacityPower\"; [SerializeField] private GameObject lavaFloorFX; [SerializeField] private Material floorMaterial; [SyncVar(OnChange = nameof(OnIsLavaFloorChange))] private bool _isLavaFloorActive; private void OnIsLavaFloorChange(bool oldValue, bool newValue, bool asServer) { if (asServer) return; if (newValue) { floorMaterial.SetFloat(PROPERTY_FIELD_NAME, 0); lavaFloorFX.SetActive(true); StartCoroutine(LavaFadeIn()); } else { lavaFloorFX.SetActive(false); } } private IEnumerator LavaFadeIn() { float time = 0; while (time < 1) { time += Time.deltaTime; floorMaterial.SetFloat(PROPERTY_FIELD_NAME, time); yield return null; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "LavaFloorController",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "LavaFloorController",
          "content": "using System.Collections; using FishNet.Object; using FishNet.Object.Synchronizing; using UnityEngine; public class LavaFloorController : NetworkBehaviour { private readonly string PROPERTY_FIELD_NAME = \"_FinalOpacityPower\"; [SerializeField] private GameObject lavaFloorFX; [SerializeField] private Material floorMaterial; [SyncVar(OnChange = nameof(OnIsLavaFloorChange))] private bool _isLavaFloorActive; private void OnIsLavaFloorChange(bool oldValue, bool newValue, bool asServer) { if (asServer) return; if (newValue) { floorMaterial.SetFloat(PROPERTY_FIELD_NAME, 0); lavaFloorFX.SetActive(true); StartCoroutine(LavaFadeIn()); } else { lavaFloorFX.SetActive(false); } } private IEnumerator LavaFadeIn() { float time = 0; while (time < 1) { time += Time.deltaTime; floorMaterial.SetFloat(PROPERTY_FIELD_NAME, time); yield return null; } } }",
          "content_tokens": 250,
          "embedding": []
        }
      ],
      "length": 843
    },
    {
      "filename": "NetworkTransformToRVOController",
      "content": "using FishNet; using FishNet.Object; using UnityEngine; using Pathfinding.RVO; [RequireComponent(typeof(RVOController))] public class NetworkTransformToRVOController : NetworkBehaviour { [SerializeField] private RVOController rvoController; private Vector3 _lastPosition = Vector3.zero; private bool _isInitialized; protected override void OnValidate() { base.OnValidate(); AssignComponentsIfRequired(); } private void Awake() { AssignComponentsIfRequired(); } public override void OnStartServer() { base.OnStartServer(); InstanceFinder.TimeManager.OnTick += TrackPosition; } public override void OnStopServer() { base.OnStopServer(); InstanceFinder.TimeManager.OnTick -= TrackPosition; } private void TrackPosition() { if (!_isInitialized) { _lastPosition = transform.position; _isInitialized = true; return; } double timeElapsed = InstanceFinder.NetworkManager.TimeManager.TickDelta; Vector3 currentPosition = transform.position; Vector3 velocity = (currentPosition - _lastPosition) / (float)timeElapsed; _lastPosition = currentPosition; rvoController.velocity = velocity; } private void AssignComponentsIfRequired() { rvoController = GetComponent<RVOController>(); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "NetworkTransformToRVOController",
          "content": "using FishNet; using FishNet.Object; using UnityEngine; using Pathfinding.RVO; [RequireComponent(typeof(RVOController))] public class NetworkTransformToRVOController : NetworkBehaviour { [SerializeField] private RVOController rvoController; private Vector3 _lastPosition = Vector3.zero; private bool _isInitialized; protected override void OnValidate() { base.OnValidate(); AssignComponentsIfRequired();  private void Awake() { AssignComponentsIfRequired(); } public override void OnStartServer() { base.OnStartServer(); InstanceFinder.TimeManager.OnTick += TrackPosition; } public override void OnStopServer() { base.OnStopServer(); InstanceFinder.TimeManager.OnTick -= TrackPosition;  ",
          "content_tokens": 175,
          "embedding": []
        },
        {
          "cs_scriptfile": "NetworkTransformToRVOController",
          "content": "private void TrackPosition() { if (!_isInitialized) { _lastPosition = transform.position; _isInitialized = true; return; } double timeElapsed = InstanceFinder.NetworkManager.TimeManager.TickDelta; Vector3 currentPosition = transform.position; Vector3 velocity = (currentPosition - _lastPosition) / (float)timeElapsed; _lastPosition = currentPosition; rvoController.velocity = velocity;  private void AssignComponentsIfRequired() { rvoController = GetComponent<RVOController>(); } }",
          "content_tokens": 120,
          "embedding": []
        }
      ],
      "length": 1171
    },
    {
      "filename": "RoomCollapsingTimer",
      "content": " using System; using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using UnityEngine; public class RoomCollapsingTimer : MonoBehaviour { private readonly string PROPERTY_FIELD_NAME = \"_FinalOpacityPower\"; [SerializeField] private GameObject lavaFloorFX; [SerializeField] private Material floorMaterial; public static Action<RoomCollapsingTimer, float> OnCollapsingTimerRoomEnter; public static Action<RoomCollapsingTimer> OnCollapsingTimerRoomExit; public float CollapsingTime => _collapsingTime; [SerializeField] private float _collapsingTime; public bool IsInitialized => isInitialized; private bool isInitialized; private Coroutine _collapsingTimerCoroutine; [SerializeField] private DamagingCollider damagingCollider; private void OnValidate() => AssignComponentsIfRequired(); private void AssignComponentsIfRequired() { damagingCollider ??= FindObjectOfType<DamagingCollider>(); } private void Awake() { AssignComponentsIfRequired(); } public bool IsLavaFloorActive { get { if (CollapsingTime - GameplayManager.GetCurrentServerTime() < 0) return true; return false; } } private void OnEnable() { if (!isInitialized) return; float timeLeft = _collapsingTime - GameplayManager.GetCurrentServerTime(); if (timeLeft < 0) { ActivateLava(); } else { _collapsingTimerCoroutine = StartCoroutine(CheckLavaActivation(timeLeft)); } } private void OnDisable() { if (!isInitialized) return; if (_collapsingTimerCoroutine != null) { StopCoroutine(_collapsingTimerCoroutine); } } private IEnumerator CheckLavaActivation(float timeLeft) { yield return new WaitForSeconds(timeLeft); ActivateLava(); } public void SetCollapsingTime(float time) { _collapsingTime = time; isInitialized = true; } private void OnTriggerEnter(Collider other) { if (!GameplayManager.IsOwningPlayer(other)) return; float timeLeft = _collapsingTime - GameplayManager.GetCurrentServerTime(); ShowScreenFX(timeLeft); OnCollapsingTimerRoomEnter?.Invoke(this, timeLeft); } private void ShowScreenFX(float timeLeft) { if (timeLeft < 0f) { damagingCollider.ShowScreenFXIfRequired(); } } private void OnTriggerStay(Collider other) { if (!GameplayManager.IsOwningPlayer(other)) return; float timeLeft = _collapsingTime - GameplayManager.GetCurrentServerTime(); ShowScreenFX(timeLeft); } private void OnTriggerExit(Collider other) { if (!GameplayManager.IsOwningPlayer(other)) return; damagingCollider.HideScreenFXIfRequired(); OnCollapsingTimerRoomExit?.Invoke(this); } public void ActivateLava() { damagingCollider.enabled = true; floorMaterial.SetFloat(PROPERTY_FIELD_NAME, 0); lavaFloorFX.SetActive(true); StartCoroutine(LavaFadeIn()); } private IEnumerator LavaFadeIn() { float time = 0f; while (time < 2f) { time += Time.deltaTime; floorMaterial.SetFloat(PROPERTY_FIELD_NAME, time); yield return null; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "RoomCollapsingTimer",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomCollapsingTimer",
          "content": " using System; using System.Collections; using _ZombieRoyale.Scripts.Core; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using FishNet; using UnityEngine; public class RoomCollapsingTimer : MonoBehaviour { private readonly string PROPERTY_FIELD_NAME = \"_FinalOpacityPower\"; [SerializeField] private GameObject lavaFloorFX; [SerializeField] private Material floorMaterial; public static Action<RoomCollapsingTimer, float> OnCollapsingTimerRoomEnter; public static Action<RoomCollapsingTimer> OnCollapsingTimerRoomExit; public float CollapsingTime => _collapsingTime; [SerializeField] private float _collapsingTime; public bool IsInitialized => isInitialized; private bool isInitialized; private Coroutine _collapsingTimerCoroutine; [SerializeField] private DamagingCollider damagingCollider; private void OnValidate() => AssignComponentsIfRequired(); private void AssignComponentsIfRequired() { damagingCollider ??= FindObjectOfType<DamagingCollider>();  ",
          "content_tokens": 244,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomCollapsingTimer",
          "content": "private void Awake() { AssignComponentsIfRequired(); } public bool IsLavaFloorActive { get { if (CollapsingTime - GameplayManager.GetCurrentServerTime() < 0) return true; return false; }  private void OnEnable() { if (!isInitialized) return; float timeLeft = _collapsingTime - GameplayManager.GetCurrentServerTime(); if (timeLeft < 0) { ActivateLava(); } else { _collapsingTimerCoroutine = StartCoroutine(CheckLavaActivation(timeLeft)); }  private void OnDisable() { if (!isInitialized) return; if (_collapsingTimerCoroutine != null) { StopCoroutine(_collapsingTimerCoroutine); } } private IEnumerator CheckLavaActivation(float timeLeft) { yield return new WaitForSeconds(timeLeft); ActivateLava();  ",
          "content_tokens": 193,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomCollapsingTimer",
          "content": "public void SetCollapsingTime(float time) { _collapsingTime = time; isInitialized = true;  private void OnTriggerEnter(Collider other) { if (!GameplayManager.IsOwningPlayer(other)) return; float timeLeft = _collapsingTime - GameplayManager.GetCurrentServerTime(); ShowScreenFX(timeLeft); OnCollapsingTimerRoomEnter?.Invoke(this, timeLeft);  private void ShowScreenFX(float timeLeft) { if (timeLeft < 0f) { damagingCollider.ShowScreenFXIfRequired(); }  private void OnTriggerStay(Collider other) { if (!GameplayManager.IsOwningPlayer(other)) return; float timeLeft = _collapsingTime - GameplayManager.GetCurrentServerTime(); ShowScreenFX(timeLeft);  ",
          "content_tokens": 180,
          "embedding": []
        },
        {
          "cs_scriptfile": "RoomCollapsingTimer",
          "content": "private void OnTriggerExit(Collider other) { if (!GameplayManager.IsOwningPlayer(other)) return; damagingCollider.HideScreenFXIfRequired(); OnCollapsingTimerRoomExit?.Invoke(this);  public void ActivateLava() { damagingCollider.enabled = true; floorMaterial.SetFloat(PROPERTY_FIELD_NAME, 0); lavaFloorFX.SetActive(true); StartCoroutine(LavaFadeIn()); } private IEnumerator LavaFadeIn() { float time = 0f; while (time < 2f) { time += Time.deltaTime; floorMaterial.SetFloat(PROPERTY_FIELD_NAME, time); yield return null; } } }",
          "content_tokens": 159,
          "embedding": []
        }
      ],
      "length": 2846
    },
    {
      "filename": "ServerPlayerManager",
      "content": "using System; using System.Collections; using System.Collections.Generic; using System.Text; using _ZombieRoyale.Scripts.Clients; using Character; using FirstGearGames.LobbyAndWorld.Clients; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using Newtonsoft.Json; using Proyecto26; using UnityEngine; public class ServerPlayerManager : RoomManager { private Dictionary<NetworkConnection, CharacterData> _characterData = new Dictionary<NetworkConnection, CharacterData>(); [SyncObject] private readonly SyncDictionary<NetworkConnection, CharacterSkinData> _characterSkinData = new SyncDictionary<NetworkConnection, CharacterSkinData>(); /// <summary> /// Client only /// </summary> public static ServerPlayerManager Instance { get; private set; } public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { } else { if (Instance == null) { Instance = this; } else { Destroy(this); } } } public void InitServer() { StartCoroutine(LoadAllPlayerCharacters()); } private void Awake() { _characterSkinData.OnChange += _characterSkinData_OnChange; } private void _characterSkinData_OnChange(SyncDictionaryOperation op, NetworkConnection connection, CharacterSkinData skinData, bool asServer) { StringBuilder sb = new StringBuilder(); string methodName = \"[_characterSkinData_OnChange] \"; switch (op) { //Adds key with value. case SyncDictionaryOperation.Add: sb.Append($\"Add \"); break; //Removes key. case SyncDictionaryOperation.Remove: sb.Append($\"Remove \"); break; //Sets key to a new value. case SyncDictionaryOperation.Set: sb.Append($\"Set \"); break; //Clears the dictionary. case SyncDictionaryOperation.Clear: sb.Append($\"Clear \"); break; //Like SyncList, indicates all operations are complete. case SyncDictionaryOperation.Complete: sb.Append($\"Complete \"); break; } sb.Append($\"Player #{connection.ClientId} gender: {(CharacterSkinData.Gender)skinData.genderId}\"); Debug.Log(sb.ToString()); } [Client] public CharacterSkinData GetCharacterSkin(NetworkConnection owner) { if (_characterSkinData.TryGetValue(owner, out CharacterSkinData skinData)) { return skinData; } else { Debug.LogError($\"No skin data found for player #{owner.ClientId}\"); } return null; } public static CharacterData GetCharacterData(NetworkConnection conn) { if (Instance._characterData.TryGetValue(conn, out CharacterData charData)) { return charData; } else { Debug.LogError($\"No character data found for player #{conn.ClientId}\"); } return null; } [Server] private IEnumerator LoadAllPlayerCharacters() { yield return new WaitUntil(() => GameplayManager.RoomDetails.StartedMembers.Count > 0); var clientInstances = GameplayManager.RoomDetails.StartedMembers; if (clientInstances.Count == 0) { Debug.LogError($\"[ServerPlayerManager] No clients in room\"); } Dictionary<NetworkConnection, string> allPlayerTokens = new Dictionary<NetworkConnection, string>(); foreach (var client in clientInstances) { var playerSettings = client.GetComponent<PlayerSettings>(); if (playerSettings != null) { allPlayerTokens.Add(client.Owner, playerSettings.Token); } } GameplayManager.RoomDetails.StorePlayerTokens(allPlayerTokens); foreach (var kv in GameplayManager.RoomDetails.PlayerTokens) { NetworkConnection owner = kv.Key; string token = kv.Value; Action<RequestException, ResponseHelper, string> callback = (exception, helper, body) => { if (exception != null) { Debug.Log(exception); return; } Debug.Log($\"[RegistrationController.GetCharacterData] body: {body}\"); bool isPlayerDontHaveChars = body.Substring(0, 2) == \"-1\"; bool isError = body == \"error\"; if (!isPlayerDontHaveChars && !isError) { CharacterData charData = JsonConvert.DeserializeObject<CharacterData>(body); _characterData.Add(owner, charData); Debug.Log($\"[RegistrationController.GetCharacterData] charData loaded for Player #{owner.ClientId}\"); } }; BackendReadWrites.GetCharacterData(token, callback); } } //TODO: Remove disconnected player from dictionary } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ServerPlayerManager",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "ServerPlayerManager",
          "content": "using System; using System.Collections; using System.Collections.Generic; using System.Text; using _ZombieRoyale.Scripts.Clients; using Character; using FirstGearGames.LobbyAndWorld.Clients; using FishNet.Connection; using FishNet.Object; using FishNet.Object.Synchronizing; using Newtonsoft.Json; using Proyecto26; using UnityEngine; public class ServerPlayerManager : RoomManager { private Dictionary<NetworkConnection, CharacterData> _characterData = new Dictionary<NetworkConnection, CharacterData>(); [SyncObject] private readonly SyncDictionary<NetworkConnection, CharacterSkinData> _characterSkinData = new SyncDictionary<NetworkConnection, CharacterSkinData>(); /// <summary> /// Client only /// </summary> public static ServerPlayerManager Instance { get; private set; } public override void OnStartNetwork() { base.OnStartNetwork(); if (IsServer) { } else { if (Instance == null) { Instance = this; } else { Destroy(this); } }  ",
          "content_tokens": 230,
          "embedding": []
        },
        {
          "cs_scriptfile": "ServerPlayerManager",
          "content": "public void InitServer() { StartCoroutine(LoadAllPlayerCharacters());  private void Awake() { _characterSkinData.OnChange += _characterSkinData_OnChange;  ",
          "content_tokens": 40,
          "embedding": []
        },
        {
          "cs_scriptfile": "ServerPlayerManager",
          "content": "private void _characterSkinData_OnChange(SyncDictionaryOperation op, NetworkConnection connection, CharacterSkinData skinData, bool asServer) { StringBuilder sb = new StringBuilder(); string methodName = \"[_characterSkinData_OnChange] \"; switch (op) { //Adds key with value. case SyncDictionaryOperation.Add: sb.Append($\"Add \"); break; //Removes key. case SyncDictionaryOperation.Remove: sb.Append($\"Remove \"); break; //Sets key to a new value. case SyncDictionaryOperation.Set: sb.Append($\"Set \"); break; //Clears the dictionary. case SyncDictionaryOperation.Clear: sb.Append($\"Clear \"); break; //Like SyncList, indicates all operations are complete. case SyncDictionaryOperation.Complete: sb.Append($\"Complete \"); break; } sb.Append($\"Player #{connection.ClientId} gender: {(CharacterSkinData.Gender)skinData.genderId}\"); Debug.Log(sb.ToString()); } [Client] public CharacterSkinData GetCharacterSkin(NetworkConnection owner) { if (_characterSkinData.TryGetValue(owner, out CharacterSkinData skinData)) { return skinData; } else { Debug.LogError($\"No skin data found for player #{owner.ClientId}\"); } return null; } public static CharacterData GetCharacterData(NetworkConnection conn) { if (Instance._characterData.TryGetValue(conn, out CharacterData charData)) { return charData; } else { Debug.LogError($\"No character data found for player #{conn.ClientId}\"); } return null; } [Server] private IEnumerator LoadAllPlayerCharacters() { yield return new WaitUntil(() => GameplayManager.RoomDetails.StartedMembers.Count > 0); var clientInstances = GameplayManager.RoomDetails.StartedMembers; if (clientInstances.Count == 0) { Debug.LogError($\"[ServerPlayerManager] No clients in room\"); } Dictionary<NetworkConnection, string> allPlayerTokens = new Dictionary<NetworkConnection, string>(); foreach (var client in clientInstances) { var playerSettings = client.GetComponent<PlayerSettings>(); if (playerSettings != null) { allPlayerTokens.Add(client.Owner, playerSettings.Token); } } GameplayManager.RoomDetails.StorePlayerTokens(allPlayerTokens); foreach (var kv in GameplayManager.RoomDetails.PlayerTokens) { NetworkConnection owner = kv.Key; string token = kv.Value; Action<RequestException, ResponseHelper, string> callback = (exception, helper, body) => { if (exception != null) { Debug.Log(exception); return; } Debug.Log($\"[RegistrationController.GetCharacterData] body: {body}\"); bool isPlayerDontHaveChars = body.Substring(0, 2) == \"-1\"; bool isError = body == \"error\"; if (!isPlayerDontHaveChars && !isError) { CharacterData charData = JsonConvert.DeserializeObject<CharacterData>(body); _characterData.Add(owner, charData); Debug.Log($\"[RegistrationController.GetCharacterData] charData loaded for Player #{owner.ClientId}\"); } }; BackendReadWrites.GetCharacterData(token, callback); } } //TODO: Remove disconnected player from dictionary }",
          "content_tokens": 761,
          "embedding": []
        }
      ],
      "length": 3947
    },
    {
      "filename": "SpawnManequinsNearPlayers",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class SpawnManequinsNearPlayers : MonoBehaviour { // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SpawnManequinsNearPlayers",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class SpawnManequinsNearPlayers : MonoBehaviour { // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } }",
          "content_tokens": 59,
          "embedding": []
        }
      ],
      "length": 257
    },
    {
      "filename": "ShowFloatingStatus",
      "content": "using DamageNumbersPro; using Invector; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; public class ShowFloatingStatus : DamageNumber { protected override void OnStart() { } protected override void OnStop() { } protected override void OnUpdate(float deltaTime) { } protected override void OnFade(float currentFade) { } protected override void OnTextUpdate() { } protected override void OnAbsorb(float number, float newSum) { } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ShowFloatingStatus",
          "content": "using DamageNumbersPro; using Invector; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; public class ShowFloatingStatus : DamageNumber { protected override void OnStart() { } protected override void OnStop() { } protected override void OnUpdate(float deltaTime) { } protected override void OnFade(float currentFade) { } protected override void OnTextUpdate() { } protected override void OnAbsorb(float number, float newSum) { } }",
          "content_tokens": 111,
          "embedding": []
        }
      ],
      "length": 483
    },
    {
      "filename": "NewTestScript",
      "content": "using NUnit.Framework; using UnityEngine; using UnityEditor.TestTools; using UnityEngine.TestTools; [TestFixture] public class TestBackendCallsTests { [SetUp] public void Setup() { } [Test] public void RegisterNewPlayer_ShouldCallBackendWithCorrectParameters() { // Arrange // You would set up any necessary mock data or expectations here // Act // Assert // You would verify that the correct parameters were passed to the backend } [Test] public void TestSetAbilityStacks_ShouldUpdateAbilityStacks() { // Arrange // Act // Assert } [Test] public void TestGetAbilityStacks_ShouldRetrieveAbilityStacks() { // Arrange // Act // Assert } [Test] public void GetCharacterData_ShouldFetchCharacterData() { // Arrange // Act // Assert } [Test] public void SaveItemsToCharacterData_ShouldSaveItems() { // Arrange // Act // Assert } [Test] public void DeleteItemsFromCharacterData_ShouldDeleteItems() { // Arrange // Act // Assert } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "NewTestScript",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "NewTestScript",
          "content": "using NUnit.Framework; using UnityEngine; using UnityEditor.TestTools; using UnityEngine.TestTools; [TestFixture] public class TestBackendCallsTests { [SetUp] public void Setup() { } [Test] public void RegisterNewPlayer_ShouldCallBackendWithCorrectParameters() { // Arrange // You would set up any necessary mock data or expectations here // Act // Assert // You would verify that the correct parameters were passed to the backend } [Test] public void TestSetAbilityStacks_ShouldUpdateAbilityStacks() { // Arrange // Act // Assert } [Test] public void TestGetAbilityStacks_ShouldRetrieveAbilityStacks() { // Arrange // Act // Assert } [Test] public void GetCharacterData_ShouldFetchCharacterData() { // Arrange // Act // Assert } [Test] public void SaveItemsToCharacterData_ShouldSaveItems() { // Arrange // Act // Assert } [Test] public void DeleteItemsFromCharacterData_ShouldDeleteItems() { // Arrange // Act // Assert } }",
          "content_tokens": 233,
          "embedding": []
        }
      ],
      "length": 925
    },
    {
      "filename": "TextMeshProNumberTextUpdater",
      "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class TextMeshProNumberTextUpdater : MonoBehaviour { // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "TextMeshProNumberTextUpdater",
          "content": "using System.Collections; using System.Collections.Generic; using UnityEngine; public class TextMeshProNumberTextUpdater : MonoBehaviour { // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } }",
          "content_tokens": 60,
          "embedding": []
        }
      ],
      "length": 260
    },
    {
      "filename": "TMProDecorator",
      "content": "using DungeonScrollerCore; using UnityEngine; using TMPro; public class TMProDecorator : MonoBehaviour { private TextMeshProUGUI _textMeshPro; public bool IsHidden => !TextMeshPro.enabled; public TextMeshProUGUI TextMeshPro { get { if (_textMeshPro == null) { _textMeshPro = GetComponent<TextMeshProUGUI>(); } return _textMeshPro; } } // Get the current text public string GetText() { return TextMeshPro.text; } // Set the text public void SetText(string newText) { TextMeshPro.text = newText; //DebugWrite.Log($\"[TMProDecorator] SetText {newText}\"); } public void ChangeColor(string hex) { Color color; ColorUtility.TryParseHtmlString(hex, out color); TextMeshPro.color = color; } // Append text public void AppendText(string textToAppend) { TextMeshPro.text += textToAppend; } // Change font size public void SetFontSize(float newSize) { TextMeshPro.fontSize = newSize; } // Change font color public void SetColor(Color newColor) { if (newColor == null) return; if (newColor == TextMeshPro.color) return; TextMeshPro.color = newColor; } public Color GetFontColor() { return TextMeshPro.color; } public static string ToUpperCase(string input) { return char.ToUpper(input[0]) + input.Substring(1).ToLower(); } public void Hide() { if (IsHidden) return; TextMeshPro.enabled = false; } public void Show() { if (!IsHidden) return; TextMeshPro.enabled = true; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "TMProDecorator",
          "content": "using DungeonScrollerCore; using UnityEngine; using TMPro; public class TMProDecorator : MonoBehaviour { private TextMeshProUGUI _textMeshPro; public bool IsHidden => !TextMeshPro.enabled; public TextMeshProUGUI TextMeshPro { get { if (_textMeshPro == null) { _textMeshPro = GetComponent<TextMeshProUGUI>(); } return _textMeshPro; } } // Get the current text public string GetText() { return TextMeshPro.text; } // Set the text public void SetText(string newText) { TextMeshPro.text = newText; //DebugWrite.Log($\"[TMProDecorator] SetText {newText}\");  ",
          "content_tokens": 158,
          "embedding": []
        },
        {
          "cs_scriptfile": "TMProDecorator",
          "content": "public void ChangeColor(string hex) { Color color; ColorUtility.TryParseHtmlString(hex, out color); TextMeshPro.color = color; } // Append text public void AppendText(string textToAppend) { TextMeshPro.text += textToAppend; } // Change font size public void SetFontSize(float newSize) { TextMeshPro.fontSize = newSize; } // Change font color public void SetColor(Color newColor) { if (newColor == null) return; if (newColor == TextMeshPro.color) return; TextMeshPro.color = newColor; } public Color GetFontColor() { return TextMeshPro.color; } public static string ToUpperCase(string input) { return char.ToUpper(input[0]) + input.Substring(1).ToLower();  ",
          "content_tokens": 187,
          "embedding": []
        },
        {
          "cs_scriptfile": "TMProDecorator",
          "content": "public void Hide() { if (IsHidden) return; TextMeshPro.enabled = false;  public void Show() { if (!IsHidden) return; TextMeshPro.enabled = true; } }",
          "content_tokens": 43,
          "embedding": []
        }
      ],
      "length": 1359
    },
    {
      "filename": "UICanvasGroupDecorator",
      "content": "using System; using System.Collections; using UnityEngine; [RequireComponent(typeof(CanvasGroup))] public class UICanvasGroupDecorator : MonoBehaviour { [SerializeField] private bool isOffOnStart = true; [SerializeField] private CanvasGroup _canvasGroup; public bool IsVisible => _isVisible; public static UICanvasGroupDecorator InstanceMainMenu { get; private set; } private Coroutine _animationCoroutine; private bool _isVisible; private void OnValidate() { if (_canvasGroup == null) _canvasGroup = GetComponent<CanvasGroup>(); } private void Awake() { if (_canvasGroup == null) _canvasGroup = GetComponent<CanvasGroup>(); if (_canvasGroup == null) Debug.LogError($\"[UICanvasGroupDecorator] CanvasGroup is null on {gameObject.name}\", gameObject); ActivateCustomInstances(); if (isOffOnStart) Hide(); else Show(); } public void StopAllAnimations() { if (_animationCoroutine != null) StopCoroutine(_animationCoroutine); } public void BlinkAlpha(float duration, float delay, float minAlpha, float maxAlpha) { StopAllAnimations(); _animationCoroutine = StartCoroutine(AlphaBlink(duration, delay, minAlpha, maxAlpha)); } private IEnumerator AlphaBlink(float duration, float delay, float minAlpha, float maxAlpha) { float time = 0f; while (_isVisible) { while (time < duration) { time += Time.deltaTime; _canvasGroup.alpha = Mathf.Lerp(maxAlpha, minAlpha, time / duration); //Debug.Log($\"[UICanvasGroupDecorator] AlphaBlink: {_canvasGroup.alpha}\"); yield return null; } yield return new WaitForSeconds(delay); time = 0; while (time < duration) { time += Time.deltaTime; _canvasGroup.alpha = Mathf.Lerp(minAlpha, maxAlpha, time / duration); //Debug.Log($\"[UICanvasGroupDecorator] AlphaBlink: {_canvasGroup.alpha}\"); yield return null; } time = 0; yield return new WaitForSeconds(delay); } } public void CrossFadeAlpha(float alpha, float duration, bool ignoreTimeScale) { StopAllAnimations(); _animationCoroutine = StartCoroutine(AlphaFade(alpha, duration, ignoreTimeScale)); } private IEnumerator AlphaFade(float alpha, float duration, bool ignoreTimeScale) { float time = 0; float startAlpha = _canvasGroup.alpha; while (time < duration) { _canvasGroup.alpha = Mathf.Lerp(startAlpha, alpha, time / duration); time = ignoreTimeScale ? time + Time.unscaledDeltaTime : time + Time.deltaTime; yield return null; } _canvasGroup.alpha = alpha; } private void ActivateCustomInstances() { if (gameObject.name == \"bg\") { InstanceMainMenu = this; } } public void Switch(bool isOnlyVisibility) { bool isOn = _canvasGroup.alpha == 0; ChangeVisibility(isOn, isOnlyVisibility); } public void Show(bool isOnlyVisibility = false) { Debug.Log($\"[UICanvasGroupDecorator] Show Canvas {gameObject}\", gameObject); ChangeVisibility(true, isOnlyVisibility); } public void HideTimed(float time) { StartCoroutine(HideTimedCoroutine(time)); } private IEnumerator HideTimedCoroutine(float time) { yield return new WaitForSeconds(time); Hide(); } public void Hide() { ChangeVisibility(false, false); StopAllAnimations(); } private void ChangeVisibility(bool isOn, bool isOnlyVisibility) { _canvasGroup.alpha = isOn ? 1 : 0; _isVisible = isOn; if (isOnlyVisibility) return; _canvasGroup.interactable = isOn; _canvasGroup.blocksRaycasts = isOn; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "UICanvasGroupDecorator",
          "content": "using System; using System.Collections; using UnityEngine; [RequireComponent(typeof(CanvasGroup))] public class UICanvasGroupDecorator : MonoBehaviour { [SerializeField] private bool isOffOnStart = true; [SerializeField] private CanvasGroup _canvasGroup; public bool IsVisible => _isVisible; public static UICanvasGroupDecorator InstanceMainMenu { get; private set; } private Coroutine _animationCoroutine; private bool _isVisible; private void OnValidate() { if (_canvasGroup == null) _canvasGroup = GetComponent<CanvasGroup>();  ",
          "content_tokens": 147,
          "embedding": []
        },
        {
          "cs_scriptfile": "UICanvasGroupDecorator",
          "content": "private void Awake() { if (_canvasGroup == null) _canvasGroup = GetComponent<CanvasGroup>(); if (_canvasGroup == null) Debug.LogError($\"[UICanvasGroupDecorator] CanvasGroup is null on {gameObject.name}\", gameObject); ActivateCustomInstances(); if (isOffOnStart) Hide(); else Show();  public void StopAllAnimations() { if (_animationCoroutine != null) StopCoroutine(_animationCoroutine);  ",
          "content_tokens": 112,
          "embedding": []
        },
        {
          "cs_scriptfile": "UICanvasGroupDecorator",
          "content": "public void BlinkAlpha(float duration, float delay, float minAlpha, float maxAlpha) { StopAllAnimations(); _animationCoroutine = StartCoroutine(AlphaBlink(duration, delay, minAlpha, maxAlpha)); } private IEnumerator AlphaBlink(float duration, float delay, float minAlpha, float maxAlpha) { float time = 0f; while (_isVisible) { while (time < duration) { time += Time.deltaTime; _canvasGroup.alpha = Mathf.Lerp(maxAlpha, minAlpha, time / duration); //Debug.Log($\"[UICanvasGroupDecorator] AlphaBlink: {_canvasGroup.alpha}\"); yield return null; } yield return new WaitForSeconds(delay); time = 0; while (time < duration) { time += Time.deltaTime; _canvasGroup.alpha = Mathf.Lerp(minAlpha, maxAlpha, time / duration); //Debug.Log($\"[UICanvasGroupDecorator] AlphaBlink: {_canvasGroup.alpha}\"); yield return null; } time = 0; yield return new WaitForSeconds(delay); }  ",
          "content_tokens": 262,
          "embedding": []
        },
        {
          "cs_scriptfile": "UICanvasGroupDecorator",
          "content": "public void CrossFadeAlpha(float alpha, float duration, bool ignoreTimeScale) { StopAllAnimations(); _animationCoroutine = StartCoroutine(AlphaFade(alpha, duration, ignoreTimeScale)); } private IEnumerator AlphaFade(float alpha, float duration, bool ignoreTimeScale) { float time = 0; float startAlpha = _canvasGroup.alpha; while (time < duration) { _canvasGroup.alpha = Mathf.Lerp(startAlpha, alpha, time / duration); time = ignoreTimeScale ? time + Time.unscaledDeltaTime : time + Time.deltaTime; yield return null; } _canvasGroup.alpha = alpha;  private void ActivateCustomInstances() { if (gameObject.name == \"bg\") { InstanceMainMenu = this; }  ",
          "content_tokens": 182,
          "embedding": []
        },
        {
          "cs_scriptfile": "UICanvasGroupDecorator",
          "content": "public void Switch(bool isOnlyVisibility) { bool isOn = _canvasGroup.alpha == 0; ChangeVisibility(isOn, isOnlyVisibility);  public void Show(bool isOnlyVisibility = false) { Debug.Log($\"[UICanvasGroupDecorator] Show Canvas {gameObject}\", gameObject); ChangeVisibility(true, isOnlyVisibility);  public void HideTimed(float time) { StartCoroutine(HideTimedCoroutine(time)); } private IEnumerator HideTimedCoroutine(float time) { yield return new WaitForSeconds(time); Hide();  public void Hide() { ChangeVisibility(false, false); StopAllAnimations();  ",
          "content_tokens": 158,
          "embedding": []
        },
        {
          "cs_scriptfile": "UICanvasGroupDecorator",
          "content": "private void ChangeVisibility(bool isOn, bool isOnlyVisibility) { _canvasGroup.alpha = isOn ? 1 : 0; _isVisible = isOn; if (isOnlyVisibility) return; _canvasGroup.interactable = isOn; _canvasGroup.blocksRaycasts = isOn; } }",
          "content_tokens": 74,
          "embedding": []
        }
      ],
      "length": 3214
    },
    {
      "filename": "AsmdefDebug",
      "content": "#if UNITY_EDITOR using System; using System.Collections.Generic; using System.Globalization; using System.Text; using UnityEditor; using UnityEditor.Compilation; using UnityEngine; /// <summary> /// https://gist.github.com/karljj1/9c6cce803096b5cd4511cf0819ff517b /// </summary> [InitializeOnLoad] public class AsmdefDebug { const string AssemblyReloadEventsEditorPref = \"AssemblyReloadEventsTime\"; const string AssemblyCompilationEventsEditorPref = \"AssemblyCompilationEvents\"; static readonly int ScriptAssembliesPathLen = \"Library/ScriptAssemblies/\".Length; private static string AssemblyTotalCompilationTimeEditorPref = \"AssemblyTotalCompilationTime\"; static Dictionary<string, DateTime> s_StartTimes = new Dictionary<string, DateTime>(); static StringBuilder s_BuildEvents = new StringBuilder(); static double s_CompilationTotalTime; static AsmdefDebug() { CompilationPipeline.assemblyCompilationStarted += CompilationPipelineOnAssemblyCompilationStarted; CompilationPipeline.assemblyCompilationFinished += CompilationPipelineOnAssemblyCompilationFinished; AssemblyReloadEvents.beforeAssemblyReload += AssemblyReloadEventsOnBeforeAssemblyReload; AssemblyReloadEvents.afterAssemblyReload += AssemblyReloadEventsOnAfterAssemblyReload; } static void CompilationPipelineOnAssemblyCompilationStarted(string assembly) { s_StartTimes[assembly] = DateTime.UtcNow; } static void CompilationPipelineOnAssemblyCompilationFinished(string assembly, CompilerMessage[] arg2) { var timeSpan = DateTime.UtcNow - s_StartTimes[assembly]; s_CompilationTotalTime += timeSpan.TotalMilliseconds; s_BuildEvents.AppendFormat(\"{0:0.00}s {1}\\n\", timeSpan.TotalMilliseconds / 1000f, assembly.Substring(ScriptAssembliesPathLen, assembly.Length - ScriptAssembliesPathLen)); } static void AssemblyReloadEventsOnBeforeAssemblyReload() { var totalCompilationTimeSeconds = s_CompilationTotalTime / 1000f; s_BuildEvents.AppendFormat(\"compilation total: {0:0.00}s\\n\", totalCompilationTimeSeconds); EditorPrefs.SetString(AssemblyReloadEventsEditorPref, DateTime.UtcNow.ToBinary().ToString()); EditorPrefs.SetString(AssemblyCompilationEventsEditorPref, s_BuildEvents.ToString()); EditorPrefs.SetString(AssemblyTotalCompilationTimeEditorPref, totalCompilationTimeSeconds.ToString(CultureInfo.InvariantCulture)); } static void AssemblyReloadEventsOnAfterAssemblyReload() { var binString = EditorPrefs.GetString(AssemblyReloadEventsEditorPref); float totalCompilationTimeSeconds = 0f; float.TryParse(EditorPrefs.GetString(AssemblyTotalCompilationTimeEditorPref, AssemblyTotalCompilationTimeEditorPref), out totalCompilationTimeSeconds); long bin; if (long.TryParse(binString, out bin)) { var date = DateTime.FromBinary(bin); var time = DateTime.UtcNow - date; var compilationTimes = EditorPrefs.GetString(AssemblyCompilationEventsEditorPref); var totalTimeSeconds = totalCompilationTimeSeconds + time.TotalSeconds; if (!string.IsNullOrEmpty(compilationTimes)) { Debug.Log($\"Compilation Report: {totalTimeSeconds:F2} seconds\\n\" + compilationTimes + \"Assembly Reload Time: \" + time.TotalSeconds + \"s\\n\"); } } } } #endif",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "AsmdefDebug",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "AsmdefDebug",
          "content": "#if UNITY_EDITOR using System; using System.Collections.Generic; using System.Globalization; using System.Text; using UnityEditor; using UnityEditor.Compilation; using UnityEngine; /// <summary> /// https://gist.github.com/karljj1/9c6cce803096b5cd4511cf0819ff517b /// </summary> [InitializeOnLoad] public class AsmdefDebug { const string AssemblyReloadEventsEditorPref = \"AssemblyReloadEventsTime\"; const string AssemblyCompilationEventsEditorPref = \"AssemblyCompilationEvents\"; static readonly int ScriptAssembliesPathLen = \"Library/ScriptAssemblies/\".Length; private static string AssemblyTotalCompilationTimeEditorPref = \"AssemblyTotalCompilationTime\"; static Dictionary<string, DateTime> s_StartTimes = new Dictionary<string, DateTime>(); static StringBuilder s_BuildEvents = new StringBuilder(); static double s_CompilationTotalTime; static AsmdefDebug() { CompilationPipeline.assemblyCompilationStarted += CompilationPipelineOnAssemblyCompilationStarted; CompilationPipeline.assemblyCompilationFinished += CompilationPipelineOnAssemblyCompilationFinished; AssemblyReloadEvents.beforeAssemblyReload += AssemblyReloadEventsOnBeforeAssemblyReload; AssemblyReloadEvents.afterAssemblyReload += AssemblyReloadEventsOnAfterAssemblyReload;  ",
          "content_tokens": 310,
          "embedding": []
        },
        {
          "cs_scriptfile": "AsmdefDebug",
          "content": "static void CompilationPipelineOnAssemblyCompilationStarted(string assembly) { s_StartTimes[assembly] = DateTime.UtcNow;  static void CompilationPipelineOnAssemblyCompilationFinished(string assembly, CompilerMessage[] arg2) { var timeSpan = DateTime.UtcNow - s_StartTimes[assembly]; s_CompilationTotalTime += timeSpan.TotalMilliseconds; s_BuildEvents.AppendFormat(\"{0:0.00}s {1}\\n\", timeSpan.TotalMilliseconds / 1000f, assembly.Substring(ScriptAssembliesPathLen, assembly.Length - ScriptAssembliesPathLen));  ",
          "content_tokens": 153,
          "embedding": []
        },
        {
          "cs_scriptfile": "AsmdefDebug",
          "content": "static void AssemblyReloadEventsOnBeforeAssemblyReload() { var totalCompilationTimeSeconds = s_CompilationTotalTime / 1000f; s_BuildEvents.AppendFormat(\"compilation total: {0:0.00}s\\n\", totalCompilationTimeSeconds); EditorPrefs.SetString(AssemblyReloadEventsEditorPref, DateTime.UtcNow.ToBinary().ToString()); EditorPrefs.SetString(AssemblyCompilationEventsEditorPref, s_BuildEvents.ToString()); EditorPrefs.SetString(AssemblyTotalCompilationTimeEditorPref, totalCompilationTimeSeconds.ToString(CultureInfo.InvariantCulture));  ",
          "content_tokens": 149,
          "embedding": []
        },
        {
          "cs_scriptfile": "AsmdefDebug",
          "content": "static void AssemblyReloadEventsOnAfterAssemblyReload() { var binString = EditorPrefs.GetString(AssemblyReloadEventsEditorPref); float totalCompilationTimeSeconds = 0f; float.TryParse(EditorPrefs.GetString(AssemblyTotalCompilationTimeEditorPref, AssemblyTotalCompilationTimeEditorPref), out totalCompilationTimeSeconds); long bin; if (long.TryParse(binString, out bin)) { var date = DateTime.FromBinary(bin); var time = DateTime.UtcNow - date; var compilationTimes = EditorPrefs.GetString(AssemblyCompilationEventsEditorPref); var totalTimeSeconds = totalCompilationTimeSeconds + time.TotalSeconds; if (!string.IsNullOrEmpty(compilationTimes)) { Debug.Log($\"Compilation Report: {totalTimeSeconds:F2} seconds\\n\" + compilationTimes + \"Assembly Reload Time: \" + time.TotalSeconds + \"s\\n\"); } } } } #endif}",
          "content_tokens": 223,
          "embedding": []
        }
      ],
      "length": 3081
    },
    {
      "filename": "CustomDictionary",
      "content": "using System.Collections.Generic; using UnityEngine; public class CustomDictionary<TKey, TValue> { private Dictionary<TKey, TValue> _dictionary; public CustomDictionary() { _dictionary = new Dictionary<TKey, TValue>(); } public void Add(TKey key, TValue value) { if (_dictionary.ContainsKey(key)) { Debug.LogWarning(\"Key already exists in the dictionary. Overwriting with new value.\"); } _dictionary[key] = value; } public bool TryGetValue(TKey key, out TValue value) { return _dictionary.TryGetValue(key, out value); } public void Remove(TKey key) { if (_dictionary.ContainsKey(key)) { _dictionary.Remove(key); } else { Debug.LogWarning(\"Key not found in the dictionary. Cannot remove.\"); } } public void Clear() { _dictionary.Clear(); } public int Count() { return _dictionary.Count; } public bool ContainsKey(TKey key) { return _dictionary.ContainsKey(key); } public bool ContainsValue(TValue value) { return _dictionary.ContainsValue(value); } public List<TKey> GetKeys() { return new List<TKey>(_dictionary.Keys); } public List<TValue> GetValues() { return new List<TValue>(_dictionary.Values); } public TValue GetOrAdd(TKey key, TValue defaultValue) { TValue value; if (!_dictionary.TryGetValue(key, out value)) { value = defaultValue; _dictionary.Add(key, defaultValue); } return value; } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "CustomDictionary",
          "content": "using System.Collections.Generic; using UnityEngine; public class CustomDictionary<TKey, TValue> { private Dictionary<TKey, TValue> _dictionary; public CustomDictionary() { _dictionary = new Dictionary<TKey, TValue>();  public void Add(TKey key, TValue value) { if (_dictionary.ContainsKey(key)) { Debug.LogWarning(\"Key already exists in the dictionary. Overwriting with new value.\"); } _dictionary[key] = value;  public bool TryGetValue(TKey key, out TValue value) { return _dictionary.TryGetValue(key, out value);  ",
          "content_tokens": 151,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomDictionary",
          "content": "public void Remove(TKey key) { if (_dictionary.ContainsKey(key)) { _dictionary.Remove(key); } else { Debug.LogWarning(\"Key not found in the dictionary. Cannot remove.\"); }  public void Clear() { _dictionary.Clear();  public int Count() { return _dictionary.Count;  public bool ContainsKey(TKey key) { return _dictionary.ContainsKey(key);  ",
          "content_tokens": 98,
          "embedding": []
        },
        {
          "cs_scriptfile": "CustomDictionary",
          "content": "public bool ContainsValue(TValue value) { return _dictionary.ContainsValue(value); } public List<TKey> GetKeys() { return new List<TKey>(_dictionary.Keys); } public List<TValue> GetValues() { return new List<TValue>(_dictionary.Values); } public TValue GetOrAdd(TKey key, TValue defaultValue) { TValue value; if (!_dictionary.TryGetValue(key, out value)) { value = defaultValue; _dictionary.Add(key, defaultValue); } return value; } }",
          "content_tokens": 135,
          "embedding": []
        }
      ],
      "length": 1297
    },
    {
      "filename": "VariableBool",
      "content": " using UnityEngine; namespace ScriptableObjectVariables { [CreateAssetMenu(fileName = \"Bool\", menuName = \"Scriptable Object Variables/Bool Variable\")] public class VariableBool : ScriptableObject { #if UNITY_EDITOR [Multiline] public string DeveloperDescription = \"\"; #endif public bool Value; public void SetValue(bool value) { Value = value; } public void SetValue(VariableBool value) { Value = value.Value; } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "VariableBool",
          "content": "using UnityEngine; namespace ScriptableObjectVariables { [CreateAssetMenu(fileName = \"Bool\", menuName = \"Scriptable Object Variables/Bool Variable\")] public class VariableBool : ScriptableObject { #if UNITY_EDITOR [Multiline] public string DeveloperDescription = \"\"; #endif public bool Value; public void SetValue(bool value) { Value = value; } public void SetValue(VariableBool value) { Value = value.Value; } } }",
          "content_tokens": 107,
          "embedding": []
        }
      ],
      "length": 416
    },
    {
      "filename": "VariableFloat",
      "content": " using UnityEngine; namespace ScriptableObjectVariables { [CreateAssetMenu(fileName = \"Float\", menuName = \"Scriptable Object Variables/Float Variable\")] public class VariableFloat : ScriptableObject { #if UNITY_EDITOR [Multiline] public string DeveloperDescription = \"\"; #endif public float Value; public void SetValue(float value) { Value = value; } public void SetValue(VariableFloat value) { Value = value.Value; } public void ApplyChange(float amount) { Value += amount; } public void ApplyChange(VariableFloat amount) { Value += amount.Value; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "VariableFloat",
          "content": "using UnityEngine; namespace ScriptableObjectVariables { [CreateAssetMenu(fileName = \"Float\", menuName = \"Scriptable Object Variables/Float Variable\")] public class VariableFloat : ScriptableObject { #if UNITY_EDITOR [Multiline] public string DeveloperDescription = \"\"; #endif public float Value; public void SetValue(float value) { Value = value; } public void SetValue(VariableFloat value) { Value = value.Value; } public void ApplyChange(float amount) { Value += amount; } public void ApplyChange(VariableFloat amount) { Value += amount.Value; } } }",
          "content_tokens": 134,
          "embedding": []
        }
      ],
      "length": 553
    },
    {
      "filename": "VariableInt",
      "content": " using UnityEngine; namespace ScriptableObjectVariables { /// <summary> /// You can modify scriptable variables in play mode and store data between levels, better than singleton. /// </summary> [CreateAssetMenu(fileName = \"Int\", menuName = \"Scriptable Object Variables/Int Variable\")] public class VariableInt : ScriptableObject { #if UNITY_EDITOR [Multiline] public string DeveloperDescription = \"\"; #endif public int Value; public void SetValue(int value) { Value = value; } public void SetValue(VariableInt value) { Value = value.Value; } public void ApplyChange(int amount) { Value += amount; } public void ApplyChange(VariableInt amount) { Value += amount.Value; } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "VariableInt",
          "content": "using UnityEngine; namespace ScriptableObjectVariables { /// <summary> /// You can modify scriptable variables in play mode and store data between levels, better than singleton. /// </summary> [CreateAssetMenu(fileName = \"Int\", menuName = \"Scriptable Object Variables/Int Variable\")] public class VariableInt : ScriptableObject { #if UNITY_EDITOR [Multiline] public string DeveloperDescription = \"\"; #endif public int Value; public void SetValue(int value) { Value = value; } public void SetValue(VariableInt value) { Value = value.Value; } public void ApplyChange(int amount) { Value += amount; } public void ApplyChange(VariableInt amount) { Value += amount.Value; } } }",
          "content_tokens": 163,
          "embedding": []
        }
      ],
      "length": 673
    },
    {
      "filename": "VariableString",
      "content": " using UnityEngine; namespace ScriptableObjectVariables { [CreateAssetMenu(fileName = \"String\", menuName = \"Scriptable Object Variables/String Variable\")] public class VariableString : ScriptableObject { [SerializeField] private string value = \"\"; public string Value { get { return value; } set { this.value = value; } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "VariableString",
          "content": "using UnityEngine; namespace ScriptableObjectVariables { [CreateAssetMenu(fileName = \"String\", menuName = \"Scriptable Object Variables/String Variable\")] public class VariableString : ScriptableObject { [SerializeField] private string value = \"\"; public string Value { get { return value; } set { this.value = value; } } } }",
          "content_tokens": 78,
          "embedding": []
        }
      ],
      "length": 325
    },
    {
      "filename": "DebugWrite",
      "content": "using System; using System.IO; using System.Text.RegularExpressions; using UnityEditor; using UnityEngine; namespace DungeonScrollerCore { public class DebugWrite { private static string _filePath; private static bool isInitiated = false; private static void FirstInit() { DateTime currentTime = DateTime.Now; var datePrefix = $\"{currentTime.Year}.{currentTime.Month}.{currentTime.Day}[{currentTime.Hour}-{currentTime.Minute}]\"; string folderName = \"Logs\"; Directory.CreateDirectory(Application.streamingAssetsPath + $\"/{folderName}/\"); _filePath = Application.streamingAssetsPath + $\"/{folderName}/{datePrefix}.txt\"; isInitiated = true; #if !UNITY_EDITOR && !UNITY_ANDROID if (!File.Exists(_filePath)) File.WriteAllText(_filePath, \" \"); #endif } private static string CurrentDateTime() { DateTime currentTime = DateTime.Now; return $\"[{currentTime.Year}-{currentTime.Month}-{currentTime.Day}]-[{currentTime.Hour}-{currentTime.Minute}-{currentTime.Second}] \"; } public static void LogError(string logText, GameObject go = null, bool isShowLog = true) { AnyLog(logText, go, isShowLog, true); } public static void Log(string logText, GameObject go = null, bool isShowLog = true) { AnyLog(logText, go, isShowLog, false); } private static void AnyLog(string logText, GameObject go, bool isShowLog, bool isError) { if (!isInitiated) FirstInit(); String noTags = Regex.Replace(logText, @\"<[^>]*>\", String.Empty); var modifyLogText = CurrentDateTime() + noTags; if (isShowLog) { #if UNITY_EDITOR if (isError) Debug.LogError(logText, go); else Debug.Log(logText, go); #else if (isError) Debug.LogError(modifyLogText, go); else Debug.Log(modifyLogText, go); #endif } #if !UNITY_EDITOR && !UNITY_ANDROID try { StreamWriter fileWriter = new StreamWriter(_filePath, true); fileWriter.Write(modifyLogText +\"\\n\"); fileWriter.Close(); } catch (Exception e) { Debug.LogError(\"Cannot write into the file!\"); throw; } #endif } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "DebugWrite",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "DebugWrite",
          "content": "using System; using System.IO; using System.Text.RegularExpressions; using UnityEditor; using UnityEngine; namespace DungeonScrollerCore { public class DebugWrite { private static string _filePath; private static bool isInitiated = false; private static void FirstInit() { DateTime currentTime = DateTime.Now; var datePrefix = $\"{currentTime.Year}.{currentTime.Month}.{currentTime.Day}[{currentTime.Hour}-{currentTime.Minute}]\"; string folderName = \"Logs\"; Directory.CreateDirectory(Application.streamingAssetsPath + $\"/{folderName}/\"); _filePath = Application.streamingAssetsPath + $\"/{folderName}/{datePrefix}.txt\"; isInitiated = true; #if !UNITY_EDITOR && !UNITY_ANDROID if (!File.Exists(_filePath)) File.WriteAllText(_filePath, \" \"); #endif } private static string CurrentDateTime() { DateTime currentTime = DateTime.Now; return $\"[{currentTime.Year}-{currentTime.Month}-{currentTime.Day}]-[{currentTime.Hour}-{currentTime.Minute}-{currentTime.Second}] \"; } public static void LogError(string logText, GameObject go = null, bool isShowLog = true) { AnyLog(logText, go, isShowLog, true); } public static void Log(string logText, GameObject go = null, bool isShowLog = true) { AnyLog(logText, go, isShowLog, false); } private static void AnyLog(string logText, GameObject go, bool isShowLog, bool isError) { if (!isInitiated) FirstInit(); String noTags = Regex.Replace(logText, @\"<[^>]*>\", String.Empty); var modifyLogText = CurrentDateTime() + noTags; if (isShowLog) { #if UNITY_EDITOR if (isError) Debug.LogError(logText, go); else Debug.Log(logText, go); #else if (isError) Debug.LogError(modifyLogText, go); else Debug.Log(modifyLogText, go); #endif } #if !UNITY_EDITOR && !UNITY_ANDROID try { StreamWriter fileWriter = new StreamWriter(_filePath, true); fileWriter.Write(modifyLogText +\"\\n\"); fileWriter.Close();  ",
          "content_tokens": 561,
          "embedding": []
        },
        {
          "cs_scriptfile": "DebugWrite",
          "content": "catch (Exception e) { Debug.LogError(\"Cannot write into the file!\"); throw; } #endif } } }",
          "content_tokens": 27,
          "embedding": []
        }
      ],
      "length": 1912
    },
    {
      "filename": "MasterManager",
      "content": " using System.Collections.Generic; using Invector.vItemManager; using UnityEngine; using ScriptableObjectVariables; namespace SingletonsExtension { [CreateAssetMenu(menuName = \"Assets/MasterManager\")]//Only one copy for entire project public class MasterManager : SingletonScriptableObject<MasterManager> { [SerializeField] private vItemListData _itemListData; public vItemListData ItemListData => _itemListData; [SerializeField] private StatsLibrary _statsLibrary; public StatsLibrary StatsLibrary => _statsLibrary; [SerializeField] private AbilityDefinitionHolder _abilityDefinitionHolder; public AbilityDefinitionHolder AbilityDefinitionHolder => _abilityDefinitionHolder; // public const string KeyTalentsData = \"Talents\"; // public const string KeyIsGraphCantBeLaunched = \"KeyIsGraphCantBeLaunched\"; // public const string KeyIsNeedToCheckBeatsVisual = \"KeyIsNeedToCheckBeatsVisual\";//0 - graph, 1 - UI // public const string KeyOptionBeatsVisual = \"KeyOptionBeatsVisual\";//0 - graph, 1 - UI public bool IsClient => _IsClientVariableBool.Value; public bool IsServer => _IsServerVariableBool.Value; [SerializeField] private GameObject[] entityPrefabsPremadePlot; [SerializeField] private Transform _player; private bool _isServer; public bool IsPlayerPersist = false; public Vector3 GetPlayerPosition() => _player.transform.position; /// <summary> /// Variables: can be edited in editor and accessed from anywhere, values does not persist between game launches /// </summary> [Header(\"Variables:\")] [SerializeField] private VariableString _userId; public string UserId => _userId.Value; public void SetUserId(int userId) { Debug.Log($\"[MasterManager.SetUserId] userId: {userId}\"); _userId.Value = userId.ToString(); } [SerializeField] private VariableString _userEmail; public string UserEmail => _userEmail.Value; public void SetUserEmail(string email) { Debug.Log($\"[MasterManager.SetUserEmail] email: {email}\"); _userEmail.Value = email; } [SerializeField] private VariableBool _IsClientVariableBool; [SerializeField] private VariableBool _IsServerVariableBool; //[field: SerializeField] public Channel3DPropertiesSO GlobalPositionalChannelProperties { get; private set; } [SerializeField] private Mesh[] _terrainsMeshes; /// <summary> /// impostors have lower tris, so we will keep them too /// </summary> [SerializeField] private Mesh[] _terrainsMeshesLowTris; [SerializeField] private Material[] _terrainsMaterials; [SerializeField] private VariableString _userName; public string UserName => _userName.Value; public void SetUsername(string username) { Debug.Log($\"[MasterManager.SetUsername] username: {username}\"); _userName.Value = username; } public string Token => _token; [SerializeField] private string _token; public void SetToken(string token) { Debug.Log($\"[MasterManager.SetToken] token: {token}\"); _token = token; } //[SerializeField] public VariableStringDictionaryInventory _inventoryConverter; public void SetLocalPlayerTransform(Transform trans) { Debug.Log($\"[MasterManager.SetLocalPlayerTransform] name: {trans.name}\"); IsPlayerPersist = true; _player = trans; } public void SetServer(bool isOn) => _IsServerVariableBool.Value = isOn; public void SetClient(bool isOn) => _IsClientVariableBool.Value = isOn; public Mesh[] GetTerrainsMeshes() => _terrainsMeshes; public Mesh[] GetTerrainMesheLowRes() => _terrainsMeshesLowTris; public Material[] GetTerrainMaterial() => _terrainsMaterials; public GameObject GetEntityPrefab(int id) => entityPrefabsPremadePlot[id]; // [SerializeField] PlayerData _playerData; // [SerializeField] DatabaseXP _databaseXP; // [SerializeField] MonsterData _monsterData; // [SerializeField] TalentsDB _talentsDB; // // public static AdmobScriptableObject AdmobManager { get {return Instance._admobManager;}} // public static PlayerData GetPlayerDataManager { get {return Instance._playerData;} } // public static DatabaseXP lDatabaseXP { get { return Instance._databaseXP; } } // public static MonsterData lMonsterData { get { return Instance._monsterData; } } // public static TalentsDB GetTalentsDB { get { return Instance._talentsDB; } } //public static bool isNoAdsOwned => _isNoAdsOwned.Value; //public static bool isHitCrit { get { return _isHitCrit.Value; } } // private void Awake() { // Debug.Log(\"MasterManager Awake\"); // Instance._IsClientVariableBool.Value = false; // Instance.IsPlayerPersist = false; // } [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)] private static void FirstInitialize() { //AdmobManager.CustomAwake(); } public static vItem GetVItem(int itemID) { return Instance.ItemListData.GetItem(itemID); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "MasterManager",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "MasterManager",
          "content": " using System.Collections.Generic; using Invector.vItemManager; using UnityEngine; using ScriptableObjectVariables; namespace SingletonsExtension { [CreateAssetMenu(menuName = \"Assets/MasterManager\")]//Only one copy for entire project public class MasterManager : SingletonScriptableObject<MasterManager> { [SerializeField] private vItemListData _itemListData; public vItemListData ItemListData => _itemListData; [SerializeField] private StatsLibrary _statsLibrary; public StatsLibrary StatsLibrary => _statsLibrary; [SerializeField] private AbilityDefinitionHolder _abilityDefinitionHolder; public AbilityDefinitionHolder AbilityDefinitionHolder => _abilityDefinitionHolder; // public const string KeyTalentsData = \"Talents\"; // public const string KeyIsGraphCantBeLaunched = \"KeyIsGraphCantBeLaunched\"; // public const string KeyIsNeedToCheckBeatsVisual = \"KeyIsNeedToCheckBeatsVisual\";//0 - graph, 1 - UI // public const string KeyOptionBeatsVisual = \"KeyOptionBeatsVisual\";//0 - graph, 1 - UI public bool IsClient => _IsClientVariableBool.Value; public bool IsServer => _IsServerVariableBool.Value; [SerializeField] private GameObject[] entityPrefabsPremadePlot; [SerializeField] private Transform _player; private bool _isServer; public bool IsPlayerPersist = false; public Vector3 GetPlayerPosition() => _player.transform.position; /// <summary> /// Variables: can be edited in editor and accessed from anywhere, values does not persist between game launches /// </summary> [Header(\"Variables:\")] [SerializeField] private VariableString _userId; public string UserId => _userId.Value; public void SetUserId(int userId) { Debug.Log($\"[MasterManager.SetUserId] userId: {userId}\"); _userId.Value = userId.ToString(); } [SerializeField] private VariableString _userEmail; public string UserEmail => _userEmail.Value; public void SetUserEmail(string email) { Debug.Log($\"[MasterManager.SetUserEmail] email: {email}\"); _userEmail.Value = email; } [SerializeField] private VariableBool _IsClientVariableBool; [SerializeField] private VariableBool _IsServerVariableBool; //[field: SerializeField] public Channel3DPropertiesSO GlobalPositionalChannelProperties { get; private set; } [SerializeField] private Mesh[] _terrainsMeshes; /// <summary> /// impostors have lower tris, so we will keep them too /// </summary> [SerializeField] private Mesh[] _terrainsMeshesLowTris; [SerializeField] private Material[] _terrainsMaterials; [SerializeField] private VariableString _userName; public string UserName => _userName.Value; public void SetUsername(string username) { Debug.Log($\"[MasterManager.SetUsername] username: {username}\"); _userName.Value = username; } public string Token => _token; [SerializeField] private string _token; public void SetToken(string token) { Debug.Log($\"[MasterManager.SetToken] token: {token}\"); _token = token; } //[SerializeField] public VariableStringDictionaryInventory _inventoryConverter; public void SetLocalPlayerTransform(Transform trans) { Debug.Log($\"[MasterManager.SetLocalPlayerTransform] name: {trans.name}\"); IsPlayerPersist = true; _player = trans;  ",
          "content_tokens": 799,
          "embedding": []
        },
        {
          "cs_scriptfile": "MasterManager",
          "content": "public void SetServer(bool isOn) => _IsServerVariableBool.Value = isOn; public void SetClient(bool isOn) => _IsClientVariableBool.Value = isOn; public Mesh[] GetTerrainsMeshes() => _terrainsMeshes; public Mesh[] GetTerrainMesheLowRes() => _terrainsMeshesLowTris; public Material[] GetTerrainMaterial() => _terrainsMaterials; public GameObject GetEntityPrefab(int id) => entityPrefabsPremadePlot[id]; // [SerializeField] PlayerData _playerData; // [SerializeField] DatabaseXP _databaseXP; // [SerializeField] MonsterData _monsterData; // [SerializeField] TalentsDB _talentsDB; // // public static AdmobScriptableObject AdmobManager { get {return Instance._admobManager;}} // public static PlayerData GetPlayerDataManager { get {return Instance._playerData;} } // public static DatabaseXP lDatabaseXP { get { return Instance._databaseXP; } } // public static MonsterData lMonsterData { get { return Instance._monsterData; } } // public static TalentsDB GetTalentsDB { get { return Instance._talentsDB; } } //public static bool isNoAdsOwned => _isNoAdsOwned.Value; //public static bool isHitCrit { get { return _isHitCrit.Value; } } // private void Awake() { // Debug.Log(\"MasterManager Awake\"); // Instance._IsClientVariableBool.Value = false; // Instance.IsPlayerPersist = false; // } [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)] private static void FirstInitialize() { //AdmobManager.CustomAwake(); } public static vItem GetVItem(int itemID) { return Instance.ItemListData.GetItem(itemID); } } }",
          "content_tokens": 432,
          "embedding": []
        }
      ],
      "length": 4616
    },
    {
      "filename": "Math",
      "content": "using System; using System.Collections; using System.Collections.Generic; using System.Globalization; using System.Runtime.CompilerServices; using UnityEngine; namespace CommonMath { [Serializable] public struct Vector3d { public const double KEpsilon = 0.000000001; public const double KEpsilonNormalSqrt = 1e-64; public double x, y, z; [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector3d(double x, double y, double z) { this.x = x; this.y = y; this.z = z; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector3d(double x, double y) { this.x = x; this.y = y; z = 0.0; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector3d(Vector3 v) { this.x = v.x; this.y = v.y; z = v.z; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Set(double newX, double newY, double newZ) { x = newX; y = newY; z = newZ; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d Lerp(Vector3d a, Vector3d b, double t) { t = Math.Clamp01(t); return new Vector3d( a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t ); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d LerpUnclamped(Vector3d a, Vector3d b, double t) { return new Vector3d( a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t ); } public double this[int index] { get { return index switch { 0 => x, 1 => y, 2 => z, _ => throw new IndexOutOfRangeException(\"Invalid Vector3d index!\") }; } set { switch (index) { case 0: x = value; break; case 1: y = value; break; case 2: z = value; break; default: throw new IndexOutOfRangeException(\"Invalid Vector3d index!\"); } } } public Vector3 UnityVector => new Vector3((float) x, (float) y, (float) z); [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d Scale(Vector3d a, Vector3d b) { return new Vector3d(a.x * b.x, a.y * b.y, a.z * b.z); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Scale(Vector3d scale) { x *= scale.x; y *= scale.y; z *= scale.z; } public static Vector3d Cross(Vector3d lhs, Vector3d rhs) { return new Vector3d( lhs.y * rhs.z - lhs.z * rhs.y, lhs.z * rhs.x - lhs.x * rhs.z, lhs.x * rhs.y - lhs.y * rhs.x); } public override int GetHashCode() { return x.GetHashCode() ^ (y.GetHashCode() << 2) ^ (z.GetHashCode() >> 2); } public override bool Equals(object other) { return other is Vector3d vector3d && Equals(vector3d); } public bool Equals(Vector3d other) { return System.Math.Abs(x - other.x) < double.Epsilon && System.Math.Abs(y - other.y) < double.Epsilon && System.Math.Abs(z - other.z) < double.Epsilon; } public static Vector3d Normalize(Vector3d value) { var mag = value.Magnitude; if (mag > KEpsilon) return value / mag; else return ZeroVector; } public void Normalize() { var mag = this.Magnitude; if (mag > KEpsilon) this = this / mag; else this = ZeroVector; } public Vector3d Normalized => Vector3d.Normalize(this); [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Dot(Vector3d lhs, Vector3d rhs) { return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z; } public static Vector3d Project(Vector3d vector, Vector3d onNormal) { var sqrMag = Dot(onNormal, onNormal); if (sqrMag < double.Epsilon) return ZeroVector; else { var dot = Dot(vector, onNormal); return new Vector3d(onNormal.x * dot / sqrMag, onNormal.y * dot / sqrMag, onNormal.z * dot / sqrMag); } } public static Vector3d ProjectOnPlane(Vector3d vector, Vector3d planeNormal) { var sqrMag = Dot(planeNormal, planeNormal); if (sqrMag < double.Epsilon) return vector; else { var dot = Dot(vector, planeNormal); return new Vector3d(vector.x - planeNormal.x * dot / sqrMag, vector.y - planeNormal.y * dot / sqrMag, vector.z - planeNormal.z * dot / sqrMag); } } public static double Angle(Vector3d from, Vector3d to) { // sqrt(a) * sqrt(b) = sqrt(a * b) -- valid for real numbers var denominator = System.Math.Sqrt(from.SqrMagnitude * to.SqrMagnitude); if (denominator < KEpsilonNormalSqrt) return 0.0; var dot = Math.Clamp(Dot(from, to) / denominator, -1.0, 1.0); return (System.Math.Acos(dot)) * Math.Rad2Deg; } public static double SignedAngle(Vector3d from, Vector3d to, Vector3d axis) { var unsignedAngle = Angle(from, to); var crossX = from.y * to.z - from.z * to.y; var crossY = from.z * to.x - from.x * to.z; var crossZ = from.x * to.y - from.y * to.x; var sign = System.Math.Sign(axis.x * crossX + axis.y * crossY + axis.z * crossZ); return unsignedAngle * sign; } public static double Distance(Vector3d a, Vector3d b) { var diffX = a.x - b.x; var diffY = a.y - b.y; var diffZ = a.z - b.z; return System.Math.Sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Length(Vector3d vector) => System.Math.Sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z); [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double SqrLength(Vector3d vector) => (vector.x * vector.x + vector.y * vector.y + vector.z * vector.z); public double Magnitude => System.Math.Sqrt(x * x + y * y + z * z); public double SqrMagnitude => (x * x + y * y + z * z); [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d Min(Vector3d lhs, Vector3d rhs) { return new Vector3d(System.Math.Min(lhs.x, rhs.x), System.Math.Min(lhs.y, rhs.y), System.Math.Min(lhs.z, rhs.z)); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d Max(Vector3d lhs, Vector3d rhs) { return new Vector3d(System.Math.Max(lhs.x, rhs.x), System.Math.Max(lhs.y, rhs.y), System.Math.Max(lhs.z, rhs.z)); } public static readonly Vector3d ZeroVector = new Vector3d(0.0, 0.0, 0.0); public static readonly Vector3d OneVector = new Vector3d(1.0, 1.0, 1.0); public static readonly Vector3d UpVector = new Vector3d(0.0, 1.0, 0.0); public static readonly Vector3d DownVector = new Vector3d(0.0, -1.0, 0.0); public static readonly Vector3d LeftVector = new Vector3d(-1.0, 0.0, 0.0); public static readonly Vector3d RightVector = new Vector3d(1.0, 0.0, 0.0); public static readonly Vector3d ForwardVector = new Vector3d(0.0, 0.0, 1.0); public static readonly Vector3d BackVector = new Vector3d(0.0, 0.0, -1.0); public static readonly Vector3d PositiveInfinityVector = new Vector3d(double.PositiveInfinity, double.PositiveInfinity, double.PositiveInfinity); public static readonly Vector3d NegativeInfinityVector = new Vector3d(double.NegativeInfinity, double.NegativeInfinity, double.NegativeInfinity); [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d operator+(Vector3d a, Vector3d b) { return new Vector3d(a.x + b.x, a.y + b.y, a.z + b.z); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d operator-(Vector3d a, Vector3d b) { return new Vector3d(a.x - b.x, a.y - b.y, a.z - b.z); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d operator-(Vector3d a) { return new Vector3d(-a.x, -a.y, -a.z); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d operator*(Vector3d a, double d) { return new Vector3d(a.x * d, a.y * d, a.z * d); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d operator*(double d, Vector3d a) { return new Vector3d(a.x * d, a.y * d, a.z * d); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d operator/(Vector3d a, double d) { return new Vector3d(a.x / d, a.y / d, a.z / d); } public static bool operator==(Vector3d lhs, Vector3d rhs) { // Returns false in the presence of NaN values. var diffX = lhs.x - rhs.x; var diffY = lhs.y - rhs.y; var diffZ = lhs.z - rhs.z; var sqrMag = diffX * diffX + diffY * diffY + diffZ * diffZ; return sqrMag < KEpsilon * KEpsilon; } public static bool operator!=(Vector3d lhs, Vector3d rhs) { // Returns true in the presence of NaN values. return !(lhs == rhs); } public override string ToString() { return ToString(null, CultureInfo.InvariantCulture.NumberFormat); } public string ToString(string format) { return ToString(format, CultureInfo.InvariantCulture.NumberFormat); } public string ToString(string format, IFormatProvider formatProvider) { if (string.IsNullOrEmpty(format)) format = \"F1\"; return $\"({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)})\"; } } public static class Math { public static bool IsWithinRange(Vector3 A, Vector3 B, float range) { float sqrRange = range * range; return (A - B).sqrMagnitude <= sqrRange; } public const double Rad2Deg = 57.29577951308232; [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Pow2(float x) => x * x; [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Pow2(double x) => x * x; [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Pow2(int x) => x * x; public static double Clamp01(double x) { if (x > 1) return 1; if (x < 0) return 0; return x; } public static double Clamp(double value, double min, double max) { if (value < min) value = min; else if (value > max) value = max; return value; } public static Tuple<long, long> SumTuples(Tuple<long, long> a, Tuple<long, long> b) { return new Tuple<long, long>(a.Item1 + b.Item1, a.Item2 + b.Item2); } public static Tuple<double, double> SumTuples(Tuple<double, double> a, Tuple<double, double> b) { return new Tuple<double, double>(a.Item1 + b.Item1, a.Item2 + b.Item2); } public static Tuple<int, int> SumTuples(Tuple<int, int> a, Tuple<int, int> b) { return new Tuple<int, int>(a.Item1 + b.Item1, a.Item2 + b.Item2); } public static Tuple<float, float> SumTuples(Tuple<float, float> a, Tuple<float, float> b) { return new Tuple<float, float>(a.Item1 + b.Item1, a.Item2 + b.Item2); } public static Tuple<long, long> SumTuples(Tuple<long, long> a, Tuple<short, short> b) { return new Tuple<long, long>(a.Item1 + b.Item1, a.Item2 + b.Item2); } public static Tuple<long, long> DiffTuples(Tuple<long, long> a, Tuple<long, long> b) { return new Tuple<long, long>(a.Item1 - b.Item1, a.Item2 - b.Item2); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "Math",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "Math",
          "content": "using System; using System.Collections; using System.Collections.Generic; using System.Globalization; using System.Runtime.CompilerServices; using UnityEngine; namespace CommonMath { [Serializable] public struct Vector3d { public const double KEpsilon = 0.000000001; public const double KEpsilonNormalSqrt = 1e-64; public double x, y, z; [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector3d(double x, double y, double z) { this.x = x; this.y = y; this.z = z; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector3d(double x, double y) { this.x = x; this.y = y; z = 0.0; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public Vector3d(Vector3 v) { this.x = v.x; this.y = v.y; z = v.z; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Set(double newX, double newY, double newZ) { x = newX; y = newY; z = newZ; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d Lerp(Vector3d a, Vector3d b, double t) { t = Math.Clamp01(t); return new Vector3d( a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t ); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d LerpUnclamped(Vector3d a, Vector3d b, double t) { return new Vector3d( a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t ); } public double this[int index] { get { return index switch { 0 => x, 1 => y, 2 => z, _ => throw new IndexOutOfRangeException(\"Invalid Vector3d index!\") }; } set { switch (index) { case 0: x = value; break; case 1: y = value; break; case 2: z = value; break; default: throw new IndexOutOfRangeException(\"Invalid Vector3d index!\"); } } } public Vector3 UnityVector => new Vector3((float) x, (float) y, (float) z); [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d Scale(Vector3d a, Vector3d b) { return new Vector3d(a.x * b.x, a.y * b.y, a.z * b.z); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Scale(Vector3d scale) { x *= scale.x; y *= scale.y; z *= scale.z; } public static Vector3d Cross(Vector3d lhs, Vector3d rhs) { return new Vector3d( lhs.y * rhs.z - lhs.z * rhs.y, lhs.z * rhs.x - lhs.x * rhs.z, lhs.x * rhs.y - lhs.y * rhs.x); } public override int GetHashCode() { return x.GetHashCode() ^ (y.GetHashCode() << 2) ^ (z.GetHashCode() >> 2); } public override bool Equals(object other) { return other is Vector3d vector3d && Equals(vector3d);  ",
          "content_tokens": 846,
          "embedding": []
        },
        {
          "cs_scriptfile": "Math",
          "content": "public bool Equals(Vector3d other) { return System.Math.Abs(x - other.x) < double.Epsilon && System.Math.Abs(y - other.y) < double.Epsilon && System.Math.Abs(z - other.z) < double.Epsilon; } public static Vector3d Normalize(Vector3d value) { var mag = value.Magnitude; if (mag > KEpsilon) return value / mag; else return ZeroVector;  ",
          "content_tokens": 112,
          "embedding": []
        },
        {
          "cs_scriptfile": "Math",
          "content": "public void Normalize() { var mag = this.Magnitude; if (mag > KEpsilon) this = this / mag; else this = ZeroVector; } public Vector3d Normalized => Vector3d.Normalize(this); [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Dot(Vector3d lhs, Vector3d rhs) { return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z; } public static Vector3d Project(Vector3d vector, Vector3d onNormal) { var sqrMag = Dot(onNormal, onNormal); if (sqrMag < double.Epsilon) return ZeroVector; else { var dot = Dot(vector, onNormal); return new Vector3d(onNormal.x * dot / sqrMag, onNormal.y * dot / sqrMag, onNormal.z * dot / sqrMag); } } public static Vector3d ProjectOnPlane(Vector3d vector, Vector3d planeNormal) { var sqrMag = Dot(planeNormal, planeNormal); if (sqrMag < double.Epsilon) return vector; else { var dot = Dot(vector, planeNormal); return new Vector3d(vector.x - planeNormal.x * dot / sqrMag, vector.y - planeNormal.y * dot / sqrMag, vector.z - planeNormal.z * dot / sqrMag); } } public static double Angle(Vector3d from, Vector3d to) { // sqrt(a) * sqrt(b) = sqrt(a * b) -- valid for real numbers var denominator = System.Math.Sqrt(from.SqrMagnitude * to.SqrMagnitude); if (denominator < KEpsilonNormalSqrt) return 0.0; var dot = Math.Clamp(Dot(from, to) / denominator, -1.0, 1.0); return (System.Math.Acos(dot)) * Math.Rad2Deg; } public static double SignedAngle(Vector3d from, Vector3d to, Vector3d axis) { var unsignedAngle = Angle(from, to); var crossX = from.y * to.z - from.z * to.y; var crossY = from.z * to.x - from.x * to.z; var crossZ = from.x * to.y - from.y * to.x; var sign = System.Math.Sign(axis.x * crossX + axis.y * crossY + axis.z * crossZ); return unsignedAngle * sign; } public static double Distance(Vector3d a, Vector3d b) { var diffX = a.x - b.x; var diffY = a.y - b.y; var diffZ = a.z - b.z; return System.Math.Sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Length(Vector3d vector) => System.Math.Sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z); [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double SqrLength(Vector3d vector) => (vector.x * vector.x + vector.y * vector.y + vector.z * vector.z); public double Magnitude => System.Math.Sqrt(x * x + y * y + z * z); public double SqrMagnitude => (x * x + y * y + z * z); [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d Min(Vector3d lhs, Vector3d rhs) { return new Vector3d(System.Math.Min(lhs.x, rhs.x), System.Math.Min(lhs.y, rhs.y), System.Math.Min(lhs.z, rhs.z)); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d Max(Vector3d lhs, Vector3d rhs) { return new Vector3d(System.Math.Max(lhs.x, rhs.x), System.Math.Max(lhs.y, rhs.y), System.Math.Max(lhs.z, rhs.z)); } public static readonly Vector3d ZeroVector = new Vector3d(0.0, 0.0, 0.0); public static readonly Vector3d OneVector = new Vector3d(1.0, 1.0, 1.0); public static readonly Vector3d UpVector = new Vector3d(0.0, 1.0, 0.0); public static readonly Vector3d DownVector = new Vector3d(0.0, -1.0, 0.0); public static readonly Vector3d LeftVector = new Vector3d(-1.0, 0.0, 0.0); public static readonly Vector3d RightVector = new Vector3d(1.0, 0.0, 0.0); public static readonly Vector3d ForwardVector = new Vector3d(0.0, 0.0, 1.0); public static readonly Vector3d BackVector = new Vector3d(0.0, 0.0, -1.0); public static readonly Vector3d PositiveInfinityVector = new Vector3d(double.PositiveInfinity, double.PositiveInfinity, double.PositiveInfinity); public static readonly Vector3d NegativeInfinityVector = new Vector3d(double.NegativeInfinity, double.NegativeInfinity, double.NegativeInfinity); [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d operator+(Vector3d a, Vector3d b) { return new Vector3d(a.x + b.x, a.y + b.y, a.z + b.z); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d operator-(Vector3d a, Vector3d b) { return new Vector3d(a.x - b.x, a.y - b.y, a.z - b.z); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d operator-(Vector3d a) { return new Vector3d(-a.x, -a.y, -a.z); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d operator*(Vector3d a, double d) { return new Vector3d(a.x * d, a.y * d, a.z * d); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d operator*(double d, Vector3d a) { return new Vector3d(a.x * d, a.y * d, a.z * d); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Vector3d operator/(Vector3d a, double d) { return new Vector3d(a.x / d, a.y / d, a.z / d); } public static bool operator==(Vector3d lhs, Vector3d rhs) { // Returns false in the presence of NaN values. var diffX = lhs.x - rhs.x; var diffY = lhs.y - rhs.y; var diffZ = lhs.z - rhs.z; var sqrMag = diffX * diffX + diffY * diffY + diffZ * diffZ; return sqrMag < KEpsilon * KEpsilon; } public static bool operator!=(Vector3d lhs, Vector3d rhs) { // Returns true in the presence of NaN values. return !(lhs == rhs); } public override string ToString() { return ToString(null, CultureInfo.InvariantCulture.NumberFormat);  ",
          "content_tokens": 1813,
          "embedding": []
        },
        {
          "cs_scriptfile": "Math",
          "content": "public string ToString(string format) { return ToString(format, CultureInfo.InvariantCulture.NumberFormat);  ",
          "content_tokens": 29,
          "embedding": []
        },
        {
          "cs_scriptfile": "Math",
          "content": "public string ToString(string format, IFormatProvider formatProvider) { if (string.IsNullOrEmpty(format)) format = \"F1\"; return $\"({x.ToString(format, formatProvider)}, {y.ToString(format, formatProvider)}, {z.ToString(format, formatProvider)})\"; } } public static class Math { public static bool IsWithinRange(Vector3 A, Vector3 B, float range) { float sqrRange = range * range; return (A - B).sqrMagnitude <= sqrRange; } public const double Rad2Deg = 57.29577951308232; [MethodImpl(MethodImplOptions.AggressiveInlining)] public static float Pow2(float x) => x * x; [MethodImpl(MethodImplOptions.AggressiveInlining)] public static double Pow2(double x) => x * x; [MethodImpl(MethodImplOptions.AggressiveInlining)] public static int Pow2(int x) => x * x; public static double Clamp01(double x) { if (x > 1) return 1; if (x < 0) return 0; return x; } public static double Clamp(double value, double min, double max) { if (value < min) value = min; else if (value > max) value = max; return value; } public static Tuple<long, long> SumTuples(Tuple<long, long> a, Tuple<long, long> b) { return new Tuple<long, long>(a.Item1 + b.Item1, a.Item2 + b.Item2); } public static Tuple<double, double> SumTuples(Tuple<double, double> a, Tuple<double, double> b) { return new Tuple<double, double>(a.Item1 + b.Item1, a.Item2 + b.Item2); } public static Tuple<int, int> SumTuples(Tuple<int, int> a, Tuple<int, int> b) { return new Tuple<int, int>(a.Item1 + b.Item1, a.Item2 + b.Item2); } public static Tuple<float, float> SumTuples(Tuple<float, float> a, Tuple<float, float> b) { return new Tuple<float, float>(a.Item1 + b.Item1, a.Item2 + b.Item2); } public static Tuple<long, long> SumTuples(Tuple<long, long> a, Tuple<short, short> b) { return new Tuple<long, long>(a.Item1 + b.Item1, a.Item2 + b.Item2); } public static Tuple<long, long> DiffTuples(Tuple<long, long> a, Tuple<long, long> b) { return new Tuple<long, long>(a.Item1 - b.Item1, a.Item2 - b.Item2); } } }",
          "content_tokens": 669,
          "embedding": []
        }
      ],
      "length": 9983
    },
    {
      "filename": "ObjectsPool",
      "content": "using System.Collections.Generic; using UnityEngine; public class ObjectsPool<T> where T : Component { private Queue<T> _unusedObjectsPool = new Queue<T>(); private List<T> _usedObjectsPool = new List<T>(); private T _prefab; private Transform _parent; public ObjectsPool(Transform parent, T prefab, int size) { _parent = parent; _prefab = prefab; ResizePool(size); } public T Allocate() { if (_unusedObjectsPool.Count == 0) { ResizePool(_usedObjectsPool.Count + 1); } T obj = _unusedObjectsPool.Dequeue(); _usedObjectsPool.Add(obj); obj.gameObject.SetActive(true); return obj; } public void Deallocate(T obj) { if (_usedObjectsPool.Contains(obj)) { _usedObjectsPool.Remove(obj); _unusedObjectsPool.Enqueue(obj); obj.gameObject.SetActive(false); } else { Debug.LogError(\"Trying to deallocate an object that is not in the used pool.\"); } } private void ResizePool(int newSize) { if (newSize < _usedObjectsPool.Count) { Debug.LogError(\"Cannot resize the pool to a smaller size than the current used objects.\"); return; } for (int i = _unusedObjectsPool.Count + _usedObjectsPool.Count; i < newSize; i++) { T obj = Object.Instantiate(_prefab, _parent); obj.gameObject.SetActive(false); _unusedObjectsPool.Enqueue(obj); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ObjectsPool",
          "content": "using System.Collections.Generic; using UnityEngine; public class ObjectsPool<T> where T : Component { private Queue<T> _unusedObjectsPool = new Queue<T>(); private List<T> _usedObjectsPool = new List<T>(); private T _prefab; private Transform _parent; public ObjectsPool(Transform parent, T prefab, int size) { _parent = parent; _prefab = prefab; ResizePool(size); } public T Allocate() { if (_unusedObjectsPool.Count == 0) { ResizePool(_usedObjectsPool.Count + 1); } T obj = _unusedObjectsPool.Dequeue(); _usedObjectsPool.Add(obj); obj.gameObject.SetActive(true); return obj;  ",
          "content_tokens": 177,
          "embedding": []
        },
        {
          "cs_scriptfile": "ObjectsPool",
          "content": "public void Deallocate(T obj) { if (_usedObjectsPool.Contains(obj)) { _usedObjectsPool.Remove(obj); _unusedObjectsPool.Enqueue(obj); obj.gameObject.SetActive(false); } else { Debug.LogError(\"Trying to deallocate an object that is not in the used pool.\"); }  private void ResizePool(int newSize) { if (newSize < _usedObjectsPool.Count) { Debug.LogError(\"Cannot resize the pool to a smaller size than the current used objects.\"); return;  ",
          "content_tokens": 132,
          "embedding": []
        },
        {
          "cs_scriptfile": "ObjectsPool",
          "content": "for (int i = _unusedObjectsPool.Count + _usedObjectsPool.Count; i < newSize; i++) { T obj = Object.Instantiate(_prefab, _parent); obj.gameObject.SetActive(false); _unusedObjectsPool.Enqueue(obj); } } }",
          "content_tokens": 69,
          "embedding": []
        }
      ],
      "length": 1220
    },
    {
      "filename": "SingletonReferences",
      "content": "using UnityEngine; namespace SingletonsExtension { public class SingletonReferences : MonoBehaviour { public MasterManager _masterManager; void Start() { //MasterManager.AdmobManager.CustomAwake(); //MasterManager.GetPlayerDataManager.CustomAwake(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SingletonReferences",
          "content": "using UnityEngine; namespace SingletonsExtension { public class SingletonReferences : MonoBehaviour { public MasterManager _masterManager; void Start() { //MasterManager.AdmobManager.CustomAwake(); //MasterManager.GetPlayerDataManager.CustomAwake(); } } }",
          "content_tokens": 60,
          "embedding": []
        }
      ],
      "length": 255
    },
    {
      "filename": "SingletonScriptableObject",
      "content": " using UnityEngine; namespace SingletonsExtension { public abstract class SingletonScriptableObject<T> : ScriptableObject where T : ScriptableObject { private static T _instance = null; public static T Instance { get { if (_instance == null) { T[] results = Resources.FindObjectsOfTypeAll<T>(); if (results.Length == 0) { Debug.LogError(\"SingletonScriptableObject: result length is 0 of \" + typeof(T).ToString()); return null; }else if (results.Length > 1) { Debug.LogError(\"SingletonScriptableObject: result length is greater than 1 of \" + typeof(T).ToString()); for (int i = 1; i < results.Length; i++) Destroy(results[i]); } _instance = results[0]; _instance.hideFlags = HideFlags.DontUnloadUnusedAsset; } return _instance; } } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SingletonScriptableObject",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "SingletonScriptableObject",
          "content": "using UnityEngine; namespace SingletonsExtension { public abstract class SingletonScriptableObject<T> : ScriptableObject where T : ScriptableObject { private static T _instance = null; public static T Instance { get { if (_instance == null) { T[] results = Resources.FindObjectsOfTypeAll<T>(); if (results.Length == 0) { Debug.LogError(\"SingletonScriptableObject: result length is 0 of \" + typeof(T).ToString()); return null; }else if (results.Length > 1) { Debug.LogError(\"SingletonScriptableObject: result length is greater than 1 of \" + typeof(T).ToString()); for (int i = 1; i < results.Length; i++) Destroy(results[i]); } _instance = results[0]; _instance.hideFlags = HideFlags.DontUnloadUnusedAsset; } return _instance; } } } }",
          "content_tokens": 204,
          "embedding": []
        }
      ],
      "length": 734
    },
    {
      "filename": "SpinOnItsOwnAxis",
      "content": "using UnityEngine; public class SpinOnItsOwnAxis : MonoBehaviour { [SerializeField] private GameObject targetObject; // The object to rotate around [SerializeField] private float rotateSpeed = 50f; // The speed of rotation [SerializeField] private bool rotateAroundOwnAxis = true; // Flag to decide if the rotation is around own axis or another gameobject [SerializeField] public float coneAngle = 45f; // The angle of rotation in a cone shape // Update is called once per frame void Update() { if (rotateAroundOwnAxis) { // Rotate around own axis transform.Rotate(new Vector3(0, Time.deltaTime * rotateSpeed, 0), Space.Self); } else if (targetObject != null) { // Rotate around the target game object in a cone shape Vector3 directionToTarget = targetObject.transform.position - transform.position; Quaternion targetRotation = Quaternion.LookRotation(directionToTarget); float angle = Vector3.Angle(transform.up, directionToTarget.normalized); if (angle <= coneAngle) { transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, rotateSpeed * Time.deltaTime); } } } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "SpinOnItsOwnAxis",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "SpinOnItsOwnAxis",
          "content": "using UnityEngine; public class SpinOnItsOwnAxis : MonoBehaviour { [SerializeField] private GameObject targetObject; // The object to rotate around [SerializeField] private float rotateSpeed = 50f; // The speed of rotation [SerializeField] private bool rotateAroundOwnAxis = true; // Flag to decide if the rotation is around own axis or another gameobject [SerializeField] public float coneAngle = 45f; // The angle of rotation in a cone shape // Update is called once per frame void Update() { if (rotateAroundOwnAxis) { // Rotate around own axis transform.Rotate(new Vector3(0, Time.deltaTime * rotateSpeed, 0), Space.Self); } else if (targetObject != null) { // Rotate around the target game object in a cone shape Vector3 directionToTarget = targetObject.transform.position - transform.position; Quaternion targetRotation = Quaternion.LookRotation(directionToTarget); float angle = Vector3.Angle(transform.up, directionToTarget.normalized); if (angle <= coneAngle) { transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, rotateSpeed * Time.deltaTime); } } } }",
          "content_tokens": 282,
          "embedding": []
        }
      ],
      "length": 1092
    },
    {
      "filename": "StringToHexColor",
      "content": "using System; using System.Security.Cryptography; using System.Text; public static class StringToHexColor { public static string GetColor(string raw) { using (MD5 md5Hash = MD5.Create()) { byte[] data = md5Hash.ComputeHash(Encoding.UTF8.GetBytes(raw)); return BitConverter.ToString(data).Replace(\"-\", string.Empty).Substring(0, 6); } } public static string GetColoredClassName(Type T) { string colorStart = \"\"; string colorEnd = \"\"; #if UNITY_EDITOR colorStart = \"<color=#\" + GetColor(T.Name) + \">\"; colorEnd = \"</color>\"; #endif return $\"{colorStart}[{T.Name}]{colorEnd}\"; } public static string GetColorClamped(float currentValue, float maxValue) { string[] colorRange = {\"#ff0000\", \"#ff4000\", \"#ff8000\", \"#ffbf00\", \"#ffff00\", \"#bfff00\", \"##80ff00\", \"#40ff00\", \"#00ff00\"}; int index = (int) (currentValue / maxValue * colorRange.Length); index = Math.Min(index, colorRange.Length - 1); return colorRange[index]; } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "StringToHexColor",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "StringToHexColor",
          "content": "using System; using System.Security.Cryptography; using System.Text; public static class StringToHexColor { public static string GetColor(string raw) { using (MD5 md5Hash = MD5.Create()) { byte[] data = md5Hash.ComputeHash(Encoding.UTF8.GetBytes(raw)); return BitConverter.ToString(data).Replace(\"-\", string.Empty).Substring(0, 6); } } public static string GetColoredClassName(Type T) { string colorStart = \"\"; string colorEnd = \"\"; #if UNITY_EDITOR colorStart = \"<color=#\" + GetColor(T.Name) + \">\"; colorEnd = \"</color>\"; #endif return $\"{colorStart}[{T.Name}]{colorEnd}\"; } public static string GetColorClamped(float currentValue, float maxValue) { string[] colorRange = {\"#ff0000\", \"#ff4000\", \"#ff8000\", \"#ffbf00\", \"#ffff00\", \"#bfff00\", \"##80ff00\", \"#40ff00\", \"#00ff00\"}; int index = (int) (currentValue / maxValue * colorRange.Length); index = Math.Min(index, colorRange.Length - 1); return colorRange[index]; } }",
          "content_tokens": 289,
          "embedding": []
        }
      ],
      "length": 918
    },
    {
      "filename": "UIHeightSetter",
      "content": "using UnityEngine; using Sirenix.OdinInspector; using UnityEngine.UI; public class UIHeightSetter : MonoBehaviour { [SerializeField] private int additionalHeight; [SerializeField] private RectTransform[] rects; [SerializeField] private VerticalLayoutGroup layoutGroup; [Button] public void UpdateHeight() { CalcFromRects(); CalcFromLayoutGroup(); } private void CalcFromLayoutGroup() { if (layoutGroup == null) { return; } float totalHeight = 0; for (int i = 0; i < layoutGroup.transform.childCount; i++) { var child = layoutGroup.transform.GetChild(i); var childHeight = child.GetComponent<RectTransform>().sizeDelta.y; totalHeight += childHeight; totalHeight += layoutGroup.spacing; } gameObject.GetComponent<RectTransform>().sizeDelta = new Vector2(gameObject.GetComponent<RectTransform>().sizeDelta.x, totalHeight + additionalHeight); } private void CalcFromRects() { if (rects.Length == 0) { return; } float totalHeight = 0; for (int i = 0; i < rects.Length; i++) { var rectsHeight = rects[i].sizeDelta.y; totalHeight += rectsHeight; } gameObject.GetComponent<RectTransform>().sizeDelta = new Vector2(gameObject.GetComponent<RectTransform>().sizeDelta.x, totalHeight + additionalHeight); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "UIHeightSetter",
          "content": "using UnityEngine; using Sirenix.OdinInspector; using UnityEngine.UI; public class UIHeightSetter : MonoBehaviour { [SerializeField] private int additionalHeight; [SerializeField] private RectTransform[] rects; [SerializeField] private VerticalLayoutGroup layoutGroup; [Button] public void UpdateHeight() { CalcFromRects(); CalcFromLayoutGroup();  ",
          "content_tokens": 88,
          "embedding": []
        },
        {
          "cs_scriptfile": "UIHeightSetter",
          "content": "private void CalcFromLayoutGroup() { if (layoutGroup == null) { return; } float totalHeight = 0; for (int i = 0; i < layoutGroup.transform.childCount; i++) { var child = layoutGroup.transform.GetChild(i); var childHeight = child.GetComponent<RectTransform>().sizeDelta.y; totalHeight += childHeight; totalHeight += layoutGroup.spacing; } gameObject.GetComponent<RectTransform>().sizeDelta = new Vector2(gameObject.GetComponent<RectTransform>().sizeDelta.x, totalHeight + additionalHeight);  ",
          "content_tokens": 133,
          "embedding": []
        },
        {
          "cs_scriptfile": "UIHeightSetter",
          "content": "private void CalcFromRects() { if (rects.Length == 0) { return; } float totalHeight = 0; for (int i = 0; i < rects.Length; i++) { var rectsHeight = rects[i].sizeDelta.y; totalHeight += rectsHeight; } gameObject.GetComponent<RectTransform>().sizeDelta = new Vector2(gameObject.GetComponent<RectTransform>().sizeDelta.x, totalHeight + additionalHeight); } }",
          "content_tokens": 108,
          "embedding": []
        }
      ],
      "length": 1196
    },
    {
      "filename": "UIResetPositionOnAwake",
      "content": "using UnityEngine; public class UIResetPositionOnAwake : MonoBehaviour { void Awake() { GetComponent<RectTransform>().localPosition = Vector3.zero; DestroyImmediate(this); } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "UIResetPositionOnAwake",
          "content": "using UnityEngine; public class UIResetPositionOnAwake : MonoBehaviour { void Awake() { GetComponent<RectTransform>().localPosition = Vector3.zero; DestroyImmediate(this); } }",
          "content_tokens": 47,
          "embedding": []
        }
      ],
      "length": 175
    },
    {
      "filename": "ChatMessageObject",
      "content": "using System.Collections; using System.Collections.Generic; using Unity.Services.Vivox; using UnityEngine; using UnityEngine.UI; using static Vivox.DnD.ChatUI; public class ChatMessageObjectUI : MonoBehaviour { [System.Serializable] public enum TextEffect { None, Shadow, Outline } public Text MessageText; public InputField MessageInputField; [Header(\"Text Properties\")] [SerializeField] private Font m_TextFont = FontData.defaultFontData.font; [SerializeField] private int m_TextFontSize = FontData.defaultFontData.fontSize; [SerializeField] private float m_TextLineSpacing = FontData.defaultFontData.lineSpacing; [SerializeField] private Color m_TextColorGlobal = Color.white; [SerializeField] private Color m_TextColorTeam = Color.blue; [SerializeField] private TextEffect m_TextEffect = TextEffect.None; [SerializeField] private Color m_TextEffectColor = Color.black; [SerializeField] private Vector2 m_TextEffectDistance = new Vector2(1f, -1f); public void SetTextMessage(VivoxMessage message, TabInfo tabInfo, bool deleted = false) { // Get the rect transform RectTransform rectTransform = (MessageText.transform as RectTransform); // Prepare the rect transform rectTransform.localScale = new Vector3(1f, 1f, 1f); rectTransform.pivot = new Vector2(0f, 1f); rectTransform.anchorMin = new Vector2(0f, 1f); rectTransform.anchorMax = new Vector2(0f, 1f); // Set the parent // rectTransform.SetParent(tabInfo.content, false); // Prepare the text component MessageText.font = this.m_TextFont; MessageText.fontSize = this.m_TextFontSize; MessageText.lineSpacing = this.m_TextLineSpacing; MessageText.color = (tabInfo.textChannel == TextChannel.Team) ? this.m_TextColorTeam : m_TextColorGlobal; string originalString = message.ReceivedTime.TimeOfDay.ToString(); int index = originalString.IndexOf('.'); MessageText.text = string.Format($\"[{((index >= 0) ? originalString[..index] : originalString)}] {message.SenderDisplayName}: {message.MessageText}\"); // Prepare the text effect if (this.m_TextEffect != TextEffect.None) { switch (this.m_TextEffect) { case TextEffect.Shadow: Shadow shadow = MessageText.gameObject.AddComponent<Shadow>(); shadow.effectColor = this.m_TextEffectColor; shadow.effectDistance = this.m_TextEffectDistance; break; case TextEffect.Outline: Outline outline = MessageText.gameObject.AddComponent<Outline>(); outline.effectColor = this.m_TextEffectColor; outline.effectDistance = this.m_TextEffectDistance; break; } } //if (deleted) //{ // MessageText.text = string.Format($\"<color=#5A5A5A><size=8>{editedText}{message.ReceivedTime}</size></color>\"); // return; //} //if (message.FromSelf) //{ // MessageText.alignment = TextAnchor.MiddleRight; // MessageText.text = string.Format($\"{message.MessageText} :<color=blue>{message.SenderDisplayName} </color>\\n<color=#5A5A5A><size=8>{editedText}{message.ReceivedTime}</size></color>\"); //} //else //{ // MessageText.alignment = TextAnchor.MiddleLeft; // MessageText.text = string.IsNullOrEmpty(message.ChannelName) // ? string.Format($\"<color=purple>{message.SenderDisplayName} </color>: {message.MessageText}\\n<color=#5A5A5A><size=8>{editedText}{message.ReceivedTime}</size></color>\") // DM // : string.Format($\"<color=green>{message.SenderDisplayName} </color>: {message.MessageText}\\n<color=#5A5A5A><size=8>{editedText}{message.ReceivedTime}</size></color>\"); // Channel Message //} } } ",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ChatMessageObject",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatMessageObject",
          "content": "using System.Collections; using System.Collections.Generic; using Unity.Services.Vivox; using UnityEngine; using UnityEngine.UI; using static Vivox.DnD.ChatUI; public class ChatMessageObjectUI : MonoBehaviour { [System.Serializable] public enum TextEffect { None, Shadow, Outline } public Text MessageText; public InputField MessageInputField; [Header(\"Text Properties\")] [SerializeField] private Font m_TextFont = FontData.defaultFontData.font; [SerializeField] private int m_TextFontSize = FontData.defaultFontData.fontSize; [SerializeField] private float m_TextLineSpacing = FontData.defaultFontData.lineSpacing; [SerializeField] private Color m_TextColorGlobal = Color.white; [SerializeField] private Color m_TextColorTeam = Color.blue; [SerializeField] private TextEffect m_TextEffect = TextEffect.None; [SerializeField] private Color m_TextEffectColor = Color.black; [SerializeField] private Vector2 m_TextEffectDistance = new Vector2(1f, -1f); public void SetTextMessage(VivoxMessage message, TabInfo tabInfo, bool deleted = false) { // Get the rect transform RectTransform rectTransform = (MessageText.transform as RectTransform); // Prepare the rect transform rectTransform.localScale = new Vector3(1f, 1f, 1f); rectTransform.pivot = new Vector2(0f, 1f); rectTransform.anchorMin = new Vector2(0f, 1f); rectTransform.anchorMax = new Vector2(0f, 1f); // Set the parent // rectTransform.SetParent(tabInfo.content, false); // Prepare the text component MessageText.font = this.m_TextFont; MessageText.fontSize = this.m_TextFontSize; MessageText.lineSpacing = this.m_TextLineSpacing; MessageText.color = (tabInfo.textChannel == TextChannel.Team) ? this.m_TextColorTeam : m_TextColorGlobal; string originalString = message.ReceivedTime.TimeOfDay.ToString(); int index = originalString.IndexOf('.'); MessageText.text = string.Format($\"[{((index >= 0) ? originalString[..index] : originalString)}] {message.SenderDisplayName}: {message.MessageText}\"); // Prepare the text effect if (this.m_TextEffect != TextEffect.None) { switch (this.m_TextEffect) { case TextEffect.Shadow: Shadow shadow = MessageText.gameObject.AddComponent<Shadow>(); shadow.effectColor = this.m_TextEffectColor; shadow.effectDistance = this.m_TextEffectDistance; break; case TextEffect.Outline: Outline outline = MessageText.gameObject.AddComponent<Outline>(); outline.effectColor = this.m_TextEffectColor; outline.effectDistance = this.m_TextEffectDistance; break; } } //if (deleted) //{ // MessageText.text = string.Format($\"<color=#5A5A5A><size=8>{editedText}{message.ReceivedTime}</size></color>\"); // return; //} //if (message.FromSelf) //{ // MessageText.alignment = TextAnchor.MiddleRight; // MessageText.text = string.Format($\"{message.MessageText} :<color=blue>{message.SenderDisplayName} </color>\\n<color=#5A5A5A><size=8>{editedText}{message.ReceivedTime}</size></color>\"); //} //else //{ // MessageText.alignment = TextAnchor.MiddleLeft; // MessageText.text = string.IsNullOrEmpty(message.ChannelName) // ? string.Format($\"<color=purple>{message.SenderDisplayName} </color>: {message.MessageText}\\n<color=#5A5A5A><size=8>{editedText}{message.ReceivedTime}</size></color>\") // DM // : string.Format($\"<color=green>{message.SenderDisplayName} </color>: {message.MessageText}\\n<color=#5A5A5A><size=8>{editedText}{message.ReceivedTime}</size></color>\"); // Channel Message //} } }",
          "content_tokens": 981,
          "embedding": []
        }
      ],
      "length": 3361
    },
    {
      "filename": "ChatUI",
      "content": "using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using UnityEngine.Events; using UnityEngine.EventSystems; using DuloGames.UI; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using Unity.Services.Vivox; using Unity.Services.Vivox.AudioTaps; using System.Threading.Tasks; using System; using System.Linq; using System.Collections; using _ZombieRoyale.Scripts.Core; using Invector.vItemManager; using FishNet; namespace Vivox.DnD { public class ChatUI : MonoBehaviour, ISelectHandler, IDeselectHandler { [System.Serializable] public enum TextChannel : int { Global = 0, Team = 1, InGame = 2 } public enum ChatState { Menu, Game } public enum TextCommand { all, team } [System.Serializable] public class SendMessageEvent : UnityEvent<int, string> { } [System.Serializable] public class TabInfo { public int id = 0; public UITab button; public Transform content; public ScrollRect scrollRect; public TextChannel textChannel; } [SerializeField] private InputField m_InputField; [Header(\"Buttons\")] [SerializeField] private Button m_SubmitButton; [SerializeField] private Button m_ScrollTopButton; [SerializeField] private Button m_ScrollBottomButton; [SerializeField] private Button m_ScrollUpButton; [SerializeField] private Button m_ScrollDownButton; [Header(\"Tab Properties\")] [SerializeField] private List<TabInfo> m_Tabs = new List<TabInfo>(); [Header(\"Events\")] /// <summary> /// Fired when the clients sends a chat message. /// First paramenter - int tabId. /// Second parameter - string messageText. /// </summary> // public SendMessageEvent onSendMessage = new SendMessageEvent(); private Image _ChatFieldImage; private UIWindow _UIWindow; private UIInputEvent _UIInputEvent; private TabInfo m_ActiveTabInfo; private bool _isActiveChat; private bool _isActiveInputField; private ChatState _currentState = ChatState.Menu; public static ChatUI Instance; /// <summary> /// Vivox components /// </summary> protected IList<KeyValuePair<string, ChatMessageObjectUI>> m_MessageObjPool = new List<KeyValuePair<string, ChatMessageObjectUI>>(); public GameObject MessageObject; protected Task FetchMessages = null; protected DateTime? oldestMessage = null; /// <summary> /// Vivox components /// </summary> protected void Awake() { if (Instance == null) { Instance = this; } // Find the active tab info this.m_ActiveTabInfo = this.FindActiveTab(); // Clear the lines of text if (this.m_Tabs != null && this.m_Tabs.Count > 0) { foreach (TabInfo info in this.m_Tabs) { // if we have a button if (info.content != null) { foreach (Transform t in info.content) { Destroy(t.gameObject); } } } } } void Start() { _UIInputEvent = GetComponent<UIInputEvent>(); _UIWindow = GetComponent<UIWindow>(); _ChatFieldImage = GetComponent<Image>(); VivoxService.Instance.ChannelJoined += OnChannelJoined; VivoxService.Instance.DirectedMessageReceived += OnDirectedMessageReceived; VivoxService.Instance.ChannelMessageReceived += OnChannelMessageReceived; if (this.m_Tabs != null && this.m_Tabs.Count > 0) { foreach (TabInfo info in this.m_Tabs) { // if we have a button if (info.scrollRect != null) { info.scrollRect.onValueChanged.AddListener(ScrollRectChange); } } } UpdateChatChannels(nameof(ChatState.Menu)); } protected void OnEnable() { // Hook the scroll up button click event if (this.m_ScrollUpButton != null) { this.m_ScrollUpButton.onClick.AddListener(OnScrollUpClick); } // Hook the scroll down button click event if (this.m_ScrollDownButton != null) { this.m_ScrollDownButton.onClick.AddListener(OnScrollDownClick); } // Hook the input field end edit event if (this.m_InputField != null) { this.m_InputField.onEndEdit.AddListener(OnInputEndEdit); } if (this.m_SubmitButton != null) { this.m_SubmitButton.onClick.AddListener(SendChatMessage); } // Hook the scroll to top button click event if (this.m_ScrollTopButton != null) { this.m_ScrollTopButton.onClick.AddListener(OnScrollToTopClick); } // Hook the scroll to bottom button click event if (this.m_ScrollBottomButton != null) { this.m_ScrollBottomButton.onClick.AddListener(OnScrollToBottomClick); } // Hook the tab toggle change events if (this.m_Tabs != null && this.m_Tabs.Count > 0) { foreach (TabInfo info in this.m_Tabs) { // if we have a button if (info.button != null) { info.button.onValueChanged.AddListener(OnTabStateChange); info.button.onValueChanged.AddListener(OnChangeTabPanel); } } } //ClearTextField(); } protected void OnDisable() { // Unhook the scroll up button click event if (this.m_ScrollUpButton != null) { this.m_ScrollUpButton.onClick.RemoveListener(OnScrollUpClick); } // Unhook the scroll down button click event if (this.m_ScrollDownButton != null) { this.m_ScrollDownButton.onClick.RemoveListener(OnScrollDownClick); } if (this.m_SubmitButton != null) { this.m_SubmitButton.onClick.RemoveListener(SendChatMessage); } // Unhook the scroll to top button click event if (this.m_ScrollTopButton != null) { this.m_ScrollTopButton.onClick.RemoveListener(OnScrollToTopClick); } // Unhook the scroll to bottom button click event if (this.m_ScrollBottomButton != null) { this.m_ScrollBottomButton.onClick.RemoveListener(OnScrollToBottomClick); } // Unhook the tab toggle change events if (this.m_Tabs != null && this.m_Tabs.Count > 0) { foreach (TabInfo info in this.m_Tabs) { // if we have a button if (info.button != null) { info.button.onValueChanged.RemoveListener(OnTabStateChange); } } } if (m_MessageObjPool.Count > 0) { ClearMessageObjectPool(); } oldestMessage = null; } protected void OnDestroy() { VivoxService.Instance.ChannelJoined -= OnChannelJoined; VivoxService.Instance.DirectedMessageReceived -= OnDirectedMessageReceived; VivoxService.Instance.ChannelMessageReceived -= OnChannelMessageReceived; #if UNITY_STANDALONE || UNITY_IOS || UNITY_ANDROID m_InputField.onEndEdit.RemoveAllListeners(); #endif if (this.m_Tabs != null && this.m_Tabs.Count > 0) { foreach (TabInfo info in this.m_Tabs) { // if we have a button if (info.scrollRect != null) { info.scrollRect.onValueChanged.RemoveAllListeners(); } } } } public void UpdateChatChannels(string state) { switch (state) { case nameof(ChatState.Menu): _currentState = ChatState.Menu; break; case nameof(ChatState.Game): _currentState = ChatState.Game; break; default: break; } m_Tabs.ForEach(t => { t.button.gameObject.SetActive(true); t.button.isOn = false; t.button.onValueChanged.Invoke(false); }); if (_currentState == ChatState.Menu) MainMenuUpdateChatChannels(); else { StartCoroutine(InGameChatChannels()); } } private void MainMenuUpdateChatChannels() { foreach (TabInfo info in this.m_Tabs) { if (info.button != null) { if (info.textChannel == TextChannel.Team || info.textChannel == TextChannel.InGame) info.button.gameObject.SetActive(false); } } _UIInputEvent.enabled = false; } private IEnumerator InGameChatChannels() { yield return new WaitUntil(() => GameplayManager.Instance != null); yield return new WaitUntil(() => GameplayManager.Instance.RoomDetails != null); m_Tabs.ForEach(x => { if (x.id == 3) { x.button.isOn = true; x.button.onValueChanged.Invoke(true); } }); foreach (TabInfo info in this.m_Tabs) { // if we have a button if (info.button != null) { if ((!GameplayManager.Instance.RoomDetails.IsTeamsMode && info.textChannel == TextChannel.Team) || info.textChannel == TextChannel.Global) { info.button.gameObject.SetActive(false); } } } string uid = SystemInfo.deviceUniqueIdentifier; VivoxService.Instance.JoinGroupChannelAsync(ChatUI.TextChannel.Team.ToString() + \"UID: \" + SteamConnectionManager.GetHostHex(), ChatCapability.TextAndAudio); VivoxService.Instance.JoinGroupChannelAsync(ChatUI.TextChannel.InGame.ToString() + \"UID: \" + SteamConnectionManager.GetHostHex(), ChatCapability.TextAndAudio); _UIInputEvent.enabled = true; OnChatPanelDeselect(); } public bool IsChatOpened() { return _isActiveChat; } /// <summary> /// Fired when the scroll up button is pressed. /// </summary> public void OnScrollUpClick() { if (this.m_ActiveTabInfo == null || this.m_ActiveTabInfo.scrollRect == null) return; PointerEventData pointerEventData = new PointerEventData(EventSystem.current); pointerEventData.scrollDelta = new Vector2(0f, 1f); this.m_ActiveTabInfo.scrollRect.OnScroll(pointerEventData); } /// <summary> /// Fired when the scroll down button is pressed. /// </summary> public void OnScrollDownClick() { if (this.m_ActiveTabInfo == null || this.m_ActiveTabInfo.scrollRect == null) return; PointerEventData pointerEventData = new PointerEventData(EventSystem.current); pointerEventData.scrollDelta = new Vector2(0f, -1f); this.m_ActiveTabInfo.scrollRect.OnScroll(pointerEventData); } /// <summary> /// Fired when the scroll to top button is pressed. /// </summary> public void OnScrollToTopClick() { if (this.m_ActiveTabInfo == null || this.m_ActiveTabInfo.scrollRect == null) return; // Scroll to top this.m_ActiveTabInfo.scrollRect.verticalNormalizedPosition = 1f; } /// <summary> /// Fired when the scroll to bottom button is pressed. /// </summary> public void OnScrollToBottomClick() { if (this.m_ActiveTabInfo == null || this.m_ActiveTabInfo.scrollRect == null) return; // Scroll to bottom this.m_ActiveTabInfo.scrollRect.verticalNormalizedPosition = 0f; } private void OnChangeTabPanel(bool value) { OnChatPanelSelect(); } public void OnChatPanelDeselectEvent() { if (_currentState == ChatState.Menu) OnChatPanelDeselect(); } public void OnChatPanelSelectEvent() { OnChatPanelSelect(); } public void OnChatPanelDeselect() { if (!_isActiveInputField || (_isActiveInputField && _isActiveChat)) { _isActiveChat = false; GetComponent<CanvasGroup>().alpha = 0.5f; ToggleInputs(true); GameStateController.Instance.SetState(GameStateController.GameState.Default); } } public void OnChatPanelSelect() { if (_isActiveInputField || (!_isActiveInputField && !_isActiveChat)) { _isActiveChat = true; GetComponent<CanvasGroup>().alpha = 1f; ToggleInputs(false); GameStateController.Instance.SetState(GameStateController.GameState.ChatOpen); } } public void OnSelect(BaseEventData eventData) { _isActiveInputField = true; ((ISelectHandler)m_InputField).OnSelect(eventData); if (_currentState == ChatState.Game) { EscapeMenu.Instance.UIWindow.enabled = false; ToggleInputs(false); GameStateController.Instance.SetState(GameStateController.GameState.ChatOpen); } if (!_isActiveChat) OnChatPanelSelect(); } public void OnDeselect(BaseEventData eventData) { _isActiveInputField = false; ((IDeselectHandler)m_InputField).OnDeselect(eventData); if (_currentState == ChatState.Game) { EscapeMenu.Instance.UIWindow.enabled = true; ToggleInputs(true); GameStateController.Instance.SetState(GameStateController.GameState.Default); } if (_isActiveChat) OnChatPanelDeselect(); } /// <summary> /// Fired when the input field is submitted. /// </summary> /// <param name=\"text\"></param> private void OnInputEndEdit(string text) { // Make sure we have input text if (!string.IsNullOrEmpty(text)) { // Make sure the return key is pressed if (Input.GetKeyDown(KeyCode.Return)) { if (string.IsNullOrEmpty(text)) { OnChatPanelDeselect(); return; } // Send the message this.SendChatMessage(); } } } private void ToggleInputs(bool enable) { if (GameplayManager.Instance == null || GameplayManager.Instance.GetAllPlayersHeroes().Count == 0) return; var nob = GameplayManager.Instance.GetAllPlayersHeroes().First(); var unit = GameplayManager.Instance.GetUnitComponents(nob); unit.InvectorManager.Inventory.lockInventoryInput = !enable; RoomSystemHandler.ShowCursor(!enable); RoomSystemHandler.LockCursor(enable); } void ClearTextField() { if (m_InputField != null) { m_InputField.text = string.Empty; m_InputField.Select(); m_InputField.ActivateInputField(); } } /// <summary> /// Fired when a tab button is toggled. /// </summary> /// <param name=\"state\"></param> public void OnTabStateChange(bool state) { // If a tab was activated if (state) { // Find the active tab this.m_ActiveTabInfo = this.FindActiveTab(); } } /// <summary> /// Finds the active tab based on the tab buttons toggle state. /// </summary> /// <returns>The active tab info.</returns> private TabInfo FindActiveTab() { // If we have tabs if (this.m_Tabs != null && this.m_Tabs.Count > 0) { foreach (TabInfo info in this.m_Tabs) { // if we have a button if (info.button != null) { // If this button is active if (info.button.isOn) { return info; } } } } return null; } /// <summary> /// Gets the tab info for the specified tab by id. /// </summary> /// <param name=\"tabId\">Tab id.</param> /// <returns></returns> public TabInfo GetTabInfo(int tabId) { // If we have tabs if (this.m_Tabs != null && this.m_Tabs.Count > 0) { foreach (TabInfo info in this.m_Tabs) { // If this is the tab we are looking for if (info.id == tabId) { return info; } } } return null; } /// <summary> /// Sends a chat message. /// </summary> /// <param name=\"text\">The message.</param> private void SendChatMessage() { if (string.IsNullOrEmpty(m_InputField.text)) { return; } int tabId = (this.m_ActiveTabInfo != null ? this.m_ActiveTabInfo.id : 0); TabInfo tabInfo = this.GetTabInfo(tabId); // Make sure we have tab info if (tabInfo == null || tabInfo.content == null) return; VivoxService.Instance.SendChannelTextMessageAsync(m_ActiveTabInfo.textChannel.ToString(), m_InputField.text); ClearTextField(); } protected void ScrollRectChange(Vector2 vector) { // Scrolled near end and check if we are fetching history already if (m_ActiveTabInfo.scrollRect.verticalNormalizedPosition >= 0.95f && FetchMessages != null && (FetchMessages.IsCompleted || FetchMessages.IsFaulted || FetchMessages.IsCanceled)) { m_ActiveTabInfo.scrollRect.normalizedPosition = new Vector2(0, 0.8f); // FetchMessages = FetchHistory(false); } } protected async Task FetchHistory(bool scrollToBottom = false) { try { var chatHistoryOptions = new ChatHistoryQueryOptions() { TimeEnd = oldestMessage }; var historyMessages = await VivoxService.Instance.GetChannelTextMessageHistoryAsync(m_ActiveTabInfo.textChannel.ToString(), 10, chatHistoryOptions); var reversedMessages = historyMessages.Reverse(); foreach (var historyMessage in reversedMessages) { AddMessageToChat(historyMessage, true, scrollToBottom); } // Update the oldest message ReceivedTime if it exists to help the next fetch get the next batch of history oldestMessage = historyMessages.FirstOrDefault()?.ReceivedTime; } catch (TaskCanceledException e) { Debug.Log($\"Chat history request was canceled, likely because of a logout or the data is no longer needed: {e.Message}\"); } catch (Exception e) { Debug.LogError($\"Tried to fetch chat history and failed with error: {e.Message}\"); } } protected void ChannelEffectValueChanged(int value) { AudioTapsManager.Instance.AddChannelAudioEffect((AudioTapsManager.Effects)value); } protected void ClearMessageObjectPool() { foreach (KeyValuePair<string, ChatMessageObjectUI> keyValuePair in m_MessageObjPool) { Destroy(keyValuePair.Value.gameObject); } m_MessageObjPool.Clear(); } IEnumerator SendScrollRectToBottom() { yield return new WaitForEndOfFrame(); // We need to wait for the end of the frame for this to be updated, otherwise it happens too quickly. m_ActiveTabInfo.scrollRect.normalizedPosition = new Vector2(0, 0); yield return null; } protected void OnDirectedMessageReceived(VivoxMessage message) { AddMessageToChat(message, false, true); } protected void OnChannelJoined(string channelName) { // FetchMessages = FetchHistory(true); } protected void OnChannelMessageReceived(VivoxMessage message) { AddMessageToChat(message, false, true); } protected void AddMessageToChat(VivoxMessage message, bool isHistory = false, bool scrollToBottom = false) { int tabId = (this.m_ActiveTabInfo != null ? this.m_ActiveTabInfo.id : 0); TabInfo tabInfo = this.GetTabInfo(tabId); var newMessageObj = Instantiate(MessageObject, m_ActiveTabInfo.content.transform); var newMessageTextObject = newMessageObj.GetComponent<ChatMessageObjectUI>(); if (isHistory) { m_MessageObjPool.Insert(0, new KeyValuePair<string, ChatMessageObjectUI>(message.MessageId, newMessageTextObject)); newMessageObj.transform.SetSiblingIndex(0); } else { m_MessageObjPool.Add(new KeyValuePair<string, ChatMessageObjectUI>(message.MessageId, newMessageTextObject)); } newMessageTextObject.SetTextMessage(message, tabInfo,false); if (scrollToBottom) { StartCoroutine(SendScrollRectToBottom()); } // Rebuild the content layout // LayoutRebuilder.ForceRebuildLayoutImmediate(tabInfo.content as RectTransform); // Scroll to bottom // this.OnScrollToBottomClick(); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "ChatUI",
          "content": "",
          "content_tokens": 0,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using UnityEngine.Events; using UnityEngine.EventSystems; using DuloGames.UI; using FirstGearGames.LobbyAndWorld.Demos.KingOfTheHill; using Unity.Services.Vivox; using Unity.Services.Vivox.AudioTaps; using System.Threading.Tasks; using System; using System.Linq; using System.Collections; using _ZombieRoyale.Scripts.Core; using Invector.vItemManager; using FishNet; namespace Vivox.DnD { public class ChatUI : MonoBehaviour, ISelectHandler, IDeselectHandler { [System.Serializable] public enum TextChannel : int { Global = 0, Team = 1, InGame = 2 } public enum ChatState { Menu, Game } public enum TextCommand { all, team } [System.Serializable] public class SendMessageEvent : UnityEvent<int, string> { } [System.Serializable] public class TabInfo { public int id = 0; public UITab button; public Transform content; public ScrollRect scrollRect; public TextChannel textChannel; } [SerializeField] private InputField m_InputField; [Header(\"Buttons\")] [SerializeField] private Button m_SubmitButton; [SerializeField] private Button m_ScrollTopButton; [SerializeField] private Button m_ScrollBottomButton; [SerializeField] private Button m_ScrollUpButton; [SerializeField] private Button m_ScrollDownButton; [Header(\"Tab Properties\")] [SerializeField] private List<TabInfo> m_Tabs = new List<TabInfo>(); [Header(\"Events\")] /// <summary> /// Fired when the clients sends a chat message. /// First paramenter - int tabId. /// Second parameter - string messageText. /// </summary> // public SendMessageEvent onSendMessage = new SendMessageEvent(); private Image _ChatFieldImage; private UIWindow _UIWindow; private UIInputEvent _UIInputEvent; private TabInfo m_ActiveTabInfo; private bool _isActiveChat; private bool _isActiveInputField; private ChatState _currentState = ChatState.Menu; public static ChatUI Instance; /// <summary> /// Vivox components /// </summary> protected IList<KeyValuePair<string, ChatMessageObjectUI>> m_MessageObjPool = new List<KeyValuePair<string, ChatMessageObjectUI>>(); public GameObject MessageObject; protected Task FetchMessages = null; protected DateTime? oldestMessage = null; /// <summary> /// Vivox components /// </summary> protected void Awake() { if (Instance == null) { Instance = this; } // Find the active tab info this.m_ActiveTabInfo = this.FindActiveTab(); // Clear the lines of text if (this.m_Tabs != null && this.m_Tabs.Count > 0) { foreach (TabInfo info in this.m_Tabs) { // if we have a button if (info.content != null) { foreach (Transform t in info.content) { Destroy(t.gameObject); } } } }  ",
          "content_tokens": 702,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "void Start() { _UIInputEvent = GetComponent<UIInputEvent>(); _UIWindow = GetComponent<UIWindow>(); _ChatFieldImage = GetComponent<Image>(); VivoxService.Instance.ChannelJoined += OnChannelJoined; VivoxService.Instance.DirectedMessageReceived += OnDirectedMessageReceived; VivoxService.Instance.ChannelMessageReceived += OnChannelMessageReceived; if (this.m_Tabs != null && this.m_Tabs.Count > 0) { foreach (TabInfo info in this.m_Tabs) { // if we have a button if (info.scrollRect != null) { info.scrollRect.onValueChanged.AddListener(ScrollRectChange); } }  UpdateChatChannels(nameof(ChatState.Menu));  ",
          "content_tokens": 176,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "protected void OnEnable() { // Hook the scroll up button click event if (this.m_ScrollUpButton != null) { this.m_ScrollUpButton.onClick.AddListener(OnScrollUpClick); } // Hook the scroll down button click event if (this.m_ScrollDownButton != null) { this.m_ScrollDownButton.onClick.AddListener(OnScrollDownClick); } // Hook the input field end edit event if (this.m_InputField != null) { this.m_InputField.onEndEdit.AddListener(OnInputEndEdit);  ",
          "content_tokens": 129,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "if (this.m_SubmitButton != null) { this.m_SubmitButton.onClick.AddListener(SendChatMessage); } // Hook the scroll to top button click event if (this.m_ScrollTopButton != null) { this.m_ScrollTopButton.onClick.AddListener(OnScrollToTopClick); } // Hook the scroll to bottom button click event if (this.m_ScrollBottomButton != null) { this.m_ScrollBottomButton.onClick.AddListener(OnScrollToBottomClick); } // Hook the tab toggle change events if (this.m_Tabs != null && this.m_Tabs.Count > 0) { foreach (TabInfo info in this.m_Tabs) { // if we have a button if (info.button != null) { info.button.onValueChanged.AddListener(OnTabStateChange); info.button.onValueChanged.AddListener(OnChangeTabPanel); } } } //ClearTextField();  ",
          "content_tokens": 218,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "protected void OnDisable() { // Unhook the scroll up button click event if (this.m_ScrollUpButton != null) { this.m_ScrollUpButton.onClick.RemoveListener(OnScrollUpClick); } // Unhook the scroll down button click event if (this.m_ScrollDownButton != null) { this.m_ScrollDownButton.onClick.RemoveListener(OnScrollDownClick);  ",
          "content_tokens": 91,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "if (this.m_SubmitButton != null) { this.m_SubmitButton.onClick.RemoveListener(SendChatMessage); } // Unhook the scroll to top button click event if (this.m_ScrollTopButton != null) { this.m_ScrollTopButton.onClick.RemoveListener(OnScrollToTopClick); } // Unhook the scroll to bottom button click event if (this.m_ScrollBottomButton != null) { this.m_ScrollBottomButton.onClick.RemoveListener(OnScrollToBottomClick); } // Unhook the tab toggle change events if (this.m_Tabs != null && this.m_Tabs.Count > 0) { foreach (TabInfo info in this.m_Tabs) { // if we have a button if (info.button != null) { info.button.onValueChanged.RemoveListener(OnTabStateChange); } }  ",
          "content_tokens": 199,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "if (m_MessageObjPool.Count > 0) { ClearMessageObjectPool(); } oldestMessage = null;  protected void OnDestroy() { VivoxService.Instance.ChannelJoined -= OnChannelJoined; VivoxService.Instance.DirectedMessageReceived -= OnDirectedMessageReceived; VivoxService.Instance.ChannelMessageReceived -= OnChannelMessageReceived; #if UNITY_STANDALONE || UNITY_IOS || UNITY_ANDROID m_InputField.onEndEdit.RemoveAllListeners(); #endif if (this.m_Tabs != null && this.m_Tabs.Count > 0) { foreach (TabInfo info in this.m_Tabs) { // if we have a button if (info.scrollRect != null) { info.scrollRect.onValueChanged.RemoveAllListeners(); } } }  ",
          "content_tokens": 191,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "public void UpdateChatChannels(string state) { switch (state) { case nameof(ChatState.Menu): _currentState = ChatState.Menu; break; case nameof(ChatState.Game): _currentState = ChatState.Game; break; default: break; } m_Tabs.ForEach(t => { t.button.gameObject.SetActive(true); t.button.isOn = false; t.button.onValueChanged.Invoke(false); }); if (_currentState == ChatState.Menu) MainMenuUpdateChatChannels(); else { StartCoroutine(InGameChatChannels()); }  ",
          "content_tokens": 139,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "private void MainMenuUpdateChatChannels() { foreach (TabInfo info in this.m_Tabs) { if (info.button != null) { if (info.textChannel == TextChannel.Team || info.textChannel == TextChannel.InGame) info.button.gameObject.SetActive(false); } } _UIInputEvent.enabled = false; } private IEnumerator InGameChatChannels() { yield return new WaitUntil(() => GameplayManager.Instance != null); yield return new WaitUntil(() => GameplayManager.Instance.RoomDetails != null); m_Tabs.ForEach(x => { if (x.id == 3) { x.button.isOn = true; x.button.onValueChanged.Invoke(true); } }); foreach (TabInfo info in this.m_Tabs) { // if we have a button if (info.button != null) { if ((!GameplayManager.Instance.RoomDetails.IsTeamsMode && info.textChannel == TextChannel.Team) || info.textChannel == TextChannel.Global) { info.button.gameObject.SetActive(false); } } } string uid = SystemInfo.deviceUniqueIdentifier; VivoxService.Instance.JoinGroupChannelAsync(ChatUI.TextChannel.Team.ToString() + \"UID: \" + SteamConnectionManager.GetHostHex(), ChatCapability.TextAndAudio); VivoxService.Instance.JoinGroupChannelAsync(ChatUI.TextChannel.InGame.ToString() + \"UID: \" + SteamConnectionManager.GetHostHex(), ChatCapability.TextAndAudio); _UIInputEvent.enabled = true; OnChatPanelDeselect();  ",
          "content_tokens": 376,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "public bool IsChatOpened() { return _isActiveChat; } /// <summary> /// Fired when the scroll up button is pressed. /// </summary> public void OnScrollUpClick() { if (this.m_ActiveTabInfo == null || this.m_ActiveTabInfo.scrollRect == null) return; PointerEventData pointerEventData = new PointerEventData(EventSystem.current); pointerEventData.scrollDelta = new Vector2(0f, 1f); this.m_ActiveTabInfo.scrollRect.OnScroll(pointerEventData); } /// <summary> /// Fired when the scroll down button is pressed. /// </summary> public void OnScrollDownClick() { if (this.m_ActiveTabInfo == null || this.m_ActiveTabInfo.scrollRect == null) return; PointerEventData pointerEventData = new PointerEventData(EventSystem.current); pointerEventData.scrollDelta = new Vector2(0f, -1f); this.m_ActiveTabInfo.scrollRect.OnScroll(pointerEventData); } /// <summary> /// Fired when the scroll to top button is pressed. /// </summary> public void OnScrollToTopClick() { if (this.m_ActiveTabInfo == null || this.m_ActiveTabInfo.scrollRect == null) return; // Scroll to top this.m_ActiveTabInfo.scrollRect.verticalNormalizedPosition = 1f; } /// <summary> /// Fired when the scroll to bottom button is pressed. /// </summary> public void OnScrollToBottomClick() { if (this.m_ActiveTabInfo == null || this.m_ActiveTabInfo.scrollRect == null) return; // Scroll to bottom this.m_ActiveTabInfo.scrollRect.verticalNormalizedPosition = 0f;  ",
          "content_tokens": 393,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "private void OnChangeTabPanel(bool value) { OnChatPanelSelect();  public void OnChatPanelDeselectEvent() { if (_currentState == ChatState.Menu) OnChatPanelDeselect();  public void OnChatPanelSelectEvent() { OnChatPanelSelect();  public void OnChatPanelDeselect() { if (!_isActiveInputField || (_isActiveInputField && _isActiveChat)) { _isActiveChat = false; GetComponent<CanvasGroup>().alpha = 0.5f; ToggleInputs(true); GameStateController.Instance.SetState(GameStateController.GameState.Default); }  ",
          "content_tokens": 140,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "public void OnChatPanelSelect() { if (_isActiveInputField || (!_isActiveInputField && !_isActiveChat)) { _isActiveChat = true; GetComponent<CanvasGroup>().alpha = 1f; ToggleInputs(false); GameStateController.Instance.SetState(GameStateController.GameState.ChatOpen); }  public void OnSelect(BaseEventData eventData) { _isActiveInputField = true; ((ISelectHandler)m_InputField).OnSelect(eventData); if (_currentState == ChatState.Game) { EscapeMenu.Instance.UIWindow.enabled = false; ToggleInputs(false); GameStateController.Instance.SetState(GameStateController.GameState.ChatOpen);  if (!_isActiveChat) OnChatPanelSelect();  ",
          "content_tokens": 175,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "public void OnDeselect(BaseEventData eventData) { _isActiveInputField = false; ((IDeselectHandler)m_InputField).OnDeselect(eventData); if (_currentState == ChatState.Game) { EscapeMenu.Instance.UIWindow.enabled = true; ToggleInputs(true); GameStateController.Instance.SetState(GameStateController.GameState.Default);  ",
          "content_tokens": 90,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "if (_isActiveChat) OnChatPanelDeselect(); } /// <summary> /// Fired when the input field is submitted. /// </summary> /// <param name=\"text\"></param> private void OnInputEndEdit(string text) { // Make sure we have input text if (!string.IsNullOrEmpty(text)) { // Make sure the return key is pressed if (Input.GetKeyDown(KeyCode.Return)) { if (string.IsNullOrEmpty(text)) { OnChatPanelDeselect(); return; } // Send the message this.SendChatMessage(); } }  ",
          "content_tokens": 128,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "private void ToggleInputs(bool enable) { if (GameplayManager.Instance == null || GameplayManager.Instance.GetAllPlayersHeroes().Count == 0) return; var nob = GameplayManager.Instance.GetAllPlayersHeroes().First(); var unit = GameplayManager.Instance.GetUnitComponents(nob); unit.InvectorManager.Inventory.lockInventoryInput = !enable; RoomSystemHandler.ShowCursor(!enable); RoomSystemHandler.LockCursor(enable);  ",
          "content_tokens": 110,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "void ClearTextField() { if (m_InputField != null) { m_InputField.text = string.Empty; m_InputField.Select(); m_InputField.ActivateInputField(); } } /// <summary> /// Fired when a tab button is toggled. /// </summary> /// <param name=\"state\"></param> public void OnTabStateChange(bool state) { // If a tab was activated if (state) { // Find the active tab this.m_ActiveTabInfo = this.FindActiveTab(); } } /// <summary> /// Finds the active tab based on the tab buttons toggle state. /// </summary> /// <returns>The active tab info.</returns> private TabInfo FindActiveTab() { // If we have tabs if (this.m_Tabs != null && this.m_Tabs.Count > 0) { foreach (TabInfo info in this.m_Tabs) { // if we have a button if (info.button != null) { // If this button is active if (info.button.isOn) { return info; } } } } return null; } /// <summary> /// Gets the tab info for the specified tab by id. /// </summary> /// <param name=\"tabId\">Tab id.</param> /// <returns></returns> public TabInfo GetTabInfo(int tabId) { // If we have tabs if (this.m_Tabs != null && this.m_Tabs.Count > 0) { foreach (TabInfo info in this.m_Tabs) { // If this is the tab we are looking for if (info.id == tabId) { return info; } } } return null; } /// <summary> /// Sends a chat message. /// </summary> /// <param name=\"text\">The message.</param> private void SendChatMessage() { if (string.IsNullOrEmpty(m_InputField.text)) { return; } int tabId = (this.m_ActiveTabInfo != null ? this.m_ActiveTabInfo.id : 0); TabInfo tabInfo = this.GetTabInfo(tabId); // Make sure we have tab info if (tabInfo == null || tabInfo.content == null) return; VivoxService.Instance.SendChannelTextMessageAsync(m_ActiveTabInfo.textChannel.ToString(), m_InputField.text); ClearTextField();  ",
          "content_tokens": 526,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "protected void ScrollRectChange(Vector2 vector) { // Scrolled near end and check if we are fetching history already if (m_ActiveTabInfo.scrollRect.verticalNormalizedPosition >= 0.95f && FetchMessages != null && (FetchMessages.IsCompleted || FetchMessages.IsFaulted || FetchMessages.IsCanceled)) { m_ActiveTabInfo.scrollRect.normalizedPosition = new Vector2(0, 0.8f); // FetchMessages = FetchHistory(false); } } protected async Task FetchHistory(bool scrollToBottom = false) { try { var chatHistoryOptions = new ChatHistoryQueryOptions() { TimeEnd = oldestMessage }; var historyMessages = await VivoxService.Instance.GetChannelTextMessageHistoryAsync(m_ActiveTabInfo.textChannel.ToString(), 10, chatHistoryOptions); var reversedMessages = historyMessages.Reverse(); foreach (var historyMessage in reversedMessages) { AddMessageToChat(historyMessage, true, scrollToBottom); } // Update the oldest message ReceivedTime if it exists to help the next fetch get the next batch of history oldestMessage = historyMessages.FirstOrDefault()?.ReceivedTime;  ",
          "content_tokens": 274,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "catch (TaskCanceledException e) { Debug.Log($\"Chat history request was canceled, likely because of a logout or the data is no longer needed: {e.Message}\");  catch (Exception e) { Debug.LogError($\"Tried to fetch chat history and failed with error: {e.Message}\"); }  protected void ChannelEffectValueChanged(int value) { AudioTapsManager.Instance.AddChannelAudioEffect((AudioTapsManager.Effects)value);  ",
          "content_tokens": 107,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "protected void ClearMessageObjectPool() { foreach (KeyValuePair<string, ChatMessageObjectUI> keyValuePair in m_MessageObjPool) { Destroy(keyValuePair.Value.gameObject); } m_MessageObjPool.Clear(); } IEnumerator SendScrollRectToBottom() { yield return new WaitForEndOfFrame(); // We need to wait for the end of the frame for this to be updated, otherwise it happens too quickly. m_ActiveTabInfo.scrollRect.normalizedPosition = new Vector2(0, 0); yield return null;  protected void OnDirectedMessageReceived(VivoxMessage message) { AddMessageToChat(message, false, true);  protected void OnChannelJoined(string channelName) { // FetchMessages = FetchHistory(true);  ",
          "content_tokens": 179,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "protected void OnChannelMessageReceived(VivoxMessage message) { AddMessageToChat(message, false, true);  ",
          "content_tokens": 28,
          "embedding": []
        },
        {
          "cs_scriptfile": "ChatUI",
          "content": "protected void AddMessageToChat(VivoxMessage message, bool isHistory = false, bool scrollToBottom = false) { int tabId = (this.m_ActiveTabInfo != null ? this.m_ActiveTabInfo.id : 0); TabInfo tabInfo = this.GetTabInfo(tabId); var newMessageObj = Instantiate(MessageObject, m_ActiveTabInfo.content.transform); var newMessageTextObject = newMessageObj.GetComponent<ChatMessageObjectUI>(); if (isHistory) { m_MessageObjPool.Insert(0, new KeyValuePair<string, ChatMessageObjectUI>(message.MessageId, newMessageTextObject)); newMessageObj.transform.SetSiblingIndex(0); } else { m_MessageObjPool.Add(new KeyValuePair<string, ChatMessageObjectUI>(message.MessageId, newMessageTextObject)); } newMessageTextObject.SetTextMessage(message, tabInfo,false); if (scrollToBottom) { StartCoroutine(SendScrollRectToBottom()); } // Rebuild the content layout // LayoutRebuilder.ForceRebuildLayoutImmediate(tabInfo.content as RectTransform); // Scroll to bottom // this.OnScrollToBottomClick(); } } }",
          "content_tokens": 272,
          "embedding": []
        }
      ],
      "length": 16430
    },
    {
      "filename": "VivoxLobbyScreenUI",
      "content": " using System.Threading.Tasks; using Unity.Services.Vivox; namespace Vivox.DnD { public class VivoxLobbyScreenUI : LobbyScreenUI { protected override Task JoinLobbyChannel() { return VivoxService.Instance.JoinGroupChannelAsync(ChatUI.TextChannel.Global.ToString(), ChatCapability.TextAndAudio); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "VivoxLobbyScreenUI",
          "content": "using System.Threading.Tasks; using Unity.Services.Vivox; namespace Vivox.DnD { public class VivoxLobbyScreenUI : LobbyScreenUI { protected override Task JoinLobbyChannel() { return VivoxService.Instance.JoinGroupChannelAsync(ChatUI.TextChannel.Global.ToString(), ChatCapability.TextAndAudio); } } }",
          "content_tokens": 82,
          "embedding": []
        }
      ],
      "length": 300
    },
    {
      "filename": "VivoxLoginScreenUI",
      "content": "using System; using UnityEngine; using UnityEngine.Android; using UnityEngine.EventSystems; using UnityEngine.UI; using Unity.Services.Vivox; using System.Collections.Generic; using System.Text.RegularExpressions; using _ZombieRoyale.Scripts.Clients; using System.Collections; namespace Vivox.DnD { public class VivoxLoginScreenUI : LoginScreenUI { [SerializeField] private PlayerData _playerData; private void OnEnable() { _playerData.OnPlayerLoggedIn += VivoxLogin; } private void VivoxLogin() { StartCoroutine(StartLogin()); } private IEnumerator StartLogin() { yield return new WaitUntil(() => !string.IsNullOrEmpty(_playerData.SteamUsername)); LoginToVivox(); } protected override void Start() { m_EventSystem = FindObjectOfType<EventSystem>(); VivoxService.Instance.LoggedIn += OnUserLoggedIn; VivoxService.Instance.LoggedOut += OnUserLoggedOut; return; #if !(UNITY_STANDALONE || UNITY_IOS || UNITY_ANDROID) DisplayNameInput.interactable = false; #else DisplayNameInput.onEndEdit.AddListener((string text) => { LoginToVivoxService(); }); #endif LoginButton.onClick.AddListener(() => { LoginToVivoxService(); }); // OnUserLoggedOut(); var systInfoDeviceName = String.IsNullOrWhiteSpace(SystemInfo.deviceName) == false ? SystemInfo.deviceName : Environment.MachineName; DisplayNameInput.text = Environment.MachineName.Substring(0, Math.Min(k_DefaultMaxStringLength, Environment.MachineName.Length)); } protected override void LoginToVivoxService() { if (IsMicPermissionGranted()) { // The user authorized use of the microphone. LoginToVivox(); } else { // We do not have the needed permissions. // Ask for permissions or proceed without the functionality enabled if they were denied by the user if (IsPermissionsDenied()) { m_PermissionAskedCount = 0; LoginToVivox(); } else { AskForPermissions(); } } } protected override async void LoginToVivox() { //LoginButton.interactable = false; string username = _playerData.SteamUsername; var correctedDisplayName = Regex.Replace(username, \"[^a-zA-Z0-9_-]\", \"\"); if (string.IsNullOrEmpty(correctedDisplayName)) { Debug.LogError($\"Please enter a display name. {correctedDisplayName}\"); return; } await VivoxVoiceManager.Instance.InitializeAsync(correctedDisplayName); var loginOptions = new LoginOptions() { DisplayName = correctedDisplayName, ParticipantUpdateFrequency = ParticipantPropertyUpdateFrequency.FivePerSecond }; await VivoxService.Instance.LoginAsync(loginOptions); } } }",
      "tokens": 0,
      "chunks": [
        {
          "cs_scriptfile": "VivoxLoginScreenUI",
          "content": "using System; using UnityEngine; using UnityEngine.Android; using UnityEngine.EventSystems; using UnityEngine.UI; using Unity.Services.Vivox; using System.Collections.Generic; using System.Text.RegularExpressions; using _ZombieRoyale.Scripts.Clients; using System.Collections; namespace Vivox.DnD { public class VivoxLoginScreenUI : LoginScreenUI { [SerializeField] private PlayerData _playerData; private void OnEnable() { _playerData.OnPlayerLoggedIn += VivoxLogin;  ",
          "content_tokens": 126,
          "embedding": []
        },
        {
          "cs_scriptfile": "VivoxLoginScreenUI",
          "content": "private void VivoxLogin() { StartCoroutine(StartLogin()); } private IEnumerator StartLogin() { yield return new WaitUntil(() => !string.IsNullOrEmpty(_playerData.SteamUsername)); LoginToVivox(); } protected override void Start() { m_EventSystem = FindObjectOfType<EventSystem>(); VivoxService.Instance.LoggedIn += OnUserLoggedIn; VivoxService.Instance.LoggedOut += OnUserLoggedOut; return; #if !(UNITY_STANDALONE || UNITY_IOS || UNITY_ANDROID) DisplayNameInput.interactable = false; #else DisplayNameInput.onEndEdit.AddListener((string text) => { LoginToVivoxService(); }); #endif LoginButton.onClick.AddListener(() => { LoginToVivoxService(); }); // OnUserLoggedOut(); var systInfoDeviceName = String.IsNullOrWhiteSpace(SystemInfo.deviceName) == false ? SystemInfo.deviceName : Environment.MachineName; DisplayNameInput.text = Environment.MachineName.Substring(0, Math.Min(k_DefaultMaxStringLength, Environment.MachineName.Length)); } protected override void LoginToVivoxService() { if (IsMicPermissionGranted()) { // The user authorized use of the microphone. LoginToVivox(); } else { // We do not have the needed permissions. // Ask for permissions or proceed without the functionality enabled if they were denied by the user if (IsPermissionsDenied()) { m_PermissionAskedCount = 0; LoginToVivox(); } else { AskForPermissions(); } } } protected override async void LoginToVivox() { //LoginButton.interactable = false; string username = _playerData.SteamUsername; var correctedDisplayName = Regex.Replace(username, \"[^a-zA-Z0-9_-]\", \"\"); if (string.IsNullOrEmpty(correctedDisplayName)) { Debug.LogError($\"Please enter a display name. {correctedDisplayName}\"); return; } await VivoxVoiceManager.Instance.InitializeAsync(correctedDisplayName); var loginOptions = new LoginOptions() { DisplayName = correctedDisplayName, ParticipantUpdateFrequency = ParticipantPropertyUpdateFrequency.FivePerSecond }; await VivoxService.Instance.LoginAsync(loginOptions); } } }",
          "content_tokens": 530,
          "embedding": []
        }
      ],
      "length": 2430
    }
  ]
}